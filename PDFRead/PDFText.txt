Al-Karaki-Routing Techniques in wireless sensor networks-pdf,IEEE Wireless Communications • December 20046 1536-1284/04/$2000 © 2004 IEEEThis research was sup-ported in part by theICUBE initiative of IowaState University Amesand the Hashemite Uni-versity Zarqa Jordan1 In this article we con-sider routing toward a BSonlyWIRELESS SENSOR NETWORKSINTRODUCTIONDue to recent technological advances the manu-facturing of small and low-cost sensors hasbecome technically and economically feasibleThese sensors measure ambient conditions inthe environment surrounding them and thentransform these measurements into signals thatcan be processed to reveal some characteristicsabout phenomena located in the area aroundthese sensors A large number of these sensorscan be networked in many applications thatrequire unattended operations hence producinga wireless sensor network (WSN) In fact theapplications of WSNs are quite numerous Forexample WSNs have profound effects on mili-tary and civil applications such as target fieldimaging intrusion detection weather monitor-ing security and tactical surveillance distributedcomputing detecting ambient conditions such astemperature movement sound light or thepresence of certain objects inventory controland disaster management Deployment of a sen-sor network in these applications can be in ran-dom fashion (eg dropped from an airplane in adisaster management application) or manual(eg fire alarm sensors in a facility or sensorsplanted underground for precision agriculture)Creating a network of these sensors can assistrescue operations by locating survivors identify-ing risky areas and making the rescue teammore aware of the overall situation in a disasterareaTypically WSNs contain hundreds or thou-sands of these sensor nodes and these sensorshave the ability to communicate either amongeach other or directly to an external base station(BS) A greater number of sensors allows forsensing over larger geographical regions withgreater accuracy Figure 1 shows a schematicdiagram of sensor node components Basicallyeach sensor node comprises sensing processingtransmission mobilizer position finding systemand power units (some of these components areoptional like the mobilizer) The same figureshows the communication architecture of aWSN Sensor nodes are usually scattered in asensor field which is an area where the sensornodes are deployed Sensor nodes coordinateamong themselves to produce high-quality infor-mation about the physical environment Eachsensor node bases its decisions on its missionthe information it currently has and its knowl-edge of its computing communication and ener-gy resources Each of these scattered sensornodes has the capability to collect and routedata either to other sensors or back to an exter-nal BS(s)1 A BS may be a fixed or mobile nodecapable of connecting the sensor network to anexisting communications infrastructure or to theInternet where a user can have access to thereported dataIn the past few years intensive research thataddresses the potential of collaboration amongsensors in data gathering and processing andcoordination and management of the sensingactivity was conducted In most applicationssensor nodes are constrained in energy supplyand communication bandwidth Thus innovativetechniques to eliminate energy inefficiencies thatshorten the lifetime of the network and efficientJAMAL N AL-KARAKI THE HASHEMITE UNIVERSITYAHMED E KAMAL IOWA STATE UNIVERSITYABSTRACTWireless sensor networks consist of smallnodes with sensing computation and wirelesscommunications capabilities Many routingpower management and data dissemination pro-tocols have been specifically designed for WSNswhere energy awareness is an essential designissue Routing protocols in WSNs might differdepending on the application and network archi-tecture In this article we present a survey ofstate-of-the-art routing techniques in WSNs Wefirst outline the design challenges for routingprotocols in WSNs followed by a comprehensivesurvey of routing techniques Overall the rout-ing techniques are classified into three cate-gories based on the underlying networkstructure: flit hierarchical and location-basedrouting Furthermore these protocols can beclassified into multipath-based query-basednegotiation-based QoS-based and coherent-based depending on the protocol operation Westudy the design trade-offs between energy andcommunication overhead savings in every rout-ing paradigm We also highlight the advantagesand performance issues of each routing tech-nique The article concludes with possible futureresearch areasROUTING TECHNIQUES INWIRELESS SENSOR NETWORKS: A SURVEYWSNs consist ofsmall nodes withsensing computationand wireless communicationscapabilities Manyprotocols have beenspecifically designedfor WSNs whereenergy awareness is an essentialdesign issue IEEE Wireless Communications • December 2004 7use of the limited bandwidth are highly requiredSuch constraints combined with a typical deploy-ment of large number of sensor nodes posemany challenges to the design and managementof WSNs and necessitate energy-awareness at alllayers of the networking protocol stack Forexample at the network layer it is highly desir-able to find methods for energy-efficient routediscovery and relaying of data from the sensornodes to the BS so that the lifetime of the net-work is maximizedRouting in WSNs is very challenging due tothe inherent characteristics that distinguish thesenetworks from other wireless networks likemobile ad hoc networks or cellular networksFirst due to the relatively large number of sen-sor nodes it is not possible to build a globaladdressing scheme for the deployment of a largenumber of sensor nodes as the overhead of IDmaintenance is high Thus traditional IP-basedprotocols may not be applied to WSNs Further-more sensor nodes that are deployed in an adhoc manner need to be self-organizing as the adhoc deployment of these nodes requires the sys-tem to form connections and cope with the resul-tant nodal distribution especially as theoperation of sensor networks is unattended InWSNs sometimes getting the data is moreimportant than knowing the IDs of which nodessent the data Second in contrast to typical com-munication networks almost all applications ofsensor networks require the fbw of sensed datafrom multiple sources to a particular BS Thishowever does not prevent the flow of data to bein other forms (eg multicast or peer to peer)Third sensor nodes are tightly constrained interms of energy processing and storage capaci-ties Thus they require careful resource manage-ment Fourth in most application scenariosnodes in WSNs are generally stationary afterdeployment except for maybe a few mobilenodes Nodes in other traditional wireless net-works are free to move which results in unpre-dictable and frequent topological changesHowever in some applications some sensornodes may be allowed to move and change theirlocation (although with very low mobility) Fifthsensor networks are application-specific (iedesign requirements of a sensor network changewith application) For example the challengingproblem of low-latency precision tactical surveil-lance is different from that of a periodic weathermonitoring task Sixth position awareness ofsensor nodes is important since data collection isnormally based on the location Currently it isnot feasible to use Global Positioning System(GPS) hardware for this purpose Methods basedon triangulation [1] for example allow sensornodes to approximate their position using radiostrength from a few known points It is found in[1] that algorithms based on triangulation ormultilateration can work quite well under condi-tions where only very few nodes know their posi-tions a priori (eg using GPS hardware) Still itis favorable to have GPS-free solutions [2] forthe location problem in WSNs Finally data col-lected by many sensors in WSNs is typicallybased on common phenomena so there is a highprobability that this data has some redundancySuch redundancy needs to be exploited by therouting protocols to improve energy and band-width utilization Usually WSNs are data-centricnetworks in the sense that data is requestedbased on certain attributes (ie attribute-basedaddressing) An attribute-based address is com-posed of a set of attribute-value pair query Forexample if the query is something like [tempera-ture > 60°F] sensor nodes that sense tempera-ture > 60°F only need to respond and reporttheir readingsDue to such differences many new algo-rithms have been proposed for the routing prob-lem in WSNs These routing mechanisms havetaken into consideration the inherent features ofWSNs along with the application and architec-ture requirements The task of finding and main-taining routes in WSNs is nontrivial since energyrestrictions and sudden changes in node status(eg failure) cause frequent and unpredictabletopological changes To minimize energy con-sumption routing techniques proposed in the lit-erature for WSNs employ some well-knownrouting tactics as well as tactics special to WSNssuch as data aggregation and in-network pro-cessing clustering different node role assign-ment and data-centric methods Almost all ofthe routing protocols can be classified accordingto the network structure as flit hierarchical orlocation-based Furthermore these protocols canbe classified into multipath-based query-basednegotiation-based quality of service (QoS)-based and coherent-based depending on theprotocol operation In flat networks all nodes playthe same role while hierarchical protocols aimto cluster the nodes so that cluster heads can dosome aggregation and reduction of data in orderto save energy Location-based protocols utilizeposition information to relay the data to thedesired regions rather than the whole networkThe last category includes routing approachesbased on protocol operation which vary accord-ing to the approach used in the protocol In thisarticle we explore these routing techniques inWSNs that have been developed in recent yearsand develop a classification for these protocolsn Figure 1 The components of a sensor nodeProcessing unitPosition finding system MobilizerTargetSensor nodeBSUserInternetProcessorStorageSensing unitSensorTransmissionunitPowergeneratorADC TransceiverPower unit             IEEE Wireless Communications • December 20048Then we discuss each of the routing protocolsunder this classification Our objective is to pro-vide deeper understanding of the current routingprotocols in WSNs and identify some openresearch issues that can be further pursuedAlthough there are some previous efforts onsurveying the characteristics applications andcommunication protocols in WSNs [3 4] thescope of the survey presented in this article isdistinguished from these surveys in many aspectsThe surveys in [3 4] addressed several designissues and techniques for WSNs describing thephysical constraints on sensor nodes applica-tions architectural attributes and the protocolsproposed in all layers of the network stackHowever these surveys were not devoted torouting only Due to the importance of routingin WSNs and the availability of a significantbody of literature on this topic a detailed surveybecomes necessary and useful at this stage Ourwork is a dedicated study of the network layerdescribing and categorizing the differentapproaches to data routing In addition we sum-marize routing challenges and design issues thatmay affect the performance of routing protocolsin WSNs The rest of this article is organized asfollows We discuss routing challenges anddesign issues in WSNs A classification and com-prehensive survey of routing techniques in WSNsis presented A summary of future researchdirections on routing in WSNs is discussed Wethen conclude with final remarksROUTING CHALLENGES ANDDESIGN ISSUES IN WSNSDespite the innumerable applications of WSNsthese networks have several restrictions such aslimited energy supply limited computing powerand limited bandwidth of the wireless links con-necting sensor nodes One of the main designgoals of WSNs is to carry out data communica-tion while trying to prolong the lifetime of thenetwork and prevent connectivity degradation byemploying aggressive energy management tech-niques The design of routing protocols in WSNsis influenced by many challenging factors Thesefactors must be overcome before efficient com-munication can be achieved in WSNs In the fol-lowing we summarize some of the routingchallenges and design issues that affect the rout-ing process in WSNsNode deployment: Node deployment in WSNsis application-dependent and can be either man-ual (deterministic) or randomized In manualdeployment the sensors are manually placedand data is routed through predetermined pathsHowever in random node deployment the sen-sor nodes are scattered randomly creating an adhoc routing infrastructure If the resultant distri-bution of nodes is not uniform optimal cluster-ing becomes necessary to allow connectivity andenable energy-efficient network operation Inter-sensor communication is normally within shorttransmission ranges due to energy and band-width limitations Therefore it is most likely thata route will consist of multiple wireless hopsEnergy consumption without losing accuracy:Sensor nodes can use up their limited supply ofenergy performing computations and transmit-ting information in a wireless environment Assuch energy-conserving forms of communicationand computation are essential Sensor node life-time shows a strong dependence on battery life-time [5] In a multihop WSN each node plays adual role as data sender and data router Themalfunctioning of some sensor nodes due topower failure can cause significant topologicalchanges and might require rerouting of packetsand reorganization of the networkData reporting method: Data reporting inWSNs is application-dependent and also dependson the time criticality of the data Data reportingcan be categorized as either time-driven event-driven query-driven or a hybrid of all thesemethods The time-driven delivery method issuitable for applications that require periodicdata monitoring As such sensor nodes will peri-odically switch on their sensors and transmitterssense the environment and transmit the data ofinterest at constant periodic time intervals Inevent-driven and query-driven methods sensornodes react immediately to sudden and drasticchanges in the value of a sensed attribute due tothe occurrence of a certain event or respond toa query generated by the BS or another node inthe network As such these are well suited totime-critical applications A combination of theprevious methods is also possible The routingprotocol is highly influenced by the data report-ing method in terms of energy consumption androute calculationsNode/link heterogeneity: In many studies allsensor nodes were assumed to be homogeneous(ie have equal capacity in terms of computa-tion communication and power) Howeverdepending on the application a sensor node canhave a different role or capability The existenceof a heterogeneous set of sensors raises manytechnical issues related to data routing Forexample some applications might require adiverse mixture of sensors for monitoring tem-perature pressure and humidity of the sur-rounding environment detecting motion viaacoustic signatures and capturing images orvideo tracking of moving objects Either thesespecial sensors can be deployed independentlyor the different functionalities can be included inthe same sensor nodes Even data reading andreporting can be generated from these sensors atdifferent rates subject to diverse QoS con-straints and can follow multiple data reportingmodels For example hierarchical protocols des-ignate a cluster head node different from thenormal sensors These cluster heads can be cho-sen from the deployed sensors or be more pow-erful than other sensor nodes in terms of energybandwidth and memory Hence the burden oftransmission to the BS is handled by the set ofcluster headsFault tolerance: Some sensor nodes may failor be blocked due to lack of power physicaldamage or environmental interference The fail-ure of sensor nodes should not affect the overalltask of the sensor network If many nodes failmedium access control (MAC) and routing pro-tocols must accommodate formation of newlinks and routes to the data collection BSs Thismay require actively adjusting transmit powersOne of the maindesign goals ofWSNs is to carry outdata communicationwhile trying to prolong the lifetimeof the network andprevent connectivitydegradation byemploying aggressive energymanagement techniques                IEEE Wireless Communications • December 2004 9and signaling rates on the existing links to reduceenergy consumption or rerouting packetsthrough regions of the network where moreenergy is available Therefore multiple levels ofredundancy may be needed in a fault-tolerantsensor networkScalability: The number of sensor nodesdeployed in the sensing area may be on theorder of hundreds or thousands or more Anyrouting scheme must be able to work with thishuge number of sensor nodes In addition sen-sor network routing protocols should be scalableenough to respond to events in the environmentUntil an event occurs most sensors can remainin the sleep state with data from the few remain-ing sensors providing coarse qualityNetwork dynamics: In many studies sensornodes are assumed fixed However in manyapplications both the BS or sensor nodes can bemobile [6] As such routing messages from or tomoving nodes is more challenging since routeand topology stability become important issuesin addition to energy bandwidth and so forthMoreover the phenomenon can be mobile (ega target detection/ tracking application) On theother hand sensing fixed events allows the net-work to work in a reactive mode (ie generatingtraffic when reporting) while dynamic events inmost applications require periodic reporting tothe BSTransmission media: In a multihop sensornetwork communicating nodes are linked by awireless medium The traditional problems asso-ciated with a wireless channel (eg fading higherror rate) may also affect the operation of thesensor network In general the required band-width of sensor data will be low on the order of1–100 kb/s Related to the transmission media isthe design of MAC One approach to MACdesign for sensor networks is to use time-divisionmultiple access (TDMA)-based protocols thatconserve more energy than contention-basedprotocols like carrier sense multiple access(CSMA) (eg IEEE 80211) Bluetooth technol-ogy [7] can also be usedConnectivity: High node density in sensornetworks precludes them from being completelyisolated from each other Therefore sensornodes are expected to be highly connected Thishowever may not prevent the network topologyfrom being variable and the network size fromshrinking due to sensor node failures In addi-tion connectivity depends on the possibly ran-dom distribution of nodesCoverage: In WSNs each sensor node obtainsa certain view of the environment A given sen-sor’s view of the environment is limited in bothrange and accuracy; it can only cover a limitedphysical area of the environment Hence areacoverage is also an important design parameterin WSNsData aggregation: Since sensor nodes maygenerate significant redundant data similarpackets from multiple nodes can be aggregatedto reduce the number of transmissions Dataaggregation is the combination of data from dif-ferent sources according to a certain aggregationfunction (eg duplicate suppression minimamaxima and average) This technique has beenused to achieve energy efficiency and data trans-fer optimization in a number of routing proto-cols Signal processing methods can also be usedfor data aggregation In this case it is referredto as data fusion where a node is capable of pro-ducing a more accurate output signal by usingsome techniques such as beamforming to com-bine the incoming signals and reducing the noisein these signalsQuality of service: In some applications datashould be delivered within a certain period oftime from the moment it is sensed or it will beuseless Therefore bounded latency for datadelivery is another condition for time-con-strained applications However in many applica-tions conservation of energy which is directlyrelated to network lifetime is considered rela-tively more important than the quality of datasent As energy is depleted the network may berequired to reduce the quality of results in orderto reduce energy dissipation in the nodes andhence lengthen the total network lifetimeHence energy-aware routing protocols arerequired to capture this requirementROUTING PROTOCOLS IN WSNSIn this section we survey the state-of-the-artrouting protocols for WSNs In general routingin WSNs can be divided into flat-based routinghierarchical-based routing and location-basedrouting depending on the network structure Inflat-based routing all nodes are typicallyassigned equal roles or functionality In hierar-chical-based routing nodes will play differentroles in the network In location-based routingsensor nodes’ positions are exploited to routedata in the network A routing protocol is con-sidered adaptive if certain system parameterscan be controlled in order to adapt to currentnetwork conditions and available energy levelsFurthermore these protocols can be classifiedinto multipath-based query-based and negotia-tion-based QoS-based or coherent-based routingtechniques depending on the protocol operationIn addition to the above routing protocols canbe classified into three categories proactivereactive and hybrid depending on how thesource finds a route to the destination In proac-tive protocols all routes are computed beforethey are really needed while in reactive proto-cols routes are computed on demand Hybridprotocols use a combination of these two ideasWhen sensor nodes are static it is preferable tohave table-driven routing protocols rather thanreactive protocols A significant amount of ener-gy is used in route discovery and setup of reac-tive protocols Another class of routing protocolsis called cooperative In cooperative routingnodes send data to a central node where datacan be aggregated and may be subject to furtherprocessing hence reducing route cost in terms ofenergy use Many other protocols rely on timingand position information We also shed somelight on these types of protocols in this articleIn order to streamline this survey we use a clas-sification according to the network structure andprotocol operation (routing criteria) The classi-fication is shown in Fig 2 where numbers in thefuture indicate the referencesIn the rest of this section we present aIn WSNs each sensor node obtainsa certain view of theenvironment A givensensor’s view of theenvironment is limited in both rangeand accuracy; it can only cover alimited physical areaof the environmentHence area coverage is also animportant designparameter in WSNs                                        IEEE Wireless Communications • December 200410detailed overview of the main routing paradigmsin WSNs We start with network-structure-basedprotocolsNETWORK-STRUCTURE-BASED PROTOCOLSThe underlying network structure can play a sig-nificant role in the operation of the routing pro-tocol in WSNs In this section we survey in detailmost of the protocols that fall into this categoryFlat Routing — The first category of routing proto-cols are the multihop flat routing protocols Inflat networks each node typically plays the samerole and sensor nodes collaborate to perform thesensing task Due to the large number of suchnodes it is not feasible to assign a global identi-fier to each node This consideration has led todata-centric routing where the BS sends queriesto certain regions and waits for data from thesensors located in the selected regions Sincedata is being requested through queriesattribute-based naming is necessary to specifythe properties of data Early work on data cen-tric routing (eg SPIN and directed diffusion[8]) were shown to save energy through datanegotiation and elimination of redundant dataThese two protocols motivated the design ofmany other protocols that follow a similar con-cept In the rest of this subsection we summa-rize these protocols and highlight theiradvantages and performance issuesSensor Protocols for Information via Negoti-ation: Heinzelman et al in [9 10] proposed afamily of adaptive protocols called Sensor Proto-cols for Information via Negotiation (SPIN) thatdisseminate all the information at each node toevery node in the network assuming that allnodes in the network are potential BSs Thisenables a user to query any node and get therequired information immediately These proto-cols make use of the property that nodes in closeproximity have similar data and hence there is aneed to only distribute the data other nodes donot posses The SPIN family of protocols usesdata negotiation and resource-adaptive algo-rithms Nodes running SPIN assign a high-levelname to completely describe their collected data(called meta-data) and perform metadata negoti-ations before any data is transmitted Thisensures that there is no redundant data sentthroughout the network The semantics of themeta-data format is application-specific and notspecified in SPIN For example sensors mightuse their unique IDs to report meta-data if theycover a certain known region In addition SPINhas access to the current energy level of thenode and adapts the protocol it is running basedon how much energy is remaining These proto-cols work in a time-driven fashion and distributethe information all over the network even whena user does not request any dataThe SPIN family is designed to address thedeficiencies of classic flooding by negotiationand resource adaptation The SPIN family ofprotocols is designed based on two basic ideas:1) Sensor nodes operate more efficiently andconserve energy by sending data that describethe sensor data instead of sending all the data;for example image and sensor nodes must moni-tor the changes in their energy resources2) Conventional protocols like flooding orgossiping-based routing protocols [11] wasteenergy and bandwidth when sending extra andunnecessary copies of data by sensors coveringoverlapping areas The drawbacks of floodinginclude implosion which is caused by duplicatemessages sent to the same node overlap whentwo nodes sensing the same region send similarpackets to the same neighbor and resourceblindness in consuming large amounts of energywithout consideration for energy constraintsGossiping avoids the problem of implosion byjust selecting a random node to which to sendthe packet rather than broadcasting the packetblindly However this causes delays in propaga-tion of data through the nodesSPIN’s meta-data negotiation solves the clas-sic problems of flooding thus achieving a lot ofenergy efficiency SPIN is a three-stage protocolas sensor nodes use three types of messagesADV REQ and DATA to communicate ADVis used to advertise new data REQ to requestdata and DATA is the actual message itselfThe protocol starts when a SPIN node obtainsnew data it is willing to share It does so bybroadcasting an ADV message containing meta-n Figure 2 Routing protocols in WSNs: a taxonomyFlatnetworkrouting23713141516183941491891217192223353126482533424647HierarchicalnetworkroutingLocation-basedroutingNetwork structureNegotiation-basedrouting3721026282934 22027Multipath-basedroutingQuery-basedrouting1144QoS-basedrouting11233Coherent-basedroutingProtocol operationRouting protocols in WSNs               IEEE Wireless Communications • December 2004 11data If a neighbor is interested in the data itsends a REQ message for the DATA and theDATA is sent to this neighbor node The neigh-bor sensor node then repeats this process withits neighbors As a result the entire sensor areawill receive a copy of the dataThe SPIN family of protocols includes manyprotocols The main two are called SPIN-1 andSPIN-2; they incorporate negotiation beforetransmitting data in order to ensure that onlyuseful information will be transferred Also eachnode has its own resource manager that keepstrack of resource consumption and is polled bythe nodes before data transmission The SPIN-1protocol is a three-stage protocol as describedabove An extension to SPIN-1 is SPIN-2 whichincorporates a threshold-based resource aware-ness mechanism in addition to negotiationWhen energy in the nodes is abundant SPIN-2communicates using the three-stage protocol ofSPIN1 However when the energy in a nodestarts approaching a low threshold it reduces itsparticipation in the protocol; that is it partici-pates only when it believes it can complete allthe other stages of the protocol without goingbelow the low energy threshold In conclusionSPIN-1 and SPIN-2 are simple protocols thatefficiently disseminate data while maintaining noper-neighbor state These protocols are well suit-ed to an environment where the sensors aremobile because they base their forwarding deci-sions on local neighborhood information Otherprotocols of the SPIN family are (please refer to[3 7] for more details):• SPIN-BC: This protocol is designed for broad-cast channels• SPIN-PP: This protocol is designed for point-to-point communication (ie hop-by-hoprouting)• SPIN-EC: This protocol works similar toSPIN-PP but with an energy heuristic addedto it• SPIN-RL: When a channel is lossy a protocolcalled SPIN-RL is used where adjustments areadded to the SPIN-PP protocol to account forthe lossy channelOne of the advantages of SPIN is that topo-logical changes are localized since each nodeneed know only its single-hop neighbors SPINprovides more energy savings than flooding andmetadata negotiation almost halves the redun-dant data However SPIN’s data advertisementmechanism cannot guarantee delivery of dataTo see this consider the application of intrusiondetection where data should be reliably reportedover periodic intervals and assume that nodesinterested in the data are located far away fromthe source node and the nodes between sourceand destination nodes are not interested in thatdata; such data will not be delivered to the desti-nation at allDirected diffusion: In [12] C Intanagonwi-wat et al proposed a popular data aggregationparadigm for WSNs called directed diffusionDirected diffusion is a data-centric (DC) andapplication-aware paradigm in the sense that alldata generated by sensor nodes is named byattribute-value pairs The main idea of the DCparadigm is to combine the data coming fromdifferent sources en route (in-network aggrega-tion) by eliminating redundancy minimizing thenumber of transmissions thus saving networkenergy and prolonging its lifetime Unlike tradi-tional end-to-end routing DC routing findsroutes from multiple sources to a single destina-tion that allows in-network consolidation ofredundant dataIn directed diffusion sensors measure eventsand create gradients of information in theirrespective neighborhoods The BS requests databy broadcasting interests An interest describes atask required to be done by the network Aninterest diffuses through the network hop byhop and is broadcast by each node to its neigh-bors As the interest is propagated throughoutthe network gradients are set up to draw datasatisfying the query toward the requesting node(ie a BS may query for data by disseminatinginterests and intermediate nodes propagatethese interests) Each sensor that receives theinterest sets up a gradient toward the sensornodes from which it receives the interest Thisprocess continues until gradients are set up fromthe sources back to the BS More generally agradient specifies an attribute value and a direc-tion The strength of the gradient may be differ-ent toward different neighbors resulting indifferent amounts of information flow At thisstage loops are not checked but are removed ata later stage Figure 3 shows an example of theworking of directed diffusion (sending interestsbuilding gradients and data dissemination)When interests fit gradients paths of informa-tion flow are formed from multiple paths andthen the best paths are reinforced to preventfurther flooding according to a local rule Inorder to reduce communication costs data isaggregated on the way The goal is to find agood aggregation tree that gets the data fromsource nodes to the BS The BS periodicallyrefreshes and resends the interest when it startsto receive data from the source(s) This is neces-sary because interests are not reliably transmit-ted throughout the networkAll sensor nodes in a directed-diffusion-basednetwork are application-aware which enablesdiffusion to achieve energy savings by selectingempirically good paths and by caching and pro-cessing data in the network Caching canincrease the efficiency robustness and scalabili-ty of coordination between sensor nodes whichis the essence of the data diffusion paradigmOther usage of directed diffusion is to sponta-neously propagate an important event to somesections of the sensor network Such a type ofinformation retrieval is well suited only to persis-tent queries where requesting nodes are notexpecting data that satisfy a query for a durationof time This makes it unsuitable for one-timequeries as it is not worth setting up gradientsfor queries that use the path only onceThe performance of data aggregation meth-ods used in the directed diffusion paradigm isaffected by a number of factors including thepositions of the source nodes in the network thenumber of sources and the communication net-work topology In order to investigate these fac-tors two models of source placement (shown inFig 4) were studied in [12] These models arecalled the event radius (ER) model and the ran-The goal is to find agood aggregationtree that gets thedata from sourcenodes to the BS The BS periodicallyrefreshes and resends the interestwhen it starts toreceive data fromthe source(s) This isnecessary becauseinterests are not reliably transmittedthroughout the network        IEEE Wireless Communications • December 200412dom sources (RS) model In the ER model asingle point in the network area is defined as thelocation of an event This may correspond to avehicle or some other phenomenon beingtracked by the sensor nodes All nodes within adistance S (called the sensing range) of thisevent that are not BSs are considered to be datasources The average number of sources isapproximately piS2n in a unit area network withn sensor nodes In the RS model k of the nodesthat are not BSs are randomly selected to besources Unlike the ER model the sources arenot necessarily clustered near each other Inboth models of source placement for a givenenergy budget a greater number of sources canbe connected to the BS However each one per-forms better in terms of energy consumptiondepending on the application In conclusion theenergy savings with aggregation used in directeddiffusion can be transformed to provide a greaterdegree of robustness with respect to dynamics inthe sensed phenomenaDirected diffusion differs from SPIN in twoaspects First directed diffusion issues dataqueries on demand as the BS sends queries tothe sensor nodes by flooding some tasks InSPIN however sensors advertise the availabilityof data allowing interested nodes to query thatdata Second all communication in directed dif-fusion is neighbor to neighbor with each nodehaving the capability to perform data aggrega-tion and caching Unlike SPIN there is no needto maintain global network topology in directeddiffusion However directed diffusion may notbe applied to applications (eg environmentalmonitoring) that require continuous data deliv-ery to the BS This is because the query-drivenon-demand data model may not help in thisregard Moreover matching data to queriesmight require some extra overhead at the sensornodesRumor routing: Rumor routing [13] is a vari-ation of directed diffusion and is mainly intend-ed for applications where geographic routing isnot feasible In general directed diffusion usesflooding to inject the query to the entire net-work when there is no geographic criterion todiffuse tasks However in some cases there isonly a small amount of data requested from thenodes; thus the use of flooding is unnecessaryAn alternative approach is to flood the events ifthe number of events is small and the numberof queries is large The key idea is to route thequeries to the nodes that have observed a par-ticular event rather than flooding the entire net-work to retrieve information about the occurringevents In order to flood events through the net-work the rumor routing algorithm employslong-lived packets called agents When a nodedetects an event it adds the event to its localtable called an events table and generates anagent Agents travel the network in order topropagate information about local events to dis-tant nodes When a node generates a query foran event the nodes that know the route mayrespond to the query by inspecting its eventtable Hence there is no need to flood thewhole network which reduces the communica-tion cost On the other hand rumor routingmaintains only one path between source anddestination as opposed to directed diffusionwhere data can be routed through multiplepaths at low rates Simulation results showedthat rumor routing can achieve significant ener-gy savings compared to event flooding and canalso handle a node’s failure However rumorrouting performs well only when the number ofevents is small For a large number of eventsthe cost of maintaining agents and event tablesin each node becomes infeasible if there is notenough interest in these events from the BSMoreover the overhead associated with rumorrouting is controlled by different parametersused in the algorithm such as time to live (TTL)pertaining to queries and agents Since thenodes become aware of events through theevent agents the heuristic for defining the routeof an event agent highly affects the performanceof next-hop selection in rumor routingMinimum Cost Forwarding Algorithm: TheMinimum Cost Forwarding Algorithm (MCFA)[8] exploits the fact that the direction of routingis always known (ie toward the fixed externalBS) Hence a sensor node need not have an Figure 3 An example of interest diffusion in a sensor network(a) Propagate interestSource SinkSource Sink(b) Set up gradients(c) Send data and path reinforcementSource SinkThe energy savingswith aggregationused in the directeddiffusion can betransformed to provide a greaterdegree of robustnesswith respect todynamics in thesensed phenomena                           IEEE Wireless Communications • December 2004 13unique ID nor maintain a routing table Insteadeach node maintains the least cost estimate fromitself to the BS Each message to be forwardedby the sensor node is broadcast to its neighborsWhen a node receives the message it checks if itis on the least cost path between the source sen-sor node and the BS If this is the case itrebroadcasts the message to its neighbors Thisprocess repeats until the BS is reachedIn MCFA each node should know the leastcost path estimate from itself to the BS This isobtained as follows The BS broadcasts a mes-sage with the cost set to zero while every nodeinitially sets its least cost to the BS to infinity(∞) Each node upon receiving the broadcastmessage originated at the BS checks to see ifthe estimate in the message plus the link onwhich it is received is less than the current esti-mate If yes the current estimate and the esti-mate in the broadcast message are updated Ifthe received broadcast message is updated it isresent; otherwise it is purged and nothing fur-ther is done However the previous proceduremay result in some nodes having multipleupdates and those nodes far away from the BSwill get more updates from those closer to theBS To avoid this MCFA was modified to runa backoff algorithm at the setup phase Thebackoff algorithm dictates that a node will notsend the updated message until  a * lc timeunits have elapsed from the time at which themessage is updated where a is a constant andlc is the link cost at which the message wasreceivedGradient-based routing: Schurgers et al [14]proposed another variant of directed diffusioncalled gradient-based routing (GBR) The keyidea in GBR is to memorize the number of hopswhen the interest is diffused through the wholenetwork As such each node can calculate aparameter called the height of the node which isthe minimum number of hops to reach the BSThe difference between a node’s height and thatof its neighbor is considered the gradient on thatlink A packet is forwarded on a link with thelargest gradient GBR uses some auxiliary tech-niques such as data aggregation and trafficspreading in order to uniformly divide the trafficover the network When multiple paths passthrough a node which acts as a relay node thatrelay node may combine data according to a cer-tain function In GBR three different data dis-semination techniques have been discussed:• A stochastic scheme where a node picks onegradient at random when there are two ormore next hops that have the same gradient• An energy-based scheme where a nodeincreases its height when its energy dropsbelow a certain threshold so that other sensorsare discouraged from sending data to thatnode• A stream-based scheme where new streamsare not routed through nodes that are cur-rently part of the path of other streamsThe main objective of these schemes is toobtain balanced distribution of the traffic in thenetwork thus increasing the network lifetimeSimulation results of GBR showed that GBRoutperforms directed diffusion in terms of totalcommunication energyInformation-driven sensor querying and con-strained anisotropic diffusion routing: Tworouting techniques information-driven sensorquerying (IDSQ) and constrained anisotropicdiffusion routing (CADR) were proposed in[15] CADR aims to be a general form of direct-ed diffusion The key idea is to query sensorsand route data in the network such that informa-tion gain is maximized while latency and band-width are minimized CADR diffuses queries byusing a set of information criteria to select whichsensors can get the data This is achieved by acti-vating only the sensors that are close to a partic-ular event and dynamically adjusting data routesThe main difference from directed diffusion isthe consideration of information gain in additionto communication cost In CADR each nodeevaluates an information/cost objective androutes data based on the local information/costgradient and end-user requirements Estimationtheory was used to model information utility InIDSQ the querying node can determine whichnode can provide the most useful informationwith the additional advantage of balancing theenergy cost However IDSQ does not specifical-ly define how the query and information arerouted between sensors and the BS ThereforeIDSQ can be seen as a complementary optimiza-tion procedure Simulation results showed thatthese approaches are more energy-efficient thann Figure 4 Two models used in a data-centric routing paradigm such as directed diffusion: a) event radiusmodel; b) random source model(a)Source nodeSink nodeSink(b)SinkThe key idea in GBRis to memorize thenumber of hopswhen the interest isdiffused through thewhole network As such each nodecan calculate aparameter called theheight of the nodewhich is the minimum number of hops to reach the BS                        IEEE Wireless Communications • December 200414directed diffusion where queries are diffused inan isotropic fashion and reach nearest neighborsfirstCOUGAR: Another data-centric protocolcalled COUGAR [16] views the network as ahuge distributed database system The key ideais to use declarative queries in order to abstractquery processing from the network layer func-tions such as selection of relevant sensors and soon COUGAR utilizes in-network data aggrega-tion to obtain more energy savings The abstrac-tion is supported through an additional querylayer that lies between the network and applica-tion layers COUGAR incorporates an architec-ture for the sensor database system where sensornodes select a leader node to perform aggrega-tion and transmit the data to the BS The BS isresponsible for generating a query plan thatspecifies the necessary information about thedata flow and in-network computation for theincoming query and sends it to the relevantnodes The query plan also describes how toselect a leader for the query The architectureprovides in-network computation ability that canprovide energy efficiency in situations when thegenerated data is huge COUGAR provides anetwork-layer-independent method for dataquery However COUGAR has some draw-backs First the addition of a query layer oneach sensor node may add extra overhead interms of energy consumption and memory stor-age Second to obtain successful in-networkdata computation synchronization among nodesis required (not all data are received at the sametime from incoming sources) before sending thedata to the leader node Third the leader nodesshould be dynamically maintained to preventthem from being hotspots (failure-prone)ACQUIRE: In [17] Sadagopan et al pro-posed a technique for querying sensor networkscalled Active Qwery Forwarding in Sensor Net-works (ACQUIRE) Similar to COUGARACQUIRE views the network as a distributeddatabase where complex queries can be furtherdivided into several subqueries The operation ofACQUIRE can be described as follows The BSnode sends a query which is then forwarded byeach node receiving the query During this eachnode tries to respond to the query partially byusing its precached information and then for-wards it to another sensor node If the pre-cached information is not up-to-date the nodesgather information from their neighbors within alookahead of d hops Once the query is resolvedcompletely it is sent back through either thereverse or shortest path to the BS HenceACQUIRE can deal with complex queries byallowing many nodes to send responses Notethat directed diffusion may not be used for com-plex queries due to energy considerations asdirected diffusion also uses a flooding-basedquery mechanism for continuous and aggregatequeries On the other hand ACQUIRE can pro-vide efficient querying by adjusting the value ofthe lookahead parameter d When d is equal tonetwork diameter ACQUIRE behaves similar toflooding However the query has to travel morehops if d is too small A mathematical modelingwas used to find an optimal value of the parame-ter d for a grid of sensors where each node hasfour immediate neighbors However there is novalidation of results through simulation Toselect the next node for forwarding the queryACQUIRE either picks it randomly or the selec-tion is based on maximum potential query satis-faction Recall that either selection of the nextnode is based on information gain (CADR andIDSQ) or the query is forwarded to a node thatknows the path to the searched event (rumorrouting)Energy-Aware Routing: The objective of theEnergy-Aware Routing protocol [18] a destina-tion-initiated reactive protocol is to increase thenetwork lifetime Although this protocol is simi-lar to directed diffusion it differs in the sensethat it maintains a set of paths instead of main-taining or enforcing one optimal path at higherrates These paths are maintained and chosen bymeans of a certain probability The value of thisprobability depends on how low the energy con-sumption is that each path can achieve By hav-ing paths chosen at different times the energy ofany single path will not deplete quickly This canachieve longer network lifetime as energy is dis-sipated more equally among all nodes Networksurvivability is the main metric of this protocolThe protocol assumes that each node is address-able through class-based addressing that includesthe locations and types of the nodes The proto-col initiates a connection through localizedflooding which is used to discover all routesbetween a source/ destination pair and theircosts thus building up the routing tables High-cost paths are discarded and a forwarding tableis built by choosing neighboring nodes in a man-ner that is proportional to their cost Then for-warding tables are used to send data to thedestination with a probability inversely propor-tional to the node cost Localized flooding isperformed by the destination node to keep thepaths alive Compared to directed diffusion thisprotocol provides an overall improvement of215 percent energy saving and a 44 percentincrease in network lifetime However theapproach requires gathering location informa-tion and setting up the addressing mechanismfor the nodes which complicate route setupcompared to directed diffusionRouting protocols with random walks: Theobjective of the random-walks-based routingtechnique [19] is to achieve load balancing in astatistical sense by making use of multipath rout-ing in WSNs This technique considers onlylarge-scale networks where nodes have very lim-ited mobility In this protocol it is assumed thatsensor nodes can be turned on or off at randomtimes Furthermore each node has a uniqueidentifier but no location information is neededNodes were arranged such that each node fallsexactly on one crossing point of a regular grid ona plane but the topology can be irregular Tofind a route from a source to its destination thelocation information or lattice coordination isobtained by computing distances between nodesusing the distributed asynchronous version of thewell-known Bellman-Ford algorithm An inter-mediate node would select as the next hop theneighboring node that is closer to the destina-tion according to a computed probability Bycarefully manipulating this probability someThe objective of random walks basedrouting technique isto achieve load balancing in a statistical sense andby making use ofmulti-path routing in WSNs This technique considersonly large scale networks wherenodes have very limited mobility                        IEEE Wireless Communications • December 2004 15kind of load balancing can be obtained in thenetwork The routing algorithm is simple asnodes are required to maintain little state infor-mation Moreover different routes are chosen atdifferent times even for the same pair of sourceand destination nodes However the main con-cern about this protocol is that the topology ofthe network may not be practicalHierarchical Routing — Hierarchical or cluster-based routing methods originally proposed inwireline networks are well-known techniqueswith special advantages related to scalability andefficient communication As such the concept ofhierarchical routing is also utilized to performenergy-efficient routing in WSNs In a hierarchi-cal architecture higher-energy nodes can beused to process and send the information whilelow-energy nodes can be used to perform thesensing in the proximity of the target The cre-ation of clusters and assigning special tasks tocluster heads can greatly contribute to overallsystem scalability lifetime and energy efficiencyHierarchical routing is an efficient way to lowerenergy consumption within a cluster performingdata aggregation and fusion in order to decreasethe number of transmitted messages to the BSHierarchical routing is mainly two-layer routingwhere one layer is used to select cluster headsand the other for routing However most tech-niques in this category are not about routing butrather “who and when to send or process/ aggre-gate” the information channel allocation and soon which can be orthogonal to the multihoprouting functionLEACH protocol: Heinzelman et al [5] intro-duced a hierarchical clustering algorithm forsensor networks called Low Energy AdaptiveClustering Hierarchy (LEACH) LEACH is acluster-based protocol which includes distribut-ed cluster formation LEACH randomly selects afew sensor nodes as cluster heads (CHs) androtates this role to evenly distribute the energyload among the sensors in the network InLEACH the CH nodes compress data arrivingfrom nodes that belong to the respective clusterand send an aggregated packet to the BS inorder to reduce the amount of information thatmust be transmitted to the BS LEACH uses aTDMA/code-division multiple access (CDMA)MAC to reduce intercluster and intracluster col-lisions However data collection is centralizedand performed periodically Therefore this pro-tocol is most appropriate when there is a needfor constant monitoring by the sensor networkA user may not need all the data immediatelyHence periodic data transmissions are unneces-sary and may drain the limited energy of thesensor nodes After a given interval of time ran-domized rotation of the role of CH is conductedso that uniform energy dissipation in the sensornetwork is obtained The authors found basedon their simulation model that only 5 percent ofthe nodes need to act as CHsThe operation of LEACH is separated intotwo phases the setup phase and the steady statephase In the setup phase the clusters are orga-nized and CHs are selected In the steady statephase the actual data transfer to the BS takesplace The duration of the steady state phase islonger than the duration of the setup phase inorder to minimize overhead During the setupphase a predetermined fraction of nodes pelect themselves as CHs as follows A sensornode chooses a random number r between 0and 1 If this random number is less than athreshold value T(n) the node becomes a CHfor the current round The threshold value is cal-culated based on an equation that incorporatesthe desired percentage to become a CH the cur-rent round and the set of nodes that have notbeen selected as a CH in the last (1/P) roundsdenoted G It is given bywhere G is the set of nodes that are involved inthe CH election All elected CHs broadcast anadvertisement message to the rest of the nodesin the network that they are the new CHs Allthe non-CH nodes after receiving this advertise-ment decide on the cluster to which they wantto belong This decision is based on the signalstrength of the advertisement The non-CHnodes inform the appropriate CHs that they willbe a member of the cluster After receiving allthe messages from the nodes that would like tobe included in the cluster and based on the num-ber of nodes in the cluster the CH node createsa TDMA schedule and assigns each node a timeslot when it can transmit This schedule is broad-cast to all the nodes in the clusterDuring the steady state phase the sensornodes can begin sensing and transmitting data tothe CHs The CH node after receiving all thedata aggregates it before sending it to the BSAfter a certain time which is determined a pri-ori the network goes back into the setup phaseagain and enters another round of selecting newCHs Each cluster communicates using differentCDMA codes to reduce interference from nodesbelonging to other clustersAlthough LEACH is able to increase the net-work lifetime there are still a number of issuesabout the assumptions used in this protocolLEACH assumes that all nodes can transmitwith enough power to reach the BS if neededand that each node has computational power tosupport different MAC protocols Therefore itis not applicable to networks deployed in largeregions It also assumes that nodes always havedata to send and nodes located close to eachother have correlated data It is not obvious howthe number of predetermined CHs (p) is goingto be uniformly distributed through the networkTherefore there is the possibility that the elect-ed CHs will be concentrated in one part of thenetwork; hence some nodes will not have anyCHs in their vicinity Furthermore the idea ofdynamic clustering brings extra overhead (headchanges advertisements etc) which may dimin-ish the gain in energy consumption Finally theprotocol assumes that all nodes begin with thesame amount of energy capacity in each electionround assuming that being a CH consumesapproximately the same amount of energy foreach node The protocol should be extended toaccount for non-uniform energy nodes (ie usean energy-based threshold) An extension toLEACH LEACH with negotiation was pro-T n pp r pn G( ) ( mod( / )) = − ∈1 1 if The operation ofLEACH is separatedinto two phases thesetup phase and thesteady state phaseIn the setup phasethe clusters are organized and CHsare selected In thesteady state phasethe actual data trans-fer to the base station takes place                          IEEE Wireless Communications • December 200416posed in [5] The main theme of the proposedextension is to precede data transfers with high-level negotiation using meta-data descriptors asin the SPIN protocol discussed earlier Thisensures that only data that provides new infor-mation is transmitted to the CHs before beingtransmitted to the BS Table 1 compares SPINLEACH and directed diffusion according to dif-ferent parameters It is noted from the table thatdirected diffusion shows a promising approachfor energy-efficient routing in WSNs due to theuse of in-network processingPower-Efficient Gathering in Sensor Infor-mation Systems: In [20] an enhancement overthe LEACH protocol was proposed The proto-col called Power-Efficient Gathering in SensorInformation Systems (PEGASIS) is a near opti-mal chain-based protocol The basic idea of theprotocol is that in order to extend network life-time nodes need only communicate with theirclosest neighbors and they take turns in commu-nicating with the BS When the round of allnodes communicating with the BS ends a newround starts and so on This reduces the powerrequired to transmit data per round as the powerdraining is spread uniformly over all nodesHence PEGASIS has two main objectives Firstincrease the lifetime of each node by using col-laborative techniques Second allow only localcoordination between nodes that are closetogether so that the bandwidth consumed incommunication is reduced Unlike LEACHPEGASIS avoids cluster formation and uses onlyone node in a chain to transmit to the BS insteadof multiple nodesTo locate the closest neighbor node inPEGASIS each node uses the signal strength tomeasure the distance to all neighboring nodesand then adjusts the signal strength so that onlyone node can be heard The chain in PEGASISwill consist of those nodes that are closest toeach other and form a path to the BS Theaggregated form of the data will be sent to theBS by any node in the chain and the nodes inthe chain will take turns sending to the BS Thechain construction is performed in a greedyfashion Simulation results showed that PEGA-SIS is able to increase the lifetime of the net-work to twice that under the LEACH protocolSuch performance gain is achieved through theelimination of the overhead caused by dynamiccluster formation in LEACH and decreasingthe number of transmissions and reception byusing data aggregation Although the clusteringoverhead is avoided PEGASIS still requiresdynamic topology adjustment since a sensornode needs to know about the energy status ofits neighbors in order to know where to route itsdata Such topology adjustment can introducesignificant overhead especially for highly uti-lized networks Moreover PEGASIS assumesthat each sensor node is able to communicatewith the BS directly In practical cases sensornodes use multihop communication to reach theBS Also PEGASIS assumes that all nodesmaintain a complete database of the location ofall other nodes in the network The method bywhich the node locations are obtained is notoutlined In addition PEGASIS assumes that allsensor nodes have the same level of energy andare likely to die at the same time Note also thatPEGASIS introduces excessive delay for distantnodes on the chain In addition the single lead-er can become a bottleneck Finally although inmost scenarios sensors will be fixed or immobileas assumed in PEGASIS some sensors may beallowed to move and hence affect the protocolfunctionalityAn extension to PEGASIS called Hierarchi-cal PEGASIS was introduced in [2] with theobjective of decreasing the delay incurred forpackets during transmission to the BS For thispurpose simultaneous transmissions of data arestudied in order to avoid collisions throughapproaches that incorporate signal coding andspatial transmissions In the latter only spatiallyseparated nodes are allowed to transmit at thesame time The chain-based protocol withCDMA-capable nodes constructs a chain ofnodes that forms a tree-like hierarchy and eachselected node at a particular level transmits datato a node in the upper level of the hierarchyThis method ensures data transmitting in paral-lel and reduces delay significantly Such a hierar-chical extension has been shown to performbetter than the regular PEGASIS scheme by afactor of about 60Threshold-Sensitive Energy Efficient Proto-cols: Two hierarchical routing protocols calledThreshold-Sensitive Energy Efficient SensorNetwork Protocol (TEEN) and Adaptive Period-ic TEEN (APTEEN) are proposed in [21 22]These protocols were proposed for time-criticalapplications In TEEN sensor nodes sense themedium continuously but data transmission isdone less frequently A CH sensor sends itsmembers a hard threshold which is the thresh-old value of the sensed attribute and a softthreshold which is a small change in the value ofthe sensed attribute that triggers the node toswitch on its transmitter and transmit Thus thehard threshold tries to reduce the number oftransmissions by allowing the nodes to transmitonly when the sensed attribute is in the range ofinterest The soft threshold further reduces thenumber of transmissions that might otherwiseoccur when there is little or no change in thesensed attribute A smaller value of the softthreshold gives a more accurate picture of thenetwork at the expense of increased energy con-sumption Thus the user can control the trade-off between energy efficiency and data accuracyWhen CHs are to change (Fig 5a) new valuesfor the above parameters are broadcast Themain drawback of this scheme is that if then Table 1 Comparison between SPIN LEACH anddirected diffusionDirectedSPIN LEACH diffusionOptimal route No No YesNetwork lifetime Good Very good GoodResource Yes Yes YesawarenessUse of meta-data Yes No YesPEGASIS assumesthat all sensor nodeshave the same levelof energy and theyare likely to die atthe same time Notealso that PEGASISintroduces excessivedelay for distantnode on the chainIn addition the single leader canbecome a bottleneck              IEEE Wireless Communications • December 2004 17thresholds are not received the nodes will nevercommunicate and the user will not get any datafrom the network at allThe nodes sense their environment continu-ously The first time a parameter from theattribute set reaches its hard threshold value thenode switches its transmitter on and sends thesensed data The sensed value is stored in aninternal variable called sensed value (SV) Thenodes will transmit data in the current clusterperiod only when the following conditions aretrue:• The current value of the sensed attribute isgreater than the hard threshold• The current value of the sensed attribute dif-fers from SV by an amount equal to or greaterthan the soft thresholdImportant features of TEEN include its suit-ability for time-critical sensing applicationsAlso since message transmission consumes moreenergy than data sensing the energy consump-tion in this scheme is less than in proactive net-works The soft threshold can be varied Atevery cluster change time fresh parameters arebroadcast so the user can change them asrequiredAPTEEN on the other hand is a hybrid pro-tocol that changes the periodicity or thresholdvalues used in the TEEN protocol according touser needs and the application type InAPTEEN the CHs broadcast the followingparameters (Fig 5b):• Attributes (A):  a set of physical parametersabout which the user is interested in obtaininginformation• Thresholds: consists of the hard threshold(HT) and soft threshold (ST)• Schedule: a TDMA schedule assigning a slotto each node• Count time (CT): the maximum time periodbetween two successive reports sent by a nodeThe node senses the environment continuous-ly and only those nodes that sense a data valueat or beyond HT transmit Once a node senses avalue beyond HT it transmits data only whenthe value of that attribute changes by an amountequal to or greater than ST If a node does notsend data for a time period equal to CT it isforced to sense and retransmit the data ATDMA schedule is used and each node in thecluster is assigned a transmission slot HenceAPTEEN uses a modified TDMA schedule toimplement the hybrid network The main fea-tures of the APTEEN scheme include the fol-lowing It combines both proactive and reactivepolicies It offers a lot of flexibility by allowingthe user to set the CT interval and the thresholdvalues for energy consumption can be controlledby changing the CT as well as the threshold val-ues The main drawback of the scheme is theadditional complexity required to implement thethreshold functions and CT Simulation of TEENand APTEEN has shown that these two proto-cols outperform LEACH The experiments havedemonstrated that APTEEN’s performance issomewhere between LEACH and TEEN interms of energy dissipation and network lifetimeTEEN gives the best performance since itdecreases the number of transmissions Themain drawbacks of the two approaches are theoverhead and complexity associated with form-ing clusters at multiple levels the method ofimplementing threshold-based functions andhow to deal with attribute-based naming ofqueriesSmall minimum energy communication net-work (MECN): In [23] a protocol is proposedthat computes an energy-efficient subnetworkthe minimum energy communication network(MECN) for a certain sensor network utilizinglow-power GPS MECN identifies a relay regionfor every node The relay region consists ofnodes in a surrounding area where transmittingthrough those nodes is more energy-efficientthan direct transmission The enclosure of anode i is created by taking the union of all relayregions node i can reach The main idea ofMECN is to find a subnetwork that will havefewer nodes and require less power for transmis-sion between any two particular nodes In thisway global minimum power paths are foundwithout considering all the nodes in the networkThis is performed using a localized search foreach node considering its relay region MECN isself-reconfiguring and thus can dynamicallyadapt to node failure or the deployment of newsensors The small MECN (SMECN) [24] is anextension to MECN In MECN it is assumedthat every node can transmit to every othernode which is not possible every time InSMECN possible obstacles between any pair ofnodes are considered However the network isstill assumed to be fully connected as in the caseof MECN The subnetwork constructed bySMECN for minimum energy relaying is prov-ably smaller (in terms of number of edges) thanthe one constructed in MECN Hence the sub-network (ie subgraph G ′) constructed bySMECN is smaller than the one constructed byMECN if the broadcast region is circular aroundthe broadcasting node for a given power settingSubgraph G′ of graph G which represents then Figure 5 Time line for the operation of a) TEEN and b) APTEEN(a)ParametersTimeClusterhead receivesmessageCluster changetimeAttribute > threshold(b)TDMA scheduleand parametersTimeFrame timeCluster formationCluster changetimeSlot fornode iImportant features of TEEN include itssuitability for time-critical sensing applications Alsosince message transmission consumes more energy than datasensing the energyconsumption in thisscheme is less than in proactivenetworks                      IEEE Wireless Communications • December 200418sensor network minimizes the energy usage sat-isfying the following conditions:• The number of edges in G′ is less than in Gwhile containing all nodes in G• The energy required to transmit data from anode to all its neighbors in subgraph G’ is lessthan the energy required to transmit to all itsneighbors in graph G Assume that r = (u u1… v) is a path between u and v that spans k –1 intermediate nodes u1 … uk–1 The totalpower consumption of one path like r is givenbywhere u = u0 and v = uk and the powerrequired to transmit data under this protocol isp(uv) = td(uv)nfor some appropriate constant t n is the pathloss exponent of outdoor radio propagationmodels n ≥ 2 and d(uv) is the distance betweenu and v It is assumed that a reception at thereceiver takes a constant amount of powerdenoted c  The subnetwork computed bySMECN helps in sending messages on mini-mum-energy paths However the proposed algo-rithm is local in the sense that it does notactually find the minimum-energy path it justconstructs a subnetwork in which it is guaran-teed to exist Moreover the subnetwork con-structed by SMECN makes it more likely thatthe path used is one that requires less energyconsumption In addition finding a subnetworkwith a smaller number of edges introduces moreoverhead in the algorithmSelf-organizing protocol: Subramanian et al[25] describes a self-organizing protocol (SOP)and an application taxonomy that was used tobuild architecture to support heterogeneoussensors Furthermore these sensors can bemobile or stationary Some sensors probe theenvironment and forward the data to a designat-ed set of nodes that act as routers Router nodesare stationary and form the backbone for com-munication Collected data are forwardedthrough the routers to the more powerful BSnodes Each sensing node should be able toreach a router in order to be part of the net-work A routing architecture that requiresaddressing of each sensor node has been pro-posed Sensing nodes are identifible through theaddress of the router node to which they areconnected The routing architecture is hierarchi-cal where groups of nodes are formed andmerge when needed The Local Markov Loops(LML) algorithm which performs a randomwalk on spanning trees of a graph was used tosupport fault tolerance and as a means of broad-casting Such an approach is similar to the ideaof a virtual grid used in some other protocolsdiscussed later under location-based routingprotocols In this approach sensor nodes can beaddressed individually in the routing architec-ture; hence it is suitable for applications wherecommunication to a particular node is requiredFurthermore this algorithm incurs a small costfor maintaining routing tables and keeping abalanced routing hierarchy It was also foundthat the energy consumed for broadcasting amessage is less than that consumed in the SPINprotocol This protocol however is not an on-demand protocol especially in the organizationphase of the algorithm and thus introducesextra overhead Another issue is related to theformation of a hierarchy It could happen thatthere are many cuts in the network and hencethe probability of applying reorganization phaseincreases which is an expensive operationSensor aggregates routing: In [26] a set ofalgorithms for constructing and maintaining sen-sor aggregates were proposed The objective isto collectively monitor target activity in a certainenvironment (target tracking applications) Asensor aggregate comprises those nodes in a net-work that satisfy a grouping predicate for a col-laborative processing task The parameters ofthe predicate depend on the task and its resourcerequirements The formation of appropriate sen-sor aggregates were discussed in [26] in terms ofallocating resources to sensing and communica-tion tasks Sensors in a sensor field are dividedinto clusters according to their sensed signalstrength so there is only one peak per clusterThen local cluster leaders are elected One peakmay represent one target multiple targets or notarget if the peak is generated by noise sourcesTo elect a leader information exchangesbetween neighboring sensors are necessary If asensor after exchanging packets with all its one-hop neighbors finds that it is higher than all itsone-hop neighbors on the signal field landscapeit declares itself a leader This leader-basedtracking algorithm assumes that the unique lead-er knows the geographical region of the collabo-rationThree algorithms were proposed in [26] Firstwas a lightweight protocol Distributed Aggre-gate Management (DAM) for forming sensoraggregates for a target monitoring task The pro-tocol comprises a decision predicate P for eachnode to decide if it should participate in anaggregate and a message exchange scheme Mabout how the grouping predicate is applied tonodes A node determines if it belongs to anaggregate based on the result of applying thepredicate to the data of the node as well asinformation from other nodes Aggregates areformed when the process eventually convergesSecond Energy-Based Activity Monitoring(EBAM) estimates the energy level at each nodeby computing the signal impact area combininga weighted form of the detected target energy ateach impacted sensor assuming that each targetsensor has equal or constant energy level Thethird algorithm Expectation-Maximization LikeActivity Monitoring (EMLAM) removes theconstant and equal target energy level assump-tion EMLAM estimates the target positions andsignal energy using received signals and uses theresulting estimates to predict how signals fromthe targets may be mixed at each sensor Thisprocess is iterated until the estimate is sufficient-ly goodThe distributed track initiation managementscheme combined with the leader-based track-ing algorithm described in [26] forms a scalablesystem The system works well in tracking multi-ple targets when the targets are not interferingC r p u u ci iik( ) ( (  ) )= ++=−∑ 101The subnetwork constructed bySMECN makes itmore likely that thepath used is onethat requires lessenergy consumptionIn addition finding asub-network with asmaller number ofedges introducesmore overhead inthe algorithm                                                                                        IEEE Wireless Communications • December 2004 19and it can recover from intertarget interferenceonce the targets move apartVirtual grid architecture routing: An energy-efficient routing paradigm is proposed in [27]that utilizes data aggregation and in-networkprocessing to maximize the network lifetimeDue to the node stationarity and extremely lowmobility in many applications in WSNs a rea-sonable approach is to arrange nodes in a fixedtopology as briefly mentioned in [28] A GPS-free approach [2] is used to build clusters thatare fixed equal adjacent and nonoverlappingwith symmetric shapes In [27] square clusterswere used to obtain a fixed rectilinear virtualtopology Inside each zone a node is optimallyselected to act as CH Data aggregation is per-formed at two levels: local and then global Theset of CHs also called local aggregators (LAs)perform local aggregation while a subset ofthese LAs are used to perform global aggrega-tion However the determination of an optimalselection of global aggregation points calledmaster aggregators (MAs) is NP-hard Figure 6illustrates an example of fixed zoning and theresulting virtual grid architecture (VGA) used toperform two-level data aggregation Note thatthe location of the BS is not necessarily at theextreme corner of the grid; it can be located atany arbitrary placeTwo solution strategies for the routing withdata aggregation problem are presented in [27]:an exact algorithm using an integer linear pro-gram (ILP) formulation and some near-optimalbut simple and efficient approximate algorithms:a genetics-algorithm-based heuristic a k-meansheuristic and a greedy-based heuristic In [29]another efficient heuristic the Clustering-BasedAggregation Heuristic (CBAH) was also pro-posed to minimize energy consumption in thenetwork and hence prolong the network lifetimeThe objective of all algorithms is to select anumber of MAs out of the LAs that maximizenetwork lifetime For a realistic scenario it isassumed in [27] that LA nodes form possiblyoverlapping groups Members of each group sen-sie the same phenomenon; hence their readingsare correlated However each LA node thatexists in the overlapping region will send data toits associated MA for each of the groups towhich it belongs It was noted in [29] that theproblem of assigning MAs to LAs in CBAH issimilar to the classical bin packing problem amajor difference being that neither the identitiesnor the amount of power each MA will be usingfor different LAs are known In CBAH the setof MAs are selected based on incremental filingof some bins with capacities Besides being fastand scalable to large sensor networks theapproximate algorithms in [27 29] produceresults not far from the optimal solutionHierarchical power-aware routing: In [30]hierarchical power-aware routing was proposedThe protocol divides the network into groups ofsensors Each group of sensors in geographicproximity are clustered together as a zone andeach zone is treated as an entity To performrouting each zone is allowed to decide how itwill route a message hierarchically across theother zones such that the battery lives of thenodes in the system are maximized Message arerouted along the path that has the maximumover all the minimum of the remaining powercalled the max-min path The motivation is thatusing nodes with high residual power may bemore expensive than the path with the minimalpower consumption An approximation algo-rithm called the max-min zPmin algorithm wasproposed in [30] The crux of the algorithm isbased on the trade-off between minimizing thetotal power consumption and maximizing theminimal residual power of the network Hencethe algorithm tries to enhance a max-min pathby limiting its power consumption as followsFirst the algorithm finds the path with the leastpower consumption (Pmin) by using the Dijkstraalgorithm Second the algorithm finds a paththat maximizes the minimal residual power inthe network The proposed algorithm tries tooptimize both solution criteria This is achievedby relaxing the minimal power consumption forthe message to be equal to zPmin with parameterz ≥ 1 to restrict the power consumption for send-ing one message to zPmin The algorithm con-sumes at most zPmin while maximizing theminimal residual power fractionAnother algorithm that relies on max-minzPmin called zone-based routing is also pro-posed in [30] Zone-base routing is a hierarchicalapproach where the area covered by the (sensor)n Figure 6 Regular shape tessellation applied to the network areaBase stationSensor node Local aggregator nodeMaster aggregator node                            IEEE Wireless Communications • December 200420network is divided into a small number of zonesTo send a message across the entire area a glob-al path from zone to zone is found The sensorsin a zone autonomously direct local routing andparticipate in estimating the zone power levelEach message is routed across the zones usinginformation about the zone power estimates Aglobal controller for message routing is assignedthe role of managing the zones This may be thenode with the highest power If the network canbe divided into a relatively small number ofzones the scale for the global routing algorithmis reduced The global information required tosend each message across is summarized by thepower level estimate of each zone A zone graphwas used to represent connected neighboringzone vertices if the current zone can go to thenext neighboring zone in that direction Eachzone vertex has a power level of 1 Each zonedirection vertex is labeled by its estimated powerlevel computed by a procedure which is a modi-fied Bellman-Ford algorithm Moreover twoalgorithms were outlined for local and globalpath selection using the zone graphTwo-Tier Data Dissemination: An approachin [6] called Two-Tier Data Dissemination(TTDD) provides data delivery to multiplemobile BS In TTDD each data source proac-tively builds a grid structure that is used to dis-seminate data to the mobile sinks by assumingthat sensor nodes are stationary and location-aware In TTDD sensor nodes are stationaryand location-aware whereas sinks may changetheir locations dynamically Once an eventoccurs sensors surrounding it process the signaland one of them becomes the source to generatedata reports Sensor nodes are aware of theirmission which will not change frequently Tobuild the grid structure a data source choosesitself as the start crossing point of the grid andsends a data announcement message to each ofits four adjacent crossing points using simplegreedy geographical forwarding When the mes-sage reaches the node closest to the crossingpoint (specified in the message) it will stopDuring this process each intermediate nodestores the source information and further for-wards the message to its adjacent crossing pointsexcept the one from which the message comesThis process continues until the message stops atthe border of the network The nodes that storethe source information are chosen as dissemina-tion points After this process the grid structureis obtained Using the grid a BS can flood aquery which will be forwarded to the nearestdissemination point in the local cell to receivedata Then the query is forwarded along otherdissemination points upstream to the sourceThe requested data then flows down in thereverse path to the sink Trajectory forwarding isemployed as the BS moves in the sensor fieldAlthough TTDD is an efficient routing approachthere are some concerns about how the algo-rithm obtains location information which isrequired to set up the grid structure The lengthof a forwarding path in TTDD is larger than thelength of the shortest path The authors ofTTDD believe that the suboptimality in the pathlength is worth the gain in scalability Finallyhow TTDD would perform if mobile sensornodes are allowed to move in the network is stillan open question Comparison results betweenTTDD and directed diffusion showed thatTTDD can achieve longer lifetimes and shorterdata delivery delays However the overheadassociated with maintaining and recalculatingthe grid as network topology changes may behigh Furthermore TTDD assumed the avail-ability of a very accurate positioning system thatis not yet available for WSNsThe above mentioned flat and hierarchicalprotocols are different in many aspects At thispoint we compare the different routingapproaches for flat and hierarchical sensor net-works as shown in Table 2Location-Based Routing Protocols — In this kind ofrouting sensor nodes are addressed by means oftheir locations The distance between neighbor-ing nodes can be estimated on the basis ofn Table 2 Hierarchical vs flat topologies routingHierarchical routing Flat routingReservation-based scheduling Contention-based schedulingCollisions avoided Collision overhead presentReduced duty cycle due to periodic sleeping Variable duty cycle by controlling sleep time of nodesData aggregation by clusterhead Node on multihop path aggregates incoming data from neighborsSimple but non-optimal routing Routing can be made optimal but with an added complexityRequires global and local synchronization Links formed on the fly without synchronizationOverhead of cluster formation throughout the network Routes formed only in regions that have data for transmissionLower latency as multiple hops network formed by Latency in waking up intermediate nodescluster- heads always available and setting up the multipathEnergy dissipation is uniform Energy dissipation depends on traffic patternsEnergy dissipation cannot be controlled Energy dissipation adapts to traffic patternFair channel allocation Fairness not guaranteed             IEEE Wireless Communications • December 2004 21incoming signal strengths Relative coordinatesof neighboring nodes can be obtained byexchanging such information between neighbors[1 2 31] Alternatively the location of nodesmay be available directly by communicating witha satellite using GPS if nodes are equipped witha small low-power GPS receiver [28] To saveenergy some location-based schemes demandthat nodes should go to sleep if there is no activ-ity More energy savings can be obtained by hav-ing as many sleeping nodes in the network aspossible The problem of designing sleep periodschedules for each node in a localized mannerwas addressed in [32 28] In the rest of this sec-tion we review most of the location- or geo-graphic-based routing protocolsGeographic Adaptive Fidelity: GAF [28] isan energy-aware location-based routing algo-rithm designed primarily for mobile ad hoc net-works but may be applicable to sensor networksas well The network area is first divided intofixed zones and form a virtual grid Inside eachzone nodes collaborate with each other to playdifferent roles For example nodes will electone sensor node to stay awake for a certainperiod of time and then the rest go to sleepThis node is responsible for monitoring andreporting data to the BS on behalf of the nodesin the zone Hence GAF conserves energy byturning off unnecessary nodes in the networkwithout affecting the level of routing fidelityEach node uses its GPS-indicated location toassociate itself with a point in the virtual gridNodes associated with the same point on thegrid are considered equivalent in terms of thecost of packet routing Such equivalence isexploited in keeping some nodes located in aparticular grid area in sleeping state in order tosave energy Thus GAF can substantiallyincrease the network lifetime as the number ofnodes increases There are three states definedin GAF: discovery for determining the neigh-bors in the grid; active reflecting participationin routing; and sleep when the radio is turnedoff In order to handle mobility each node inthe grid estimates its time of leaving the gridand sends this to its neighbors The sleepingneighbors adjust their sleeping time accordinglyin order to keep routing fidelity Before theleaving time of the active node expires sleepingnodes wake up and one of them becomes activeGAF is implemented both for nonmobility(GAF-basic) and mobility (GAF-mobility adap-tation) of nodes Figure 7 shows an example offixed zoning that can be used in sensor networkssimilar to that proposed in [28] The fixed clus-ters in [28] are selected to be equal and squareThe selection of the square size is dependent onthe required transmitting power and communi-cation direction Vertical and horizontal com-munication is guaranteed to happen if the signaltravels a distance of a = r/2√2 chosen such thatany two sensor nodes in adjacent vertical orhorizontal clusters can communicate directlyFor diagonal communication to happen the sig-nal has to span a distance of b = r/2√2 Theissue is how to schedule roles for the nodes toact as CHs A CH can ask the sensor nodes inits cluster to switch on and start gathering dataif it senses an object Then the CH is responsi-ble for receiving raw data from other nodes inits cluster and forwarding it to the BS Theauthors in [28] assumed that sensor nodes canknow their locations using GPS cards which isinconceivable with current technology GAFstrives to keep the network connected by keep-ing a representative node always in active modefor each region on its virtual grid Simulationresults show that GAF performs at least as wellas a normal ad hoc routing protocol in terms oflatency and packet loss and increases the life-time of the network by saving energy AlthoughGAF is a location-based protocol it may also beconsidered a hierarchical protocol where theclusters are based on geographic location Foreach particular grid area a representative nodeacts as the leader to transmit the data to othernodes The leader node however does not doany aggregation or fusion as in the case of otherhierarchical protocols discussed earlierGeographic and Energy Aware Routing: Yuet al [33] discussed the use of geographic infor-mation while disseminating queries to appropri-ate regions since data queries often includegeographic attributes The protocol Geographicand Energy Aware Routing (GEAR) uses ener-gy-aware and geographically informed neighborselection heuristics to route a packet toward thedestination region The key idea is to restrict thenumber of interests in directed diffusion by onlyconsidering a certain region rather than sendingthe interests to the whole network By doingthis GEAR can conserve more energy thandirected diffusionEach node in GEAR keeps an estimatedcost and a learning cost of reaching the destina-tion through its neighbors The estimated costis a combination of residual energy and dis-tance to destination The learned cost is arefinement of the estimated cost that accountsfor routing around holes in the network A holeoccurs when a node does not have any closerneighbor to the target region than itself Ifthere are no holes the estimated cost is equalto the learned cost The learned cost is propa-n Figure 7 An example of zoning in sensor net-worksLocal aggregator (LA)aarbTo save energysome location basedschemes demandthat nodes should goto sleep if there isno activity Moreenergy savings canbe obtained by having as manysleeping nodes in the network as possible                          IEEE Wireless Communications • December 200422gated one hop back every time a packet reachesthe destination so that route setup for the nextpacket will be adjusted There are two phasesin the algorithm:• Forwarding packets toward the target region:Upon receiving a packet a node checks itsneighbors to see if there is one neighbor thatis closer to the target region than itself Ifthere are more than one the nearest neighborto the target region is selected as the nexthop If they are all further than the nodeitself this means there is a hole In this caseone of the neighbors is picked to forward thepacket based on the learning cost functionThis choice can then be updated according tothe convergence of the learned cost during thedelivery of packets• Forwarding the packets within the region: Ifthe packet has reached the region it can bediffused in that region by either recursive geo-graphic forwarding or restricted floodingRestricted flooding is good when the sensorsare not densely deployed In high-density net-works recursive geographic forwarding ismore energy-efficient than restricted floodingIn that case the region is divided into four suregions and four copies of the packet are cre-ated This splitting and forwarding processcontinues until regions with only one node areleftIn [33] GEAR was compared to a similarnon-energy-aware routing protocol GPSR [34]which is one of the earlier methods in geograph-ic routing and uses planar graphs to solve theproblem of holes In GPSR the packets followthe perimeter of the planar graph to find theirroute Although the GPSR approach reduces thenumber of states a node should keep it wasdesigned for general mobile ad hoc networksand requires a location service to map locationsand node identifiers GEAR not only reducesenergy consumption for route setup but alsoperforms better than GPSR in terms of packetdelivery The simulation results show that foruneven traffic distribution GEAR delivers 70–80percent more packets than GPSR For uniformtraffic pairs GEAR delivers 25–35 percent morepackets than GPSRMFR DIR and GEDIR: Stojmenovic andLin [35] described and discussed basic localizedrouting algorithms These protocols deal withbasic distance progress and direction-basedmethods The key issues are forward and back-ward directions A source node or any interme-diate node will  select one of its neighborsaccording to a certain criterion The routingmethods that belong to this category are MostForward within Radius (MFR) GeographicDistance Routing (GEDIR) that is a variant ofgreedy algorithms the two-hop greedy methodalternate greedy method and DIR (a compassrouting method) GEDIR is a greedy algorithmthat always moves the packet to the neighbor ofthe current vertex whose distance to the desti-nation is minimized The algorithm fails whenthe packet crosses the same edge twice in suc-cession In most cases the MFR and greedymethods have the same path to the destinationIn the DIR method the best neighbor has theclosest direction (ie angle) toward the desti-nation That is the neighbor with the minimumangular distance from the imaginary line joiningthe current node and the destination is select-ed In MFR the best neighbor A will minimizethe dot product DA— DS— where S D are thesource and destination nodes respectively andSD— represents the Euclidian distance betweenthe two nodes S D Alternatively one can max-imize the dot product SD—SA— Each methodstops forwarding the message at a node forwhich the best choice is to return the messageback to a previous node GEDIR and MFRsare loop-free while DIR may create loopsunless past traffic is memorized or a time-stamp is enforced [35]A comparison study [35] between these algo-rithms showed that the three basic algorithmshad comparable performance in terms of deliv-ery rate and average dilation Moreover simula-tions revealed that the nodes in MFR and greedymethods select the same forwarding neighbor inmore than 99 percent of cases and the entireselected paths were identical in most casesThe Greedy Other Adaptive Face Routing: In[36] a geometric ad hoc routing algorithm com-bining greedy and face routing was proposedWe will now briefly review the key points ofGreedy Other Adaptive Face Routing(GOAFR) The greedy algorithm of GOAFRalways picks the neighbor closest to a node to benext for routing However it can easily be stuckat some local minimum (ie no neighbor is clos-er to a node than the current node) Other FaceRouting (OFR) is a variant of Face Routing(FR) The FR algorithm [35] is the first thatguarantees success if the source and destinationare connected However the worst case cost ofFR is proportional to the size of the network interms of number of nodes The first algorithmthat can compete with the best route in theworst case is Adaptive Face Routing (AFR)Moreover by a lower bound argument AFR isshown to be asymptotically worst-case optimalBut AFR is not average-case efficient OFR uti-lizes the face structure of planar graphs suchthat the message is routed from node s to node tby traversing a series of face boundaries Theaim is to find the best node on the boundary(ie the closest node to the destination t) byusing geometric planes When finished the algo-rithm returns to s the best node on the bound-ary The simple greedy algorithm behaves well indense networks but fails for very simple configu-rations as was shown in [36] It was shown thatGOAFR can achieve both worst-case optimalityand average-case efficiency Based on the simu-lation results of GOAFR there are several waysto further improve the average-case perfor-mance It was also shown that GOAFR outper-forms other prominent algorithms such as GPSRand AFRSPAN: Another position-based algorithmcalled SPAN [32] selects some nodes as coor-dinators based on their positions The coordi-nators form a network backbone used toforward messages A node should become acoordinator if two neighbors of a non-coordi-nator node cannot reach each other directly orvia one or two coordinators (three-hop reacha-bility) New and existing coordinators are notThe simulationresults show that for an uneven trafficdistribution GEARdelivers 70 percentto 80 percent morepackets than GPSRFor uniform trafficpairs GEAR delivers25 percent to 35percent more packets than GPSR                                      IEEE Wireless Communications • December 2004 23necessarily neighbors in [32] which in effectmakes the design less energy-efficient becauseof the need to maintain the positions of two-or three-hop neighbors in the complicatedSPAN algorithmROUTING PROTOCOLS BASED ONPROTOCOL OPERATIONIn this section we review routing protocols withdifferent routing functionality It should benoted that some of these protocols may fallunder one or more of the above routing cate-goriesMultipath Routing Protocols — In this subsection westudy routing protocols that use multiple pathsrather than a single path in order to enhancenetwork performance The fault tolerance(resilience) of a protocol is measured by thelikelihood that an alternate path exists betweena source and a destination when the primarypath fails This can be increased by maintainingmultiple paths between the source and destina-tion at the expense of increased energy con-sumption and traffic generation These alternatepaths are kept alive by sending periodic mes-sages Hence network reliability can beincreased at the expense of increased overheadin maintaining the alternate pathsThe authors in [37] proposed an algorithmthat routes data through a path whose nodeshave the largest residual energy The path ischanged whenever a better path is discoveredThe primary path will be used until its energyfalls below the energy of the backup path atwhich time the backup path is used Using thisapproach the nodes in the primary path will notdeplete their energy resources through continualuse of the same route hence achieving longerlife However the path switching cost was notquantified in the articleThe authors of [38] proposed the use of a setof suboptimal paths occasionally to increase thelifetime of the network These paths are chosenby means of a probability that depends on howlow the energy consumption of each path isThe path with the largest residual energywhen used to route data in a network may bevery energy-expensive too so there is a trade-off between minimizing the total power con-sumed and the residual energy of the networkThe authors in [30] proposed an algorithm inwhich the residual energy of the route isrelaxed a bit in order to select a more energy-efficient pathIn [39] multipath routing was used toenhance the reliability of WSNs The proposedscheme is useful for delivering data in unreliableenvironments It is known that network reliabili-ty can be increased by providing several pathsfrom source to destination and sending the samepacket on each path However using this tech-nique traffic will increase significantly Hencethere is a trade-off between the amount of traf-fic and the reliability of the network This trade-off is studied in [39] using a redundancy functionthat is dependent on the multipath degree andfailing probabilities of the available paths Theidea is to split the original data packet into sub-packets and then send each subpacket throughone of the available multipaths It has beenfound that even if some of these subpackets arelost the original message can still be recon-structed According to their algorithm it hasalso been found that for a given maximum nodefailure probability using a higher multipathdegree than a certain optimal value will increasethe total probability of failureDirected diffusion [12] is a good candidatefor robust multipath routing and delivery Basedon the directed diffusion paradigm a multipathrouting scheme that finds several partially dis-joint paths is studied in [40] (alternate routes arenot node disjoint ie routes are partially over-lapped) It has been found that the use of multi-path routing provides a viable alternative forenergy-efficient recovery from failures in WSNsThe motivation for using these braided paths isto keep the cost of maintaining the multipathslow The costs of alternate paths are comparableto the primary path because they tend to bemuch closer to the primary pathQuery-Based Routing — In this kind of routing thedestination nodes propagate a query for data(sensing task) from a node through the networkand a node with this data sends the data thatmatches the query back to the node that initiat-ed the query Usually these queries are describedin natural language or high-level query lan-guages For example client C1 may submit aquery to node N1 and ask: Are there moving vehi-cles in battle space region 1? All the nodes havetables consisting of the sensing task queries theyreceive and send data that matches these taskswhen they receive it Directed diffusion [12]described earlier is an example of this type ofrouting In directed diffusion the BS node sendsout interest messages to sensors As the interestis propagated throughout the sensor networkthe gradients from the source back to the BS areset up When the source has data for the inter-est the source sends the data along the interest’sgradient path To lower energy consumptiondata aggregation (eg duplicate suppression) isperformed en routeThe rumor routing protocol [41] uses a set oflong-lived agents to create paths that are direct-ed toward the events they encounter Wheneveran agent crosses a path leading to an event it hasnot encountered yet it creates a path state thatleads to the event When agents come acrossshorter paths or more efficient paths they opti-mize the paths in routing tables accordinglyEach node maintains a list of its neighbors andan events table that is updated whenever newevents are encountered Each node can also gen-erate an agent in a probabilistic fashion Eachagent contains an events table that is synchro-nized with every node it visits The agent has alifetime of a certain number of hops after whichit dies A node will not generate a query unlessit learns a route to the required event If there isno route available the node transmits a query ina random direction Then the node waits toknow if the query reached the destination for acertain amount of time after which the nodefloods the network if no response is receivedfrom the destinationIt was shown thatGOAFR can achieveboth worst-case opti-mality and average-case efficiencyBased on thesimulation results ofGOAFR there areseveral ways to further improve theaverage-case performance It wasalso shown thatGOAFR outperformsother prominentalgorithms such asGPSR or AFR            IEEE Wireless Communications • December 200424Negotiation-Based Routing Protocols — These proto-cols use high-level data descriptors in order toeliminate redundant data transmissions throughnegotiation Communication decisions are alsomade based on the resources available to themThe SPIN family protocols [9] discussed earlierand the protocols in [10] are examples of nego-tiation-based routing protocols The motivationis that the use of flooding to disseminate datawill produce implosion and overlap between thesent data so nodes will receive duplicate copiesof the same data This operation consumesmore energy and processing by sending thesame data by different sensors The SPIN proto-cols are designed to disseminate the data of onesensor to all other sensors assuming these sen-sors are potential BSs Hence the main idea ofnegotiation-based routing in WSNs is to sup-press duplicate information and prevent redun-dant data from being sent to the next sensor orthe BS by conducting a series of negotiationmessages before the real data transmissionbeginsQoS-based Routing — In QoS-based routing proto-cols the network has to balance between energyconsumption and data quality In particular thenetwork has to satisfy certain QoS metrics(delay energy bandwidth etc) when deliveringdata to the BSSequential Assignment Routing (SAR) pro-posed in [42] is one of the first routing proto-cols for WSNs to introduce the notion of QoSinto routing decisions A routing decision inSAR is dependent on three factors: energyresources QoS on each path and the prioritylevel of each packet To avoid single route fail-ure a multipath approach and localized pathrestoration schemes are used To create multi-ple paths from a source node a tree rooted atthe source node to the destination nodes (iethe set of BSs) is built The paths of the tree arebuilt while avoiding nodes with low energy orQoS guarantees At the end of this processeach sensor node will be part of a multipathtree As such SAR is a table-driven multipathprotocol that aims to achieve energy efficiencyand fault tolerance In essence SAR calculatesa weighted QoS metric as the product of theadditive QoS metric and a weight coefficientassociated with the priority level of the packetThe objective of SAR is to minimize the aver-age weighted QoS metric throughout the life-time of the network If topology changes due tonode failures path recomputation is needed Asa preventive measure a periodic recomputationof paths is triggered by the BS to account forany changes in topology A handshake proce-dure based on a local path restoration schemebetween neighboring nodes is used to recoverfrom a failure Failure recovery is done byenforcing routing table consistency betweenupstream and downstream nodes on each pathSimulation results showed that SAR offers lesspower consumption than the minimum  energymetric algorithm which focuses only the energyconsumption of each packet without consideringits priority SAR maintains multiple paths fromnodes to BS Although this ensures fault toler-ance and easy recovery the protocol suffersfrom the overhead of maintaining the tables andstates at each sensor node especially when thenumber of nodes is hugeAnother QoS routing protocol for WSNs thatprovides soft real-time end-to-end guaranteeswas introduced in [43] The protocol requireseach node to maintain information about itsneighbors and uses geographic forwarding tofind the paths In addition SPEED strives toensure a certain speed for each packet in thenetwork so that each application can estimatethe end-to-end delay for the packets by dividingthe distance to the BS by the speed of the pack-et before making an admission decision More-over SPEED can provide congestion avoidancewhen the network is congested The routingmodule in SPEED is called Stateless GeographicNondeterministic Forwarding (SNFG) and workswith four other modules at the network layerDelay estimation at each node is basically madeby calculating the elapsed time before an ACK isreceived from a neighbor as a response to atransmitted data packet By looking at the delayvalues SNGF selects the node that meets thespeed requirement If it fails the relay ratio ofthe node is checked calculated by looking at themiss ratios of the neighbors of a node (the nodesthat could not provide the desired speed) and isfed to the SNGF module When compared toDSR and AOVD SPEED performs better interms of end-to-end delay and miss ratio More-over the total transmission energy is less due tothe simplicity of the routing algorithm; controlpacket overhead is less However SPEED doesnot consider any further energy metric in itsrouting protocol Therefore for more realisticunderstanding of SPEED’s energy consumptionthere is a need to compare it to a routing proto-col that is energy-awareCoherent and Noncoherent Processing — Data process-ing is a major component in the operation ofwireless sensor networks Hence routing tech-niques employ different data processing tech-niques In general sensor nodes will cooperatewith each other in processing different dataflooded in the network area Two examples ofdata processing techniques proposed in WSNsare coherent and noncoherent data-processing-based routing [42] In noncoherent data process-ing routing nodes will locally process the rawdata before it is sent to other nodes for furtherprocessing The nodes that perform further pro-cessing are called aggregators In coherent rout-ing the data is forwarded to aggregators afterminimum processing The minimum processingtypically includes tasks like timestamping andduplicate suppressio To perform energy-effi-cient routing coherent processing is normallyselectedNoncoherent functions have fairly low datatraffic loading On the other hand since coher-ent processing generates long data streamsenergy efficiency must be achieved by path opti-mality In noncoherent processing data process-ing incurs three phases:• Target detection data collection and prepro-cessing• Membership declaration• Central node electionThe main idea ofnegotiation-basedrouting in WSNs isto suppress duplicateinformation and prevent redundantdata from being sentto the next sensor orthe basestation byconducting a seriesof negotiation messages before the real data transmission begins         IEEE Wireless Communications • December 2004 25During phase 1 a target is detected its data col-lected and preprocessed When a node decidesto participate in a cooperative function it willenter phase 2 and declare this intention to allneighbors This should be done as soon as possi-ble so that each sensor has a local understandingof the network topology Phase 3 is the electionof the central node Since the central node isselected to perform more sophisticated informa-tion processing it must have sufficient energyreserves and computational capabilityIn [42] single and multiple winner algorithmswere proposed for noncoherent and coherentprocessing respectively In the single winneralgorithm (SWE) a single aggregator node iselected for complex processing The election of anode is based on the energy reserves and com-putational capability of that node By the end ofthe SWE process a minimum-hop spanning treewill completely cover the network In the multi-ple winner algorithm (MWE) a simple extensionto SWE is proposed When all nodes are sourcesand send their data to the central aggregatornode a large amount of energy will be con-sumed; hence this process has a high cost Oneway to lower the energy cost is to limit the num-ber of sources that can send data to the centralaggregator node Instead of keeping a record ofonly the best candidate node (master aggregatornode) each node will keep a record of up to nnodes of those candidates At the end of theMWE process each sensor in the network has aset of minimum-energy paths to each sourcenode (SN) After that SWE is used to find thenode that yields the minimum energy consump-tion This node can then serve as the centralnode for coherent processing In general theMWE process has longer delay higher overheadand lower scalability than that for noncoherentprocessing networksWe observed that there are some hybrid pro-tocols that fit under more than one category Wesummarize recent results on data routing inWSNs in Table 3 The table shows how differentrouting protocols ft under different categoriesand also compares different routing techniquesaccording to many metricsROUTING IN WSNS: FUTURE DIRECTIONSThe future vision of WSNs is to embed numer-ous distributed devices to monitor and interactwith physical world phenomena and to exploitspatially and temporally dense sensing and actu-ation capabilities of those sensing devices Thesenodes coordinate among themselves to create anetwork that performs higher-level tasksAlthough extensive efforts have been exertedso far on the routing problem in WSNs thereare still some challenges that confront effectivesolutions to the routing problem First there istight coupling between sensor nodes and thephysical world Sensors are embedded in unat-tended places or systems This is different fromtraditional Internet PDA and mobility applica-tions that interface primarily and directly withhuman users Second sensors are characterizedby a small footprint and as such nodes presentstringent energy constraints since they areequipped with small finite energy sources Thisis also different from traditional fixed butreusable resources Third communications isthe primary consumer of energy in this environ-ment where sending a bit over 10 or 100 m con-sumes as much energy as thousands to millionsof operations (known as R4 signal energydropoff) [44]Although the performance of these protocolsis promising in terms of energy efficiency fur-ther research is needed to address issues such asQoS posed by video and imaging sensors andreal-time applications Energy-aware QoS rout-ing in sensor networks will ensure guaranteedbandwidth (or delay) through the duration ofconnection as well as provide the use of themost energy efficient path Another interestingissue for routing protocols is the considerationof node mobility Most current protocols assumethat the sensor nodes and BS are stationaryHowever there might be situations such as bat-tle environments where the BS and possibly thesensors need to be mobile In such cases fre-quent update of the position of the commandnode and sensor nodes and propagation of thatinformation through the network may excessivelydrain the energy of nodes New routing algo-rithms are needed in order to handle the over-head of mobility and topology changes in suchan energy-constrained environment Futuretrends in routing techniques in WSNs focus ondifferent directions; all share the common objec-tive of prolonging network lifetime We summa-rize some of these directions and give somepertinent references as follows:•Exploit redundancy: Typically a large num-ber of sensor nodes are implanted inside orbeside the phenomenon Since sensor nodes areprone to failure fault tolerance techniques comeinto the picture to keep the network operatingand performing its tasks Routing techniquesthat explicitly employ fault tolerance techniquesin an efficient manner are still under investiga-tion (eg [39])•Tiered architectures (mix of form/energyfactors): Hierarchical routing is an old techniqueto enhance scalability and efficiency of the rout-ing protocol However novel techniques of net-work clustering that maximize network lifetimeare also a hot area of research in WSNs (eg[45])•Exploit spatial diversity and density of sen-sor/actuator nodes: Nodes will span a networkarea that might be large enough to provide spa-tial communication between sensor nodesAchieving energy-efficient communication in thisdensely populated environment deserves furtherinvestigation Dense deployment of sensor nodesshould allow the network to adapt to an unpre-dictable environment•Achieve desired global behavior with adap-tive localized algorithms (ie do not rely onglobal interaction or information): However in adynamic environment this is hard to model (eg[12])•Leverage data processing inside the networkand exploit computation near data sources toreduce communication (ie perform in-networkdistributed processing): WSNs are organizedaround naming data not nodes’ identities Sincewe have large collections of distributed ele-The future vision ofWSNs is to embednumerous distributeddevices to monitorand interact withphysical world phenomena and toexploit spatially andtemporally densesensing and actuation capabilitiesof those sensingdevices            IEEE Wireless Communications • December 200426ments localized algorithms that achieve system-wide properties in terms of local processing ofdata before it is sent to the destination are stillneeded Nodes in the network will store nameddata and make it available for processing Thereis a high need to create efficient processingpoints in the network (eg duplicate suppres-sion aggregation correlation of data) How toefficiently and optimally find those points is stillan open research issue (eg [27])•Time and location synchronization: Energy-efficient techniques for associating time and spa-tial coordinates with data to supportcollaborative processing are also required [1]•Localization: Sensor nodes are randomlydeployed into an unplanned infrastructure Theproblem of estimating spatial coordinates of thenode is referred to as localization GPS cannotbe used in WSNs as GPS can work only out-doors and not in the presence of any obstruc-tion Moreover GPS receivers are expensive andunsuitable for the construction of small cheapsensor nodes Hence there is a need to developother means of establishing a coordinate systemwithout relying on an existing infrastructureMost of the proposed localization techniquestoday depend on recursive trilateration/multilat-eration techniques (eg [46]) which would notprovide enough accuracy in WSNs•Self-configuration and reconfiguration areessential to the lifetime of unattended systems ina dynamic and energy constrained environmentThis is important for keeping the network upand running As nodes die and leave the net-n Table 3 Classification and comparison of routing protocols in wireless sensor networksClassifi- Mobility Position Power Negotiation- Data aggre- Local- QoS State comp- Scalab- Multi- Query-cation awareness usage based gation ization lexity ility path basedSPIN Flat Poss No Ltd Yes Yes No No Low Ltd Yes YesDirect Flat Ltd No Ltd Yes Yes Yes No Low Ltd Yes YesdiffusionRumor Flat Very Ltd No N/A No Yes No No Low Good No YesroutingGBR Flat Ltd No N/A No Yes No No Low Ltd No YesMCFA Flat No No N/A No No No No Low Good No NoCADR Flat No No Ltd No Yes No No Low Ltd No NoCOUGAR Flat No No Ltd No Yes No No Low Ltd No YesACQUIRE Flat Ltd No N/A No Yes No No Low Ltd No YesEAR Flat Ltd No N/A No No No Low Ltd No YesLEACH Hierarchical Fixed BS No Max No Yes Yes No CHs Good No NoTEEN & Hierarchical Fixed BS No Max No Yes Yes No CHs Good No NoAPTEENPEGASIS Hierarchical Fixed BS No Max No No Yes No Low Good No NoMECN & Hierarchical No No Max No No No No Low Low No NoSMECNOP Hierarchical No No N/A No No No No Low Low No NoHPAR Hierarchical No No N/A No No No No Low Good No NoVGA Hierarchical No No N/A Yes Yes Yes No CHs Good Yes NoSensor Hierarchical Ltd No N/A No Yes No No Low Good No PossaggregateTTDD Hierarchical Yes Yes Ltd No No No No Mod Low Poss PossGAF Location Ltd No Ltd No No No No Low Good No NoGEAR Location Ltd No Ltd No No No No Low Ltd No NoSPAN Location Ltd No N/A Yes No No No Low Ltd No NoMFR Location No No N/A No No No No Low Ltd No NoGEDIRGOAFR Location No No N/A No No No Low Good No NoSAR Location No No N/A Yes Yes No Yes Mod Ltd No YesSPEED QoS No No N/A No No No Yes Mod Ltd No Yes         IEEE Wireless Communications • December 2004 27work update and reconfiguration mechanismsshould take place A feature that is important inevery routing protocol is to adapt to topologychanges very quickly and to maintain the net-work functions (eg [9])•Secure routing: Current routing protocolsoptimize for the limited capabilities of nodesand the application-specific nature of networksbut do not consider security Although theseprotocols have not been designed with securityas a goal it is important to analyze their securityproperties One aspect of sensor networks thatcomplicates the design of a secure routing proto-col is in-network aggregation In WSNs in-net-work processing makes end-to-end securitymechanisms harder to deploy because intermedi-ate nodes need direct access to the contents ofthe messages (eg [47 48])Other possible future research for routingprotocols includes the integration of sensor net-works with wired networks (ie the Internet)Most applications in security and environmentalmonitoring require the data collected from sen-sor nodes to be transmitted to a server so thatfurther analysis can be done On the other handthe requests from the user should be made tothe BS through the Internet Since the routingrequirements of each environment are differentfurther research is necessary for handling thesekinds of situationsCONCLUSIONSRouting in sensor networks is a new area ofresearch with a limited but rapidly growing setof research results In this article we present acomprehensive survey of routing techniques inwireless sensor networks that have been present-ed in the literature They have the commonobjective of trying to extend the lifetime of thesensor network while not compromising datadeliveryOverall the routing techniques are classifiedbased on the network structure into three cate-gories: flat hierarchical and location-basedrouting protocols Furthermore these protocolsare classified into multipath-based query-basednegotiation-based and QoS-based routing tech-niques depending on protocol operation Wealso highlight the design trade-offs betweenenergy and communication overhead savings insome of the routing paradigm as well as theadvantages and disadvantages of each routingtechnique Although many of these routing tech-niques look promising there are still many chal-lenges that need to be solved in sensor networksWe highlight those challenges and pinpointfuture research directions in this regardREFERENCES[1] N Bulusu J Heidemann and D Estrin “GPS-less LowCost Out Door Localization for Very Small Devices”Tech rep 00729 Comp Sci Dept USC Apr 2000[2] A Savvides C-C Han and M Srivastava “DynamicFine-Grained Localization in Ad-Hoc Networks of Sen-sors” Proc 7th ACM MobiCom July 2001 pp 166–79[3] I Akyildiz et al “A Survey on Sensor Networks” IEEECommun Mag vol 40 no 8 Aug 2002 pp 102–14[4] S Tilak N Abu-Ghazaleh W Heinzelman “A Taxono-my of Wireless Micro-sensor Network Models” ACMSIGMOBILE Mobile Comp Commun Rev vol 6 no 2Apr 2002 pp 28–36[5] W Heinzelman A Chandrakasan and H Balakrishnan“Energy-Efficient Communication Protocol for WirelessMicrosensor Networks” Proc 33rd Hawaii Int’l ConfSys Sci Jan 2000[6] F Ye et al “A Two-Tier Data Dissemination Model forLarge-Scale Wireless Sensor Networks” Proc ACM/IEEEMOBICOM 2002[7] http://wwwieee802org/15/[8] F Ye et al “A Scalable Solution to Minimum Cost Forward-ing in Large Sensor Networks” Proc 10th Int’l ConfComp Commun and Networks 2001 pp 304–09[9] W Heinzelman J Kulik and H Balakrishnan “AdaptiveProtocols for Information Dissemination in WirelessSensor Networks” Proc 5th ACM/IEEE Mobicom Seat-tle WA Aug 1999 pp 174–85[10] J Kulik W R Heinzelman and H Balakrishnan“Negotiation-Based Protocols for Disseminating Infor-mation in Wireless Sensor Networks” Wireless Net-works vol 8 2002 pp 169–85[11] S Hedetniemi and A Liestman “A Survey of Gossip-ing and brocadcasting in Communication Networks”IEEE Network vol 18 no 4 1988 pp 319–49[12] C Intanagonwiwat R Govindan and D Estrin“Directed Diffusion: a Scalable and Robust Communica-tion Paradigm for Sensor Networks” Proc ACM Mobi-Com 2000 Boston MA 2000 pp 56–67[13] D Braginsky and D Estrin “Rumor Routing Algorithmfor Sensor Networks” Proc 1st Wksp Sensor Networksand Apps Atlanta GA Oct 2002[14] C Schurgers and MB Srivastava “Energy EfficientRouting in Wireless Sensor Networks” MILCOM ProcCommun for Network-Centric Ops: Creating the InfoForce McLean VA 2001[15] M Chu H Haussecker and F Zhao “Scalable Infor-mation Driven Sensor Querying and Routing for Ad HocHeterogeneous Sensor Networks” Int’l J High PerfComp Apps vol 16 no 3 Aug 2002[16] Y Yao and J Gehrke “The Cougar Approach to In-network Query Processing in Sensor Networks” SIG-MOD Record Sept 2002[17] N Sadagopan et al “The ACQUIRE Mechanism forEfficient Querying in Sensor Networks” Proc 1st Int’lWksp Sensor Network Protocol and Apps AnchorageAK May 2003[18] R C Shah and J Rabaey “Energy Aware Routing forLow Energy Ad Hoc Sensor Networks” IEEE WCNCOrlando FL Mar 17–21 2002[19] S Servetto and G Barrenechea “Constrained RandomWalks on Random Graphs: Routing Algorithms forLarge Scale Wireless Sensor Networks” Proc 1st ACMInt’l Wksp Wireless Sensor Networks and AppsAtlanta GA 2002[20] S Lindsey and C Raghavendra “PEGASIS: Power-Effi-cient Gathering in Sensor Information Systems” IEEEAerospace Conf Proc 2002 vol 3 9–16 pp 1125–30[21] A Manjeshwar and D P Agarwal “TEEN: a Routing Pro-tocol for Enhanced Efficiency in Wireless Sensor Networks”1st Int’l Wksp on Parallel and Distrib Comp Issues inWireless Networks and Mobile Comp April 2001[22] A Manjeshwar and D P Agarwal “APTEEN: A HybridProtocol for Efficient Routing and Comprehensive Infor-mation Retrieval in Wireless Sensor Networks” ProcInt’l Parallel and Distrib Proc Symp pp 195–202[23] V Rodoplu and T H Meng “Minimum Energy MobileWireless Networks” IEEE JSAC vol 17 no 8 Aug1999 pp 1333–44[24] L Li and J Y Halpern “Minimum-Energy Mobile Wire-less Networks Revisited” IEEE ICC 2001 vol 1 pp 278–83[25] L Subramanian and R H Katz “An Architecture forBuilding Self Configurable Systems” Proc IEEE/ACMWksp Mobile Ad Hoc Net and Comp Boston MAAug 2000[26] Q Fang F Zhao and L Guibas “Lightweight Sensing andCommunication Protocols for Target Enumeration andAggregation” Proc 4th ACM MOBIHOC 2003 pp 165–76[27] J N Al-Karaki et al “Data Aggregation in WirelessSensor Networks — Exact and Approximate Algo-rithms” Proc IEEE Wksp High Perf Switching andRouting 2004 Phoenix AZ Apr 18–21 2004[28] Y Xu J Heidemann and D Estrin “Geography-informed Energy Conservation for Ad-hoc Routing”Proc 7th Annual ACM/IEEE Int’l Conf Mobile Compand Net 2001 pp 70–84[29] J N Al-Karaki and A E Kamal “On the CorrelatedData Gathering Problem in Wireless Sensor Networks”to appear in the Proc 9th IEEE Symp Comp and Com-mun Alexandria Egypt July 2004One aspect of sensornetworks that complicates thedesign of a securerouting protocol is in-network aggregation In WSNs in-networkprocessing makesend-to-end securitymechanisms harderto deploy becauseintermediate nodesneed direct access to the contents ofthe messages                                                                        IEEE Wireless Communications • December 200428[30] Q Li J Aslam and D Rus “Hierarchical Power-AwareRouting in Sensor Networks” Proc DIMACS Wksp Per-vasive Net May 2001[31] S Capkun M Hamdi and J Hubaux “GPS-free Posi-tioning in Mobile Ad-hoc Networks” Proc 34th AnnualHawaii Int’l Conf Sys Sci 2001 pp 3481–90[32] B Chen et al “SPAN: an Energy-efficient CoordinationAlgorithm for Topology Maintenance in Ad Hoc Wire-less Networks” Wireless Networks vol 8 no 5 Sept2002 pp 481–94[33] Y Yu D Estrin and R Govindan “Geographical andEnergy-Aware Routing: A Recursive Data DisseminationProtocol for Wireless Sensor Networks” UCLA CompSci Dept tech rep UCLA-CSD TR-010023 May 2001[34] B Karp and H T Kung “GPSR: Greedy PerimeterStateless Routing for Wireless Sensor Networks” ProcMobiCom 2000 Boston MA Aug 2000[35] I Stojmenovic and X Lin “GEDIR: Loop-Free LocationBased Routing in Wireless Networks” Int’l Conf Paralleland Distrib Comp and Sys Boston MA Nov 3–6 1999[36] F Kuhn R Wattenhofer and A Zollinger “Worst-CaseOptimal and Average-Case Efficient Geometric Ad HocRouting” Proc 4th ACM Int’l Conf Mobile Comp andNet 2003 pp 267–78[37] J-H Chang and L Tassiulas “Maximum Lifetime Rout-ing in Wireless Sensor Networks” Proc Adv Telecom-mun and Info Distrib Research Prog College ParkMD Mar 2000[38] C Rahul and J Rabaey “Energy Aware Routing forLow Energy Ad Hoc Sensor Networks” IEEE WCNC vol1 Mar 17–21 2002 Orlando FL pp 350–55[39] S Dulman et al “Trade-Off between Traffic Overheadand Reliability in Multipath Routing for Wireless SensorNetworks” WCNC Wksp New Orleans LA Mar 2003[40] D Ganesan et al “Highly Resilient Energy-EfficientMultipath Routing in Wireless Sensor Networks” ACMSIGMOBILE Mobile Comp Commun Rev vol 5 no 42001 pp 11–25[41] D Braginsky and D Estrin “Rumor Routing AlgorithmFor Sensor Networks” Int’l Conf Distrib Comp SysNov 2001[42] K Sohrabi and J Pottie “Protocols for Self-Organiza-tion of a Wireless Sensor Network” IEEE Pers Com-mun vol 7 no 5 2000 pp 16–27 [43] T He et al “SPEED: A Stateless Protocol for Real-timeCommunication in Sensor Networks” Proc Int’l ConfDistrib Comp Sys Providence RI May 2003[44] D Goodman Wireless Personal Communications Sys-tems Reading MA: Addison-Wesley 1997[45] S Bandyopadhyay and E Coyle “An Energy Efficient Hierarchical Clustering Algorithm for WirelessSensor Networks” Proc INFOCOM 2003 vol 3 pp1713–23[46] N Bulusu et al “Scalable Coordination for WirelessSensor Networks: Self-Configuring Localization Sys-tems” Proc 6th Int’l Symp Commun Theory andApps Ambleside UK July 2001[47] A Perrig et al “SPINS: Security Protocols for Sensor Net-works” Wireless Networks vol 8 2000 pp 521–34[48] C Karlof and D Wagner “Secure Routing in WirelessSensor Networks: Attacks and Countermeasures” AdHoc Networks vol 1 2003 pp 293–315ADDITIONAL READING[1] S Hedetniemi S Hedetniemi and A Liestman “A Sur-vey of Gossiping and Broadcasting in CommunicationNetworks” Networks vol 18 1988BIOGRAPHIESJAMAL N AL-KARAKI [M] (jkaraki@huedujo) is an assistantprofessor in the Electrical and Computer EngineeringDepartment at the Hashemite University Zarqa Jordan Heobtained his PhD in computer engineering from IowaState University in 2004 He received his BSc and MScdegrees in electrical/computer engineering from JordanUniversity of Science and Technology in 1993 and 1995respectively His research interests lie in protocols andarchitectures for wireless and mobile networks particularlymobile ad hoc networks and wireless sensor networks Heis also interested in fault-tolerant computing and parallelprocessing He has published more than 20 technicalpapers in these areasAHMED E KAMAL [SM] (kamal@iastateedu) received a BSc(distinction with honors) and an MSc both from CairoUniversity Egypt and an MASc and a PhD both fromthe University of Toronto Canada all in electrical engineer-ing in 1978 1980 1982 and 1986 respectively He is cur-rently a professor of electrical and computer engineering atIowa State University His research interests include opticalnetworks wireless and sensor networks performance eval-uation and QoS in the InternetWe presented a comprehensive survey of routingtechniques in wireless sensor networks which havebeen presented inthe literature Theyhave the commonobjective of trying toextend the lifetimeof the sensor net-work while not compromising data delivery                                                          
Collison Attack-pdf,TSINGHUA SCIENCE AND TECHNOLOGY ISSNll1007-0214ll05/09llpp505-519 Volume 16 Number 5 October 2011 Forced Collision: Detecting Wormhole Attacks with  Physical Layer Network Coding* Zhiwei Li Di Pu† Weichao Wang** Alex Wyglinski†  Department of Software & Information Systems UNC Charlotte 9201 Univ City Blvd Charlotte NC 28223 USA;  † Department of Electrical & Computer Engineering Worcester Polytechnic Institute 100 Institute Road  Worcester MA 01609 USA   Abstract: Previous research on security of network coding focused on the protection of data dissemination procedures and the detection of malicious activities such as pollution attacks The capabilities of network coding to detect other attacks have not been fully explored In this paper we propose a new mechanism based on physical layer network coding to detect wormhole attacks When two signal sequences collide at the receiver the starting point of the collision is determined by the distances between the receiver and the senders Therefore by comparing the starting points of the collisions at two receivers we can estimate the distance between them and detect fake neighbor connections via wormholes While the basic idea is clear we have proposed several schemes at both physical and network layers to transform the idea into a    practical approach Simulations using BPSK modulation at the physical layer show that the wireless nodes can effectively detect fake neighbor connections without the adoption of special hardware or time       synchronization   Key words: physical layer network coding; wormhole attacks; cross-layer design    Introduction Investigators have proposed the physical layer network coding technique[12] to fully explore the advantages such as improved throughput reduced congestion and strengthened robustness The technique is especially valuable in wireless networks when we consider the limited bandwidth and power resources of the nodes Since network coding may allow data errors and/or corrupted packets to propagate widely and ruin the data recovery procedure at the final destination previ-ous research into network coding security focused on the protection of data dissemination procedures and the detection of malicious activities such as pollution   attacks[34]  However the security capabilities of physical layer network coding to detect malicious attacks have not been fully explored For instance it is possible that when signals collide at the receiver we can potentially extract information about the network structure This information can then be used to detect attacks on net-work topology In this paper we conduct an investiga-tion of this problem Specifically we propose a new mechanism to detect wormhole attacks  Several reasons lead us to choose wormhole attacks as the primary research topic for this investigation First wormhole attacks impose severe threats to the correct detection of network topology which is the foundation of various operations within wireless net-works such as routing and data transmission Second a wormhole attack is a representation of stealth attacks on wireless networks where traditional methods such       Received: 2011-06-21; revised: 2011-08-29 ** Supported in part by the NSF CNS Award (No 1143602) ** To whom correspondence should be addressed E-mail: weichaowang@unccedu   Tsinghua Science and Technology October 2011 16(5): 505-519  506 as encryption and authentication cannot defend against such attacks Therefore a detection method based on physical layer network coding will allow us to better understand this problem Finally previous approaches for detecting wormhole attacks are usually imple-mented at the network layer Our proposed approach uses physical layer properties At the same time our approach does not require time synchronization among wireless nodes or depend on any special hardware  The basic idea of our proposed approach is as fol-lows: when the long sequences from two senders col-lide at the receiver the starting point of the collision between the sequences is jointly determined by the sending time and the physical distances across all the receiver and senders For two receivers their starting points of collision will be different and this difference is restricted by the physical distance between them Therefore through measuring and comparing the overlapping parts of the received sequences we can estimate the physical distance between two wireless nodes and detect the fake connection between them Since the proposed approach only measures the start-ing point of the collision in the sequences we do not need time synchronization among the wireless nodes Our analysis will also show that the physical distances among the senders and receivers will not impact the detection results Therefore we can choose the senders from a large area within the network  Although the basic idea of the proposed approach is clear we need to design schemes at both physical layer and network layer to make the approach practical At the network layer we need to determine the senders and their data sequences Mechanisms must be de-signed to prevent the man-in-the-middle attack At the same time the receivers need a scheme to verify the authenticity of the recovered sequences from collisions At the physical layer we need to carefully select data transmission parameters such as modulation and car-rier frequency Consequently algorithms are designed to recover the received sequences We will also inves-tigate the impacts of different factors such as phase shift and carrier frequency jitter on the proposed ap-proach using both analysis and simulation  Our investigation has the following contributions:  •  We make an attempt to explore the security capa-bilities of the physical layer network coding technique The research will demonstrate that in addition to   improving the bandwidth efficiency and data robust-ness in wireless networks physical layer network cod-ing can also be used to detect malicious attacks This research provides a new incentive for further develop-ment of this technique  •  The proposed wormhole detection mechanism does not require any special hardware or time synchro-nization in the wireless network Therefore existing systems can easily adopt the proposed approach with-out going through drastic structural and functional changes  •  We carefully design schemes in both network layer and physical layer to make the approach practical Impacts of different factors in the communication channel are studied through theoretic analysis and simulation  The remainder of the paper is organized as follows: in Section 1 we introduce the basic idea of the detec-tion mechanism and the role of physical layer network coding in wormhole detection Section 2 reviews the related work Sections 3 and 4 design mechanisms in the network layer and in the physical layer to make the approach secure and practical We perform both an analysis and simulations to investigate the impacts of different factors in the physical layer In Section 5 we study the security and detection accuracy of the pro-posed approach Finally Section 6 concludes the paper   1  The Basic Idea In this part we introduce the basic idea of using physical layer network coding to detect wormhole at-tacks We assume that two wireless nodes are neighbors if and only if the distance between them is shorter than r  However this assumption does not restrict wireless nodes from transmitting signals at a higher power level in order to reach a longer distance We assume the attackers are not capable of compro-mising any wireless nodes within the network How-ever they can deploy their own nodes to eavesdrop on the traffic tunnel the packets and retransmit the data In the following analysis we use MNd  to represent the physical distance between two nodes M  and N  We use T  to represent a specific moment and t  to represent a time duration If the radio signal propagates at the speed of light s  the transmission delay between two nodes M and N will be MNds  In the following Zhiwei Li et al：Forced Collision: Detecting Wormhole Attacks with Physical …  507analysis we describe the time difference between the received sequences We are not using the system clocks to directly measure the actual time On the contrary we can pinpoint the starting bit in the sequence that the collision starts Then we can translate this information into a time difference This topic is discussed further in Section 51  Figure 1a illustrates an example of using physical layer network coding to verify the neighbor relation-ship We assume that nodes A  and B  in the net-work can hear each other and they want to verify the neighbor relationship They jointly choose two other nodes C and D in the network that can both hear from C and D will then generate and send out long random sequences that will collide at A  and B  Without losing generality we assume that node C  will send out its sequence first We assume that C  starts send-ing at 0CT =  and D  starts sending at 0DT    Based on these assumptions we can derive that A  will receive the signals from C  at the time ACds  and the signals from D  at ADDdT s⎛ ⎞+⎜ ⎟⎝ ⎠  Therefore the difference between the arriving time of the two se-quences at node A  is diffA AD ACDd dt T s−⎛ ⎞= +⎜ ⎟⎝ ⎠  as illustrated in Fig 1b In other words A  will first    receive the sequence from C  for diffAt  seconds then the two sequences will collide at the node If diffA 0t <  the sequence from D  will arrive first at A  Simi-larly we can derive the difference between the arriving time at node B  as diffB BD BCDd dt T s−⎛ ⎞= +⎜ ⎟⎝ ⎠   Now let us look at the difference between diffAt  and diffBt :   diffB diffAt t− BD BC AD ACD Dd d d dT Ts s− −⎛ ⎞ ⎛ ⎞= + − + =⎜ ⎟ ⎜ ⎟⎝ ⎠ ⎝ ⎠  ( ) ( )BD AD AC BCd d d ds− + −         (1) For the three nodes A  B  and D  they either form a triangle or stay on the same line Either way we must have ( )BD ADd d|| − || - ABd|| ||  Similarly we have ( )AC BCd d|| − || - ABd|| ||  Therefore we must have:  diffB diffA( )t t|| − || ( ) ( )BD AD AC BCd d d ds|| − + − ||= -  AC BCBD AD d dd ds s|| − |||| − || + =AB ABd ds s|| || || ||+-  2 2ABd rs s× -               (2) The last part of the equation holds since when A  and B  are real neighbors the distance between them is smaller than or equal to r  From Eq (2) we can see that the difference between diffAt  and diffBt  is re-stricted by the physical distance between nodes A  and B  In this way the two nodes can compare the time differences between the received colliding se-quences to verify their neighbor relationship  Below we will study the case when A  and B  are not real neighbors and they have to communicate through a wormhole Here we adopt a simplified model of attackers and assume that the two attackers X  and Y  can send and receive radio signals at the same time More realistic scenarios will be discussed in Section 4 Since the malicious nodes possess total control over the tunneling procedure in the following analysis we assume that X  and Y  will introduce extra delay XYtJJJG  and YXtJJJG  for the traffic transmitted in different directions This scenario is illustrated in Fig 1c  Following the previous assumptions we can derive that A  will receive the sequence from C  at time ACds   (a) Sequences from C and D collide at A and B  (b) diffAt : difference b/w arriving time of two sequences at A (c) Two colliding sequences are tunneled through the wormhole  Fig 1  Two colliding sequences and the impacts of the wormhole   Tsinghua Science and Technology October 2011 16(5): 505-519  508 and the sequence from D  at time DT⎛ +⎜⎝  DY XY AXYXd d d ts+ + ⎞+ ⎟⎠JJJG  Similarly B  will receive the sequence from C  at time CX XY BYXYd d dt s+ +⎛ ⎞+⎜ ⎟⎝ ⎠JJJG  and the sequence from D at time ( )BDDdT s+  There-fore we have  diffA diffBt t− ( )DY BY BDXY YXd d dt ts+ −= + + +JJJG JJJG  ( ) 2AX CX AC XYd d d ds s+ − + ×        (3) Since the three nodes A  C  and X  either form a triangle or are on the same line we must have ( ) 0AX CX ACd d d+ −   Similarly we have ( DY BYd d+ −     ) 0BDd   The extra transmission delay XYtJJJG  and YXtJJJG  introduced by the malicious nodes cannot be smaller than 0 Therefore we have  diffA diffB 2 XYdt ts⎛ ⎞|| − || ×⎜ ⎟⎝ ⎠          (4) When the length of the wormhole XYd  is longer than the radio transmission range r  we have diffA diffB2rt t s|| − || >  Combining the results in Eqs (2) and (4) we find that two nodes in the wireless network can verify their neighbor relationship by comparing the differences between the starting points of collision in the received sequences  The proposed approach has several highly desirable properties First since the mechanism uses only the starting points of the collision between the sequences to detect wormholes we do not need the senders or receivers to synchronize their clocks As illustrated in Eqs (2) and (4) the parameter DT  has been canceled out Second in Eq (2) the physical distances between the senders and the receivers have also been canceled out The difference is determined only by the physical distance between the nodes that want to verify their neighbor relationship This implies that we can choose the senders from a large area in the network and they do not need to be direct neighbors of A  and B  Third the proposed mechanism does not require the wireless nodes to be equipped with any special hard-ware which will result in a lower node cost The capa-bilities of the nodes to recover colliding sequences will be discussed in Section 4 Finally the proposed    approach works in a distributed manner and does not require a centralized controller Nodes A  and B  can determine their senders and exchange diffAt  and diffBt  to detect wormholes With these desirable prop-erties the approach can be easily adopted by existing networks  2  Related Work 21  Wormhole detection Location and Time Based Solutions This group of solutions try to restrict the transmission range of a packet by measuring the time and/or positions of the wireless nodes For example packet leash is proposed by Hu et al[5] for wormhole prevention The geo-graphic leashes and temporal leashes use location in-formation and signal propagation delay respectively to verify a neighbor relation In SECTOR[6] the wireless nodes use a special hardware to respond to a one-bit challenge The challenger measures the round trip time to estimate the distance between the nodes Using di-rectional antenna[7] the neighbor relation between two nodes can be verified based on the directions of the received signals In LiteWorp[8] the wireless nodes use the short safe period after deployment to detect the real 1-hop and 2-hop neighbors They will then monitor the packet forwarding actions to detect wormholes The improved approach[9] for wormhole detection in mo-bile wireless networks requires the nodes to have GPS and loosely synchronized clocks The EDWA[10] method also requires the wireless nodes to be equipped with GPS In TrueLink[11] the wireless nodes strictly follow the 80211 standard of the time interval between packets to restrict their transmission distances It re-quires the wireless nodes to have very accurate clocks  Graph Based Approaches Investigators have tried to detect wormholes based on their impacts on the network topology MDS-VoW[12] is a centralized mechanism for wormhole detection in sensor networks It reconstructs the layout of sensors using multi-di-mensional scaling and detects wormholes by visualiz-ing the anomalies introduced by the attacks A decen-tralized approach for dynamic networks is proposed in Ref [13] In Ref [14] the researchers analyze the geometric random graphs induced by the communica-tion range constraint of the nodes They present a de-fense mechanism based on local broadcast keys Zhiwei Li et al：Forced Collision: Detecting Wormhole Attacks with Physical …  509Maheshwari et al[15] model the wormhole detection problem as a disk graph embedding task They design a localized algorithm to locate the forbidden substruc-tures in the connectivity graph  Statistical Analysis Methods In Ref [16] the in-vestigators study the impacts of wormholes on multi-    path routing protocols They try to locate the hot links that are contained in a majority of the obtained routes In NNT and ADT[17] the researchers try to detect in-creases in the node degrees and decreases in the short-est paths caused by the wormholes  22  Physical layer network coding Physical layer Network Coding (PNC) tries to turn the broadcast property of wireless networks to a capacity boosting advantage It uses the additive nature of the electromagnetic waves to serve as the coding proce-dure The PNC technique under QPSK modulation is studied in Ref [2] The researchers investigate the gen-eral modulation-demodulation principles and analyze the performance penalty of different factors In Ref [1] the authors try to decode the interfered signals under MSK modulation The mechanism can recover the col-liding sequences under phase shift and the lack of synchronization After these pioneering papers re-search on PNC focuses on improving the decoding accuracy In Ref [18] the authors compare the am-plify-and-forward and decode-and-forward techniques Zhang et al investigate the decoding techniques of PNC over finite and infinite fields in Ref [19] In Ref [20] the authors propose to dynamically adjust the coefficients to increase the ‘distances’ among different codes Investigators also proposed to adopt Tomlinson-     Harashima precoding to improve the data recovery accuracy[21] The determination of threshold values for decoding in two-way relay channels is studied in Ref [22]  3  Building a Practical Approach: Network Layer Issues In Section 1 we introduce the basic idea of using physical layer network coding to detect wormhole at-tacks However several issues need to be solved before the idea can be turned into a viable solution In this section we focus on the issues in the network layer The physical layer issues will be handled in the next section  31  Assumptions and model of attackers We assume that the links among wireless nodes are bidirectional and the two neighboring nodes can al-ways send packets to each other We adopt the unit disk graph model in this work and assume that two wireless nodes are neighbors when the distance between them is shorter than r  where r  is defined as the communi-cation range We assume that the wireless nodes can adjust the transmission power such that the signal range can be increased es 2r  We assume that each node is equipped with an omni-directional antenna We also assume that the communication channel is half duplex and a node cannot transmit and receive signals at the same time The wireless nodes will periodically broadcast neighbor discovery beacons such that changes in neighbor lists can be detected  We assume that the wireless nodes share a secure light-weight Pseudo Random Bit Generator (PRBG)[23] The senders will use this generator to determine the sequences By exchanging only the seeds for the PRBG the receivers can regenerate the sequences and deter-mine whether or not they have successfully recovered the sequences Since we assume that the malicious nodes are all external attackers the wireless nodes will employ encryption to protect the data communication amongst them They can use either group keys or pair wise keys Note that the generation and maintenance of the keys is beyond the scope of this paper  For the attackers we assume that they cannot com-promise the legitimate nodes in the wireless networks At the same time they cannot break the secret keys amongst the legitimate nodes by passively listening to the communication channel The attackers can deploy their own nodes in the network to form wormholes We assume that the attackers can communicate with each other through a real-time long-range out-of-band channel  The assumption of the half-duplex channel has some impacts on the analysis of data collision through the wormhole As illustrated in Fig 1c the malicious node X  cannot simultaneously listen to the sequence from C  and forward data to A It has to be decoupled into two nodes 1X  and 2X  in order to accomplish these tasks As illustrated in Fig 2a 1X  can get a copy of   Tsinghua Science and Technology October 2011 16(5): 505-519  510 the data that 2X  is transmitting through the out-of-     band channel Therefore 1X  will be able to decode the sequence from C  in the presence of interference Decoupling the node X  into two nodes will intro-duce some changes to Eq (4) However these changes can be hidden in the transmission delay of the worm-hole and will not subvert our approach  32  Selection of senders In this part we study two problems: first how to choose the senders in a real network environment; second the relationship between the wormhole detec-tion probability and the number of rounds of verifica-tion Answers to these questions will allow us to better understand the advantages and limitations of the pro-posed approach  321  Selection of senders The analysis in Section 1 showed that the detection of wormholes will not be impacted by the distances among the senders and receivers However in a real wireless network several reasons restrict us from choosing a sender that is multiple hops away from the receiver First if the sender is far away from the re-ceivers it has to transmit the signal at a high power level This will not only consume the limited battery power of the sender but it will also cause interference in a large area Second if we choose a sender that is multiple hops away this path has a higher probability to contain a wormhole The malicious nodes can then manipulate the arriving time of the sequences and compromise the detection mechanism Therefore we propose to choose the senders from the union of the neighbor lists of the receivers  Figure 2b shows the areas that the senders can be chosen from As an example nodes A  and B  want to verify their neighbor relationship They jointly choose the senders C  and D  such that C  is a di-rect neighbor of A  and D  is a direct neighbor of B Since A  and B  are neighbors the senders must be within the distance 2r  to both of the receivers In this way the senders can adjust their sending power to make sure that the signals can be received by both of the receivers  This scheme will greatly increase the pool of send-ers that we can choose from As shown in Fig 2b if we require the senders to be direct neighbors of both receivers we can choose senders only from zone 2 Now we can choose from zones 1 and 3 as well If the distance between A  and B  is d  where ( )d r-  the size of zone 2 is  22 2zone2Area 2 arccos 2 2d dr d rr⎛ ⎞ ⎛ ⎞= − −⎜ ⎟ ⎜ ⎟⎝ ⎠ ⎝ ⎠  and the size of zone 1 is 2 zone2π Arear −  Therefore if the distance between A  and B  has a uniform dis-tribution on the interval [0 ]r  we can calculate the average size of zone 2 We find that on average the ratio between the total size of zones 1 2 and 3 and the size of zone 2 is about 19 This implies that our ap-proach has a much larger pool of senders to conduct wormhole detection  322  Determining number of verification rounds In Fig 1c we show one possible scenario of sender selections in which C  and D  are at different sides of the wormhole Since the wireless nodes cannot dis-tinguish a real neighbor from a fake neighbor through the wormhole there is a chance that both senders are located at the same side of the wormhole At the same time the existence of multiple wormholes in the net-work can also create more complicated scenarios In Fig 3 we illustrate two such cases In both scenarios the sequences from C  and D  will go through a wormhole to reach B Therefore the malicious nodes can manipulate the difference between the arriving time of the two sequences to compromise the proposed approach To mitigate such attacks we propose to conduct multiple rounds of verification with different senders to improve the odds of countering the mali-cious nodes  We assume that nodes A  and B  are connected through a wormhole and they want to verify their neighbor relationship We assume that the number of real neighbors of A  and B  are RNA  and RNB   Fig 2  Practical issues in the network layer: (a) a more realistic node model of the attackers for the half-duplex channel; (b) the zones that the senders can be chosen from Zhiwei Li et al：Forced Collision: Detecting Wormhole Attacks with Physical …  511 Fig 3  Neighbor selection scenarios that can avoid detection respectively Similarly the number of fake neighbors of the two nodes through the wormhole are FNA  and FNB  Therefore the probability that we choose one real neighbor for each receiver in order to form the senders within p  rounds is RN RN1 1RN FN RN FNpA BA A B B⎛ ⎞− −⎜ ⎟+ +⎝ ⎠∙       (5) Based on this equation we can see that the mali-cious nodes can reduce the probability of being de-tected by introducing a large number of fake neighbors via wormholes However in real wireless networks there are several reasons that will restrict the attackers from doing this First when the attackers deploy a large number of malicious nodes to create numerous wormholes it will become fairly difficult for them to maintain a web of real-time out-of-band communica-tion channels across all of these nodes Second the legitimate nodes possess a good estimate of the node density and the average number of neighbors in the network Previous research efforts[2425] have shown that the node degrees in MANETs follow some distri-butions Therefore if the wormholes make the node degrees abnormally large the legitimate nodes will become suspicious and adopt other mechanisms to de-tect the wormholes If the node degrees follow some distributions such as binomial[25] the wireless nodes can easily figure out the corresponding parameters to achieve a certain detection probability  33  Generation of sending sequences The sequences that the senders transmit should satisfy two requirements: First the receivers should be able to verify the authenticity of the sequences to make sure that they are generated by the senders Second the se-quences should be kept as a secret from the attackers before they are sent out The first requirement will guarantee that the attackers cannot generate some   random sequence to deceive the receiver As illustrated in Fig 1c if the receivers cannot verify the authentic-ity of the sequences the malicious nodes X  and Y  can generate some random sequences to send to A  and B  In this way they can easily control the differ-ence between the arriving time of the two sequences and compromise the proposed approach The second requirement can prevent the man-in-the-middle attack If the attackers know the sequences before they are sent by C  and D  they can impersonate the senders and control the starting point of the collision of the sequences at the receivers  To satisfy these requirements the wireless nodes can use the following procedure to generate the sequences We assume that every node is equipped with the same PRBG They also have a secure channel to exchange information and the attackers cannot gain access to the data Therefore the two senders and two receivers can jointly determine two random numbers These numbers will be used by the two senders as the seeds for the PRBG Since the receivers also know the seeds they can easily verify the received sequences At the same time the seeds will be kept as a secret from the     attackers  34  Neighbor verification procedure Given the building blocks at the network layer the following neighbor relation verification algorithm is employed  (1) When two nodes A and B want to verify their neighbor relationship each of them will choose one neighbor from their neighbor lists namely C and D  to be the senders C and D should be within 2r to both A and B  (2) The four nodes will jointly choose two seeds Cr  and Dr  for the PRBG at C and D to generate the se-quences A and B will also have a copy of the seeds  (3) A uses ( xorC Dr r ) as the seed for the PRBG to   Tsinghua Science and Technology October 2011 16(5): 505-519  512 generate a series of pilot bits A will broadcast the pilot bits at the power level such that B C and D will all receive the data to learn that the verification procedure starts  (4) C and D will verify the pilot bits from A Each of them will then choose a random delay to make sure that A and B are ready to receive Then the two nodes will send out the sequences generated by the PRBG based on the seeds Cr  and Dr  They will send the sequences with a sufficiently high power level such that both A and B can receive them The two sequences will be long enough such that a large part of the se-quences will collide at the receivers  (5) A and B will use the algorithm in Section 4 to separate the sequences and verify them The two nodes will exchange the starting points of the collisions and use the method described in Section 1 to verify their neighbor relationship  (6) Steps 1 to 5 will repeat until A and B find that they are connected through a wormhole or they are convinced that they are real neighbors after p rounds  4  Building a Practical Approach: Physical Layer Issues To turn the proposed approach into a practical solution the physical layer needs to accomplish the following tasks First the physical layer needs to successfully separate the two interfered sequences It also needs to locate the starting point of the collision so that the in-formation can be used to detect wormholes Second we need to assess the impacts of different factors in the physical layer on the proposed approach In the fol-lowing subsections we will determine the parameters for signal transmission design the receiver algorithm to separate the colliding sequences and evaluate the approach under different parameters through theoreti-cal analysis and simulation  41  Modulation of signals When the two senders generate their sequences using the PRBG the data bits need to be modulated and de-modulated in order to achieve over-the-air transmission Thus we need to decide on a proper modulation/   demodulation scheme on both ends  411  Binary Phase Shift Keying (BPSK) Phase-Shift Keying (PSK) is a digital modulation scheme that conveys data by modulating the phase of the carrier wave Since any digital modulation scheme uses a finite number of distinct signals to represent digital data PSK uses a finite number of phases that are each assigned with a unique pattern of binary bits The demodulator which is designed specifically for the symbol set used by the modulator determines the phase of the received signal and maps it back to the symbol it represents thus recovering the original bi-nary data This requires the receiver to be able to com-pare the phase of the received signal to a reference signal  BPSK is the simplest form of PSK It uses two phases which are often separated by π  Using BPSK a symbol can be expressed by the following formula: c( ) cos(2π ) 12i is t t iω θ= + =  where iθ  is the phase of the symbol and 1 2 πθ θ| − | =  It does not particularly matter exactly where the con-stellation points are positioned so long as their phase difference is sufficiently large eg π   When we consider that there are two senders in the proposed mechanism the j-th output symbol of sender i  can be expressed as c( ) cos(2π ) 12 12ij ijs t t i jω θ= + = =  where ijθ  is the phase and 11 1θ θ=  12 1 πθ θ= +  21 2θ θ=  22 2 πθ θ= +   412  Why BPSK Several reasons lead us to choose BPSK as the modu-lation scheme for the proposed mechanism First BPSK is a very robust modulation scheme Compared to the other PSK schemes the constellation points of BPSK are the farthest away from each other which means it takes a substantial amount of noise or distor-tion to make the demodulator reach an incorrect deci-sion This property is especially important when we consider that the receiver must verify the authenticity of the received sequences to avoid attacks on the pro-posed approach  This modulation scheme will also help the receiver separate the two sequences Using BPSK the largest phase difference among the four modulated symbols is π/2  When the two input sequences are orthogonal to each other it is straightforward for the receiver to dis-tinguish between those two sequences from their colli-sion Furthermore the structure of the receiver is much simpler compared to the other modulation schemes resulting in lower implementation costs of the     Zhiwei Li et al：Forced Collision: Detecting Wormhole Attacks with Physical …  513proposed approach  42  Data recovery algorithms Data recovery is the most important task that the re-ceiver needs to implement Below we will describe in detail the sequence detection and separation algorithms For simplicity we do not consider frequency jitter and power amplitude in this subsection although they will be discussed later in this section  421  Packet reception When we are designing the physical layer mechanisms the first question we need to answer is how the re-ceiver can detect the arrival of a data packet This is a standard problem in digital communication Since the received signal demonstrates a much higher energy level than that of the white noise the receiver can look at the incoming energy level to detect the reception of data packets  Next since our approach does not require the wire-less nodes to maintain synchronized clocks there is a good chance that the sequence from one sender will arrive at the receiver first Therefore the receiver must be able to locate the starting point of the collision Be-fore this point the receiver runs standard BPSK de-coding After this point the receiver will treat the data as a packet corrupted by interference It will then exe-cute the interference decoding algorithm described below To answer this question the receiver will meas-ure the variance in the energy level of the incoming signals Since BPSK encodes the bits in the phase the energy of a non-interfered BPSK signal is nearly con-stant When two signals collide at the receiver the variance will become much larger Therefore we can set up a threshold and when the variance is larger than the pre-determined value the sequence separation al-gorithm will be executed  422  Data recovery As described in Section 412 one of the key advan-tages of using two BPSK signals is to simplify the structure of the receiver Given the modulation scheme in Section 412 the receiver only needs a low pass filter and an oscillator which generates the cosine wave of the same phase offset as one of the sequences Without loss of generality we assume its phase offset to be the same as Sequence 1 Therefore the receiver can be expressed as  c 1( ) cos(2π )r t tω θ= +  where cω  is the carrier frequency of the receiver and 1θ  is the phase of Sequence 1  If the received signal is from Sequence 1 for exam-ple 11s  using trigonometric identities the output of the oscillator will be  1 11 c 1 c 1( ) ( ) ( ) cos(2π ) cos(2π )r t s t r t t tω θ ω θ= = + + =∙ ∙  c 11 [1 cos(4π 2 )]2tω θ+ +            (6) Similarly if the received signal is from Sequence 2 for example 21s  the output of the oscillator will be  2 21 c 2 c 1( ) ( ) ( ) cos(2π ) cos(2π )r t s t r t t tω θ ω θ= = + + =∙ ∙  1 2 c 1 21 [cos( ) cos(4π )]2tθ θ ω θ θ− + + +      (7) Since we attach a low pass filter after the oscillator at the receiver the c4π tω  term in Eqs (6) and (7) will be eliminated Since the two sequences collide at the receiver the final output of the filter will be  1 2 1 21 1( ) ( ) ( ) cos( )2 2r t t tr r θ θ= + = + −        (8) Since 1 2cos( ) 1θ θ− -  1 2( ) ( )t tr r   the demodula-tion is actually determined by 1( )tr  such that the final output of the receiver is the recovered Sequence 1 In particular when 1 2 π/2θ θ− = 1 2cos( ) 0θ θ− =  so that 1( ) ( ) r t tr=   there is no interference from Sequence 2 resulting in the recovered Sequence 1 being the most accurate This is the orthogonal case mentioned in Sec-tion 412 When the phase difference between the two signals is not π 2/  we propose to adopt the phase equalization method to compensate for this error The details of the method will be described in Section 423 When the recovered Sequence 1 is obtained it can be subtracted from the combined signal to yield Sequence 2 The receiver will then execute the decoding algo-rithm to recover the second sequence  Sequence Verification  As we discussed in Section 3 the receiver must verify the authenticity of the re-covered sequences to defend against attacks from ma-licious nodes Since the receiver has a copy of the seeds of the PRBG it can regenerate the sequences It will then compare the calculated sequences to the re-covered ones To distinguish a correct sequence from a random one the similarity between the calculated se-quence and the recovered one should be non-negligibly larger than 05 This threshold value shows that the proposed mechanism is very robust against bit errors in recovered sequences    Tsinghua Science and Technology October 2011 16(5): 505-519  514 423  Improvement on the algorithm Based on the discussion above it is obvious that in order to achieve the highest recovery accuracy we need to ensure that the phase offset of the receiver is consistent with the phase offset of Sequence 1 and that the phase difference between the two senders ( 1 2θ θ| − | ) is around π/2  However in reality the phase is actually a time-varying variable that depends on many factors Consequently we introduce pre-    equalization here to compensate for this error  Pre-equalization is a function applied at the trans-mitter that counteracts the phase degradation caused by the transmission channel Equalization is implemented in two steps namely channel training and data trans-mission In the first step each of the two senders will send out some pilot bits to train the channel The re-ceiver will figure out how the channel influences the phases by comparing the received signals Then before the second step starts the senders will adjust their phases based on the feedback from the receiver Since we assume this communication system is in a pseudo-stationary state within a period of time the channel condition in Step 2 is almost the same as in Step 1 Thus these adjustments will lead to orthogo-nality in Step 2  43  Impacts of various factors on BER As discussed in Section 3 the receiver must verify the authenticity of the recovered sequences Otherwise an attacker can send out some random sequence and the receiver cannot distinguish it from the real sequence In this subsection we plan to investigate the impacts of various factors in the physical layer on the bit error rate (BER) which is defined as  number of incorrectly recovered bitsBER total number of transmitted bits=  431  Phase difference In Section 422 the final output of the filter is  1 2 1 21 1( ) ( ) ( ) cos( )2 2r t t tr r θ θ= + = + −    When 1 2 π/2θ θ− =  such that 1 2cos( ) 0θ θ− =  the two signals are orthogonal to each other and they have the least interference When 1 2 0θ θ− =  such that 1 2cos( ) 1θ θ− =  then 1 2( ) ( )t tr r=   which means the interference from Sequence 2 is as strong as Sequence 1 itself Therefore the recovered Sequence 1 will be the least accurate Using probability theory we can calculate the BER value in this case There are four possible combinations of Sequence 1 and Sequence 2 namely {(00)(01)(10)(11)} When the transmitted bits are (00) or (11) there will be no problem since the interference of Sequence 2 will not change the de-cision on Sequence 1 However when the transmitted bits are (01) or (10) the resulting signal is around 0 which means there is a probability of 05 that the re-covered bit is wrong Therefore the BER here can be expressed as a conditional probability:  BER [ (0 1) (1 0)] [(0 1) (1 0)]P E P= |   ×  ∪ ∪ 1 1 12 2 4= × =                (9) where E  is the event that a bit is incorrectly     recovered  When 1 2 (0 π/2)θ θ− ∈   such that 1 2cos( )θ θ− ∈      (0 1)  Since the cosine function is monotonically de-creasing in the range (0 π 2) /  we can expect that the interference from Sequence 2 decreases as 1 2θ θ−  increases which means the BER is a monotonically decreasing function within the range [0 14 ] concerning phase difference Note that the receiver can still suc-cessfully verify the recovered sequences with the 25% BER rate  432  Frequency jitter In our previous analysis the carrier frequencies of Se-quence 1 Sequence 2 and the oscillator are assumed to be the same However similar to the behavior of the phase the carrier frequency is also a time-varying variable In this subsection we will explore how the frequency jitter affects the BER performance When taking frequency jitter into account the symbol can be expressed as  c( ) cos(2π( ) )i i is t A tω ω θΔ= + +  where iωΔ  is the frequency jitter of the i-th carrier frequency The frequency jitter of the oscillator is as-sumed to be 3ωΔ   As for Sequence 1 whose frequency jitter is 1ωΔ  its output of the oscillator will be  1 1( ) ( ) ( )r t s t r t= =∙  c 1 1 c 3 1cos[2π( ) ] cos[2π( ) ]t tω ω θ ω ω θΔ Δ+ + + + =∙  1 3 c 1 3 11{cos[2π( ) ] cos[4π 2π( ) 2 ]}2t t tω ω ω ω ω θΔ Δ Δ Δ− + + + +(10) Due to the low pass filter the final output of the fil-ter will be  Zhiwei Li et al：Forced Collision: Detecting Wormhole Attacks with Physical …  5151 1 31( ) cos[2π( ) ]2t tr ω ωΔ Δ= −          (11) Similarly as for Sequence 2 whose frequency jitter is 2ωΔ  its output of the low pass filter will be  2 2 3 2 11( ) cos[2π( ) ( )]2t tr ω ω θ θΔ Δ= − + −     (12) Considering the orthogonal case where 2 1θ θ− =     π/2  Eq (12) becomes  2 2 3 2 31 1( ) cos[2π( ) π/2] sin[2π( ) ]2 2t t tr ω ω ω ωΔ Δ Δ Δ= − + = − (13) In order to get an accurate recovery of Sequence 1 the 1( )tr  should be as large as possible while 2( )tr  should be as small as possible Therefore we would like 1 3 0ω ωΔ Δ− =  and 2 3 0ω ωΔ Δ− =  In other words if the carriers have the same frequency jitter it will have no effect on BER Otherwise it will result in an increased number of bit errors  44  Simulation results In this subsection we use computer simulators imple-mented in Simulink to explore the impacts of various factors on BER and compare them with the theoretical analysis results derived in Section 43  441  Phase difference and SNR In real wireless networks all the signals will pass through a noisy channel prior to arriving at the receiver In wireless communication an Additive White Gaus-sian Noise (AWGN) channel is the most widely used model and the Signal-to-Noise power Ratio (SNR) is a key metric of the transmission performance across this channel Intuitively a high noise level will result in a high BER rate  In this part the relationship between the BER and phase difference as well as BER and SNR are studied SNR values of 0 dB 3 dB and 5 dB are examined The phase difference ranges from 0 to π/2  The resulting plot is shown in Fig 4  There are several important observations about the results shown in Fig 4  All the three curves are monotonically decreasing functions  When the phase difference is equal to zero BER≈     0 25  in all three cases  Given the same phase difference the BER is larger when there is a higher noise level   Fig 4  The BER values with respect to phase differ-ence and SNR The blue curve is obtained when SNR=0 dB the pink curve corresponds to SNR=3 dB and the red curve is for SNR=5 dB All of these observations match the analysis results in Section 431  442  Power amplitude In our previous discussions we have not taken power amplitude into account However in an actual commu-nication system the power of a signal will gradually deteriorate on its way to the destination Even when the two signals are transmitted using the same power the received power will not be the same Therefore the resulting output of the filter should be rewritten as  1 21 2 1 2 1 21 1( ) ( ) ( ) cos( )2 2r t A t A t A Ar r θ θ= + = + −    (14) where 1A  and 2A  are amplitude of the received Se-quence 1 and received Sequence 2 which are different  In order to recover Sequence 1 correctly we want the interference from Sequence 2 to be as low as pos-sible This is a relative comparison between the two sequences such that we can use a fraction to express their relationship:  1 12 2 1 2cos( )P AP A θ θ= −  Given 1 2θ θ−  is kept constant if 1A  becomes larger or 2A  becomes smaller the interference from Sequence 2 becomes weaker such that the recovered Sequence 1 is more accurate  In the following simulation we set phase difference between two signals to be π/2  and the SNR to be 5 dB We also assume that the receiver has the same phase offset as Sequence 1 The amplitude of Sequence 1 is increased from −5 dB to 5 dB while the amplitude of Sequence 2 is decreased from 5 dB to −5 dB There-fore the ratio is monotonically increasing The BER plot is shown in Fig 5  Based on Fig 5 it is obvious that the power ampli-tude has an impact on BER When 2A  is much larger than 1A  the BER can be as high as 008 However   Tsinghua Science and Technology October 2011 16(5): 505-519  516 when 1A  becomes larger than 2A  ( 121AA > ) the BER value falls below 05% which introduces a very low bit error rate  The simulation results provide us some insight into the data recovery algorithm When the senders send out the pilot bits to train the channel for phase equali-zation the receiver can also provide feedback to them for their transmission power Based on the signal dete-rioration model we can control the power ratio be-tween the received signals to achieve a balance be-tween the recovery rates of the two sequences  443  Frequency jitter In this subsection the relationship between the BER and frequency jitter is studied We set the phase dif-ference of the two signals to be π/2  the amplitude of the two sequences to be the same and the SNR value to be 5 dB We change the carrier frequency of the re-ceiver Since the carrier frequency can be either smaller or larger than the normal one we use fre-quency offset as the x-axis and the corresponding BER plot is shown in Fig 6  Based on Fig 6 it is obvious that the frequency jit-ter also has an impact on the BER As predicted in Section 432 when there is no frequency jitter which means the two senders and the receiver have the same carrier frequency the BER is the lowest Consequently the more jitter presents in the system the higher the BER will be However when the frequency jitter is within a range we have a relatively low BER rate and the overall performance will not be severely hurt  Having studied Figs 4-6 we can conclude that phase difference has the largest impact on the BER rate We can adopt different methods to compensate for the errors so that the detection capabilities of the proposed approach will not be severely impacted by these   factors   5  Discussion 51  Why depend on PNC to measure  time difference As shown in Section 1 the proposed approach meas-ures the starting point of interference of two colliding sequences to estimate the distance between the receiv-ers Here we have to answer one question: why do not we directly use system clocks to measure the differ-ence between the arriving time of two sequences? In that way we can let the two senders send out their packets alternatively and still allow the receivers to estimate their distance  Unfortunately previous research[2627] has shown that wireless nodes have a maximum clock drift rate at microsecond level ( 610− s) At the same time the de-viations of clock drift rates are also at the microsecond level Equation (2) in Section 1 shows that when the two receivers are real neighbors the difference be-tween diffAt  and diffBt  is restricted by 2rs  If we as-sume that the radio range r  is 250 meters and the signal propagates at the speed of light the difference is roughly 500 m÷300 000 km/s ≈ 61 67 10 s− ×  We can see that the measured duration and the clock drift are at the same level Therefore directly using the system clock to measure the time difference will introduce a large number of false alarms  Physical layer network coding provides a solution to this problem As the analysis in Ref [1] shows the wireless nodes can locate the bit from which the inter-ference of two colliding sequences starts If the wire-less nodes are transmitting at the bit rate of 11 Mb/s 167 μs equals to the difference of 18 bits in the re-ceived sequences With the continuous increase in the bit-rate of wireless networks the difference will    Fig 5  The BER value with respect to amplitude The x-axis is the ratio of amplitude between two sequences  Fig 6  The BER value with respect to frequency jit-ter The x-axis is the carrier frequency offset of the  receiver Zhiwei Li et al：Forced Collision: Detecting Wormhole Attacks with Physical …  517become larger and larger Therefore physical layer network coding allows us to more accurately measure the difference and detect fake neighbor connections  52  Security of the proposed approach In Section 3 we discuss the authenticity of the received sequences and the prevention of man-in-the-middle attack In this part we study other security aspects of the approach  When node A uses ( xorC Dr r ) as the seed to gener-ate the pilot bits it is very difficult for the attackers to counterfeit this information If we assume that the seeds Cr  and Dr  have the length of k  and the pilot bits have the length of h  the probability that an at-tacker can correctly regenerate the pilot bits without the information of Cr  and Dr  equals to 1 1max(  )2 2h k We can adjust the values of k  and h  to prevent the attackers from fabricating the starting signal and conducting man-in-the-middle attack on the mechanism  Since the attackers have a total control over the tun-neling procedure they can block the verification pro-cedure by discarding the packets going through the wormhole This operation however will allow the le-gitimate nodes to derive more information about the wormholes If node A  fails to get a sequence from a sender and it is not because of the low quality of the communication channel we conclude that there is a wormhole between A  and the sender This can be proven by contradiction If there is no wormhole be-tween A  and the sender we know that the distance between them is shorter than 2 r  Therefore the sender will send out the sequence when it receives the pilot bits and A  would have received the sequence When node B  fails to receive a sequence it will ex-change information with node A  If A  gets that se-quence B  concludes that there is a wormhole be-tween the sender and B  It can draw this conclusion since node A  confirms that the sender actually sends out the sequence Therefore if there is no wormhole between B  and the sender it would have received it Based on the analysis we can see that the attackers will expose more wormholes when they try to avoid detection by discarding packets  Except for discarding packets the attackers can also intentionally add noise to the packets when they tunnel them through the wormhole This operation may lead to one of the two results If the introduced noises are not strong and the receivers can still verify the authen-ticity of the sequences the neighbor verification pro-cedure will not be impacted On the contrary if the bit error rate becomes very large and the receiver can no longer verify the authenticity of the sequence it will treat the packet as a lost one The receiver can then follow the description in the previous paragraph and treat the connection as a wormhole This decision can be justified as follows: treating a very error-prone connection as a wormhole and avoiding it during the routing procedure will not significantly deteriorate the network performance  53  False alarms of the proposed approach False positive and false negative alarms are important parameters to evaluate a detection mechanism In Sec-tion 32 we propose to adopt multiple rounds of veri-fication to reduce false negative alarms In this part we focus on the investigation of false positive alarms  When nodes A  and B  are real neighbors and the proposed approach identifies that they are connected through a wormhole we have a false positive alarm If both of the senders C  and D  are real neighbors to at least one of the receivers we can derive that the two senders are within 2r  to the two receivers In this way both the pilot bits and the transmitted sequences will reach their targets and the verification procedure will complete successfully Therefore to cause a false positive alarm we must have at least one sender con-necting to both receivers through wormholes Without losing generality we assume that the sender is node C  If the two receivers A  and B  get the sequence from C  through the same sending operation of the wormhole the attackers will not be able to manipulate the difference between diffAt  and diffBt  since this op-eration has the same effect as node C  is at the posi-tion of the wormhole node The attacker can keep the sequence in the wormhole for a period of time This operation however has the same effect as node C  adjusts its transmission time Previous analysis has shown that this parameter will be removed from the final calculation result  With this analysis we find that the attackers need to deliver the sequence from C  to the two receivers through two different sending operations so that they   Tsinghua Science and Technology October 2011 16(5): 505-519  518 can control the difference between their arriving time This goal can be achieved through maintaining two separate wormholes to the receivers or transmitting the sequences through different directional antennas Both schemes will increase the deployment difficulty and the hardware costs of the attackers At the same time the following simulation will show that the false positive alarms have limited impacts on the average path length in the network  In this simulation we assume that the legitimate nodes are deployed randomly and uniformly in a 2 km 2 km×  area The transmission range r  is 250 m Two legitimate nodes A  and B  are real neighbors When they want to verify the neighbor rela-tionship the attackers will transmit the sequences to them through two malicious nodes X  and X ′  re-spectively Here X  is only a neighbor of A  and X ′  is only a neighbor of B  Since A  and B  are real neighbors the physical distance between X  and X ′  is in the interval [03 ]r  Under these assumptions we study the relationship among the number of false positive alarms the node density and the number of wormholes in the network  Figure 7 shows the simulation results We can see that the node density does not have a large impact on the ratio between the number of false positive alarms and the total number of neighbor relations in the net-work At the same time when there are fewer than 3 pairs of wormholes there are less than 1% of real neighbor relations that are wrongly labeled as worm-holes Previous research[12] shows that when the false positive alarm rate is smaller than 1% its impacts   on the average path length among legitimate nodes are  very limited Therefore we conclude that when there are not many pairs of wormholes in the network the false positive alarms will not significantly deteriorate the network performance 6  Conclusions In this paper we propose a wormhole detection mecha-nism for wireless networks based on physical layer network coding When the sequences from two senders collide at the receiver the starting point of collision is determined by the distances from the senders to the receiver Two wireless nodes can then compare their starting points of collision to estimate the distance be-tween them and verify the neighbor relationship To turn this mechanism into a practical approach we study various problems in the network layer and the physical layer We also analyze the safety of the pro-posed approach and investigate the false alarm rate  Immediate extensions to our approach consist of the following aspects First we will implement the pro-posed approach in software defined radio and test it in real network environments Second we will improve the efficiency of the detection mechanism by allowing multiple pairs of neighbors to share the same pair of senders Finally we will investigate using physical layer network coding to detect other stealth attacks on wireless network topology   References [1] Katti S Gollakota S Katabi D Embracing wireless inter-ference: Analog network coding In: Proceedings of the conference on Applications Technologies Architectures and Protocols for Computer Communications (SigComm) Kyoto Japan 2007: 397-408 [2] Zhang Shengli Liew S C Lam P P Hot topic: Physi-cal-layer network coding In: Proceedings of the Annual International Conference on Mobile Computing and Net-working (MobiCom) Los Angeles CA USA 2006: 358-365 [3] Charles D Jain K Lauter K Signatures for network cod-ing Int J Inf Coding Theory 2009 1(1): 3-14 [4] Dong Jing Curtmola R Nita-Rotaru C Practical defenses against pollution attacks in intra-flow network coding for wireless mesh networks In: Proceedings of the ACM Con-ference on Wireless Network Security (WiSec)  Zurich Switzerland 2009: 111-122 [5] Hu Y C Perrig A Johnson D Wormhole attacks in wire-less networks IEEE J Sel Areas Commun 2006 24(2): 370-380  Fig 7  Percent of real neighbors labeled as wormholes (false positive alarm) Zhiwei Li et al：Forced Collision: Detecting Wormhole Attacks with Physical …  519[6] apkumCˇ  S Buttyán L Hubaux J P Sector: Secure tracking of node encounters in multi-hop wireless networks In: Proceedings of ACM Workshop on Security of Ad Hoc and Sensor Networks Alexandria VA USA 2003: 21-32 [7] Hu Lingxuan Evans D Using directional antennas to pre-vent wormhole attacks In: Proceedings of Network and Distributed System Security Symposium San Diego USA 2004 [8] Khalil I Bagchi S Shroff N B Liteworp: Detection and isolation of the wormhole attack in static multihop wireless networks Comput Netw 2007 51(13): 3750-3772 [9] Khalil I Bagchi S Shroff N B Mobiworp: Mitigation of the wormhole attack in mobile multihop wireless networks Ad Hoc Netw 2008 6(3): 344-362 [10] Wang Xia Wong J An end-to-end detection of wormhole attack in wireless ad-hoc networks In: Annual Interna-tional Computer Software and Applications Conference Beijing China 2007: 39-48 [11] Eriksson J Krishnamurthy S Faloutsos M Truelink: A practical countermeasure to the wormhole attack in wire-less networks In: Proceedings of IEEE International Con-ference on Network Protocols Santa Barbara CA USA 2006: 75-84 [12] Wang Weichao Bhargava B Visualization of wormholes in sensor networks In: Proceedings of the 3rd ACM Work-shop on Wireless Security (WiSe) Philadelphia PA USA 2004: 51-60 [13] Wang Weichao Kong Jiejun Bhargava B et al Visualisa-tion of wormholes in underwater sensor networks: A dis-tributed approach Int J Secur Netw 2008 3(1): 10-23 [14] Poovendran R Lazos L A graph theoretic framework for preventing the wormhole attack in wireless ad hoc net-works Wirel Netw 2007 13(1): 27-59 [15] Maheshwari R Gao Jie Das S R Detecting wormhole attacks in wireless networks using connectivity informa-tion In: 26th IEEE International Conference on Computer Communications Anchorage AK USA 2007: 107-115 [16] Qian Lijun Song Nan Li Xiangfang Detection of worm-hole attacks in multi-path routed wireless ad hoc networks: A statistical analysis approach Journal of Network and Computer Applications 2007 30(1): 308-330 [17] Buttyan L Dora L Vajda I Statistical wormhole detection in sensor networks In: European Workshop on Security and Privacy in Ad-hoc and Sensor Networks Visegrad Hungary 2005: 128-141 [18] Stankovic V Fagoonee L Moinian A et al Wireless full-duplex communications based on network coding In: Proceedings of 45th Annual Allerton Conference on Com-munications Control and Computing Illinois USA 2007: 690-694 [19] Zhang Shengli Liew S C Lu Lu Physical layer network coding schemes over finite and infinite fields In: IEEE GLOBECOM New Orleans LO USA 2008: 1-6 [20] Pu Wei Luo Chong Jiao Binxing et al Natural network coding in multi-hop wireless networks In: IEEE ICC Bei-jing China 2008: 2388-2392 [21] Hao Yonggang Goeckel D Ding Zhiguo et al Achievable rates for network coding on the exchange channel In: IEEE Milcom Orlando FL USA 2007: 1-7 [22] Cui Tao Ho T Kliewer J Some results on relay strategies for memoryless two-way relay channels In: Information Theory and Applications Workshop San Diego CA USA 2008: 158-164 [23] Latif R Hussain M Hardware-based random number gen-eration in wireless sensor networks (WSNs) In: Proceed-ings of the International Conference and Workshops on Advances in Information Security and Assurance Seoul Korea 2009: 732-740 [24] Nguyen H Shinoda Y A node’s number of neighbors in wireless mobile ad hoc networks: A statistical view In: Proceedings of International Conference on Networks Cancun Mexico 2009: 52-60 [25] Tseng C C Chen H T Chen K C Distribution of the node degree for wireless ad hoc networks in shadow fading en-vironments IEICE Transactions on Communications 2007 E90-B(8): 2155-2158 [26] Romer K Time synchronization in ad hoc networks In: ACM MOBIHOC Rome Italy 2001: 173-182 [27] Song Hui Zhu Sencun Cao Guohong Attack-resilient time synchronization for wireless sensor networks In: Proc of IEEE International Conference on Mobile Ad-hoc and Sensor Systems (MASS) Washington DC USA 2005   
Attack-01 CTP Sink hole-pdf,Launching a Sinkhole Attack in WirelessSensor Networks; the Intruder SideIoannis Krontiris Thanassis Giannetsos Tassos DimitriouAthens Information Technology 19002 Peania Athens GreeceEmail: {ikroagiatdim}@aitedugrAbstract—One of the reasons that the research of intrusion de-tection in wireless sensor networks has not advanced significantlyis that the concept of “intrusion” is not clear in these networks Inthis paper we investigate in depth one of the most severe attacksagainst sensor networks namely the sinkhole attack and weemphasize on strategies that an attacker can follow to successfullylaunch such an attack Then we propose specific detection rulesthat can make legitimate nodes become aware of the threat whilethe attack is still taking place Finally we demonstrate the attackand present some implementation details that emphasize the littleeffort that an attacker would need to put in order to break intoa realistic sensor networkI INTRODUCTIONThe pervasive interconnection of wireless sensor deviceshas given birth to a broad class of exciting new applicationsin several areas of our lives However as every networksensor networks are exposed to security threats which if notproperly addressed can exclude them from being deployed inthe envisaged scenarios Their wireless and distributed natureand the serious constraints in node battery power preventpreviously known security approaches to be deployed andhas created a large number of vulnerabilities that attackerscan exploit in order to gain access in the network and theinformation transferred withinSecuring sensor networks against these threats is a chal-lenging research area necessary for commercially attractivedeployments Encryption and authentication mechanisms pro-vide reasonable defense for mote-class outsider attacks How-ever cryptography is inefficient in protecting against laptop-class and insider attacks It remains an open problem foradditional research and development since the presence ofinsiders significantly lessens the effectiveness of link layersecurity mechanisms This is because an insider is allowedto participate in the network and have complete access to anymessages routed through the network and is free to modifysuppress or eavesdrop on the contentsWhat makes it even easier for attackers is the fact thatmost protocols for sensor networks are not designed havingsecurity threats in mind As a consequence deployments ofsensor networks rarely include security protection and little orno effort is usually required from the side of the attacker toperform the attack So it is very important to study realisticattacker models and evaluate the practicality and efficiency ofcertain attacksThis paper investigates one of the most severe routingattacks in sensor networks namely the sinkhole attack [1]from the attacker’s point of view Our goal is to describe themost effective ways to launch this attack and demonstrate themin practice We reveal the weaknesses of the routing protocolsthat are most widely used by the research community hopingthat this will lead to a better awareness of the threats and thestudy of more efficient security protocols Then we proposesome countermeasures against these threats in the directionof intrusion detection Some first intrusion detection systemshave started to appear for sensor networks but rarely dothey include specific detection rules [2] Rules against specificattacks like the one we present here if properly generalizedcould lead to better and more realistic IDS designsThis paper is structured as follows: In Section II we statethe routing protocols considered here and why they werechosen Then we state our assumption about the attackerin Section III and previous work in Section IV Section Vdescribes the sinkhole attack in detail and how it can belaunched successfully against the considered routing protocolsThen in Section VI we discuss specific detection rules thatcould make legitimate nodes aware that such an attack takesplace in their neighborhood Finally Section VII demonstratesour implementation of the attack and Section VIII concludesthe paperII THE ROUTING LAYER MODELThere appears to be a great diversity in deployed routingprotocols for sensor networks In this paper we concentrate onthe two most popular ones the MintRoute protocol and theMultiHopLQI MintRoute is used in most real sensor networksdeployments today as for example in [3]–[5] and has alsoserved as the basis for TinyOS 2x Collection Tree ProtocolMany current sensor node platforms like the micaZ Telosand Intel Mote2 use the same radio chip the CC2420 Thisradio chip provides a hardware indicator called Link QualityIndicator (LQI) which is believed to be a better indicator oflink quality than RSSI This has led several routing protocolsto adopt LQI indicated by the last packet as the criterionfor parent selection In this paper we investigate one of theseprotocols the MultiHopLQI [6] which is widely used inMoteIV Tmote Sky It has been also used in several sensornetwork deployments [7]–[9] The Drain collection protocolis a derivative of MultiHopLQI and served as the basis forthe TinyOS 2x dissemination service Several other customrouting protocols were designed based on MintRoute andMultiHopLQIIEEE International Conference on Wireless & Mobile Computing Networking & Communication978-0-7695-3393-3/08 $2500 © 2008 IEEEDOI 101109/WiMob200883526III THREAT MODELIn this paper we assume the presence of an attacker that canaccess (and eventually change) the internal state of a sensornode This type of attack is referred to as node capture inthe literature [10] Most existing routing schemes for sensornetworks can be substantially influenced even if the attackercaptures one node or a minute portion of the network [1] Sofor the attacks described here we will assume that the attackerhas captured just one node (although the same setting can begeneralized to more nodes) which was previously a legitimatemember of the network To avoid detection we assume thatthe attacker does not reprogram the memory of the node butshe rather connects the node to a laptop in order to monitorthe packets received Then she can change the contents of thepackets and resend them using the attached node Thereforethe attacker has access only to her immediate vicinity and doesnot use a stronger transmitter or an outbound communicationchannelIV RELATED WORKA first approach on the detection of sinkhole attacks hasbeen presented by Ngai et al [11] This approach involvesthe base station in the detection process resulting in a highcommunication cost for the protocol The base station floodsthe network with a request message containing the IDs of theaffected nodes The affected nodes reply to the base stationwith a message containing their IDs ID of the next hop and theassociated cost The received information is then used from thebase station to construct a network flow graph for identifyingthe sinkholeOther existing protocols build detecting mechanisms forsinkhole attacks in sensor networks that are based on routingprotocols usually deployed in Ad-Hoc networks like the Ad-hoc On-demand Distance Vector Protocol (AODV) [12] andthe Dynamic Source Routing (DSR) Protocol [13]In our experience routing protocols specifically designedfor sensor networks like MintRoute and MultiHopLQI requiremuch less resources and are usually preferred for such net-works A first effort to detect Sinkhole attacks on MintRoutewas made in one of our earlier publications [14] We includethis discussion here also in a more formal way and comple-ment it with new ways to launch this attack and detect itV THE SINKHOLE ATTACKThe sinkhole attack is a particularly severe attack thatprevents the base station from obtaining complete and correctsensing data thus forming a serious threat to higher-layerapplications In a Sinkhole attack [1] a compromised nodetries to draw all or as much traffic as possible from a particulararea by making itself look attractive to the surrounding nodeswith respect to the routing metric As a result the adversarymanages to attract all traffic that is destined to the base stationBy taking part in the routing process she can then launchmore severe attacks like selective forwarding modifying oreven dropping the packets coming throughA Sinkhole Attack on MintRouteMintRoute uses link quality estimates as the routing costmetric to build the routing tree toward the base station For thecalculation of these link estimates MintRoute uses the packeterror rate The nodes periodically transmit a packet called“route update” and each node estimates the link quality ofits neighbors based on the packet loss of the packets receivedfrom each corresponding neighbor The list of these estimatesfor each neighbor is broadcasted by the node periodically inits route update packetsEvery node maintains a Neighbor Table and updates it whenit receives a route update packet This table stores a list withthe IDs of all neighboring nodes and their corresponding linkcosts The node chooses its “parent node” to be the one withthe best link quality in the Neighbor Table Note that the hopdistance of each neighbor to the base station is not taken underconsideration in choosing the parent unless two nodes havethe same link qualityThe parent changing mechanism is triggered every time thelink quality of one or more nodes becomes 75% better thanthe link quality of the current parent or the link quality ofthe current parent drops below 25 in absolute value (with 255being the maximum value) In such case the node with thehighest quality becomes the new parent However if two ofsuch candidate nodes happen to have the same link qualitythe new parent will be the one with the smaller hop count tothe base stationIn the case of a routing protocol like MintRoute that useslink estimates as the routing metric the compromised nodelaunching the sinkhole attack will try to persuade its neighborsto change their current parents and choose the sinkhole nodeas their new one There are two ways to do that:1) Advertise an attractive link quality for itself2) Make other nodes look like they have worse link qualitythan itselfNote that the attacker cannot launch a sinkhole attack byadvertising that it has a lower hop count to the base station asthis metric is not the primary criterion in this routing protocolSo the attacker needs to come up with more sophisticatedwaysMoreover just advertising a high link quality to the othernodes may not be enough since most of these routing pro-tocols try to be robust meaning that they don’t allow thenodes to change parents frequently and for no good reasonFor example when a node changes its parent this could createa routing cycle in the network which is followed by an extracost to resolve it Therefore aside from advertising a highlink quality for itself another way for the attacking node tolaunch the sinkhole attack is to make the current parents looklike they have a very poor link quality which will trigger theparent changing mechanism in their children Then the newparent to be chosen will be the sinkhole nodeThe way to do that is to change the link quality estimatessent by the parent nodes within their route update packetsThe attacker listens to the route update messages from its527neighbors alters them and replays them impersonating theoriginal sender Even if there is an underlying key mechanismthat nodes can use to communicate securely with each othermost probably the attacker will be using a broadcast key sharedwith the nodes to be able to overhear change and send thesepacketsCABDEFNode LinkQualityBCF170255150NeighborTable(a)CABDEFNode LinkQualityBCF20255150NeighborTable(b)Fig 1: The two phases of sinkhole attack on MintRoute (a)Node C (attacker) receives the route update packet of node A(b) Node C sends a forged packet to A impersonating B Inboth cases the Neighbor Table of node A is indicatedLet’s take for example the case shown in Figure 1 wherenode C is the attacker and node B is the current parent of nodeA Node C has sent its own route update packet advertising afake link quality (at the maximum value of 255) but this is notenough to make node A change its parent Therefore when itreceives the route update packet of node A it changes the linkquality of node B to a low value and sends it back to A as aunicast packet impersonating B Upon receiving this packetnode A thinks it is a route update packet from B it extractsthe link quality estimation and updates the corresponding entryin the Neighbor Table This will trigger the parent changingmechanism and since the link quality of node B is below 25that node will be ignored in the selection algorithm and nodeC will be chosenAfter performing the above attack for all of its neighborsthe Sinkhole node will eventually attract the traffic passingthrough these nodesB Sinkhole Attack on MultiHopLQIFrom what we described in the previous section the weak-ness of MintRoute is that each node is based on the advertisedlink quality from other nodes to decide on its parent In Mul-tiHopLQI the nodes calculate the link quality based on theirown hardware Each node periodically broadcasts a beaconmessage and the receivers extract the LQI given by their radiochip This number is given to a function that calculates the costof the corresponding link The cost is inversely proportionalto the LQI The most attractive link is the one with the lowestcost In what follows we will use the notation CostAB toindicate the cost estimation of node A for the link betweenitself and BThe payload of the beacon message includes the sender’scurrent parent and a cost for the whole path to the base station(ie the path cost) This cost is calculated as the sum of allthe costs of the links that make the path For a node B thathas a parent D its path cost is calculated asCostB = CostBD + CostD (1)The value of CostB is included in the beacon of node BNode A that receives the beacon reads and stores the value ina table It also calculates CostAB as we described above andcalculates its own path cost CostA using Equation (1) NodeA chooses as its parent the node that minimizes CostAAccording to this algorithm we identify three ways for anattacker C to launch the sinkhole attack:1) Advertise a low path cost with its parent2) Make other nodes look like they have worse path coststhan itself3) Change its parent to the neighbor with the minimumpath costLet us describe each of the above strategies using theexample shown in Figure 2 Let’s suppose that initially thenodes have chosen their parents as depicted in Figure 2(a)The path costs for each node are also indicated Node C iscompromised by an attacker and her goal according to thesinkhole attack is to attract as much traffic as possible fromthe neighboring nodes convincing them to choose C as theirparentsABCDEF(145) (156)(128)(92)(152)(a)ABCDEF(15) (42)(38)(48)(128)(b)ABCDEF(145) (156)(128)(1000)(187)(c)ABCDEF(107)(134)(124)(92)(149)(d)Fig 2: Three sinkhole attacks on MultiHopLQI Case (a)shows the original settings of the network before the attackwhile cases (b) (c) and (d) show the result of each of the threestrategiesThe first and easiest way is to advertise the minimumpath cost to the base station This is shown in Figure 2(b)According to the function built in MultiHopLQI the path costthat corresponds to the maximum LQI is 15 The result ofthis attack is that nodes A E and F change their parents toC as this reduces their corresponding path costs This willalso trigger the parent changing mechanism at the parent of528the attacker node B However choosing any of the childrenof C will result in the formation of a routing cycle since Bis the attacker’s parent and eventually will be forced to goback to its old parent D In the experiments we noticed thatthis behavior of B kept repeating however according to therouting protocol it is legitimate so we consider that the goalof the attack has been reachedThe second way to launch a sinkhole attack is for nodeC to impersonate a node and advertise a very high pathcost on its behalf For example in Figure 2(c) the attackerbroadcasts beacons impersonating node E and advertises apath cost equal to let’s say 1000 Its child F updates itsown path cost to 1000 + CostEF and realizes that choosingnode C as its parent will reduce it substantially Since nodeE will keep broadcasting its legitimate beacons periodically(with path cost 92) the attacker needs to do the same with itsspoofed messages immediately after the messages of E Thiswill keep CostE in the memory of node F at the attacker’sdesirable value If node C follows the same strategy for eachnode in its vicinity it will manage to attract all the trafficThe third strategy for the attacker is to look for the nodewith the minimum path cost in the neighborhood and advertisethe best possible but also legitimate path cost for itself Forexample in Figure 2(d) node E has the best path cost In thisnetwork it is the case thatCostE + CostEC > CostB + CostBC so node C had chosen B as its parent For the attack howevernode C chooses E as its parent and advertises a very attractivepath cost ie CostE + 15 This is much less than the pathcost it was advertising before The neighbors will update thisvalue in their tables and hopefully their corresponding pathcosts will drop by choosing C as their parents as it is thecase with Figure 2(d) In Section VI we will see that thisform of attack is the hardest to detect since the attacker doesnothing that is not legitimateVI DETECTING THE SINKHOLE ATTACKBased on the vulnerabilities of the routing protocols thatwe exposed in the previous section we now move a stepfurther and propose specific rules that can be used to detectthe attack Since all communication in a WSN is conductedover the air nodes can listen on the network and captureand examine individual packets passing from their immediateneighborhood in real time So the question that we try toanswer in this section is whether nodes can autonomouslyrealize that a sinkhole attack takes place in their neighborhoodwithout the help of the base station or clusterheadsA Detection on MintRouteIn order to detect the sinkhole attack on MintRoute we adda rule that will trigger an alert whenever a malicious nodetries to impersonate another node according to the attack wedescribed in Section V-A The intuition is that route updatepackets should originate only from their legitimate sender andthe nodes should defend against impersonation attacks0 100 200 300 400 500 600 700 800100150200250Link Estimate of node A for node CLink Quality (receiveEst)Time (sec)0 100 200 300 400 500 600 700 800100150200250Link Estimate of node C for node ALink Quality (receiveEst)Time (sec)Fig 3: The estimates of node A and node C for the qualityof the link between them based on the packet loss rateRule 1: For each overheard route update packet check thesender field which must belong to one of your neighborsFor the example shown in Figure 1 the rule will be triggeredin node B since it will overhear the packet sent by node Cimpersonating B It will be also triggered in nodes E andF  which will overhear a packet from node B without beingneighbors of B As the attacking node tries to acquire morenodes using this method the rule will be triggered in more ofits neighborsThere is also another rule that can be used by legitimatenodes which is based on anomaly detection In particularwe make the following observation: according to MintRouteeach node independently measures the link quality estimate ofeach neighbor and receives their estimates through the routeupdate packets As one expects these values cannot have abig deviation from each other For example let’s take the linkbetween the two nodes A and C of the network in Figure 1Figure 3 shows the estimate of node A for the quality of thatlink and the estimate of node C for the same link and forthe same period of time As it is expected the estimates ofthe two nodes for the same link are almost the same withsome small deviation In particular the maximum differencethat we found between the two link estimates was 49 whichcorresponds to 192%As we said in Section V-A an attacking node may tryto advertise a very high link quality for itself hoping thatthis value will be more than 75% better than the link qualityestimate of a node for its current parent This advertisementis overheard by its neighbors However this value will notcorrespond to the link quality estimate that the node has forthe link with the attacking node This observation can help usdefine a second rule as followsRule 2: For each [parent child] pair of your neighborscompare the link quality estimate they advertise for the linkbetween them Their difference cannot exceed 50529Let us note that for a node that detects an anomaly accordingto the above rules it is only an indication that a sinkhole attackis in progress For example using Rule 1 there is no way toknow which node is trying to launch the attack since thesender field is altered The only conclusion that can be drawnso far is that the attacker is one of the neighboring nodessince the route update packets are only broadcasted locallySimilarly for Rule 2 a monitoring node cannot know whichof the two nodes advertises fake link quality However webelieve that this is a promising research direction and if theserules are used properly in an intrusion detection system thatinduces collaboration with other nodes in the area successfuldetection can occur [14] [15]B Detection on MultiHopLQISince some of the attacker’s strategies are common betweenthe two routing protocols the corresponding rules can alsobe applied to detect the sinkhole attack in MultiHopLQI Inparticular in the case that the attacker tries to impersonateanother node and advertise a high path cost (ref Figure 2(c))Rule 1 from the previous section can be applied here as wellFor the strategy described in Figure 2(b) where the attackeradvertises the minimum path cost there is an inconsistency inthe protocol itself that we can take advantage and define a newrule We notice that the path costs should be increasing as wemove more hops away from the base station In other wordseach node should be advertising a bigger path cost than itsparent as it is derived by Equation (1) In this attack it’s nothard to see that this condition is violated According to thedescription of the attack the attacker advertises a path costwhich is smaller that its parent The nodes that are neighborsof both the attacker and its parent have their path costs storedin their memory according to the protocol So they could applythe following rule and detect the attacker:Rule 3: For each beacon check that the advertised path costof the node is bigger than the path cost of its fatherIf this rule is violated one of the two nodes lies about itspath cost and it has to be the one that advertises the smallercost In a different case in which the attacker for whateverreason advertises a bigger path cost than its legitimate childthat child would immediately update its path cost according toEquation (1) and may trigger the parent changing mechanismdepending on the result In any case however the rule wouldnot be violated So this rule can lead to immediate detectionDetecting the third attack that we described in Section V-Bfor MultiHopLQI is more difficult because as we said theattacker advertises a path cost that is within the limits andis higher than the cost of its parent as it is supposed tobe However the advertised cost is still fake and does notcorrespond to the real link quality so like we did in the caseof MintRoute we turn to anomaly detection We made thesame experiment and compared the LQI of two nodes E andC for the link between them As shown in Figure 4 they arethe same except for a small deviation The maximum observeddifference was 7 So for MultiHopLQI we can define anequivalent rule with Rule 2 as follows0 100 200 300 400 500 600 700 800708090100110LQI of node E for node CTime (sec)Link Quality (receiveEst)0 100 200 300 400 500 600 700 800708090100110LQI of node C for node ETime (sec)Link Quality (receiveEst)Fig 4: The estimates of node E and node C for the qualityof the link between them based on the LQIRule 4: For each [parent child] pair of your neighborscompare the LQI they advertise for the link between themTheir difference cannot exceed 10The only problem about applying this rule in practice isthat nodes in MultiHopLQI do not advertise the LQI that theycalculate for their links We strongly suggest this modificationfor future designs of similar routing protocols Alternativelysuch a mechanism could be embedded in an IDS systemVII IMPLEMENTATION OF THE ATTACKIn this section we demonstrate the sinkhole attack on areal sensor network deployment describing the details of oursetting and the tools that we developed In particular wehave decided to implement the third strategy described inSection V-B as it is the most interesting and difficult to detectIn this way we make it even clearer that launching a sinkholeattack against an unprotected network is a trivial task for anattacker and stress the need for security measuresIn our implementation we used Tmote Sky nodes fromMoteIV We took the side of the attacker and we placed ournode inside a sensor network that was set up using MultiHop-LQI as the routing protocol and Delta at the application layerWe assumed no previous knowledge for the network so wefirst built a packet sniffer in order to acquire the necessaryinformation for the attack As we said MultihopLQI period-ically transmits a beacon message containing information ofthe node’s parent path cost These packets can be used toreconstruct the network connectivity from the sniffer tracesThe sniffer is implemented as a modified version ofthe TinyOS TOSBase (standard application distributed withTinyOS) only that the code was modified to pass everypacket received over the radio to the serial port regardlessof destination address or AM group ID In this way we hadall overheard packets forwarded to our laptop A graphical userinterface of our Java application revealing the IDs of the nodes530in our vicinity their parents and the path costs is shown inFigure 5(a) The base station does not appear in the topologysince it is 2-hops from our “malicious” node(a)(b)Fig 5: Launching the sinkhole attack on a real deployednetwork using MultiHopLQI (a) The network topology beforethe attack (b) The network topology after the attackAfter acquiring the necessary information the first step forthe attack consists of identifying the node with the small-est path cost This is done automatically after listening tobroadcast packets In the example of Figure 5 it is node 6with Cost6 = 42 The second step is to broadcast beaconsthrough our node advertising that our parent is node 6 andour path cost to it is Cost1 = Cost6 + 15 = 57 The resultis shown in Figure 5(b) All nodes except node 2 minimizedtheir path costs by choosing our node as their new parentWe intentionally chose to include this example to show thatthe attack does not necessarily succeed to attract all nodesIt solely depends on the path cost that the nodes had withtheir parents Let us note however that by trying differenttopologies we rarely missed attracting 100% of the nodesVIII CONCLUSIONSIn this paper we identified several vulnerabilities of twopopular routing protocols of sensor networks and showed howthey can be exploited by an attacker to launch a sinkholeattack It turns out that the effort the attacker has to put isminimal and the attack can go undetected unless certaindetection rules are applied We identified such rules andhighlighted any modifications that are necessary for the routingprotocols The results of this work serve a two-fold purpose:they motivate a better design of routing protocols that canmake them more resilient to attacks and they also open theway for defining more general and formal rules in intrusiondetection systemsACKNOWLEDGEMENTSThe authors would like to thank the reviewers for theirhelpful commentsREFERENCES[1] C Karlof and D Wagner “Secure routing in wireless sensor networks:Attacks and countermeasures” AdHoc Networks Journal vol 1 no 2–3pp 293–315 September 2003[2] R Roman J Zhou and J Lopez “Applying intrusion detection sys-tems to wireless sensor networks” in Proceedings of IEEE ConsumerCommunications and Networking Conference (CCNC ’06) Las VegasUSA January 2006 pp 640–644[3] G Werner-Allen K Lorincz M Welsh O Marcillo J JohnsonM Ruiz and J Lees “Deploying a wireless sensor network on an activevolcano” IEEE Internet Computing vol 10 no 2 pp 18–25 2006[4] T Schmid H Dubois-Ferrie`re and M Vetterli “SensorScope: Ex-periences with a Wireless Building Monitoring Sensor Network” inProceeding of the Workshop on Real-World Wireless Sensor Networks(REALWSN ’05) Stockholm Sweden June 2005[5] S Kim S Pakzad D Culler J Demmel G Fenves S Glaser andM Turon “Wireless sensor networks for structural health monitoring”in SenSys ’06: Proceedings of the 4th international conference onEmbedded networked sensor systems 2006 pp 427–428[6] TinyOS http://wwwtinyosnet/tinyos-1x/tos/lib/MultiHopLQI 2004[7] G Werner-Allen K Lorincz J Johnson J Lees and M Welsh“Fidelity and yield in a volcano monitoring sensor network” in OSDI’06: Proceedings of the 7th symposium on Operating systems designand implementation Berkeley CA USA: USENIX Association 2006[8] G Giorgetti S Mastroianni J Lewis G Manes and S Gupta“The personal sensor network: A user-centric monitoring solution” inBodyNets ’07: Proceedings of the 2nd International Conference on BodyArea Networks 2007[9] J Paek and R Govindan “RCRT: rate-controlled reliable transportfor wireless sensor networks” in SenSys ’07: Proceedings of the 5thinternational conference on Embedded networked sensor systems NewYork NY USA: ACM 2007 pp 305–319[10] A Perrig J Stankovic and D Wagner “Security in wireless sensornetworks” Communications of the ACM vol 47 no 6 pp 53–57 2004[11] E C H Ngai J Liu and M R Lyu “On the intruder detection forsinkhole attack in wireless sensor networks” in Proceedings of theIEEE International Conference on Communications (ICC ’06) IstanbulTurkey June 2006[12] D Dallas C Leckie and K Ramamohanarao “Hop-count monitoring:Detecting sinkhole attacks in wireless sensor networks” in ICON ’07:Proceedings of the 15th IEEE International Conference on NetworksAdelaide SA 2007 pp 176–181[13] A A Pirzada and C McDonald “Circumventing sinkholes and worm-holes in wireless sensor networks” in IWWAN ’05: Proceedings ofInternational Workshop on Wireless Ad-hoc Networks 2005[14] I Krontiris T Dimitriou T Giannetsos and M Mpasoukos “Intru-sion detection of sinkhole attacks in wireless sensor networks” inProceedings of the 3rd International Workshop on Algorithmic Aspectsof Wireless Sensor Networks (AlgoSensors ’07) Wroclaw Poland July2007[15] I Krontiris T Giannetsos and T Dimitriou “LIDeA: A distributedlightweight intrusion detection architecture for sensor networks” inProceedings of the 4th International Conference on Security and Pri-vacy for Communication Networks (SecureComm ’08) Istanbul TurkeySeptember 2008531
CTP-2006-pdf,The Collection Tree Protocol (CTP)TEP: 123Group: Network Working GroupType: DocumentaryStatus: FinalTinyOS-Version: > 21Author: Rodrigo Fonseca Omprakash Gnawali Kyle Jamieson Sukun KimPhilip Levis and Alec WooDraft-Created: 3-Aug-2006Draft-Version: 115Draft-Modified: 2009-01-16Draft-Discuss: TinyOS Developer List <tinyos-devel atmailmillenniumberkeleyedu>NoteThis memo documents a part of TinyOS for the TinyOS Community and requests discussionand suggestions for improvements Distribution of this memo is unlimited This memo is in fullcompliance with TEP 1AbstractThis memo documents the Collection Tree Protocol (CTP) which provides best-effort anycast datagramcommunication to one of the collection roots in a network1 IntroductionA collection protocol delivers data to one of possibly several data sinks providing a many-to-one networklayer Collection is a fundamental component of most sensor network applications The Collection TreeProtocol (CTP) is a reference Collection protocol in TinyOS 2x The users use Collection interfacesdescribed in TEP 1193 to use CTP in their applicationsIn this TEP after a brief discussion of Collection and CTP we specify the CTP routing and dataframes CTP uses routing frames to update and build collection tree in the network CTP uses dataframes to deliver application payload to the sink and to probe topology inconsistenciesAll fields in this specification are in network byte order2 Assumptions and LimitationsCTP is a tree-based collection protocol Some number of nodes in a network advertise themselves astree roots Nodes form a set of routing trees to these roots CTP is address-free in that a node doesnot send a packet to a particular root; instead it implicitly chooses a root by choosing a next hopNodes generate routes to roots using a routing gradient1The CTP protocol assumes that the data link layer provides four things:1) Provides an efficient local broadcast address2) Provides synchronous acknowledgments for unicast packets3) Provides a protocol dispatch field to support multiple higher-level protocols4) Has single-hop 16-bit source and destination fieldsCTP assumes that it has link quality estimates of some number of nearby neighbors These pro-vide an estimate of the number of transmissions it takes for the node to send a unicast packet whoseacknowledgment is successfully receivedCTP has several mechanisms in order to achieve high delivery reliability but it does not promise100% reliable delivery It is a best effort protocolCTP is designed for relatively low traffic rates such that there is enough space in the channelto transmit and receive routing frames even when the network is forwarding collection data framesBandwidth-limited systems or high data rate applications might benefit from a different protocol whichcan for example pack multiple small frames into a single data-link packet or employ rate controlmechanisms3 Collection and CTPCTP uses expected transmissions (ETX) as its routing gradient A root has an ETX of 0 The ETX ofa node is the ETX of its parent plus the ETX of its link to its parent This additive measure assumesthat nodes use link-level retransmissions Given a choice of valid routes CTP SHOULD choose the onewith the lowest ETX value CTP represents ETX values as 16-bit decimal fixed-point real numberswith a precision of tenths An ETX value of 45 for example represents an ETX of 45 while an ETXvalue of 10 represents an ETX of 1Routing loops are a problem that can emerge in a CTP network Routing loops generally occur whena node choose a new route that has a significantly higher ETX than its old one perhaps in response tolosing connectivity with a candidate parent If the new route includes a node which was a descendantthen a loop occursCTP addresses loops through two mechanisms First every CTP packet contains a node’s currentgradient value If CTP receives a data frame with a gradient value lower than its own then this indicatesthat there is an inconsistency in the tree CTP tries to resolve the inconsistency by broadcasting abeacon frame with the hope that the node which sent the data frame will hear it and adjust its routesaccordingly If a collection of nodes is separated from the rest of the network then they will form aloop whose ETX increases forever CTP’s second mechanism is to not consider routes with an ETXhigher than a reasonable constant The value of this constant is implementation dependentPacket duplication is an additional problem that can occur in CTP Packet duplication occurs when anode receives a data frame successfully and transmits an ACK but the ACK is not received The senderretransmits the packet and the receiver receives it a second time This can have disasterous effectsover multiple hops as the duplication is exponential For example if each hop on average producesone duplicate then on the first hop there will be two packets on the second there will be four on thethird there will be eight etc CTP keeps a small cache of packet signature for the packets it has seento detect packet duplicates When a new packet arrives if its signature results in cache hit CTP dropsthe packet because it is a duplicateRouting loops complicate duplicate suppression as a routing loop may cause a node to legitimatelyreceive a packet more than once Therefore if a node suppresses duplicates based solely on originatingaddress and sequence number packets in routing loops may be dropped CTP data frames thereforehave an additional time has lived (THL) field which the routing layer increments on each hop Alink-level retransmission has the same THL value while a looped version of the packet is unlikely to doso24 CTP Data FrameThe CTP data frame format is as follows:10 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|P|C| reserved | THL |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| ETX |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| origin |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| seqno | collect_id |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| data +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+Field definitions are as follows:• P: Routing pull The P bit allows nodes to request routing information from othernodes If the unicast destination of the data frame with a valid route hears a packetwith the P bit set it SHOULD transmit a routing frame in the near future Nodesother than the link-layer destination of the data frame MAY respond to the P bit inthe data frame• C: Congestion notification If a node drops a CTP data frame it MUST set the C fieldon the next data frame it transmits• THL: Time Has Lived When a node generates a CTP data frame it MUST set THLto 0 When a node receives a CTP data frame it MUST increment the THL If a nodereceives a THL of 255 it increments it to 0• ETX: The ETX routing metric of the single-hop sender When a node transmits a CTPdata frame it MUST put the ETX value of its route through the single-hop destinationin the ETX field If a node receives a packet with a lower gradient than its own thenit MUST schedule a routing frame in the near future• origin: The originating address of the packet A node forwarding a data frame MUSTNOT modify the origin field• seqno: Origin sequence number The originating node sets this field and a nodeforwarding a data frame MUST NOT modify it• collect id: Higher-level protocol identifier The origin sets this field and a node for-warding a data frame MUST NOT modify it• data: the data payload of zero or more bytes A node forwarding a data frame MUSTNOT modify the data payload The length of the data field is computed by subtractingthe size of the CTP header from the size of the link layer payload provided by the linklayerTogether the origin seqno and collect id fields denote a unique *origin packet* Together theorigin seqno collect id and THL denote a unique *packet instance* within the network Thedistinction is important for duplicate suppression in the presence of routing loops If a node suppressesorigin packets then if asked to forward the same packet twice due to a routing loop it will drop thepacket However if it suppresses packet instances then it will route successfully in the presence oftransient loops unless the THL happens to wrap around to a forwarded packet instanceA node MUST send CTP data frames as unicast messages with link-layer acknowledgments enabled35 CTP Routing FrameThe CTP routing frame format is as follows:10 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|P|C| reserved | parent |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| parent | ETX |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| ETX |+-+-+-+-+-+-+-+-+The fields are as follows:• P: Same as data frame with one difference: Routing frames are broadcast so multiplenodes respond to the P bit in the routing frame• C: Congestion notification If a node drops a CTP data frame it MUST set the C fieldon the next routing frame it transmits• parent: The node’s current parent• metric: The node’s current routing metric valueWhen a node hears a routing frame it MUST update its routing table to reflect the address’ newmetric If a node’s ETX value changes significantly then CTP SHOULD transmit a broadcast framesoon thereafter to notify other nodes which might change their routes The parent field acts as asurrogate for the single-hop destination field of a data packet: a parent can detect when a child’s ETXis significantly below its own When a parent hears a child advertise an ETX below its own it MUSTschedule a routing frame for transmission in the near futureA node MUST send CTP routing frames as broadcast messages6 ImplementationAn implementation of CTP can be found in the tos/lib/net/ctp directory of TinyOS 20 This sectiondescribes the structure of that implementation and is not in any way part of the specification of CTPThis implementation has three major subcomponents:1) A link estimator which is responsible for estimating the single-hop ETX of communicationwith single-hop neighbors2) A routing engine which uses link estimates as well as network-level information to decide whichneighbor is the next routing hop3) A forwarding engine which maintains a queue of packets to send It decides when and if tosend them The name is a little misleading: the forwarding engine is responsible for forwarded trafficas well as traffic generated on the node61 Link EstimationThe implementation uses two mechanisms to estimate the quality of a link: periodic LEEP1 packetsand data packets The implementation sends routing beacons as LEEP packets These packets seed theneighbor table with bidirectional ETX values The implementation adapts its beaconing rate based onnetwork dynamics using an algorithm similar to the trickle dissemination protocol2 Beacons are senton an exponentially increasing randomized timer The implementation resets the timer to a small valuewhen one or more of the following conditions are met:1) The routing table is empty (this also sets the P bit)42) The node’s routing ETX increases by >= 1 transmission3) The node hears a packet with the P bit setThe implementation augments the LEEP link estimates with data transmissions This is a directmeasure of ETX Whenever the data path transmits a packet it tells the link estimator the destinationand whether it was successfully acknowledged The estimator produces an ETX estimate every 5 suchtransmissions where 0 successes has an ETX of 6The estimator combines the beacon and data estimates by incorporating them into an exponentiallyweighted moving average Beacon-based estimates seed the neighbor table The expectation is thatthe low beacon rate in a stable network means that for a selected route data estimates will outweighbeacon estimates Additionally as the rate at which CTP collects data estimates is proportional to thetransmission rate then it can quickly detect a broken link and switch to another candidate neighborThe component tos/lib/net/4bitle/LinkEstimatorP implements the link estimator It couplesLEEP-based and data-based estimates as described in462 Routing EngineThe implementation’s routing engine is responsible for picking the next hop for a data transmission Itkeeps track of the path ETX values of a subset of the nodes maintained by the link estimation tableThe minimum cost route has the smallest sum the path ETX from that node and the link ETX of thatnode The path ETX is therefore the sum of link ETX values along the entire route The componenttos/lib/net/ctp/CtpRoutingEngineP implements the routing engine63 Forwarding EngineThe component tos/lib/net/ctp/CtpForwardingEngineP implements the forwarding engine It hasfive responsibilities:1) Transmitting packets to the next hop retransmitting when necessary and passingacknowledgment based information to the link estimator2) Deciding when to transmit packets to the next hop3) Detecting routing inconsistencies and informing the routing engine4) Maintaining a queue of packets to transmit which are a mix of locally generatedand forwarded packets5) Detecting single-hop transmission duplicates caused by lost acknowledgmentsThe four key functions of the forwading engine are packet reception (SubReceivereceive())packet forwarding (forward()) packet transmission (sendTask()) and deciding what to do after apacket transmission (SubSendsendDone())The receive function decides whether or not the node should forward a packet It checks for duplicatesusing a small cache of recently received packets If it decides a packet is not a duplicate it calls theforwading functionThe forwarding function formats the packet for forwarding It checks the received packet to see ifthere is possibly a loop in the network It checks if there is space in the transmission queue If there isno space it drops the packet and sets the C bit If the transmission queue was empty then it posts thesend taskThe send task examines the packet at the head of the transmission queue formats it for the nexthop (requests the route from the routing layer etc) and submits it to the AM layerWhen the send completes sendDone examines the packet to see the result If the packet wasacknowledged it pulls the packet off the transmission queue If the packet was locally generated itsignals sendDone() to the client above If it was forwarded it returns the packet to the forwardingmessage pool If there are packets remaining in the queue (eg the packet was not acknowledged) itstarts a randomized timer that reposts this task This timer essentially rate limits CTP so that it doesnot stream packets as quickly as possible in order to prevent self-collisions along the path57 CitationsRodrigo Fonseca473 Soda HallBerkeley CA 94720-1776phone - +1 510 642-8919email - rfonseca@csberkeleyeduOmprakash GnawaliRonald Tutor Hall (RTH) 4183710 S McClintock AvenueLos Angeles CA 90089phone - +1 213 821-5627email - gnawali@usceduKyle JamiesonThe Stata Center32 Vassar StCambridge MA 02139email - jamieson@csailmiteduPhilip Levis358 Gates HallComputer Science LaboratoryStanford UniversityStanford CA 94305phone - +1 650 725 9046email - pal@csstanfordeduAlec WooArch Rock Corporation501 2nd St Ste 410San Francisco CA 94107-4132email - awoo@archrockcomSukun Kim6Samsung Electronics416 Maetan-3-dong Yeongtong-GuSuwon Gyeonggi 443-742Korea Republic ofphone - +82 10 3065 6836email - sukunkim@samsungcom8 Citations1 TEP 124: Link Estimation Extension Protocol2 Philip Levis Neil Patel David Culler and Scott Shenker “A Self-Regulating Algorithm for CodeMaintenance and Propagation in Wireless Sensor Networks” In Proceedings of the First USENIXConference on Networked Systems Design and Implementation (NSDI) 20043 TEP 119: Collection4 Rodrigo Fonseca Omprakash Gnawali Kyle Jamieson and Philip Levis “Four Bit Wireless LinkEstimation” In Proceedings of the Sixth Workshop on Hot Topics in Networks (HotNets VI) November20077
CTP-Martin-pdf,Collection Tree ProtocolA look into datapath validation and adaptive beaconingSpeaker: Martin LanterCollection Protocols• Why do we need collection protocols?– “Collecting data at a base station is a common requirement of sensor network applications The general approach used is to build one or more collection trees each of which is rooted at a base station When a node has data which needs to be collected it sends the data up the tree and it forwards collection data that other nodes send to it” [TinyOS TEP 119]• Requirements1 Reliability: > 90% of packets2 Robustness3 Efficiency: Use a minimum of transmissions4 Hardware IndependenceCollection Tree Protocol (CTP)• Is a protocol that computes routes to one or more sinks• Builds and maintains minimum cost tree(s) with the sink(s) as roothttp://singstanfordedu/gnawali/ctp/Challenges for CTP• Link dynamics– Wireless links can have coherence as small as 500 ms• Routing Inconsistencies– Inconsistencies/routing changes might lead to loopshttp://wwwtdwessde/nepal/nepalhtmhttp://tinyurlcom/6x9dh4rHow to find a route• Minimize transmission costs– ETX = Expected number of transmissions• Every node maintains an estimate of the cost of a route to a collection pointRouting in CTP3 hops4 hopssourcesinkCTP ArchitectureForwarts data packetsComputes ETX and Route to sinkComputes ETX to neighboors[Colesanti and Santini 2010]Parent SelectionijklsinkLink estimator:- ETX1hop(ij)- ETX1hop(ik)- ETX1hop(il)Routing Engine:- ETXmultihop(ij) = ETX1hop(ij) + ETXmultihop(j)- ETXmultihop(ik) = ETX1hop(ik) + ETXmultihop(k)- ETXmultihop(il) = ETX1hop(il) + ETXmultihop(l)Link estimator• Link estimator:• - ETX1hop(ij)• - ETX1hop(ik)• - ETX1hop(il)http://singstanfordedu/gnawali/ctp/Parent SelectionijklsinkLink estimator:- ETX1hop(ij)- ETX1hop(ik)- ETX1hop(il)Routing Engine:- ETXmultihop(ij) = ETX1hop(ij) + ETXmultihop(j)- ETXmultihop(ik) = ETX1hop(ik) + ETXmultihop(k)- ETXmultihop(il) = ETX1hop(il) + ETXmultihop(l)Data vs Control Traffic• Data packets– Unicast• Control Beacons– Broadcast[Colesanti and Santini 2010]Control Beacon• Control beacon has– Two fields: Parentand cost– Two control bits: • Pull bit (P)• Congestion bit (C)[Colesanti and Santini 2010][Colesanti and Santini 2010]Link Dynamics• Other protocols typically use periodic beacons to update network topology and link estimates– Faster rates lead to higher cost– Slower rates lead to misinterpretations• But CTP uses adaptive beaconing!Adaptive Beaconing• CTP uses the Trickle Algorithm [Levis 2004]• In CTP:– Start with lowest interval of 64 ms– When interval expires double it up to 1 hour• Node resets the interval if– It is asked to forward a packet from a node whose ETX is lower or equal to its own– Is routing cost degrees significantly– It receives a packet with the P bit setData Plane Design• Per-client Queuing– One single outstanding packet per client (process)• Hybrid Send Queue– Route through- and locally-generated traffic buffer• Transmit Timer– Wait two packet times between transmissions• Transmit Cache– Avoid duplicatesRetransmission and Duplicates[Colesanti and Santini 2010][Colesanti and Santini 2010]jklEvaluationCTPOthersOthers:- MultiHopLQI- Hyper- RBC- DozerCollection Protocols• Why do we need collection protocols?– “Collecting data at a base station is a common requirement of sensor network applications The general approach used is to build one or more collection trees each of which is rooted at a base station When a node has data which needs to be collected it sends the data up the tree and it forwards collection data that other nodes send to it” [TinyOS TEP 119]• Requirements1 Reliability: > 90% of packets2 Robustness3 Efficiency: Use a minimum of transmissions4 Hardware IndependenceTestbeds[Gnawali 2009] Reliability[Gnawali 2009] ReliabilityCTP MultiHopLQI[Gnawali 2009] RobustnessCTP MultiHopLQI[Gnawali 2009] Efficiency[Gnawali 2009] Efficiency[Gnawali 2009] Furthermore• Agility– After a pause of 20 mins and removal of a node the beacon rate decreased to 1 beacon per 8 min– Establish a new route withing 325 ms• Transmit timer• Transmit cache• External interference• Link layers• Energy profileWhy to use CTP• CTP delivers >90% of packets (usually 999%)• CTP sends 73% fewer beacons than others• CTP reduces topology repair latency by 998%In short: CTP is greatQuestions?http://tinyurlcom/67luhsvReferences• [TEP 119] R Fonseca O Gnawali K Jamieson S Kim P Levis and A Woo TEP 119: Collection Protocol Feb 2006• [TEP 123] R Fonseca O Gnawali K Jamieson S Kim P Levis and A Woo TEP 123: The Collection Tree Protocol Aug 2006• [Gnawali 2009] Gnawali et al: Collection Tree Protocol 2009• [Colesanti and Santini 2010] U Colesanti S Santini Tech report: A Performance Evaluation Of The Collection Tree Protocol Based On Its Implementation For The Castalia Wireless Sensor Networks Simulator• [Levis 2004] P Levis N Patel D Culler and S Shenker Trickle: A selfregulating algorithm for code maintenance and propagation in wireless sensor networks In Proc of the USENIX NSDI Conf San Francisco CA Mar 2004• [Fonseca 2007] R Fonseca O Gnawali K Jamieson and P Levis Four Bit Wireless Link Estimation In Hotnets-VI Atlanta GA Nov 2007
CTP-Neo-2009-pdf,Collection Tree ProtocolOmprakash GnawaliStanford University & University of Southern Californiagnawali@csstanfordeduRodrigo FonsecaBrown University & Yahoo! Researchrfonseca@csbrowneduKyle JamiesonUniversity College Londonkjamieson@csuclacukDavid MossRincon Researchdmm@rinconcomPhilip LevisStanford Universitypal@csstanfordeduAbstractThis paper presents and evaluates two principles for wire-less routing protocols The first is datapath validation: datatraffic quickly discovers and fixes routing inconsistenciesThe second is adaptive beaconing: extending the Trickle al-gorithm to routing control traffic reduces route repair latencyand sends fewer beaconsWe evaluate datapath validation and adaptive beaconingin CTP Noe a sensor network tree collection protocol Weuse 12 different testbeds ranging in size from 20–310 nodescomprising seven platforms and six different link layers onboth interference-free and interference-prone channels In allcases CTP Noe delivers > 90% of packets Many experi-ments achieve 999% Compared to standard beaconing CTPNoe sends 73% fewer beacons while reducing topology re-pair latency by 998% Finally when using low-power linklayers CTP Noe has duty cycles of 3% while supporting ag-gregate loads of 30 packets/minuteCategories and Subject DescriptorsC21 [Computer-communication networks]: NetworkArchitecture and Design—Wireless communication; C2[Computer-communication networks]: Network ProtocolsGeneral TermsDesign Experimentation PerformanceKeywordsCollection CTP Sensor Network Routing1 IntroductionThis paper describes two principles for wireless routingprotocol design: datapath validation and adaptive beaconingIt evaluates these principles in the context of CTP Noe animplementation of the Collection Tree Protocol (CTP) [10]CTP is a routing protocol that computes anycast routes to aPermission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributedfor profit or commercial advantage and that copies bear this notice and the full citationon the first page To copy otherwise to republish to post on servers or to redistributeto lists requires prior specific permission and/or a feeSenSys’09 November 4–6 2009 Berkeley CA USACopyright 2009 ACM 978-1-60558-748-6 $500single or a small number of designated sinks in a wirelesssensor network Four goals motivate the need for datapathvalidation and adaptive beaconing:Reliability: a protocol should deliver at least 90% ofend-to-end packets when a route exists even under challeng-ing network conditions 999% delivery should be achievablewithout end-to-end mechanismsRobustness: it should be able to operate without tun-ing or configuration in a wide range of network conditionstopologies workloads and environmentsEfficiency: it should deliver packets with the minimumamount of transmissions across the network and requiringlittle stateHardware Independence: it should achieve the threeabove goals without assuming specific radio chip featuresas sensor networks use a wide range of platformsAchieving these goals depends on link estimation accu-racy and agility At the packet level wireless links can havecoherence times as small as 500 milliseconds [29] Being ef-ficient requires using these links when possible but avoidingthem when they fail The four-bit link estimator for exampleis able to reduce delivery costs by up to 44% by changing itsestimates as quickly as every five packets [11]Such dynamism is inherently challenging Rapid topol-ogy changes necessitate distance-vector rather than link-state algorithms Simple distance-vector protocols howeversuffer from routing loops and other problems that harm reli-ability and efficiency The two principles we present allow arouting protocol to react at the same timescales as the topol-ogy changes while remaining efficient and robustThe first datapath validation actively uses data pack-ets to validate the routing topology and detect loops Eachdata packet contains the link-layer transmitter’s estimate ofits distance A node detects a possible routing loop when itreceives a packet to forward from a node with a smaller orequal distance to the destination Rather than drop such apacket the routing layer repairs the topology and forwardsthe packet normally Data packets detect routing inconsisten-cies precisely when a route is needed even when the controltraffic rate is very lowThe second adaptive beaconing extends the Trickle [18]algorithm originally designed for code updates to dynam-ically adapt control traffic Adaptive beaconing can react intens of milliseconds to topology changes yet send a few con-trol packets per hour when the topology is stableWhile the CTP specification [10] describes protocolpacket formats and interoperability requirements several as-pects are left open for an implementation to decide such asthe timings for routing and forwarding packets This paperdescribes and evaluates the algorithms and mechanisms thatone particular implementation called CTP Noe uses In ad-dition to incorporating adaptive beaconing and datapath val-idation CTP Noe includes additional mechanisms and al-gorithms to improve performance These include re-transmittimers a hybrid queue for forwarded and local packets per-client queuing and a duplicate suppression cacheWe evaluate CTP Noe on 12 different testbeds ranging insize from 20–310 nodes and comprising seven hardware plat-forms While not deployments in the field the testbeds com-prise diverse environmental conditions beyond our controlprovide reproducibility and have enough diversity to give usconfidence that CTP Noe achieves the above goals Anecdo-tal reports from several deployments support this belief Intwo testbeds that have Telos nodes we evaluate CTP Noe us-ing three link layers: full power low power listening [25] andlow power probing [22] In one Telos-based testbed wherethere is exceptionally high 80211b interference we evaluateCTP Noe on an interference-prone and an interference-freechannel Evaluating CTP Noe we find:• Across all testbeds configurations and CSMA layersCTP Noe’s end-to-end delivery ratio ranges from 905%to 999% CTP Noe supports median duty cycles of 3%while sustaining aggregate loads of 30 pkts per minute• Compared to MultihopLQI a collection protocol usedin recent deployments [36] CTP Noe drops 90% fewerpackets while sending 29% fewer packets• Compared to MultihopLQI’s fixed 30 second beacon in-terval CTP Noe’s adaptive beaconing and datapath val-idation sends 73% fewer beacons while cutting loop re-covery latency by 998%• Testbeds vary significantly in their density connectiv-ity and link stability and the dominant cause of CTPNoe’s packet loss varies across them correspondinglyThis paper makes three research contributions First itdescribes two key principles adaptive beaconing and data-path validation which enable routing layers to remain effi-cient robust and reliable in highly dynamic topologies onmany different link layers Second it describes the designand implementation of CTP Noe a collection protocol thatuses these two mechanisms Third by evaluating CTP Noeon 12 different testbeds it provides a comparative study oftheir behavior and properties The variation across testbedssuggests that protocols designed for and evaluated on onlya single testbed are prone to failures when they encounterdifferent network conditionsIn Section 2 we identify two main challenges in im-plementing robust and efficient wireless network protocolsnamely link dynamics and transient loops Based on theseobservations we present adaptive beaconing and datapathvalidation in Section 3 Section 4 follows by giving detaileddescriptions of how CTP Noe implements these two mecha-nisms while Section 5 describes CTP Noe’s data plane Sec-tion 6 presents a comprehensive experimental evaluation ofCTP Noe on 12 testbeds Section 7 presents prior work Sec-tion 8 discusses our experiences with CTP Noe and Sec-tion 9 concludes2 MotivationHaving a robust highly reliable and efficient collectionprotocol benefits almost every sensor network application to-day as well as the many transport routing overlay and ap-plication protocols that sit on top of collection trees At firstglance collection protocols may appear very simple Theyprovide best-effort unreliable anycast packet delivery to oneof the data sinks in the networkHowever despite providing a simple service that is fun-damental to so many systems and being in use for almosta decade collection protocols today typically suffer frompoor performance Deployments observe delivery ratios of2-68% [16 21 31 36]Furthermore it is unclear why collection performs well incontrolled situations yet poorly in practice even at low datarates To better understand the causes of these failures weran a series of experiments on 12 different testbeds and foundtwo phenomena to be the dominant causes: link dynamicsand transient loops21 Link DynamicsProtocols typically use periodic beacons to maintain theirtopology and estimate link qualities The beaconing rate in-troduces a tradeoff between agility and efficiency: a fasterrate leads to a more agile network but higher cost while alower rate leads to a slower-to-adapt network and lower costEarly protocol designs such as MintRoute assumed that in-termediate links had stable independent packet losses andused this assumption to derive the necessary sampling win-dow for an accurate estimate [38] But in some environmentsparticularly in the 24 GHz frequency space links can behighly dynamic Experimental studies have found that manylinks are not stationary but bursty on the time scale of a fewhundred milliseconds [29]Protocols today however settle for beacon rates on theorder of tens of seconds leading to typical rate mismatchesof two to three orders of magnitude This means that at lowbeacon rates while data packets might observe contiguousperiods of 0% and 100% reception ratios periodic controlpackets might observe a reception ratio of 50% The periodsof 0% cause many wasted retransmissions and packet dropsFor a periodic beacon to be able to sample these link varia-tions the beacon period would have to be in the order of fewhundred millisecondsLink dynamics also poses a challenge in routing protocoldesign - how should a routing protocol be designed when theunderlying link topology can change in the order of a fewhundred milliseconds?22 Transient LoopsRapid link topology changes can have serious adverseeffects on existing routing protocols causing losses in thedata plane or long periods of disconnection while the topol-ogy adjusts In most variations of distributed distance vec-tor algorithms link topology changes may result in transientloops which causes packet drops1 This is the case even inpath-vector protocols like BGP designed to avoid loop for-mation [23]The MultihopLQI protocol for example discards pack-ets when it detects a loop until a new next hop is found Thiscan take a few minutes causing a significant outage We ex-perimentally examine this behavior of MultiHopLQI in Sec-tion 63 In DSDV designed to avoid loops when a link goesdown the entire subtree whose root used that link is discon-nected until an alternate path is found [24] This happensonly when the global sequence number for the collection rootchanges: rapid link dynamics require quick sequence numberprogression introducing a significant control packet loadIn both cases the problem is that topology repairs hap-pen at the timescale of control plane maintenance which op-erates at a time scale orders of magnitude longer than thedata plane Since the data plane has no say in the routing de-cisions it has to choose between dropping packets or stop-ping traffic until the topology repairs This in turn createsa tension on the control plane between efficiency in stabletopologies and delivery in dynamic ones3 Design OverviewA collection protocol builds and maintains minimum-cost trees to nodes that advertise themselves as tree rootsCollection is address-free: when there are multiple base sta-tions it sends to the one with the minimum cost withoutknowing its address In this paper we assume all data packetsare simple unicast framesRapidly changing link qualities cause nodes to have staletopology information which can lead to routing loops andpacket drops This section presents two mechanisms that en-able a routing protocol to be robust to stale route informationand agile to link dynamics while also having a low overheadwhen the topology is stable The first is datapath validation:using data packets to dynamically probe and validate theconsistency of its routing topology The second is adaptivebeaconing which extends the Trickle code propagation algo-rithm so it can be applied to routing control traffic Trickle’sexponential timer allows nodes to send very few control bea-cons when the topology is consistent yet quickly adapt whenthe datapath discovers a possible problem31 Datapath ValidationEvery node maintains an estimate of the cost of its routeto a collection point We assume expected transmissions(ETX) as the cost metric but any similar gradient metric canwork just as well A node’s cost is the cost of its next hopplus the cost of its link to the next hop: the cost of a route isthe sum of the costs of its links Collection points advertise acost of zeroEach data packet contains the transmitter’s local cost esti-mate When a node receives a packet to forward it comparesthe transmitter’s cost to its own Since cost must always de-crease if a transmitter’s advertised cost is not greater thanthe receiver’s then the transmitter’s topology information isstale and there may be a routing loop Using the data path to1RAM limitation and high cost for update propagation precludesthe use of link-state protocols in sensor networksvalidate the topology in this way allows a protocol to detectpossible loops on the first data packet after they occur32 Adaptive BeaconingWe assume that the collection layer updates stale routinginformation by sending control beacons As with data pack-ets beacons contain the transmitter’s local cost estimate Un-like data packets however control beacons are broadcasts Asingle beacon updates many nearby nodesCollection protocols typically broadcast control beaconsat a fixed interval [238] This interval poses a basic tradeoffA small interval reduces how stale information can be andhow long a loop can persist but uses more bandwidth andenergy A large interval uses less bandwidth and energy butcan let topological problems persist for a long timeAdaptive beaconing breaks this tradeoff achieving bothfast recovery and low cost It does so by extending theTrickle algorithm [18] to maintaining its routing topologyTrickle is designed to reliably and efficiently propagatecode in a wireless network Trickle’s basic mechanism istransmitting the version number of a node’s code using arandomized timer Trickle adds two mechanisms on top ofthis randomized transmission: suppression and adapting thetimer interval If a node hears another node advertise thesame version number it suppresses its own transmissionWhen a timer interval expires Trickle doubles it up to amaximum value (τh) When Trickle hears a newer versionnumber it shrinks the timer interval to a small value (τl)If all nodes have the same version number their timer in-tervals increase exponentially up to τh Furthermore only asmall subset of nodes transmit per interval as a single trans-mission can suppress many nearby nodes When there is newcode however the interval shrinks to τl  causing nodes toquickly learn of and receive new codeUnlike algorithms in ad-hoc routing protocols such asDSDV [24] adaptive beaconing does not assume the treemaintains a global sequence number or version number thatmight allow a simple application of Trickle Instead adaptivebeaconing uses the routing cost gradient to control when toreset the timer interval The routing layer resets the intervalto τl on three events:1 It is asked to forward a data packet from a nodewhose ETX is not higher than its own The protocolinterprets this as neighbors having a significantly out-of-date estimate and possibly a routing loop It beaconsto update its neighbors2 Its routing cost decreases significantly The protocoladvertises this event because it might provide lower-cost routes to nearby nodes In this case “significant”is an ETX of 153 It receives a packet with the P bit set The “Pull” bitadvertises that a node wishes to hear beacons from itsneighbors eg because it has just joined the networkand needs to seed its routing table The pull bit providesa mechanism for nodes to actively request topology in-formation from neighbors Section 43 provides greaterdetail on the P bitIn a network with very stable links both the first and sec-ond events are rare As long as nodes do not set the P bitthe beacon interval increases exponentially up to τh Whenthe topology changes significantly however affected nodesreset their intervals to τl  and transmit to quickly reach con-sistency While it could we assume that adaptive beaconingdoes not use Trickle’s suppression mechanism233 Other DetailsDatapath validation and adaptive beaconing allow a rout-ing layer to maintain an efficient yet agile topology but areinsufficient by themselves Numerous systems issues arise inpacket forwarding that affect efficiency reliability and ro-bustness such as self-interference link-layer duplicate sup-pression retransmission policies and queuing We defer pre-senting these systems and implementation issues to Sec-tion 5 which discusses the data plane The next section givesa detailed description of the implementation of these tech-niques in CTP Noe’s control plane4 Control Plane DesignThis section describes how CTP Noe discovers selectsand advertises routes41 Route Computation and SelectionTEP 123 specifies the CTP routing packet format nodesuse to exchange topology information [10] which we sum-marize here A CTP routing frame has two fields and twocontrol bits The two fields advertise the node’s current par-ent and routing cost The two control bits are the pull bit (P)and the congested bit (C) We discuss the meaning and useof the P bit below The C bit is for signaling higher-layercongestion control and is not relevant for this paperChanging routes too quickly can harm efficiency as deal-ing with noise in link estimates requires time To dampenthe topology change rate CTP Noe employs hysteresis inpath selection: it only switches routes if it believes the otherroute is significantly better than its current one where “sig-nificantly” better is having an ETX at least 15 lower Whilehysteresis has the danger of allowing CTP Noe to use sub-optimal routes it can be shown that noise in link estimatescauses better routes to dominate a node’s next hop selection42 Control Traffic TimingWhen CTP Noe’s topology is stable it relies on datapackets to maintain probe and improve link estimates androuting state Beacons however form a critical part of rout-ing topology maintenance First since beacons are broad-casts they are the basic neighbor discovery mechanism andprovide the bootstrapping mechanism for neighbor tablesSecond there are times when nodes must advertise informa-tion such as route cost changes to all of their neighborsBecause CTP Noe separates link estimation from its con-trol beacons its estimator does not require or assume a fixedbeaconing rate This allows CTP Noe to adjust its beacon-ing rate based on the expected importance of the beacon in-formation to its neighbors Minimizing broadcasts has theadditional benefit that they are typically much more expen-sive to send with low-power link layers than unicast packetsWhen the routing topology is working well and routing cost2In Trickle terminology CTP Noe sets k = ∞estimates are accurate CTP Noe slows its beaconing rateHowever when the routing topology changes significantlyor CTP Noe detects a problem with the topology it quicklyinforms nearby nodes so they can react accordinglyCTP Noe sends routing packets using a variant of theTrickle algorithm [18] It maintains a beaconing intervalwhich varies between 64 ms and one hour Whenever thetimer expires CTP Noe doubles it up to the maximum (onehour) Whenever CTP Noe detects an event which indicatesthe topology needs active maintenance it resets the timer tothe minimum (64 ms) These values are independent of theunderlying link layer If a packet time is larger than 64 msthen the timer simply expires several times until it reaches apacket time43 Resetting the Beacon IntervalAs Section 32 above mentions three events cause CTPNoe to reset its beaconing interval to the minimum lengthThe simplest one is the P bit CTP Noe resets its bea-con interval whenever it receives a packet with the P bit setA node sets the P bit when it does not have a valid routeFor example when a node boots its routing table is emptyso it beacons with the P bit set Setting the P bit allows anode to “pull” advertisements from its neighbors in order toquickly discover its local neighborhood It also allows a nodeto recover from large topology changes which cause all of itsrouting table entries to be staleCTP Noe also resets its beacon interval when its costdrops significantly Though this is not necessary for correct-ness a node whose cost drops quickly may suddenly be amuch more desirable next hop Resetting its beacon intervalallows the node’s neighbors to quickly learn this informationThe final and most important event is when CTP Noe de-tects that there might be a routing topology inconsistencyCTP Noe imposes an invariant: the cost of each hop mustmonotonically decrease Let p be a path consisting of k linksbetween node n0 and the root node nk such that node ni for-wards its packets to node ni+1 For the routing state to beconsistent the following constraint must be satisfied:∀i ∈ {0k−1} ETX(ni)> ETX(ni+1)where ETX(x) is the path ETX from node x to the rootCTP Noe forwards data packets in a possible loop nor-mally: it does not drop them However it introduces a slightpause in forwarding the length of the minimum beacon inter-val This ensures that it sends the resulting beacon before thedata packet such that the inconsistent node has a chance toresolve the problem If there is a loop of length L this meansthat the forwarded packet takes L− 1 hops before reachingthe node that triggered topology recovery As that node hasupdated its routing table it will pick a different next hopIf the first beacon was lost then the process will repeat Ifit chooses another inconsistent next hop it will trigger a sec-ond topology recovery In highly dynamic networks packetsoccasionally traverse multiple loops incrementally repairingthe topology until finally the stale node picks a safe nexthop and the packet escapes to the root The cost of these rareevents of a small number of transient loops is typically muchless than the aggregate cost of general forwarding: improv-ing routes through rare transient loops is worth the costSend Queue!Transmit Cache!Transmit Timer!Link!Link!Client Queues!Pool!?!duplicate!Figure 1 The CTP Noe’s forwarding path5 Data Plane DesignIn the previous section we described the important rolethat the control plane plays in detecting inconsistencies in thetopology and resetting the beacon interval to fix them Thissection describes CTP Noe’s data plane Unlike the controlplane which is a set of consistency algorithms the concernsof the data plane are much more systems- and implemen-tation-oriented This section describes four mechanisms inthe data plane that achieve efficiency robustness and reli-ability: per-client queuing a hybrid send queue a transmittimer and a packet summary cache Figure 1 shows the CTPNoe data path and how these four mechanisms interactA CTP data frame has an eight byte header [10] The dataframe header shares two fields with the routing frame theone byte control field (P and C bits) and the two byte routeETX field The one byte time has lived (THL) is the oppositeof a TTL: it starts at zero at an end point and each hop incre-ments it by one A one-byte dispatch identifier called CollectID allows multiple clients to share a single CTP Noe layerA two byte origin field contains the identifier of the nodethat originated the packet and a node increments a one bytesequence number on each packet it originatesCTP Noe uses a very aggressive retransmission policyBy default it will retransmit a packet up to 32 times Thispolicy stems from the fact that all packets have the samedestination and thus the same next hop The outcome oftransmitting the next packet in the queue will be the sameas the current one Instead of dropping CTP Noe combinesa retransmit delay with proactive topology repair to increasethe chances of delivering the current packet In applicationswhere receiving more recent packets is more important thanreceiving nearly all packets the number of retransmissionscan be adjusted without affecting the routing algorithm51 Per-client QueuingCTP Noe maintains two levels of queues The top levelis a set of one-deep client queues Each client can have asingle outstanding packet If a client needs additional queu-ing it must implement it on top of this abstraction Theseclient queues do not actually store packets; they are simpleguards that keep track of whether a client has an outstand-ing packet When a client sends a packet the client queuechecks whether it is available If so the client queue marksitself busy and passes the packet down to the send queueThese client queues provide isolation as a single client can-not fill the send queue and starve others; this is in contrast toTinyOS 1x collection layers which used a shared queue52 Hybrid Send QueueCTP Noe’s lower level queue contains both routethrough- and locally-generated traffic (as in ARC [37])maintained by a FIFO policy This hybrid send queue is oflengthC+F  where C is the number of CTP Noe clients andF is the size of the forwarding buffer pool Following thispolicy means that technically the send queue never rejectsa packet If it is full this means the forwarding path is usingall of its buffers and all clients have an outstanding packetWhen CTP Noe receives a packet to forward it firstchecks if the packet is a duplicate: Section 54 describes thisprocess below If the packet is a duplicate it discards thepacket If the packet is not a duplicate CTP Noe checks ifit has a free packet buffer in its memory pool If so it putsthe received packet on the send queue to be forwarded Oth-erwise it discards the packet53 Transmit TimerMultihop wireless protocols encounter self-interferencewhere a node’s transmissions collide with prior packets it hassent which other nodes are forwarding For a route of nodesA→ B→ C →    self-interference can easily occur at Bwhen A transmits a new packet at the same time C forwardsthe previous one [19]CTP Noe prevents self interference by rate-limiting itstransmissions In the idealized scenario above where only theimmediate children and parent are in the transmission rangeof a transmitter if A waits at least two packet times betweentransmissions then it will avoid self-interference as C willhave finished forwarding [37] While real networks are morecomplex (the interference range can be greater than the trans-mit range) two packet times represents the minimum timingfor a flow longer than two hopsThe transmission wait timer depends on the packet rateof the radio If the expected packet time is p then CTP Noewaits in the range of (15p25p) such that the average waittime is 2p but there is randomization to prevent edge condi-tions due to MAC backoff or synchronized transmissions54 Transmit CacheLink layer acknowledgments are not perfect: they aresubject both to false positives and false negatives False neg-atives cause a node to retransmit a packet which is alreadyin the next hop’s forwarding queue CTP Noe needs to sup-press these duplicates as they can increase multiplicativelyon each hop Over a small number of hops this is not a sig-nificant issue but in face of the many hops of transient rout-ing loops this leads to an exponential number of copies of apacket that can overflow all queues in the loop [17]Since CTP Noe forwards looping packets in order to ac-tively repair its topology CTP Noe needs to distinguish link-layer duplicates from looping packets It detects duplicatesby examining three values: the origin address the origin se-quence number and the THL Looping packets will matchin the address and sequence number but will have a differ-ent THL (unless the loop was a multiple of 256 hops long)while link-layer duplicates have matching THL valuesWhen CTP Noe receives a packet to forward it scans itssend queue for duplicates It also scans a transmit cache con-taining the 3-tuples of the N most recently forwarded pack-Testbed Location Platform Nodes Physical size Degree PL Cost Cost Churnm2 or m3 Min Max PL node·hrTutornet (16) USC Tmote 91 50×25×10 10 60 312 591 190 3137Wymanpark Johns Hopkins Tmote 47 80×10 4 30 323 462 143 847Motelab Harvard Tmote 131 40×20×15 9 63 305 553 181 424Kanseia Ohio State TelosB 310 40×20 214 305 145 - - 434Mirage Intel Research Mica2dot 35 50×20 9 32 292 383 131 205NetEye Wayne State Tmote 125 6×4 114 120 134 140 104 194Mirage Intel Research MicaZ 86 50×20 20 65 170 185 109 192Quanto UC Berkeley Epic-Quanto 49 35×30 8 47 293 335 114 111Twist TU Berlin Tmote 100 30×13×17 38 81 169 201 119 101Twist TU Berlin eyesIFXv2 102 30×13×17 22 100 258 264 102 069Vinelab UVA Tmote 48 60×30 6 23 279 349 125 063Tutornet (26) USC Tmote 91 50×25×10 14 72 202 207 102 004Blazeb Rincon Research Blaze 20 30×30 9 19 130 - - -a Packet cost logging failed on 10 nodesb Blaze instrumentation does not provide cost and churn informationTable 1 Testbed configuration and topology properties from most to least dynamic Cost is transmissions per deliveryand PL is Path Length the average number of hops a data packet takes Cost/PL is the average transmissions per linkThere are two entries for Tutornet with TMotes: one is 802154 channel 16 the other channel 26ets The cache is necessary for the case where duplicates ar-rive more slowly than the rate at which the node drains itsqueue: in this case the duplicate will no longer be in thesend queueFor maximal efficiency the transmit cache should be aslarge as possible We have found that in practice and evenunder high load having a cache size of four slots is enoughto suppress most (> 99%) duplicates on the testbeds that weused for experiments A larger cache improves duplicate de-tection slightly but not significantly enough to justify its coston memory-constrained platforms6 EvaluationThis section evaluates how the mechanisms describedabove namely adaptive control traffic rate datapath valida-tion and the data plane optimizations combine to achievethe four goals from Section 1: reliability robustness effi-ciency and hardware independenceWe evaluate our implementation of CTP Noe using the4-bit link estimator from [11] on 12 different testbeds en-compassing seven platforms six link layers multiple den-sities and frequencies Despite having anecdotal evidenceof several successful real-world deployments of CTP Noethese results focus on publicly available testbeds becausethey represent at least theoretically reproducible results Thehope is that different testbed environments we examine suffi-ciently capture a reasonable degree of variation in hardwareplatforms topology and RF environment61 TestbedsTable 1 summarizes the 12 testbeds we use It lists thename platform number of nodes physical span and topol-ogy properties of each network Some testbeds (eg Mirage)are on a single floor while others (eg Motelab) are on mul-tiple floors Unless otherwise noted detailed experiments areon the Tutornet testbedThe minimum and maximum degree column in Table 1are the in-degree of the nodes with the smallest and largestnumber of links respectively To roughly quantify the link-layer topology of each testbed we ran an experiment whereeach node broadcasts a packet every 16 seconds The intervalis randomized to avoid collisions We consider all links thatdelivered at least one packet as part of the topology We usethis very liberal definition of a link because it is what a rout-ing layer or link estimator must deal with: a single packetcan add a node as a candidate albeit perhaps not for longAs the differing Tutornet results indicate the link stabil-ity and quality results should not be considered definitive forall experiments For example most 802154 channels sharethe same frequency bands as 80211: 802154 on an inter-fering channel has more packet losses and higher link dy-namics than an uninterfering one For example Tutornet onchannel 16 has the highest churn while Tutornet on channel26 has the lowest We revisit the implications of this effect inSection 611 All of the values in Table 1 for 802154 test-beds with the exception of Quanto and channel 16 Tutor-net experiment (Mirage Tutornet Vinelab Twist Wyman-park Kansei Neteye Motelab) use the non-interfering chan-nel 26 Channel allocation concerns prevented us from doingthe same in Quanto: it was measured with channel 15To roughly quantify link stability and quality we ranCTP Noe with an always-on link layer for three hours andcomputed three values: PL the average path length (hops apacket takes to the collection root); the average cost (trans-missions/delivery); and the node churn (parent change rate)We also look at cost/PL which indicates how any transmis-sions CTP Noe makes on average per hop Wide networkshave a larger PL Networks with many intermediate links orsparse topologies have a higher cost/PL ratio (sparsity meansa node might not have a good link to use) Networks withmore variable links or very high density have a high churn(density can increase churn because a node has more par-ents to try and choose from) As the major challenge adap-tive beaconing and datapath validation seek to address is linkdynamics we order the testbeds on churn from highest (Tu-Testbed Frequency MAC IPI Avg 5th% LossDelivery DeliveryMotelab 248GHz CSMA 16s 947% 447% RetransmitMotelab 248GHz BoX-50ms 5m 944% 269% RetransmitMotelab 248GHz BoX-500ms 5m 966% 826% RetransmitMotelab 248GHz BoX-1000ms 5m 951% 885% RetransmitMotelab 248GHz LPP-500ms 5m 905% 478% RetransmitTutornet (26) 248GHz CSMA 16s 999% 1000% QueueTutornet (16) 243GHz CSMA 16s 952% 929% QueueTutornet (16) 243GHz CSMA 22s 979% 954% QueueTutornet (16) 243GHz CSMA 30s 994% 981% QueueWymanpark 248GHz CSMA 16s 999% 1000% RetransmitNetEye 248GHz CSMA 16s 999% 964% RetransmitKansei 248GHz CSMA 16s 999% 1000% RetransmitVinelab 248GHz CSMA 16s 999% 999% RetransmitQuanto 2425GHz CSMA 16s 999% 1000% RetransmitTwist (Tmote) 248GHz CSMA 16s 993% 1000% RetransmitTwist (Tmote) 248GHz BoX-2s 5m 983% 929% RetransmitMirage (MicaZ) 248GHz CSMA 16s 999% 998% QueueMirage (Mica2dot) 9164MHz B-MAC 16s 989% 975% AckTwist (eyesIFXv2) 8683MHz CSMA 16s 999% 999% RetransmitTwist (eyesIFXv2) 8683MHz SpeckMAC-183ms 30s 948% 447% QueueBlaze 315MHz B-MAC-300ms 4m 999% - QueueTable 2 Summary of experimental results across the testbeds The first section compares how different low-power linklayers and settings affect delivery on Motelab The second section compares how the 802154 channel affects delivery onTutornet The third section shows results from other TelosB/TMote testbeds and the fourth section shows results fromtestbeds with other platforms In all settings CTP Noe achieves an average delivery ratio of over 90% In Motelab asmall number of nodes (the 5th percentile) have poor delivery due to poor connectivitytornet on channel 16) to lowest (Tutornet on channel 26)Every experiment uses all available nodes In some test-beds this means the set of nodes across experiments is al-most but not completely identical due to backchannel con-nectivity issues However we do not prune problem nodesa common approach in experimental studies using Mote-lab [35] In the case of Motelab this approach greatly affectsthe computed average performance as some nodes are barelyconnected to the rest of the network62 Experimental MethodologyWe modified three variables across all of the experiments:the inter-packet interval (IPI) with which the applicationsends packets with CTP Noe the MAC layer used and thenode ID of the root node Generally to obtain longer routeswe picked roots that were in one corner of a testbedWe used 6 different MAC layers as shown in Table 2All MAC layers used are the standard TinyOS 210 imple-mentations In the cases where we use low power link layerswe report the interval For example “BoX-1s” means BoX-MAC with a check interval of 1 second while “LPP-500ms”means low-power probing with a probing interval of 500msEvaluating efficiency is difficult as temporal dynamicsprevent knowing what the optimal route was for each packetTherefore we evaluate efficiency as a comparative measureWe compare CTP Noe with the TinyOS 21 implementationof MultihopLQI a well-established well-tested and highlyused collection layer that is part of the TinyOS release AsMultihopLQI has been used in recent deployments eg ona volcano in Ecuador [36] we consider it a reasonable com-parison Other notable collection layers such as Hyper [28]RBC [39] and Dozer [5] are either implemented in TinyOS1x (Hyper RBC) or are closed source and specific to a plat-form (Dozer tinynode) As TinyOS 2x and 1x have differ-ent packet scheduling and MAC layers we found that com-paring with 1x protocols unfairly favors CTP Noe Further-more MultihopLQI has been heavily used by a large numberof groups with good success such that using it unchanged isreasonable something which is not typically true of pure re-search protocols63 Reliable Robust Hardware-independentBefore evaluating the effectiveness of each mechanism tothe overall performance of CTP Noe we first look at high-level results from experiments across multiple testbeds aswell as a long duration experiment Table 2 shows resultsfrom 21 experiments across the 12 testbeds In these experi-ments we chose IPI values well below saturation such thatavailable throughput does not limit the delivery ratio TheLoss column describes the dominant cause of packet loss: re-transmit means CTP Noe dropped a packet after 32 retrans-missions queue means it dropped a received packet due to afull forwarding queue and ack means it heard link layer ac-knowledgments for packets that did not arrive successfullyIn all cases CTP Noe maintains an average delivery ratioabove 90%: it meets the reliability goal The lowest aver-age delivery ratio is for Motelab using low power probing(500ms) 905% The second lowest is Motelab using BoX-MAC (50ms) at 944% In Motelab packet loss is the dom-inant cause of failure: retransmission drops represent CTP 0 02 04 06 08 1 0  5  10  15  20  25  30  35  40Delivery RatioTime(hours)maxmedianmin(a) Delivery Ratio for CTP Noe 0 02 04 06 08 1 0  5  10  15  20  25  30  35  40Delivery RatioTime(hours)maxmedianmin(b) Delivery Ratio for MultiHopLQIFigure 2 CTP Noe has a consistently higher delivery ra-tio than MultiHopLQI In these plots we show for eachtime interval the minimum median and maximum de-livery ratio across all nodesNoe sending a packet 32 times yet never delivering it Ex-amining the logs this occurs because some Motelab nodesare only intermittently and sparsely connected (its compar-atively small minimum degree of nine in Table 1 reflectsthis) Furthermore CTP Noe maintains this level of reliabil-ity across all configurations and settings and requires con-figuration of a single constant the expected packet transmis-sion time when used on different radio platforms Thus itmeets the robustness and hardware independence goals Wetherefore focus comparative evaluations on MultihopLQITo show the consistency of delivery ratio over time inFigure 2(a) we show the result from one experiment whenwe ran CTP Noe for over 37 hours The delivery ratio re-mains consistently high over the duration of the experimentFigure 2(b) shows the result from a similar experiment withMultihopLQI Although MultihopLQI’s average delivery ra-tio was 85% delivery is highly variable over time occasion-ally dipping to 58% for some nodes In the remainder ofthis section we evaluate through detailed experiments howthe different techniques we use in CTP Noe contribute to itshigher delivery ratio while maintaining low control trafficrates and agility in response to changes in the topology64 EfficiencyA protocol that requires a large number of transmissionsis not well-suited for duty-cycled network We measure datadelivery efficiency using the cost metric which accounts for 1 15 2 25 3 35 4 45 5CTPMultiHopLQIDelivery cost per packetProtocolControl costData costFigure 3 CTP Noe’s cost is 24% lower than MultiHo-pLQI and the portion of that is control is 73% lower 0 100 200 300 400 500 600 0  1  2  3  4  5Total number of beacons / nodeTime(hours)MultiHopLQICTPFigure 4 CTP Noe’s beaconing rate decreases and stabi-lizes over time It is significantly smaller than Multiho-pLQI’s over the long runall the control and data transmissions in the network normal-ized by the packets received at the sink This metric gives arough measure of the energy spent delivering a single packetto the sink Figure 3 compares the delivery cost for CTP Noeand MultiHopLQI CTP Noe’s cost is 24% lower than thatof MultiHopLQI The figure also shows that control packetsfor CTP Noe occupy a much smaller fraction of the cost thanMultiHopLQI (22% vs 84%) The decrease in data trans-missions is a result of good route selection and agile routerepair The decrease in control transmissions is due to CTPNoe’s adaptive beaconing65 Adaptive Control TrafficFigure 4 shows CTP Noe’s and MultihopLQI’s controltraffic from separate seven-hour experiments on TutornetCTP Noe’s control traffic rate is high at network startup asCTP Noe probes and discovers the topology but decreasesand stabilizes over time MultiHopLQI sends beacons at afixed interval of 30 seconds Using a Trickle timer allowsCTP Noe to send beacons as quickly as every 64 ms andquickly respond to topology problems within a few packettimes By adapting its control rate and slowing down whenthe network is stable however CTP Noe has a much lowercontrol packet rate than MultiHopLQI At the same timeit can respond to topology problems in 64 ms rather than30 seconds a 998% reduction in response timeLower beacon rates are generally at odds with routeagility During one experiment we introduced four new 0 10 20 30 40 50 60 70 80 90 100 0  20  40  60  80  100  120Total number of beaconsTime(minutes)Node 38Node 39Node 40Node 41Figure 5 Number of beacons for selected nodes in theneighborhood of the new node There is a big jump incontrol traffic shortly after four new nodes are intro-duced and it levels offnodes in the network 60 minutes after the start Figure 5shows that the control overhead for selected nodes in thevicinity of the new nodes increases immediately after thenodes were introduced as beacons are sent rapidly The bea-con rate decays shortly afterward The increase in beaconingrate (in response to the pull bit) was localized to the neigh-borhood of the nodes introduced and produced fast conver-gence New nodes were able to send collection packets to thesink within four seconds after booting66 Topology InconsistenciesNext we look at how route inconsistencies are distributedover space and time and their impact on control overheadFigure 6(a) shows inconsistencies detected by each nodein an experiment over a 65-hour period Inconsistenciesare temporally correlated across nodes and typically con-strained to a subset of nodes The lowest curve in Figure 6(b)shows the cumulative count of route inconsistencies in thesame experiment and how the rate decreases over time Inthe beginning most of the inconsistencies are due to discov-ery and initial rounds of path selection Over time link dy-namics are the dominant cause of inconsistencies We havealso observed a similar trend in number of parent changes:frequent changes in the beginning as the nodes discover newlinks and neighbors and fewer changes once the network hasselected high quality routesWhen a node detects such an inconsistency it resets itsbeacon timer The top curve in Figure 6(b) shows the totalnumber of routing beacons sent (Total Beacons) The middlecurve Churn Beacons is the subset of these beacons sent bythe Trickle timer when a parent change resets the intervalThe difference between these two curves provides an upperbound on the number of beacons sent due to inconsistenciesIt is an upper bound because of the beacons that would havebeen sent normally at the slowest beacon interval and someoccasional beacon caused by packets with the pull bit setIn 65 hours the nodes sent 12299 total beacons while theydetected 3025 inconsistencies and triggered 4485 beaconsdue to parent change: CTP Noe sent 26 beacons per incon-sistency detected in order to re-establish the path to the root 0 10 20 30 40 50 60 0  1  2  3  4  5  6  7Node idTime(hours)(a) Inconsistent routing states over time andby node; each point is a detected route incon-sistency 0 50 100 150 200 250 0  1  2  3  4  5  6  7Total number of events / nodeTime(hours)Total BeaconsChurn BeaconsInconsistencies(b) Breakdown of control overhead from routeinconsistenciesFigure 6 Route inconsistencies and repair67 Robustness to FailureTo measure how effectively the routes can adapt to nodefailures we ran CTP Noe for two hours with an IPI of 8sAfter 60 minutes we removed the ten nodes that were for-warding the most packets in the network CTP Noe uses thefour-bit link estimator which reflects changes in the topol-ogy in a few packet times This resets the trickle timers andcauses rapid route convergence around the failureFigure 7(a) plots the minimum median and maximumdelivery ratio across node over time The figure shows onlya tiny change in delivery ratio due to the disruption: theminimum delivery ratio across the network drops to 98%15 nodes dropped one or two packets each right after thedisruption and most nodes found new routes in under onesecond The 10-minute dip in the graph is an artifact of thesliding window we used to calculate average delivery ratioThe median delivery ratio remained at 100%Figure 7(b) shows the result of a similar experiment withMultiHopLQI After 80 minutes we removed ten nodes thatwere forwarding the most packets The resulting disruptioncaused the delivery ratio of some nodes to drop as low as60% while the median delivery ratio dropped to 80%68 AgilityThe prior experiment shows that CTP Noe can quicklyroute around node failures when there is a constant stream oftraffic To delve deeper into how CTP Noe adapts to sud- 0 02 04 06 08 1 0  20  40  60  80  100  120  140Delivery RatioTime(minutes)maxmedianmin(a) Nodes fail at 60 minutes and CTP Noedoes not observe any significant disruption 0 02 04 06 08 1 0  20  40  60  80  100  120  140Delivery RatioTime(minutes)maxmedianmin(b) Nodes fail at 80 minutes: MultihopLQI’smedian delivery drops to 80% for 10 minutesFigure 7 Robustness of CTP Noe and MultiHopLQI when the 10 most-heavily-forwarding nodes fail 0 02 04 06 08 1 0  1  2  3  4  5  6  7  8  9  10 11 15 20 25 30 35 40 45 50Delivery RatioGoodput (pkts/s)Wait time[x2x]msDeliveryGoodputFigure 8 Effect of a per-hop rate-limiting transmit timeron goodput and delivery ratio on the CC2420 radio Waittime between packets is [x2x] msden topology changes we ran a different experiment Weran CTP Noe on Tutornet with each node generating a datapacket every eight seconds for six minutes allowing it tosettle on a good routing tree delivering 100% of the pack-ets Then we stopped generating data traffic on all the nodesfor 14 minutes At the 20th minute we removed (erased theprogram running on the mote) node 26 from the networkand shortly thereafter made node 53 (node 26’s child in therouting tree) start sending data packets As expected packettransmissions from node 53 to non-existent node 26 failedWe found that after twelve packet transmissions (325ms) CTP Noe switched to node 40 as its new parent Thusalthough the beacon rate in the network had decreased to onebeacon every eight minutes CTP Noe was able to quickly (in325ms) select a new parent when its existing parent was re-moved from the network CTP Noe remains efficient evenwhen the beacon interval decays tens of minutes maintain-ing the ability to react to topology changes within a fewpacket transmission times69 Transmit TimerCTP Noe pauses briefly between packet transmissions toavoid self-interference as described in Section 53 Here weshow how we established this value for the CC2420 radioand quantify its benefit to CTP Noe’s reliabilityFigure 8 shows how the duration of a transmission waittimer affects a single node flow on channel 26 in the Tutornettestbed In this experiment a single node sends packets asfast as it can across 3-hops to the data sink The transmissiontimers in Figure 8 range from [12] to [1020]ms At valuesbelow [714]ms delivery dips below 95%Although goodput increases slightly with smaller trans-mit timers this benefit comes at a significant cost: the deliv-ery ratio drops as low as 72% which does not satisfy the re-liability requirement However as the timer length increasespast [816]ms goodput drops significantly as the timer in-troduces idleness Therefore CTP Noe uses 7–14ms (15–3average packet times) as its wait timer for the CC2420 radioSimilarly CTP Noe uses 15–3 average packet times asits transmit timer on other radios We have found that thissetting works across the platforms and testbeds in these ex-periments but factors such as load density and link qualitiesultimately determine the maximum rate that a path can ac-commodate Some MACs might introduce large delays be-tween the packets in which case CTP Noe transmit timerscan be smallerAlthough CTP Noe’s primary goal is not high throughputtraffic its use of transmit timers allows it to avoid collisionswhile under high load Transmit timers are insufficient forend-to-end reliability: bottleneck links of low PRR can over-flow transmit queues Robust end-to-end reliability requireshigher-layer congestion and flow control [14 22 26 36] butCTP Noe’s transmit timers make its reliability more robustto the high load these protocols can generate610 Transmit CacheWe evaluate the transmit cache by running two exper-iments on Tutornet Both experiments use the CSMA linklayer have an IPI of 8s and use 802154 channel 16 Thefirst experiment uses standard CTP Noe; the second disablesits transmit cache CTP Noe has an average cost of 318packets/delivery Disabling the transmit cache increases thisto 347 packets/delivery a 9% increase The transmit cacheimproves CTP Noe’s efficiency by 9%These cost values are over 50% higher than those re-ported in Table 1 because channel 16 suffers from 80211interference while the results in Table 1 are on channel 26Chan Freq Delivery PL Cost Cost ChurnPL node-hr16 243GHz 952% 312 591 1894 313726 248GHz 999% 202 207 1025 004Table 3 Results on how channel selection effects CTPNoe’s performance on Tutornet Channel 16 overlapswith Wi-Fi; channel 26 does notFigure 9 80211 activity captured using the Wi-Spy Spec-trum Analyzer tool on Tutornet Channel 1 and 11 aremost heavily used by the building occupantswhich does not The next section examines how CTP Noeresponds to external interference in greater detail611 External InterferenceThe first two results in the second set of rows in Table 2are obtained from experiments on Tutornet with the samelink layer transmission rate and root node but differ signif-icantly in their delivery ratio This difference is due to the802154 channel they used The experiment on channel 26(248 GHz) observed an average delivery ratio of 999%; theexperiment on channel 16 (243 GHz) observed an averagedelivery ratio of 952% Table 3 summarizes the differencesbetween the two settingsUsing channel 16 the average path length increasedfrom 202 to 312 hops and the cost increased from 207to 591 transmissions per successfully delivered packet Theincrease in cost is not only due to longer paths but alsoa larger number of transmissions per hop which increasedfrom 1025 to 1894Channel 16 overlaps with several 80211b channels (2-6) while channel 26 is almost entirely outside the 80211bband Figure 9 shows Wi-Fi activity by Wi-Fi channel onthe Tutornet testbed RF interference from Wi-Fi causes linkqualities to drop increases tree depth because longer linksare generally less reliable It also causes a larger number ofretransmissions decreasing effective capacityTo test this hypothesis we re-ran the channel 16 exper-iment with inter packet intervals of 22 seconds and 30 sec-onds Table 2 shows the results At 22 seconds CTP Noe hasan average delivery ratio of 979% and at 30 seconds it has994%CTP Noe achieves high delivery even with high ex-ternal interference but achieves lower sustainable data rateon a busy channelLink Layer Average PL Cost Cost Duty CycleDelivery PL Median MeanCSMA 947% 305 553 181 1000% 100%BoX-50ms 944% 328 648 198 248% 249%BoX-500ms 971% 338 661 196 40% 46%BoX-1s 951% 540 834 154 28% 38%LPP-500ms 905% 376 855 227 66% 66%Table 4 Detailed Motelab results on how link layer set-tings affect CTP Noe’s topology and performance 0 50 100 150 200 250 0  50  100  150  200  250Energy Consumption (mAh/day)Message generation interval (s)CTP (100ms)CTP (200ms)CTP (300ms)MultiHopLQI (300ms)Figure 10 Energy consumption for CTP Noe and Multi-HopLQI for 100ms-300ms sleep intervals612 Link LayersThe first section of Table 2 contains six experiments onthe Motelab testbed using the standard TinyOS CSMA layerlow-power listening with BoX-MAC and low-power prob-ing with LPP Table 4 has further details on these resultsLow-power listening observes longer paths (higher aver-age PL) and higher end-to-end costs but the per-link cost(cost/PL) decreases Longer sleep intervals cause CTP Noeto choose longer routes of more reliable links This shift isespecially pronounced once the interval is above 500ms Thesleep interval the link layer uses affects the link qualitiesthat CTP Noe observes If the signal-to-noise ratio is com-pletely stable link qualities are independent of how often anode checks the channel There are temporal variations in thesignal-to-noise ratio: this suggests that low-power link layersshould consider the effects of link burstiness [29]Low-power probing generally under-performs low-power listening For the same check interval it has a lowerdelivery ratio and a higher duty cycle This result should notbe interpreted as a general comparison of the two howeverEach implementation can of course be improved CTP Noeis only one traffic pattern and we only compared them ona single testbed with a single traffic rate Nevertheless CTPNoe meets its reliability goal on bothWe also ran CTP Noe with low-power link layers onboth Twist testbeds For the eyesIFXv2 platform we usedthe SpeckMAC layer with a check interval of 183 ms Thelower delivery ratio with SpeckMAC compared to CSMA isdue to queue overflows on the bottleneck links because oflonger transmission times at the MAC layer613 Energy ProfileFor a more detailed examination of CTP Noe’s energyperformance we use the Blaze platform developed by Rin-con Research Blaze has a TI MSP430 microcontroller and aCC1100 [1] radio3 We used a 20-node network that RinconResearch has deployed in a 33×33m space One node in thistestbed has a precision 1 Ω resistor in series with the batteryconnected to a high precision 24-bit ADC using a data ac-quisition unit We later converted this voltage to energy andextrapolated to per day energy consumptionWe ran a total of 20 experiments for energy profilingchanging the MAC sleep interval and application data gener-ation interval For each experiment we let the network warmup for about 15 minutes We then use a dissemination proto-col to request the nodes to start sending data at a given mes-sage interval We collected energy data for 15 minutesThe platform consumes 3416 mAh/day in idle modewithout duty-cycling The result from figure 10 shows thatthe the full CTP Noe stack can run for as little as 72 mAh/-day compared to 608 mAh/day for MultiHopLQI Duringthese experiments CTP Noe consistently delivered 999% ofthe data packets to the sinkThis result shows that CTP Noe with a properly-designedlow power hardware platform can be used in long lasting de-ployments: even with a moderately-rapid (for a low powernetwork) message interval of 240 seconds two AA batteries(5000 mAh) can supply sufficient energy to run a node formore than 400 days This result is significant because it con-siders the cost for running a full network stack consisting ofdissemination and CTP Noe protocolsCTP Noe’s low energy profile is possible because it se-lects efficient paths avoids unnecessary control traffic andactively monitors the topology using the the data plane Re-duction in control traffic is especially important in these net-works because broadcast packets must be transmitted withlong preambles CTP Noe’s ability to taper off that overheadusing exponentially increasing beacon interval allows it toachieve much lower energy consumption614 Testbed ObservationsThe most salient differentiating dynamics property thatwe found across the testbeds is churn On Motelab and Kan-sei the churn is higher than on other testbeds Analysis ofCTP Noe logs show that some sections of Motelab are verysparse and have only a few links with very low PRR Theselow-quality links are bursty such that nodes cycle throughtheir list of alternative parents and actively probe the networkin search of better parents These small number of nodes ac-count for most of the churn in the network—7% of the nodesaccounted for 76% of parent changes on Motelab This alsoexplains why most packet losses in Motelab are due to re-transmission timeoutsOn Tutornet and Kansei churn is more uniform acrossnodes but for different reasons When operating on an in-terfering channel Tutornet sees bursty links due to bursts of80211 interference causing nodes to change parents oftenOn a non-interfering channel CTP Noe has very low churn3Rincon Research maintains Blaze support code in theTinyOS 2x “external contributions” repositoryon Tutornet These bursts of interference cause nodes to beunable to deliver packets for periods of time causing queueoverflows to be the dominant cause of packet loss In Kanseithe high churn is due to the sheer degree of the network7 Related WorkThe mechanisms we describe in this paper draw on ourexperiences using collection layers such as MultihopLQI [2]and MintRoute [38] and the tradeoff they introduce be-tween cost and responsiveness CTP Noe’s forwarding timerborrows from work on reliable sensornet transport proto-cols [14 27 30 32] which seek to maximize throughput byenabling pipelining through transmission timingThese two mechanisms have been mentioned before inthe literature: the 6lowpan/IP stack by Hui at al uses bothTrickle-based beaconing and datapath validation [12] Thisnetworking stack was developed concurrently with CTPNoe: the two share ideas exchanged on mailing lists in 2005-7 Where Hui et al’s paper presented the two techniques assmall parts of a larger system evaluated on a single test-bed however this paper deeply evaluates them across awide range of link layers platforms workloads and envi-ronments as well as examine the additional low-level sys-tems issues that arise when incorporating them into a rout-ing layer The use of both techniques in two heavily testedrobust network layers provides greater evidence that theseprinciples are more general than our specific implementationof them in CTP NoeAt a high level adaptive beaconing and datapath vali-dation combine elements of proactive and reactive routingparadigms proactively maintaining (at low cost) a roughapproximation of the best routing gradient and making aneffort to improve the paths data traffic traverses CTP Noedraws on mesh routing work using ETX as its routing met-ric: this work established that minimizing either the expectednumber of transmissions (ETX [6]) or a bandwidth-awarefunction of the expected number of transmissions (ENT [8])along a path [38] constructs good routes While ETX doesnot effectively capture throughput – a limitation in IP meshes– its measurement is perfectly suited to low-power sen-sor networks which seek to minimize transmissions Wheremodern WiFi protocols such as ROMA [7] still strugglewith the discrepancy between periodic beacon measurementsand actual link behavior CTP Noe avoids this problem byusing the 4-bit link estimatorAdaptive beaconing extends Trickle [18] to time its rout-ing beacons Using Trickle enables quick discovery of newnodes and recovery from failures while at the same time en-abling long beacon intervals when the network is stable Thisapproximates beaconless routing [40] in stable and static net-works without sacrificing agility or new node discoveryA large body of sensor network protocol work examineshow to mitigate congestion when traffic concentrates aroundone node [3913263334] CTP Noe’s transmit timers (Sec-tion 69) prevent self-interference by a single transmitter butdo not coordinate transmitters CTP Noe provides an under-lying routing topology and leaves inter-node congestion tohigher or lower layers Finally we note Dozer [5] a propri-etary collection protocol running exclusively on Shockfishhardware whose source code we could not obtainLike IP routing layers CTP Noe does not provide end-to-end reliability In contrast RAP [20] attempts to deliver datato a sink within a time constraint or not at all a different setof requirements than is typical to packet routing HoweverRAP uses similar mechanisms as CTP Noe such as MACpriorities and queuing mechanisms RBC [39] attempts todelivers bursty sensornet data reliably using similar mecha-nisms as CTP Noe as well as block acknowledgments8 ExperiencesCTP Noe is the result of a four-year effort that startedin 2005 In 2005 despite the critical importance of a collec-tion layer in almost every sensor network deployment therewas no well-tested and efficient protocol that met the require-ments described in Section 1 Different research group im-plemented their own collection protocol or noted ways inwhich existing protocol implementations were insufficientAs we began looking into the problem we noted funda-mental limitations in existing approaches For example thesampling bias of physical layer measurements (eg RSSIor LQI) can lead to inaccurate link estimates while peri-odic beacons can lead to poor link choices when links arebursty [29]Our measurement studies also exposed how much envi-ronmental conditions can vary Table 1 shows the tremen-dous variation across just indoor testbeds A protocol testedin one environment may not work in another For exam-ple while MultihopLQI performs reasonably well in Mi-rage in Tutornet its performance is not consistent over timedue to the high exposure to time-varying interference from80211b/g networks in the building Because CTP Noe’s de-sign and testing was spread across institutions each contrib-utor typically had a local testbed whose results differed fromothers Based on these experiences we believe that testingand debugging protocols across multiple testbeds is criticalfor experimental evidenceFrom a system implementation standpoint the most im-portant decision we made in CTP Noe’s design was includinga detailed logging layer This layer reports every major event(parent change data packet reception transmissions etc) tothe serial port Using these logs transformed a guessing gameof the causes of packet failures to a simple science of log in-spection where we could track the progress of every packetin the network4 These detailed logs for example enabled usto find a memory leak in the forwarding path where packetdrops would slowly reduce the size of the forwarding poolOver the last four years we have seen CTP Noe de-ployed in a wide variety of applications and configurationssome unexpected and unintended One of the CTP Noe de-ployments by Rincon uses an intermittently connected sinkAlthough we designed CTP Noe for low data rate regimeand most of its deployments are in that area researchershave tried to use CTP Noe on higher data rate applicationssometimes successfully [15] and sometimes with additionalmechanisms for flow control [4] These experiences suggest4http://singstanfordedu/gnawali/ctp/ links to a sub-set of the experiment logs from this effortthat despite claims that collection is a solved problem asignificant gap between single experiments and general per-formance remains: making protocols robust across environ-ments is an open and critical research challengeWe hope CTP Noe serves as a demonstration of the im-portance of serious engineering and deployment effort inwireless protocol research; it was only with the engineeringand deployment effort by the wider TinyOS community thatwe were able to uncover explore the performance issues andthus research adaptive beaconing and datapath validation9 ConclusionsThis paper describes two routing mechanisms adaptivebeaconing and datapath validation These mechanisms al-low a collection protocol to remain efficient robust and re-liable in the presence of a highly dynamic link topologyOur implementation of these mechanisms CTP Noe offers90-999% packet delivery in highly dynamic environmentswhile sending up to 73% fewer control packets than existingapproaches It is highly robust to topology changes and fail-ures It makes minimal assumptions on the physical and linklayer allowing it to run on a wide range of platforms with-out any need for fine-tuning parameters Minimizing controltraffic combined with efficient route selection allows CTPNoe to achieve duty cycles of < 3% while supporting aggre-gate loads of 25 packets/minuteThe efficacy of these two techniques suggests that thelimitations of many wireless protocols today may be ad-dressed by judiciously integrating the data and controlplanes This indicates a way in which wireless protocolsare fundamentally different than their wired siblings Whilethese techniques are presented in the context of collection anopen question worthy of future work is whether they are gen-eral to distance vector algorithms and so may have broaderapplicability in ad-hoc networkingAcknowledgmentsWe thank Alec Woo Sukun Kim and the TinyOS 2xNetwork Protocol Working Group for early design discus-sions We thank the maintainers of testbeds used in this studyfor their contribution of critical research tools to the commu-nity Finally we thank the TinyOS community for filing bugreports and trusting our code in their deploymentsThis work was supported by generous gifts from Mi-crosoft Research Intel Research DoCoMo Capital Foun-dation Capital and the National Science Foundation undergrants #0627126 #0846014 #0121778 and #052023510 References[1] Texas Instruments CC1100 Data Sheet http://focusticom/lit/ds/symlink/cc1100pdf 2003[2] The MultiHopLQI protocol http://wwwtinyosnet/tinyos-2x/tos/lib/net/lqi 2009[3] G-S Ahn E Miluzzo A Campbell S Hong and F CuomoFunneling MAC: A Localized Sink-Oriented MAC for Boost-ing Fidelity in Sensor Networks In Proc of the ACM SenSysConf pages 293–306 Boulder CO Nov 2006[4] M Bathula M Ramezanali I Pradhan N Patel J Gotschalland N Sridhar A sensor network system for measur-ing traffic in short-term construction work zones In Procof DCOSS ’09 pages 216–230 Berlin Heidelberg 2009Springer-Verlag[5] N Burri P von Rickenbach and R Wattenhofer Dozer:ultra-low power data gathering in sensor networks In Procof the IPSN Conf pages 450–459 New York NY 2007[6] D S J D Couto D Aguayo J Bicket and R Morris AHigh-Throughput Path Metric for Multi-Hop Wireless Rout-ing In Proc of the ACM MobiCom Conf San Diego CASept 2003[7] A Dhananjay H Zhang J Li and L Subramanian PracticalDistributed Channel Assignment and Routing in Dual-radioMesh Networks In Proc of the ACM SIGCOMM Conf Aug2009[8] R Draves J Padhye and B Zill Comparison of routing met-rics for static multi-hop wireless networks In Proc of theACM SIGCOMM Conf pages 133–144 Portland OR Aug2004[9] C T Ee and R Bajcsy Congestion control and fairness formany-to-one routing in sensor networks In Proc of the ACMSenSys Conf pages 148–161 Baltimore MD Nov 2004[10] R Fonseca O Gnawali K Jamieson S Kim P Levis andA Woo TEP 123: The Collection Tree Protocol Aug 2006[11] R Fonseca O Gnawali K Jamieson and P Levis Four BitWireless Link Estimation In Hotnets-VI Atlanta GA Nov2007[12] J W Hui and D E Culler IP is dead long live IP for wirelesssensor networks In Proc of the SenSys Conf pages 15–28New York NY 2008[13] B Hull K Jamieson and H Balakrishnan Mitigating con-gestion in wireless sensor networks In Proc of the ACM Sen-Sys Conf pages 134–147 Baltimore MD Nov 2004[14] S Kim R Fonseca P Dutta A Tavakoli D Culler P LevisS Shenker and I Stoica Flush: a reliable bulk transport pro-tocol for multihop wireless networks In Proc of the ACMSenSys Conf pages 351–365 ACM 2007[15] J Ko T Gao and A Terzis Empirical Study of a MedicalSensor Application in an Urban Emergency Department InBodyNets ’09: 4th Intl Conference on Body Area Networks[16] K Langendoen A Baggio and O Visser Murphy loves pota-toes: Experiences from a pilot sensor network deploymentin precision agriculture In 14th Int Workshop on Paralleland Distributed Real-Time Systems (WPDRTS) pages 1–8apr 2006[17] P Levis N Lee M Welsh and D Culler TOSSIM: Simu-lating large wireless sensor networks of tinyos motes pages126–137 Los Angeles CA Nov 2003[18] P Levis N Patel D Culler and S Shenker Trickle: A self-regulating algorithm for code maintenance and propagationin wireless sensor networks In Proc of the USENIX NSDIConf San Francisco CA Mar 2004[19] J Li C Blake D S D Couto H I Lee and R Morris Ca-pacity of Ad Hoc wireless networks In Proc of MobiCompages 61–69 ACM 2001[20] C Lu B M Blum T F Abdelzaher J A Stankovic andT He RAP: A Real-Time Communication Architecture forLarge-Scale Wireless Sensor Networks In Proc of the IEEERTAS Symposium San Jose CA September 2002[21] A Mainwaring J Polastre R Szewczyk D Culler andJ Anderson Wireless Sensor Networks for Habitat Moni-toring In Proceedings of the ACM International Workshopon Wireless Sensor Networks and Applications Sept 2002[22] R Musaloiu-E C-J Liang and A Terzis Koala: Ultra-lowpower data retrieval in wireless sensor networks In Procof the International Conference on Information Processing inSensor Networks (IPSN 2008) 2008[23] D Pei X Zhao D Massey and L Zhang A study of bgp pathvector route looping behavior In ICDCS ’04: Proceedings ofthe 24th International Conference on Distributed ComputingSystems (ICDCS’04) pages 720–729 Washington DC USA2004 IEEE Computer Society[24] C Perkins and P Bhagwat Highly Dynamic Destination-Sequenced Distance-Vector Routing (DSDV) for MobileComputers Computer Comm Review October 1994[25] J Polastre J Hill and D Culler Versatile low power mediaaccess for wireless sensor networks In Proc of the ACMSenSys Conf pages 95–107 Baltimore MD Nov 2004[26] S Rangwala R Gummadi R Govindan and K PsounisInterference-aware fair rate control in wireless sensor net-works In Proc of the ACM SIGCOMM Conf pages 63–74Pisa Italy Aug 2006[27] Y Sankarasubramaniam O¨zgu¨r Akan and I Akyildiz ESRT:Event-to-Sink Reliable Transport in Wireless Sensor Net-works In Proc of the ACM Mobihoc Conf pages 177–189Annapolis MD June 2003[28] T Schoellhammer B Greenstein and D Estrin Hyper: Arouting protocol to support mobile users of sensor networksTechnical Report 2013 CENS 2006[29] K Srinivasan M Kazandjieva S Agarwal and P Levis Thebeta-factor: Measuring wireless link burstiness In Proceed-ings of the 6th ACM Conference on Embedded NetworkedSensor Systems (SenSys) 2008[30] F Stann and J Heidemann RMST: Reliable Data Transportin Sensor Networks In Proc of the IEEE SNPA Workshoppages 102–112 Anchorage AK May 2003[31] G Tolle J Polastre R Szewczyk D E Culler N TurnerK Tu S Burgess T Dawson P Buonadonna D Gay andW Hong A macroscope in the redwoods In Proc of theACM SenSys Conf pages 51–63 San Diego CA Nov 2005[32] C-Y Wan A Campbell and L Krishnamurthy PSFQ: aReliable Transport Protocol for Wireless Sensor Networks InProc of the ACM WSNA Workshop pages 1–11 Atlanta GA2002[33] C-Y Wan S Eisenman and A Campbell CODA: Conges-tion Detection and Avoidance in Sensor Networks In ProcACM SenSys pages 266–279 Nov 2003[34] C Y Wan S Eisenman A Campbell and J CrowcroftSiphon: Overload Traffic Management using Multi-Radio Vir-tual Sinks In Proc of the ACM SenSys Conf pages 116–129San Diego CA Nov 2005[35] G Werner-Allen S Dawson-Haggerty and M Welsh Lance:Optimizing High-Resolution Data Collection in Wireless Sen-sor Networks In Proc of the ACM SenSys Conf Nov 2008[36] G Werner-Allen K Lorincz J Johnson J Lees andM Welsh Fidelity and Yield in a Volcano Monitoring Sen-sor Network In USENIX Symposium on Operating SystemsDesign and Implementation Seattle WA Nov 2006[37] A Woo and D E Culler A transmission control schemefor media access in sensor networks In Proceedings of theseventh annual international conference on Mobile comput-ing and networking Rome Italy July 2001[38] A Woo T Tong and D Culler Taming the underlyingchallenges of reliable multihop routing in sensor networksIn Proc ACM SenSys pages 14–27 Los Angeles CA Nov2003[39] H Zhang A Arora Y R Choi and M Gouda Reliablebursty convergecast in wireless sensor networks ComputerCommunications 30(13):2560–2576 Dec 2007[40] H Zhang A Arora and P Sinha Learn on the fly: Data-driven link estimation and routing in sensor network back-bones In Proc IEEE INFOCOM Barcelona Spain Apr2006
CTP-SenSys2009-pdf,Collection Tree ProtocolOmprakash Gnawali (Stanford University)     withRodrigo Fonseca (Brown University)Kyle Jamieson (University College London)David Moss (People Power Company)Philip Levis (Stanford University)ACM SenSysNovember 4 2009Collection• Anycast route to the sink(s)sink       – Used to collect data from the network to a small number of           sinks (roots base stations)– Network primitive for other       protocols• A distance vector protocol     2Common Architecture R A li iControl Plane Data Planeouter pp cat onFwdTableForwarderLink EstimatorLink Layer3Prior Work Control Plane Data PlaneETX MT Flush RMST   MultiHopLQI EAR LOF AODV DSR BGP RIP OSPF   CODA Fusion IFRC RCRT     BabelLink Layer4Wireless Link Dynamics   0 91s5Control and Data Rate Mismatch       • Can lead to poor performance       Control Plane Data Planek /b / 10 p t s1  eacon 30sLink Layer6Control and Data Rate Mismatch       • Can lead to poor performance       b /Control Plane Data Planek /1  eacon s 10 p t sLink Layer7CTP Noe R A li iControl Plane Data Planeouter pp cat onForwarderLink EstimatorLink Layer8CTP Noe’s Approach   • Enable control and data       plane interaction• Two mechanisms forControlPlDataPlane     efficient and agile topology maintenanceane– Datapath validationAd i b i– apt ve  eacon ng9Summary of Results   • 90‐99 9% delivery ratio    – Testbeds configurations link layers• Compared to MultihopLQI   – 29% lower data delivery cost– 73% fewer routing beacons– 998% lower loop detection latency• Robust against disruption• Cause for packet loss vary across testbeds10Outline• Collection• Datapath validationd i b• A apt ve  eacons• Evaluation• Conclusion11Datapath validation • Use data packets to validate the topology           – InconsistenciesLoops–• Receiver checks for consistency on each hop– Transmitter’s cost is in the header• Same time‐scale as data packets– Validate only when necessary12Routing Loops – Cost does not     decrease32CB 46D A6 31358Routing Loops – Cost does not X     decrease81CB 46D A6 31458Routing Consistency • Next hop should be closer to the destination           • Maintain this consistency criteria on a path• Inconsistency due to stale stateni ni+1 nk       15Detecting Routing Loops   • Datapath validationX– Cost in the packet– Receiver checksC 818181 < 46?• Inconsistency– Larger cost than on the packet 46<58?   • On Inconsistency– Don’t drop the packets B 4646– Signal the control plane6358 < 81?16D A635858Outline• Collection• Datapath validationd i b• A apt ve  eacons• Evaluations• Conclusion17How Fast to Send Beacons?       • Using a fixed rate beacon interval         – Can be too fastCan be too slow–      – Agility‐efficiency tradeoffA il Effi i t ibl ?• g e+ c en  poss e18Routing as Consistency   • Routing as a consistency problem       – Costs along a path must be consistent• Use consistency protocol in routing       – Leverage research on consistency protocols– Trickle19Trickle• Detecting inconsistency – Code propagation: Version number mismatchDoes not work for routing: use path consistency–              • Control propagation rate– Start with a small interval– Double the interval up to some max– Reset to the small interval when inconsistent20Control Traffic Timing   • Extend Trickle to time routing beacons         • Reset the interval• ETX(receiver) > ETX(sender)  =   • Significant decrease in gradient• “Pull” bit TXIncreasing interval      Reset interval21Adaptive Beacon Timing   ~ 8 minInfrequent beacons in the long runTutornet22         Adaptive vs Periodic Beacons     de187b /ons / nod eacon sal beaco065beacon/sTotaTime (mins)Less overhead compared to 30s‐periodicTutornet23       Node Discovery A new node introducedsotal BeaconsP th t bli h dT o a  es a s e  in < 1sTime (mins)Tutornet24Efficient and agile at the same timeOutline• Collection• Datapath validationd i b• A apt ve  eacons• Evaluation• Conclusion25Experiments• 12 testbeds • 20‐310 nodesh d• 7  ar wareplatforms• 4 radiotechnologies• 6 link layersVariations in hardware software RF environment and topology26             Evaluation Goals • Reliable?– Packets delivered to the sink• Efficient?– TX required per packet delivery• Robust?– Performance with disruption27CTP Noe Trees   Kansei TwistMirage28Reliable Efficient and Robust     Testbed Delivery RatioWymanpark 09999Vinelab 09999Tutornet 09999NetEye 09999Kansei 09998Mirage‐MicaZ 09998Quanto 0 9995  Blaze  09990Twist‐Tmote  09929Mirage‐Mica2dot  09895 False ackTwist‐eyesIFXv2  09836Motelab  09607 Retransmit29High end‐to‐end delivery ratio(but not on all the testbeds!)Reliable Efficient and Robust     098st / pktivery coDelTutornet5       10     15     20     25     30     35Time (hrs)30High delivery ratio across time(short experiments can be misleading!)Reliable Efficient and Robust     Tutornet CTP Noe31Low data and control costReliable Efficient and Robust     081cle0406Duty‐cyc002CSMA BoX‐1s LPP‐500msD0028 0066Link LayerMotelab 1pkt/5min32Low duty‐cycle with low‐power MACsReliable Efficient and Robust     Ratio10 out of 56 nodesDelivery removed at t=60 minsDTime (mins)Tutornet33No disruption in packet deliveryReliable Efficient and RobustNodes reboot every 5 mins     Routing Beacons5 i~   m nDelivery Ratio > 099Tutornet34High delivery ratio despite serious network‐wide disruption(most loss due to reboot while buffering packet)CTP Noe Performance Summary     • Reliability– Delivery ratio > 90% in all cases• Efficiency– Low cost and 5% duty cycle• Robustness– Functional despite network disruptions35AcknowledgmentFor testbed access and experiment help• Mukundan Sridharan• Matt Welsh • Anish Arora• Geoffrey Werner Challen• Prabal Dutta• Kamin Whitehouse• Hongwei Zhang• David Gay• Stephen Dawson‐Haggerty• Timothy HnatFor bug reports fixes and discussions• Mehmet Akif Antepli• Ki‐Young Jang• Xi Ju• Andreas KöpkeR M l i E• Juan Batiz‐Benet• Jonathan Hui• Scott Moeller• azvan usa o u‐ • Vinayak Naik• Rajiv Ramnath• Remi Ville• Alec Woo• and many others…h k !36T an  YouConclusion• “Hard” networks→ good protocols       – Tutornet & Motelab• Wireless routing benefits from data and           control plane interaction• Lessons applicable to distance vector routing– Datapath validation & adaptive beaconingData trace from all the testbeds available athttp://singstanfordedu/gnawali/ctp/37
Denial of sleep attack-pdf,Proceedings of the 2005 IEEE Workshop on Information Assurance and Security United States Military Academy West Point NY Wireless Sensor Network Denial of Sleep Attack Michael Brownfield Member IEEE Yatharth Gupta Member lEEE and Nathaniel Davis IV Senior Member IEEE Abstract - With the progression of compurer networks extending boundaries and joining distant locations wireless sensor networks (WSN) emerge as the new frontier in  developing opportunities fo collect and process data from remote locations Like IEEE 8023 wired and IEEE 80211 wireless netwurks remofe wireless sensor networks are vulnerable to malicious attacks While wired and infrastructure-based wireless networks huve mature intrusion detection systems and sophisticated firewalls to block these attacks wireless sensor networks have only primitive defenses WSNs rely on hardware simplici@ to make sensor jield deployments both affordable and long-lasting without any maintenance supporl Energy-constrained sensor networks periodically place nodes to sleep in order to extend the network IiJetime Denying sleep effectively attacks each sensor node's crin'cal energy resources and rapidly drains the network's lifetime This paper anabzes the energy resource vulnerabilities of wireless sensor networks models the network lifetimes of leading WSN medium access control (MAC) protocols and proposes a new MAC protocol which mitigates many of the effects of denial of sleep attacks Index terms -Wireless Security Sensor Network Energy Efficiency Medium Access Control (MAC) I INTRODUCTION The progressive nature of the Information Age creates increasing demands for processed data and the consistent hlfillment of Moore's Law produces smaller hardware devices with improved capabilities to gather and process new data As world business becomes more mobile and computational applications become widely distributed wireless networks bridge the gap by making distance and movement seamless Wireless networks require innovative medium access techniques to share the limited broadcast bandwidth in a fair and efficient manner as computing and communications devices continue to proliferate Wireless sensor networks (WSN) offer the ability for applications to remotely monitor and react to events but their remoteness also introduces challenges and vulnerabilities for network control and energy consumption This paper analyzes the security Michael Brownfield is a PhD candidate Yatharth is senior undergraduate student and Nat Davis is a Professor in the Bradley Depnrtment of Electrical and Computer Engineering at Virginia Polytechnic Institute and Siate University Email: {brownjld yatharth ndavis)@vtedu vulnerabilities of a denial of sleep attack against three leading energy-efficient sensor medium access control (MAC) protocols and proposes a new WSN MAC protocol which dramatically mitigates its effects In an effort to make inexpensive sensor platforms ubiquitous these platfoms have limited processor capability memory capacity and battery life Small system platforms which integrate sensors processors and transceivers are referred to as motes Table I illustrates the power and memory limitations of four leading motes The first mote Smartdust is the result of a UC BerkeleyiDARPA research project which designed and built a lmm3 WSN platform [l] This device represents the extreme limit for WSN resource constraints The 60kB and I2XkB EEPROMs on the other three motes also significantly limit the code size available for sophisticated protocols Developers implement sensor protocols in NesC a structural component-based programming language and link it to the hardware through a open- source operating system called TinyOS As technology advances the wireless sensor trend will continue building physically smaller and more energy-efficient platforms Table 1 Mote Microcontroller/Transceiver Platform Specifications I Platform I Smartdust I Mica2 121 I TelosA-r31 1 I Micro- 8-bit 1 16-bit I 16-bitTI 1 MSP430 controller ATMega EEPROM 5 128 128k3 60kB Radio 9 16MHz 868MHz 24GHz I 1 CClOOO [4] I CC2420 Data Rate 1 IOkbps I 768kbs r 250kbs Besides the classical denial of service attacks that plague the IEEE 8023 wired and IEEE 8021 1 wireless networks WSN networks have a unique vulnerability due to their fixed energy capacity upon deployment The mote systems generally operate on two AA batteries (30 volts) with an approximate 3000mAh energy capacity Malicious attackers can easily target the battery supplies and reduce network lifetimes from years to days Achieving a secure system requires security integration into every component to prevent a vulnerable point of attack [5][6] WSN designers must incorporate the protection of the critical energy resource into the system architectures 0-7803-9290-6/051$2000 82005 IEEE 356 Proceedings of the 2005 IEEE Workshop on Information Assurance and Security Unitcd States Military Academy West Point NY 11 RELATED WORK Most security research focuses on protecting confidentiality data integrity and service availability These protective measures are mature in wired and infrastructure-based wireless networks and continue to strengthen in response to increasingly smarter attacks Confidentiality protects against the improper disclosure of information; data integrity protects the information against improper modifications; and service availability prevents denial of system services The WSN denia1 of sleep attack is a subset of the denial of service class of network attacks Stajano and Anderson [7] first mention denial of sleep attacks in 1999 as “sleep deprivation torture” Energy-limited system designers often incorporate power management mechanisms to monitor active processes and power down non-essential subsystems when feasible A denial of sleep attack penetrates a device’s power management system to reduce the opportunities to transition into Iowcr power states Stajano and Anderson proposed either charging for service access or requiring users to perform a resource intensive function such as solving a puzzle in order to gain access Since then many researchers have studied the effects of battery intrusion for a variety of mobile devices laptops personal data assistants (PDA) and wireless sensor networks In analyzing battery attacks against PDAs Martin et al [8] divide sleep deprivation into three categories: service request power attacks benign power attacks and malignant power attacks A service requast power attack repeats valid service requests with the deliberate intention of draining power; a benign service attack initiates a power intensive operation on the device under attack (DUA) to quickly drain power resources; and a malignant power attack penetrates the DUA and alters existing programs to consume more power than required To counter these attacks Martin er al propose a system architecture which provides multi-layer authentication and energy signature monitoring The multi-layer authentication technique requires authentication for service requests accessing crippling cnergy level processes ones that cause the DUA’s lifetime to fall short of a target An energy signature monitor polls cnergy monitoring units throughout the device and reports energy patterns Upon detecting a suspected intrusion the energy signature monitor compares the energy signatures in a database using either statistical- or mles-based anomaly algorithms [9][ 103 These comparisons are feasible for a PDA platform which has the resources to store and analyze signatures However WSNs require simpler solutions to the same security challenges due to limited processing capability memory storage and energy capacity Additionally many attacks against PDAs may be caught by monitoring power variables and expected bounds of consumption but in heterogeneous WSN 0-7803-9290-6/05/%2000 02005 IEEE 357 networks some sensors report routinely while others trigger only upon the occurrence of environmental events The exposed wireless medium provides attackers with the ability to access a network without physically tapping into the system Friendly traffic flows beyond intended boundaries allowing malicious attackers to obtain information from the packets and reuse i t  against the network Additionally the wireless nature allows them to penetrate the boundaries to launch denial of service attacks or attempt to access confidential information Placed in remote areas sensor networks are even more vulnerable to attack than the wireless infrastruchre networks due to the inability to provide any physical security in protecting the nctwork WSN defenses against denial of sleep attacks involve protecting the power management mechanisms at the architectural level Since the transceiver on the WSN platform consumes the most energy and is the primary source for power management savings defensive strategies implemented at the network link or MAC layer are the most effective in protecting radio usage [61[I 111 121 Two direct link layer attacks which impact a WSN node’s energy supply are link layer collision and link laycr exhaustion [ 6 ]   A collision attack against the link layer like jamming in the physical layer occurs when an attacker sends a signal at the same time and frcquency as a legitimate message for as little as one octet (or byte) in a transmission to corrupt the entire packet [ I  L] Physical layer jamming countemeasures include frequency- hopping or code division multiple access spread spectrum techniques [13][14] Once the attacker determines the hoppingichipping frequency or incrcases the jamming power level to achieve a sufficicnt signal-to-noise ratio the transmissions begin to collide with the network traffic I f  a link layer frame fails a cyclic redundancy code (CRC) check the link layer automatically discards the entire packet In addition to  wasted bandwidth and sleep opportunities this attack consumes critical energy for both the sender and receiver in subsequent retransmissions One approach to counter the collision effects is to use forward error-correcting codes (FEC) to recover lost information [ 6 ]   Again the attacker can counter this defense by extending the duration of thc jamming signal to corrupt more bits to overcome the coding gain of the FEC A link layer exhauslion attack occurs when an attacker manipulates protocol efficiency measures and causes nodes to expend additional energy For example an attacking node in an IEEE 802 I 1-based network could repeatedIy send request-to-send messages (RTS) and force the node listed in the RTS destination field to respond with a clear-to-send (CTS) message and remain awake waiting for the follow-on message [ I  I ]   A suggested defense against this type of exhaustion is to Proceedings of the 2005 IEEE Workshop on Information Assurance and Security United States Military Academy West Point NY encrypt the control messagcs [ 141 or provide rate limiting ability to perform 128-bit AES hardware encryption on by allowing nodes to ignore excessive network requests the radio platform 1171 AES is a Federal lnforrnation from a node Rate limiting can easily be overcome by a Processing Standard (FIPS) which uses a cryptographic distributed denial of scrvice attack (DDoS) or an attacker algorithm to protect electronic data by implementing a who can iterate through many source identities in the symmetric block cipher to encrypt and decrypt anonymous wireless environment information [ 161 The Chipcon CC2420 [4J radio with integrated AES offers four security modes: 1 Disabled 111 WSN SECURITY COMPONENTS Authentication and encryption solutions for the resource- constrained WSN cannot achieve the same protection levels as wired and wireless infrastmcture-based networks Securing communications in WSNs entails a secure group approach in order to support nodes communicating with one another while performing in- network processing and aggregation necessitated by wireless bandwidth ljmitaljons [ 5 ]   Additionally individual node’s limited key storage capacity prevents the use of per-Iink encryption strategies This section introduces three leading software and hardware tools to maintain group security and performance for WSNs TinySec is a software-based link layer security architecture which provides the basic necessities in network security authentication and encryption [ 151 The network link layer is the logical choice for implementing these security components in sensor networks since the sensor traffic tends to involve either source-to-sink or broadcast traffic (one-to-many) not end-to-end [one-to-one) traffic like traditional networks TinySec is a module which works with the TinyOS operating system The design goals are to provide link layer security measures to protect access control message integrity and message confidentiality without significantly impacting the energy and throughput of the network TinySec pairs a two-byte counter and source field with tbe traditional TinyOS packet header fieids (destination active mode length) to develop an initialization vector (IV) Since the IV uses integral header fields the encryption mechanism minimizes control overhead TinySec then combines the 8-byte IV with a cyclic block code {CBC) Skipjack to attain reasonable security without a computationally complex algorithm Experiments using Advanced Encryption Standard (AES) proved to be too slow without hardware acceleration Additionally TinySec replaces the medium access control frame’s CRC field with the message authentication code to maintain the 8-byte security control overhead To allow the sensor application the ability to tradeoff security to reduce computation and communication overhead Tiny Sec provides the ability to operate in three modes: open authentication (TinySec- Auth) and authentication-encqption (TinySec-AE) Offering 3 hardware altemative to TinySec’s software components IEEE 802154 compliant radios have the 2 Cipher block chaining (CBC-MAC) authentication 3 Counter (CTR) encryption I decryption 4 Counter with Cipher Block Chaining- Message Authentication Code (CCM) authentication and encryption / decryption As with TinySec the integrated 802154 security mechanism provides message integrity and confidentiality Incorporating these algorithms using hardware and software routines located directly on the radio releases the processor’s limited memory and processing capacity to handle other operations Security Protocols for Sensor Networks (SPINS) is a software security protocol suite developed by Perrig et al at UC Berkeley for use in extremely resource- limited networks like the Smartdust lmm3 device 1181 With only %bytes of packet overhead the secure network encryption protocol (SNEP) provides data confidentiality two-party data authentication and evidence of data freshness Another SPINS suite component pTESLA authenticates broadcast messages for resource-constrained networks Although true authenticated broadcasts require asymmetric cryptographic mechanisms pTESLA uses a resource-friendly symmetric mechanism but interjects asymmetry through a delayed disclosure of symmetric keys Security issues that SPINS does not address include denial of service attacks and compromised nodes A significant limitation to this security system for dynamic WSNs is the requirement to have a base station with additional memory and energy resources and a static network topology The security offered by the current software and hardware implementations is insufficient to protect a WSN from a denial of sleep attack The three basics options are to encrypt the data and the header encrypt the data or provide no encryption Denial of sleep attacks force a sensor platform to stay awake and receive a transmitted packet If the complete packet is encrypted the sensor node must receive the entire packet decrypt the header and then determine if it is the intended receiver The data-only encryption mode allows the node to view the header as it arrives but the node will not be able to authenticate the sender until the packet data is decrypted In this case if the attacker is able to provide a legitimate source and destination the receiver will stay awake to accept the entire packet The link layer wilt then discard 0-7803-9290-6/05~$2000 2005 IEEE 358 Proceedings of the 2005 IEEE Workshop on lnformation Assurance and Security United States Military Academy West Point NY any packets which fait the message authentication code of energy receiving the packet and i t  will pass the methods exist to reduce message overhearing: early check The unencrypted mode expends the same amount CI RTS Fragment Fragment DjF nU SIF c-- incoming message up to the network layer recaifeer IV LINK LAY ER i MAC SOURCES OF ENERGY Loss Current methods in securing wireless sensor networks address the confidentiality and integrity of the data in the network Due to their limited cnergy resources WSNs remain extremely vulnerable to denial of service attacks by the draining of their most critical resource - their energy supply Understanding both normal and malicious sources of cnergy loss is essential in designing a power control system Typical sources of energy loss and thus vulnerabilities in WSNs include: frame collisions message overhearing and idle listening Frame Collisions: A framc callision occurs when a wireless sensor node sends a MAC protocol frame or message which collides or overlaps in time with another rncssage If the interfering signal strength is high enough the data is corrupted at the receiving end In most single-channel radios the radio cannot simultaneously receive while in transmit modc Therefore the message sender’s only indication of a collision is the failure of the receivcr to retum an acknowledgement (ACK) for the message Frame collisions OCCUT naturally in wireless networks due to the cxtensions of space and time in distributed radio networks Finite radio receive-to-transmit transition times (the capture effect) ranging from 2 5 0 ~ s  to 5 0 0 ~ s  after sensing a clear channel propagation delays betwcen distant stations and hiddcn nodes which are out of range of the sender but within range of the receiver are the leading causes for wireless frame collisions Resending messages causes both the sending and receiving nodc to expcnd additional energy Protocol designers reduce frame collisions by cmploying contention-free scheduling protocols or contention-based backoff algorithms to minimize the probability of collisions TypicalIy link layer parameter settings permit a limited number of retransmissions before discarding a messagc Building on the collision discussion in Section 11 attackers may take advantage of this vulnerability by successively jamming small portions of a message transmission This attack not anIy denies message exchanges but also drains network energy from the additional transmissions Message Overhearing: Receiving and discarding messages intended for othcr nodes or message overheuring is commonly employed in non-energy constrained networks to incrcase throughput and decreasc latency Message overhearing i s  costly in WSNs since it causes all of the nodes to expcnd energy rccejving a message intended for just one node Two cnergy-efficient nsgnborr NAV (RTS) 1 I NAV (CTS1 Fig 1 Message Passing Overhearing Avoidance Strategy rejection and message passing Early rejection allows a sensor node to tum off its radio once it has read the destination field for an incoming unicast message or the group id for a broadcast message [ 151 Message passing shown in Fig I allows nodes to schedule a sleep period during the overheard RTS-CTS handshake sequence by noting the message duration field and scheduling a network alhcation vector (NAV) table interrupt [20][2 11 An  attacker could exploit message passing by broadcasting multiple RTS requests or CTS responses to keep nodes from transmitting and receiving network data This attack denies network access and can increase network lifetime by continuously sending nodes to sleep Idle Listening: Non-energy constrained wireless network interface devices continuously monitor the medium for incoming transmissions Idle listening occurs when a device listens to an inactive medium Since many wireless sensor radios consume more energy during idle listening than during transmissions energy-efficient WSN MAC protocols attempt to synchronize network traffic so that transmissions begin only in predetermined time slots Once all network transmissions are complete for a particular cycle or timeframe the protocoIs allow nodes to retum to sleep until the next transmission period To launch a denial of sleep attack attackers can determine the transmission and sleep rhythm and then concentrate the attack at the end of the active period to force nodes to remain awake beyond the nomial traffic requirements V CONTENTION-3ASED SENSOR MAC PROTOCOLS WSN designers strive to extend network lifetimes while meeting application-specific throughput and latency requirements They achieve these savings by minimizing thc opportunities of frame collision$ message overhearing and idle listening The most significant method to extend network lifetime is synchronizing nodes to actively pass data and then sleep as much as possible Fig 2 shows that the CC2420 radio consumes up to 197mA in the receive mode but only luA in power off mode With two 3000mAh AA batteries the difference in lifetime of a fully active platform (20lmA) and a sleeping platform (24pA) is 62 days vs 143 years (or battery shelf life) Measurements on the CC2420 radio in the Telos A platform indicate a 047Oms power off sleep transition and a 65ms recovery time Effective power 0-7803-9290-6/05/$2000 02005 IEEE 359 Proceedings of the 2005 lEEE Workshop on Information Assurance and Security United States Military Academy West Point NY management places nodes into the various power- saving modes based upon the duration of the sleep period and can extend the lifetime of a network by two to three orders of magnitude Even with power management tools in place unless a MAC protocol can create opportunities to sleep for long durations the platform cannot achieve extended network lifetimes This section presents an overview of the energy-efficiency strategies for three leading WSN contention-based MAC protocols and introduces a new energy-efficient protocol Rad10  P l a t f m  Fig 2 Radio Energy Modes and Platform Energy Allocations 13H41 A   Sensor MAC (S-MAC S-MAC [2  13 represents the baseline energy-efficient sensor MAC protocol designed to extend WSN network lifetime S-MAC divides a time frame into listening and sleeping periods Fig 3 shows that the listen period is further divided into a synchronization period and data transfer period The synchronization period allows nodes to periodically announce their slcep schedules to correct network time drift and synchronize their sleep times to form virtual clusters of nodes with the same active listen and sleep periods By creating a 10% active duty cycle (D) node lifetimes can be significantly extended with bounded throughput and latency tradeoffs Sensors that border two synchronized clusters have the option of choosing one or the union of both sleep schedules The two nodes at the bottom of Fig 3 illustrate the effect of having nodes whose sleep schedules do not completely overlap I f  node 1 attempts to transmit to node 2 late in node 1’s listening period node 2 is already in sleep mode and will not be able to receive the message Creating a inflexible in rcsponding to network traffic fluctuations or network scaling On the other hand thc fixed sleep cycle +Listen Period‘ Node 1 I Listen I Sleep I Node 2 1 Listen I S  leep 1 Listen1 Fig 3 S-MAC Frame architecture protects the network lifetime from the denial of sleep attacks by ensuring that nodes are only vulnerable during a fixed listening period S-MAC is most vulnerable to a broadcast attack in which an attacker sends multiple broadcast messages to keep all nodes active and receiving throughout the entire listening period Let Tframc = Tlirtcn -i-Talecp and D = Tlstcn/Tramc (duty cycle D = 10%) Since an attacker can broadcast a message to the entire network simultaneously S-MAC’S maximum network lifetime from a broadcast attack is: S-MAC is also vulnerable to unicast attacks with back-to- back RTS messages but the attack effects are limited to draining energy from one node at a time while denying all other node’s network access B Timeout MAC (T-MAC) Timeout MAC (T-MAC) [22] is also an energy-efficient MAC protocol designed to maximize sleep opportunities and builds on the successes of S-MAC T-MAC obtains additional sleep time at the expense of increased throughput and latency T-MAC adopts all of S-MAC’S sleep methods (virtual clustering and message passing) and improves on the idle listening overhead by dynamically adapting the active listening period in response to network traffic T-MAC permits nodes to sleep as soon as all network traffic has completed As shown in Fig 4 the end of traffic is signaled by nodes monitoring an idle channel for an adaptive timeout (TA) period which represents the longest period in which a hidden node would have to wait before hearing the first bit of a CTS message n m m a i T  1 T i 1 1  T T 1 T T  slotted starting time for all network traffic and concentrating the traffic into a smaller time frame reduces idle listening trading off latency and throughput To minimize collisions nodes use the IEEE 8021 1 standard Furthermore S-MAC also reduces energy consumption using the message passing techniques discussed in -contention backoff for all channel access attempts TMC Ti’ -- Tlf TTlr“ Section IV for overhearing avoidance SM*C Tl 1 111 T T l T  T S-MAC’S sleep cycle is fixed at the time of network deployment This limitation causes the protocol to be Fig 4 T-MAC adaptive timeout [ZZl 0-7803-9290-6105/$2Q00 2005 IEEE 360 Proceedings of the 2005 IEEE Workshop on information Assurance and Security United States Military Academy West Point NY The waiting timeout period is determined by the largest contention window ( Q ~ - ~ ~ )   the time to send an RTS message (tRTS) and the protocol small interframe spacing (SIFS) delay before the receiving CTS node can process a response to the RTS: TA = 15 * Itcw-Ma -i- ~ R T S  + I s i d  (2) Simulations showed the requirement for a 15 scaling factor to produce a stable network Once a node has waited a timeout period without sensing any traffic the node transitions to sleep until the next scheduled listen period The arrows in Fig 4 indicate message traffic and illustrate how T-MAC effectively condenses the traffic into a smaller time frame to reduce idle listening at the expense of increased message delay In an event-based and periodic reporting scenario T-MAC achieved five times the energy savings as S-MAC T-MAC is more vulnerable to a broadcast attack than S- MAC If an attacker can get T-MAC network nodes to repeatedly receive broadcast messages the attacker can force all nodes to remain awake throughout the sleep period creating almost a 100% duty cycle Eqn 3 shows how one attacker can simultaneously drain the life of an entire network C Berkeley MAC (B-MAC) Berkeley MAC (B-MAC) [23] takes a decentralized sleep schedule approach by allowing nodes to adopt any sleep schedule but the sleep cycle frequency is fixed At the end of a node's sleep period a node wakes up and samples the channel using a process called low power listening (LPL) As illustrated in Fig 5 if the node senses activity it wakes up synchronizes with the packet preamble and receives the packet A sender must transmit a preamble length greater than the sleeping nodes sampling cycle to ensure that the node is awake for synchronization Since many of the sensor platform transceivers expend more energy receiving than transmitting experiments have shown that the penalty for idle listening in the entire network far exceeds the penalty for transmitting a longer preamble if the system is tuned correctly Since an attacker can extend a broadcast message preamble across an entire sleep period and wake up every Fig 5 BMAC low power listening 1191 node 8-MAC is equally as susceptible to a denial of sleep attack as T-MAC VI PROPOSED GATEWAY MAC (G-MAC) Gateway MAC (G-MAC) IS a proposed energy-efficient sensor MAC protocol designed to coordinate transmissions within a cluster Like the WSN MAC protocols previously discussed all nodes have equally limited resources and have traffic intended to pass to neighboring nodes for in-network processing and out of the network to designated applications (network sink) for further processing G-MAC has several energy-saving features which not only show promise in extending the network lifetime but the centralized architecture makes the network more resistant to denial of sleep attacks G-MAC divides a frame into a collection period and a distribution period as shown in Fig 6   During the collection period the cluster coordinator called the gateway sensor (GS) node collects two types of network traffic: intra-network (local) and inter-network (non- local) traffic Intra-network traffic represents messages exchanged among nodes in the same cluster The sender transmits a future-RTS (FRTS) message to reserve a delivery slot in the non-contention distribution period Inter-network traffic represents messages which originate in the cluster and will be forwarded by the gateway to the outside network The sender and gateway exchange an RTS-CTS-data-ACK message sequence for immediate collection After all transactions are complete the gateway attempts to forward a11 traffic out of the cluster gathers any incoming data €or the cluster and then transitions to sleep (I&S inter-network and sleep period in Collection Distribution lc- Period - Pctiod 4 0-78 03 -9290-6IO5/$2000 02005 IEE E Fie 6 G-MAC Frame archilecture I36 1 Proceedings of the 2005 IEEE Workshop on Information Assurance and Security United States Militaly Academy West Point NY Fig 6 )   Thc distribution period begins with all nodes waking up and receiving the gateway’s traffic indication message (GTIM) In this message the gateway declares the next collection period thc next distribution period and the schedule of message transactions between cluster nodes The GTIM describes the traffic exchange time slots by source destination and time offset Based upon the GTIM synchronization time the offset field indicates the time duration before a node must wake up for its message transaction The receiving node rebms the next offset value in  the ACK response to synchronize the next transmission G-MAC periodically elects a new gateway node to equally distribute the energy requirements among all of the sensors Although the network has a default changeover frequency for self-recovery every GTIM contains an election bit that is set to indicate whether the next distribution period will changeover the gateway To reduce the overhead of exchanging available resource updates G-MAC uses a passive method of determining the next gateway by calculating an election contention backoff period based upon a node’s available resources Nodes with fewer resources will have larger backoff times based upon a multi-tiered critical resource algorithm The group of nodes with the most available resources will produce the next gateway The new gateway is the volunteer node which first gains contention of the medium after the start of the GTIM period A gateway will signal for a new election whenever it transitions to a lower energy state reaches critical memory levels or approaches a default changeover Since cluster nodes only respond to the gateway node network attackers cannot penetrate the link layer of the G- MAC protocol Unicast or broadcast messages sent to the gateway must be authenticated prior to being distributed to the individual nodes The best success that a broadcast attacker can achieve is to send broadcast messages to the gateway and force the gateway to receive the entire message before discarding it due to authentication failure Once the gateway’s energy level reduces to a lower level a fresh gateway takes its place Shown in Eqn 4 the attacker must effectively erode the network’s energy one node at a time vlf ANALYSIS OF PROTOCOLS Modeling each network with no traffic regular unicast traffic regular broadcast and broadcast attack traffic conditions yields the results shown in Table 2 Each WSN protocol is modeled in MATLAB using similar configurations to provide a fair comparison The IEEE 80211 standard MAC protocol [24] establishes a baseline for a network lifetime without any power-saving mechanisms The S-MAC model has a 500ms frame time with a fixed sleep period of 4SOms translating to a 10% duty cycle The S-MAC implementation includes RTS- Table 2 MAC Protocol Performance Results Network Lifetime (days) 1 MAC 1 Empty I Regular 1 Regular I Denial of Protocol Network Unicast Broadcast Sleep 1 (no 1 Traffic 1 Traffic I Broadcast 1 CTS exchanges for message overhearing avoidance The T-MAC model also has a frame time of 500ms with the adaptive sleep timeout set to 102ms and a fixed contention period of 5ms for every packet The B-MAC model senses the channel for 035111s during every 14ms check interval In fairness the low power listening mechanism for B-MAC consumes the same power as the receive mode in all other models The G-MAC protocol also uses a 500ms frame time containing a collection period a GTIM broadcast and a distribution period The size of the GTIM is 35 bytes + (6  bytes * number of packetsiframe) The system models forty nodes in a single-hop neighborhood and operates at 626kbps The network lifetime is based solely on the CC2420 radio energy to receive (197mA) transmit (174mA) and power down sleep (002mA) The results indicate that G-MAC performs significantly better than the other protocols in every traffic situation The empty network case shows the protocol overhead and idle listening effects determined by the effective duty cycle IEEE 80211 performs poorly with a 100% duty cycle B-MAC establishes a 25% effective duty cycle and S-MAC uses a 10% fixed duty cycle With adaptive listening all T-MAC nodes must monitor the network for a complete timeout period of 102ms at the beginning of every 500ms slot for a 21% duty cycle G-MAC’S equivalent 095% duty cycle is the weighted average of the duty cycle of the gateway node and the other nodes The gateway node monitors the network for a complete timeout and sends the empty GTIM All other nodes wake up only to receive the GTIM and return to sleep Regular unicast and broadcast traffic is modeled as four 32-byte messages per second By only having the transmitting nodes awake during the contention period G- MAC outperforms all of the other protocols in terms of network lifetime T-MAC performs better than S-MAC due to its ability to curtail the active period after 0-7803-9290-6/05/$2000 02005 IEEE 362 Proceedings of the 2005 IEEE Workshop on Information Assurance and Security United States Military Academy West Point NY completing all transmissions Interestingly S-MAC uses less network energy with traffic than in the empty traffic scenario The ability for the passive nodes to transition to sleep after receiving the RTS or CTS messages allows them to save message overhearing energy costs The performance of B-MAC significantIy decreases because each passive node has to wake up and receive every message Additional tests show that B-MAC works well in ultra-low traffic networks Any shared medium can be attacked with physical layer jamming A denial of sleep attack is most effective if the attacking node uses knowledge of the MAC protocol to drain network energy without expcnding much of its own For fairness the model makes the unbiased assumption that each protocol can authenticate a message after it is completely received The denial of sleep broadcast attack is modeled as an attacker sending four 32-byte broadcast messages per second All nodes in S-MAC T-MAC and B-MAC protocols simultaneously receive a broadcast message but discard the message if it fails authentication The attacking node is able to deny sleep to all of the network nodes at the same time S-MAC performs better than T-MAC since it automatically transitions to sleep after receiving the last packet initiated prior to the sleep period T-MAC nodes must wait the additional adaptive timeout period With G-MAC the attacker must gain access to the network through the gateway node which relays all inter-network traffic and rcserves timing dots for intra-network traffic If the gateway does not properly authcnticate the packet it will not forward it to the other network nodes The broadcast message docs not directly affect the sleeping nodes Furthcmorc if the attacker cannot properly encrypt a GTIM message the other nodes will not accept an attacker’s traffic schedule if it tries to masquerade as the gateway node Therefore a link layer denial of sleep attacker can only affect one nodc at a time because nodes alternatc the gateway rcsponsibilitjes based upon incremental decreascs in battery levels Since n-1 nodes will always be slecping during the broadcast the network lifetime for an attack increases Iinearly with the number of nodes For these reasons G-MAC significantly outperforms the other MAC protocols in the broadcast denial of sleep attack category v111 FUTURE WORK AND CONCLUSIONS This papcr describes the denial of sleep vulnerabilities for leading wircless sensor network MAC protocols and models the catastrophic effects these attacks can havc on a deployed network The link layer denial of sleep attack exposes rhe necessity to cotisider all primary threats to every system component during the design phasc to properly integrate security with functionality The WSN link layer MAC protocol introduced in this paper Gateway MAC established an effective denial of sleep defense by centralizing duster management Future work in WSN protocol research includes analyzing other security vulnerabilities such as physical layer jamming nodekey capture containment and network layer misrouting Providing solutions for these resource- constrained networks requires delicate tradeoffs in security performance and usability IX REFERENCES [ I ]  J Kahn R Katz and K Pister “Next century chalIen es: mobile networking for ‘Smart Dust’ “ In ACMhf obrCom  Aug 1999 21 CrossBow CO oration MICA2 and MICAZ Series bata Sheet [Onlin? h t t~ : l /m~vxbowco~n  31 MotelV Corporation TelosA Data Sheet [Online] Ittp://w~~~~~inotL‘ivcom/products-revapl~i~ 41 Chi con Corporation CC 1000 and CC2420 Data L s  heet [ nline] httD://~~wc~iipciinconi/ 151 A Perrig J Stankovic and D Wagner “Security in wireless sensor networks” In ACM Comm 2004 [6 ]  A Wood and J   Stankovic “Denial of service in sensor networks ”In IEEE Computer Oct 2002 71 Stajano and R Anderson “The Resurrecting t uckhng: Securi h u e s  for Ad-hoc Wireless Networks” In IC%C Springer-Verlag 2000 I!] T Martin M Hsiao D Ha and J   Krishnaswami Denial-of-;ervice attacks on battery-powered mobile computers In PERCOM Mar 2004 [9] GJacob and N Davis “Batte -based intrusion detection” &EE Globecom Dec 2704 [ 101 J Cannady and J   Hqel l   “A comparative anal sis of current intrusion detection technologies” in T l S z  1996 1 I ]  Y   Law et al “Link-layer Jamming Attacks on S- L AC” Technical Paper Univ of Twente NL 2005 [12] E   Shi and A Perrig “Designing secure sensor networks” In IEEE Wireless Comm Dec 2004 [ 131 R Negi and A Perrig “Jamming analysis of MAC protocols” Camegie Mellon Technical Memo 2003 [14] M Stahlberg “Radio Jamming attacks against two opular mobile networks” In Helsinki University of fe‘ech Seminar on Network Security Fa11 2000 [15] C Karloff an N Sastry and D Wa ner “TinySec: A link layer securi? architecture for wireyess sensor nehvorks In ACM ensys Nov 2004 161 National Instof Std and Tech “Federal Information L rocessing Standards Publication 197: Advanced Encryption System Standard (AES)” Nov 2001 171 Wireless MAN medium access control and physical I a er s ccification for low-rate WPANs IEEE Std 8J21?4 - 2003 edition 181 A Perrig et al “SPINS: Security Protocols for L ensor Networks” In Wireless Networks 2002 I91 K Langendoen and G Halkes “Energ Efficient hedium Access Control” unpub tished ZO& [ZO] V Bharghavan et al “MACAW: a media access rotocol for wireless LANs” In ACM SIGCUMM Aug I 2  11 Y   Wei J Heidemann and D Estrin “An energy- efficient MAC rotocol for wireless sensor networks’ in INFUCUMM E n   2002 1 P994 0-7803-9290-6/05/62000 02005 IEEE 363 Proceedings of the 2005 TEEE Workshop on Information Assurance and Security United States Military Academy West Point NY E221 T van Dam and K Lan endoan “Energy-efficient MAC: An adaptive energy-ehcient MAC rotocol for wireless sensor networks” in ACM SEA’S& Nov 2003 [233 J   Polstre J   Hill andD Culler “Versatile low power media access for wireless sensor networks” in ACM SENSYS 2004 241 Wireless LAN medium access control and physical I ayer specification lEEE Std 8021 1-1997 edition 0-7803-9290-61051S2000 02005 IEEE 364 
How public key ecrptography influence wsn-pdf,How Public Key Cryptography Influences Wireless SensorNode LifetimeKrzysztof Piotrowskipiotrowski@ihp-microelectronicscomPeter Langendoerferlangendoerfer@ihp-microelectronicscomSteffen Peterpeter@ihp-microelectronicscomIHPIm Technologiepark 2515236 Frankfurt (Oder) GermanyABSTRACTIn this paper we try to estimate the real influence of pub-lic key cryptography (PKC) to the lifetime of a sensor nodein wireless sensor networks We investigate four types ofnodes; MICA2DOT MICA2 MICAz and TelosB For allthese nodes we estimate the power consumption for mostcommon RSA and ECC operations ie signature gener-ation and verification as well as key exchange mechanismsWe also estimate the power consumed by the transmission oftheir results Our results show that the application of strongcryptography is feasible Even for the most constrained nodeperforming the ECC-160 signature once every 10 minutes in-creases the duty cycle only by about 05 per cent ie theinfluence to the lifetime is not significant Nevertheless thepublic key cryptography shall be used with careCategories and Subject DescriptorsD28 [Software Engineering]: Metrics—complexity mea-sures performance measuresGeneral TermsSecurity PerformanceKeywordsWireless Sensor Networks Cryptography Complexity Per-formance Elliptic Curve Cryptography RSA1 INTRODUCTIONMany applications in the area of Wireless Sensor Networks(WSN) would gain a lot from the availability of strong pub-lic key cryptography (PKC) The most important advan-tage is the availability of authentication and key exchangemechanisms that are more secure and reliable compared toPermission to make digital or hard copies of all or part of this work forpersonal or classroom use is granted without fee provided that copies arenot made or distributed for profit or commercial advantage and that copiesbear this notice and the full citation on the first page To copy otherwise torepublish to post on servers or to redistribute to lists requires prior specificpermission and/or a feeSASN’06 October 30 2006 Alexandria Virginia USACopyright 2006 ACM 1-59593-554-1/06/0010 $500secret key cryptography However besides the advantagesthe public key cryptography has also one main disadvantageIt is computationally expensive It is nowadays clear that itis possible to apply it but the question that remains is howthe application of strong public key cryptography affects thelifetime of the energy source and thus the lifetime of the sen-sor That is why here we try to investigate the costs of publickey cryptography in WSN and their influence to the nodelifetime We distinguish between the energy consumptionfor the calculations and the energy used to transfer theirresultsIt is not easy to judge whether the PKC is generally tooexpensive for WSN or not The verdict depends on manyapplication specific factors eg how often shall the cryptooperations be performed and if the calculation shall alwaysbe followed by the transmission of the resulting signature orencrypted dataThe paper is structured as follows In the following sec-tion we present the sensor nodes for which we provide ourevaluation Then we provide information about the powerconsumption ie the costs for cryptographic operations insoftware and costs for data transmission Based on the dataprovided we estimate the lifetime of a sensor node Finallywe draw conclusions and present our plans for further work2 THE SENSORSThe sensor nodes we are focusing on in this paper canbe divided into two groups depending on the processingunit The first group is the MICA family[6] (MICA2DOTMICA2 and MICAz) based on the ATmega128L[1] micro-controller from ATMEL The second group includes sensornodes based on the MSP430F1611[10] from Texas Instru-ments like TelosB[5] and Tmote Sky[2] Since the design ofthe Tmote Sky is based on TelosB in this paper we will referto TelosB onlyIn this section we will try to estimate the performanceratio between these nodes focusing on pure cryptographiccalculations We will normalize the computational perfor-mance of these nodes using the results of the weakest oneCombining the ratio with the power consumption of eachnode we will further estimate the energy consumed by pub-lic key cryptography for all sensor nodes given more detailedenergy consumption measurements for one type of nodeFirst we use the information from the microcontrollers’documentations to calculate the overall energy consumption169Table 1: Time needed by the sensor nodes to per-form SSL/TLS handshakeSensor node RSA-1024 Performancehandshake ratio (RSA)MICA2DOT 2200 s 100MICA2/MICAz 1200 s 183TelosB 570 s 386Sensor node ECC-160 Performancehandshake ratio (ECC)MICA2DOT 160 s 100MICA2/MICAz 087 s 185TelosB 050 s 320and also the amount of energy consumed per clock cycle Ineach case the estimated power consumption is calculated at3V power supply voltage and at clock frequency as specifiedfor the node• TelosB with TI MSP430F1611 at 8 MHz 4mA → 12mW– 12 mW / 8MHz = 15 nWs• MICA2DOT with ATMEL ATmega128L at 4 MHz55mA → 165 mW– 165 mW / 4 MHz = 4125 nWs• MICA2 and MICAz with ATmega128L at 737 MHz10 mA → 30 mW– 30 mW / 737 MHz = 407 nWsThis shows that the MSP430 requires only about 40%energy consumed by ATmega running at about the sameclock frequencyThe performance ratio between MICA2DOT and MICA2or MICAz can be estimated easily since both use the sameprocessing unit The amount of clock cycles will not changeand the only difference will be in time needed to perform thesame calculation thus the performance ratio between nodesbelonging to the MICA family is equal to the clock frequencyratio And thus if we take the performance of MICA2DOTas one unit the performance of MICA2 or MICAz will beabout 185In order to estimate the performance ratio between differ-ent types of microcontrollers we will use measurements from[4] In this paper the authors measured the time needed byTelosB and MICA nodes to perform the handshake serverside step of the secure SSL/TLS communication In otherwords this handshake step is the server side part of the keyexchange mechanism Each type of sensor node performedtwo kinds of handshake ie the RSA and the ECC basedhandshake Table 1 presents the time needed for the calcu-lations only to make the results independent from the typeof radio device available at the sensor node [4]The modulo exponentiation with the big private exponentis the main and most expensive part of the full RSA-1024handshake The complete handshake needed about 22 sec-onds on MICA2DOT 12 seconds on MICA2/MICAz andabout 57 seconds on TelosB sensor nodeTable 2: Power consumed by the sensor nodes toperform SSL/TLS handshakeSensor node RSA-1024 Power consumptionhandshake ratio (RSA)MICA2DOT 36300 mWs 100MICA2/MICAz 36000 mWs 099TelosB 6840 mWs 019Sensor node ECC-160 Power consumptionhandshake ratio (ECC)MICA2DOT 2640 mWs 100MICA2/MICAz 2610 mWs 099TelosB 600 mWs 023In the case of full ECC-160 handshake where the mainand most expensive operation is the scalar point multiplica-tion the time needed was 16 seconds on MICA2DOT 087second on MICA2/MICAz and 05 second on TelosBSince both types of handshake provide the same function-ality we think that the RSA cryptography is not really rea-sonable for WSN The same conclusion was drawn in [11]The reason for this is the enormous time and thus power con-sumption for RSA calculations and the much larger amountof data to be transmittedBased on the measurements for the ECC handshake thecomputing performance of the TelosB is about 32 comparedto the performance of the MICA2DOT The TelosB is alsoabout 175 times faster than the MICA2/MICAz nodesThis is the advantage of the 16-bit processing unit of theTelosBKnowing the time needed by each type of node we esti-mate the power consumed by the nodes while calculatingthe above mentioned operations (see Table 2) Based onthese results we create another factor the power consump-tion ratio—the power consumed by the cryptographic op-erations normalized using the power consumed by the leasteffective nodeSince the clock cost is almost the same for all nodes of theMICA family the power consumption will also be the sameWhat is interesting in case of ECC the power consumed bythe TelosB node is only 23% of the power consumed by theMICA nodes performing the same operationKnowing the performance and power consumption ratiosfor these sensor nodes we can proceed to a more detailedstudy on the power consumption of public key cryptographyin WSN3 POWER CONSUMPTION CAUSEDBY APPLYING PUBLIC KEYCRYPTOGRAPHY31 Cryptographic operationsThe application of cryptography involves many mecha-nisms that create the environment for the main operationslike encryption decryption signature generation and ver-ification The cost of modular exponentiation (RSA) orpoint multiplication (ECC) is of course the main indicatorof the implementation’s efficiency But besides these twooperations cryptography requires also additional operationseg hash value calculations random number generation andtesting if a number is a prime170Table 3: Power consumption for signature genera-tion/verification and key exchange for the client andserver side on a MICA2DOTCryptosystem SignatureGeneration VerificationRSA-1024 30400 mWs 1190 mWsECC-160 2282 mWs 4509 mWsRSA-2048 230270 mWs 5370 mWsECC-224 6154 mWs 12198 mWsCryptosystem Key exchangeClient ServerRSA-1024 1540 mWs 30400 mWsECC-160 2230 mWs 2230 mWsRSA-2048 5720 mWs 230270 mWsECC-224 6040 mWs 6040 mWsTable 4: Time consumed for signature genera-tion/verification and key exchange for the client andserver side on a MICA2DOT (using the active powerconsumption equal to 138 mW)Cryptosystem SignatureGeneration VerificationRSA-1024 2203 s 086 sECC-160 165 s 327 sRSA-2048 16686 s 389 sECC-224 446 s 884 sCryptosystem Key exchangeClient ServerRSA-1024 112 s 2203 sECC-160 162 s 162 sRSA-2048 414 s 16686 sECC-224 438 s 438 sAnother paper [12] provides detailed measurements forthe MICA2DOT The authors measured power consumptionfor the MICA2DOT for the following cryptographic opera-tions:• Signature generation/verification and client/server keyexchange operations (see Table 3 [12])• Calculation of SHA-1 hash value (59 µWs/byte)• AES-128 encryption / decryption (162 µWs/byte and249 µWs/byte)However in that paper the power consumption of activeMICA2DOT is said to be 138 mW That is less than ourestimated 165 mW but the difference may be caused bysupply voltage lower than 3V We used the power consump-tion presented in [12] to estimate the time needed by theMICA2DOT See Table 4 These data were used to calcu-late the time and power consumption for all other nodesTables 6 and 7 present the estimated power consumptionand time needed by MICA2/MICAz and TelosB nodes toperform key exchange as client and server respectively aswell as signature generation and verification Even for themost powerfull TelosB the RSA private key operations arevery time and energy consumingOnce again the results show that RSA is not well suitedfor WSN Comparing ECC-160 and RSA-1024 yields in theTable 5: Estimated power consumption for signa-ture generation/verification and key exchange forthe client and server side on a MICA2DOT (basedon the time results in Table 4 and assuming the ac-tive power consumption is equal to 165 mW)Cryptosystem SignatureGeneration VerificationRSA-1024 36350 mWs 1419 mWsECC-160 2723 mWs 5396 mWsRSA-2048 275319 mWs 6419 mWsECC-224 7359 mWs 14586 mWsCryptosystem Key exchangeClient ServerRSA-1024 1848 mWs 36350 mWsECC-160 2673 mWs 2673 mWsRSA-2048 6831 mWs 275319 mWsECC-224 7227 mWs 7227 mWsTable 6: Estimated time and power consumption forsignature generation/verification and key exchangefor the client and server side on a MICA2/MICAzCryptosystem SignatureGeneration VerificationRSA-1024 35987 mWs 1405 mWs1204 s 047 sECC-160 2696 mWs 5342 mWs089 s 177 sRSA-2048 272566 mWs 6355 mWs9118 s 213 sECC-224 7285 mWs 14440 mWs241 s 478 sCryptosystem Key exchangeClient ServerRSA-1024 1830 mWs 35987 mWs061 s 1204 sECC-160 2646 mWs 2646 mWs088 s 088 sRSA-2048 6763 mWs 272566 mWs226 s 9118 sECC-224 7155 mWs 7155 mWs238 s 238 s171Table 7: Estimated time and power consumption forsignature generation/verification and key exchangefor the client and server side on a TelosBCryptosystem SignatureGeneration VerificationRSA-1024 6897 mWs 270 mWs566 s 022 sECC-160 626 mWs 1241 mWs052 s 102 sRSA-2048 52310 mWs 1220 mWs4289 s 100 sECC-224 1693 mWs 3355 mWs139 s 276 sCryptosystem Key exchangeClient ServerRSA-1024 351 mWs 6897 mWs029 s 566 sECC-160 615 mWs 615 mWs051 s 051 sRSA-2048 1298 mWs 52310 mWs106 s 4289 sECC-224 1662 mWs 1662 mWs137 s 137 sconclusion that the effort for RSA cryptography is too bigWhile the application of the even stronger ECC-224 stillseems to be feasible the time and power consumption forthe equivalent RSA-2048 is far beyond the acceptable levelThe one big potential advantage of RSA is its computa-tional asymmetry ie the private key operations are veryexpensive while the public key operations are very cheapThis might be useful for the case where the sensor nodecommunicates with a device that is not constrained withrespect to computation power and energy eg a laptop orPDA that reads the measurements out of the node [13]proposes an architecture that exactly exploits this phenom-enon But if two sensor nodes communicate with each otherthe RSA is not reasonable anymoreThe time needed for a cryptographic operation limits alsothe maximum frequency of its occurence In most cases itshould not be a problem but imagine a situation where asensor node has to sign or encrypt every reading it makesIn this extreme case if it needs 5 seconds for the signatureor encryption then the maximum sensing rate is once every5 seconds with a 100% duty cycle But if we can reducethe time for signature or encryption to 1 second the samenumber of sensor readings can be executed with a duty cy-cle reduced to 20% This underpins again the advantageprovided by applying ECCIn addition to the calculation power transmission powerhas to be considered We provide some estimations for thisin the next subsection32 Power Consumption of TransmissionAnother issue is the size of the key that directly influencesthe size of the signature and of the encrypted message Men-tioning the public key encryption we mean an encryption ofa single data block that is smaller than the used key En-cryption of a block much bigger than the key causes wasteof energy and the symmetric cryptography shall be used inthis case Transmission of data touches another importantTable 8: Current and power consumption of the Zig-Bee transceiver CC2420 Power consumption calcu-lated at 3V supply voltage Power consumption perbit at transmission speed of 250 kbit/sType of Current Power Power per bittransmission [mA] [mW] [µWs/bit]RX 188 564 0226TX -25 dBm 85 255 0102TX -15 dBm 99 297 0119TX -10 dBm 110 330 0132TX -5 dBm 140 420 0168TX 0 dBm 174 522 0209Table 9: Power consumption of the 433 MHz and868 MHz transceiver CC1000 Power consumptioncalculated at 3V supply voltage Power consumptionper bit at transmission speed of 384 kbit/sType of Current Power Power per bittransmission [mA] [mW] [µWs/bit]433 MHzRX 74 222 0578TX -20 dBm 53 159 0414TX -5 dBm 89 267 0696TX 0 dBm 104 312 0812TX 5 dBm 148 446 1160TX 10 dBm 267 801 2086868 MHzRX 96 288 0750TX -20 dBm 86 258 0672TX -5 dBm 138 414 1078TX 0 dBm 165 495 1290TX 5 dBm 254 762 1984TX 10 dBm —– —– —–factor for the estimation of power consumption which is theenergy consumed by the RF part of the sensorAll four types of sensor nodes use single chip transceiversMICA2 and MICA2DOT use 433 MHz or 868 MHz radiochip CC1000 [8] and MICAz and TelosB use ZigBee 24GHz radio chip CC2420 [7] both from Chipcon (now partof Texas Instruments) The two radio types differ in perfor-mance ZigBee devices transmit data with 250 kbit/s datarate with maximum power of 0 dBm and CC1000 chip al-lows data rates up to 768 kbit/s with maximum power of10 dBm (433 MHz) or 5 dBm (868 MHz) The MICA nodesthat use the cc1000 chip use Manchester encoding reducingthe maximum transmission rate to 384 kbit/sThe power consumption data for both chips are shown inTable 8 and Table 9 This data shows that the higher powerconsumption of cc2420 is compensated by the lower cost ofper bit transmission Now we can calculate energy consumedby the transmission of the cryptographic results The bestexample of these is the digital signature The RSA signatureis represented by an integer smaller than the used modulusand in case of ECDSA the signature are two integers smallerthan the order of the base point of the used curve Thusin case of RSA signature the size of it is about the key sizeand for ECDSA the size of a signature is about double thekey size172Table 10: Power consumed while reception of a sig-nature on cc2420 and cc1000 single chip transceiverSignature Size cc2420 cc1000433 MHz 868 MHz[bit] [µJ] [µWs] [µWs]ECDSA-160 320 7232 18496 24000RSA-1024 1024 23142 59187 76800ECDSA-224 448 10125 25894 33600RSA-2048 2048 46285 118374 153600Table 11: Power consumed while sending a signatureon cc2420 and cc1000 single chip transceiver with -5dBm and 0 dBm output powerSignature Size cc2420 cc1000433 MHz 868 MHz[bit] [µWs] [µWs] [µWs]Output power -5 dBmECDSA-160 320 5376 22272 34496RSA-1024 1024 17203 71270 110387ECDSA-224 448 7526 31180 48294RSA-2048 2048 34406 142541 220774Output power 0 dBmECDSA-160 320 6688 25984 41280RSA-1024 1024 21401 83149 132096ECDSA-224 448 9363 36378 57792RSA-2048 2048 42803 166298 264192Output power 5 dBmECDSA-160 320 —– 37120 63488RSA-1024 1024 —– 118784 203162ECDSA-224 448 —– 51968 88883RSA-2048 2048 —– 237568 406323So for the measured approaches the size of a signature isas follows:• 320 bits for ECDSA-160• 1024 bits for RSA-1024• 448 bits for ECDSA-224• 2048 bits for RSA-2048The key exchange mechanism requires at least the trans-mission of the calculation results For ECC it is the resultingpoint and for RSA the integer in both cases the size of datais comparable with the size of the signature for the corre-sponding signature schemeThe costs of signature reception for both transceivers arepresented in Table 10 Table 11 presents the power con-sumption for sending a signature Since the sending powerfor those two transceivers differs we compare the costs ofsending a signature for -5 dBm 0 dBm and for the cc1000also for 5 dBm output power Note that in a real applicationthe sending power is adjustable and depends on the environ-mental conditions and distance between the communicationpartners Thus the values presented here are somehoweidealizedIn case of digital signature there are four steps to be done;generation transmission reception and verification Thetwo communication partners share the effort the first onegenerates and transmits the signature and the second onereceives it and verifiesLet us take the less expensive signature ECDSA-160 asan example In order to point out very clear that the ap-plicability of PKC does not depend on power consumed bytransmitting keys signatures etc we will discuss some sam-ple sensor node configurations The transmission power hasthe highest impact in case that we combine a MSP430 mi-crocontroller the one with the lowest power consumptionwith a cc1000 transceiver working in the 868MHz frequencyband with 5 dBm output power thus consuming the highestenergy for transmission Even with this worst case combi-nation sending a signature requires only ten per cent of itsgeneration The reception needs only four per cent of theenergy needed for verifying the signatureFor the TelosB node the cost of communication is about 1per cent for ECDSA-160 about 2 per cent for MICA2DOTand MICA2 For MICAz the significance of communicationcosts goes below 03 per cent4 SENSOR LIFETIME ESTIMATIONBatteries are the standard power source for all the abovementioned nodes The MICA2 MICAz and TelosB nodesare powered by 2 AA cells and MICA2DOT is powered byCR2354 lithium coin cell battery To estimate the avail-able amount of energy we need to know the capacity of thebatteriesThe rated capacity of an AA alkaline battery is about 2500mAh However the manufacturers define the capacity as theamount of energy that can be delivered until the voltage of asingle AA cell reaches 08 V And since the sensor nodes arepowered by two AA batteries the voltage of such a batterypack is 16 V that is below the acceptable voltage for thenodeFigure 1: The voltage drop for a battery pack con-sisting of two AA cells while discharging with a con-stant current The areas 1 2 3 and 4 represent thepercentage of the energy available in each voltagerangeThe standard approach is to simply use the battery untilthe voltage goes below the threshold In this paper we willfocus on this method In this case the calculation of avail-able battery capacity has to take into account that someenergy will not be available The voltage of a new alkaline173AA cell is usually about 16 V and as the current is drawnthe voltage drops almost linear We will use this effect toestimate the amount of energy that can be delivered by thedouble AA cell battery pack that delivers nominal 32 VAssuming linear or almost linear voltage drop to 16 V theaverage voltage for the pack is 24 V The product of timeand current is said to be 2500 mAh which means that theenergy that could be delivered is equal to 6000 mWh orsimply 21600 Ws Figure 1 shows the voltage drop whiledischarging with constant current The time within whichthe batteries reach the cut-off (16 V) voltage depends onthe value of the current The time axis is divided into fourequal periods or steps And since the current is constant theareas 1 to 4 under the line of voltage drop are proportionalto the amount of energy delivered in each time periodThus the energy capacity available by the battery packcan be divided into four partitions depending on the voltagerange as follows:• 32 V – 28 V — 3125 % of 21600 Ws → 6750 Ws• 28 V – 24 V — 2710 % of 21600 Ws → 5850 Ws• 24 V – 20 V — 2290 % of 21600 Ws → 4950 Ws• 20 V – 16 V — 1875 % of 21600 Ws → 4050 WsFor instance if a device accepts voltage range between 20V and 32 V then the amount of energy available will reach8175 % of the whole battery pack capacity ie the devicecan consume up to 17550 Ws and 4050 Ws will be uselessNow we estimate the energy that is available for the sensornodes while powered by such a battery pack Actually forthe nodes we study only the single chip transceivers cc2420and cc1000 can work with supply voltage as low as 21 VBoth microcontroller types require voltage higher than 27V For the ATmega128L microcontroller used by the MICAfamily this value is the minimum for operation And theMSP430F1611 from TelosB requires at least 27 V to beable to write to flash though for code execution only itworks even at 18 V but only with reduced clock frequencyAlso the external flash memory chips require at least 27V supply voltage This leads us to the conclusion that theestimation of available energy will be adequate if we choosethe voltage between 28 V and 32 V as the useful rangeThus the node powered by two AA alkaline batteries usesonly 3125 % of the total capacity ie the node can consumeabout 6750 Ws until the batteries are uselessFor the cr2354 coin cell battery used by MICA2DOT therated capacity is 560 mAh and according to [3] the dis-charge characteristics is quite flat while discharging with asmall constant current of about 05 mA The starting volt-age is about 29 V at room temperature and about 80 % ofthe energy capacity can be delivered until the voltage dropsbelow 28 V Thus the rated energy capacity is about 5500Ws and the available 4400 WsWe estimated the energy consumed by the cryptographicoperations for the supply voltage of 30 V and since this isexactly the mean value of the chosen voltage range for thedouble AA battery pack the errors in the further estimationfor nodes powered by these batteries are minimized In caseof MICA2DOT the nominal voltage of the cr2354 batteryis about 01 V lower than the ideal value but we think theestimation error may be neglectedTable 12: Estimated amount of signature gener-ation / verification operations and key exchangeoperations for the client and server side on aMICA2/MICAz and TelosB with the 6750 Ws ofenergy available by the double AA battery pack aswell as on the MICA2DOT with the 4400 Ws avail-able by the cr2354 cell battery If the calculation iffollowed by transmission the amount of operationsis reduced by about 1 per centNode Crypto- Signaturesystem Generation VerificationMICA2DOT RSA-1024 12105 310078MICA2/MICAz RSA-1024 18757 480427TelosB RSA-1024 97867 2500000MICA2DOT ECC-160 161586 81542MICA2/MICAz ECC-160 250371 126357TelosB ECC-160 1078275 543916MICA2DOT RSA-2048 1598 68547MICA2/MICAz RSA-2048 2476 106216TelosB RSA-2048 12904 553279MICA2DOT ECC-224 59791 30166MICA2/MICAz ECC-224 92656 46745TelosB ECC-224 398701 201192Node Crypto- Key exchangesystem Client ServerMICA2DOT RSA-1024 238095 12105MICA2/MICAz RSA-1024 368852 18757TelosB RSA-1024 1923077 97867MICA2DOT ECC-160 164609 164609MICA2/MICAz ECC-160 255102 255102TelosB ECC-160 1097561 1097561MICA2DOT RSA-2048 64412 1598MICA2/MICAz RSA-2048 99808 2476TelosB RSA-2048 520031 12904MICA2DOT ECC-224 60883 60883MICA2/MICAz ECC-224 94340 94340TelosB ECC-224 406137 406137With the values collected so far we calculate the amountof public key cryptography operations the nodes can per-form with the available amount of energy See Table 12According to our estimations at 100 % duty cycle theprocessing unit of TelosB is able to run for 15625 hoursMICA2/MICAz for 625 hours and MICA2DOT for 771hours with the available energy Thus the use of publickey cryptography shall not increase the duty cycle of thenode in a significant manner The results in Table 13 andTable 14 show that the numbers for ECC-160 are reason-able They are even for RSA-1024 but in both cases onlyif the operations are used with care If the duty cycle is af-fected too much by the public key cryptography operationsthe lifetime of the sensor is reduced dramatically But if thenumber of public key operations is small or is spread overtime the theoretical lifetime of the node is several yearsassuming the node does nothing else Of course such anassumption is silly but the results indicate the influence ofthe public key cryptography to the lifetime of the node174Table 13: Estimated duty cycle and lifetime forRSA-1024 signature generation on a MICA2 MI-CAz and TelosB with the 6750 Ws of energy avail-able by the double AA battery pack as well as onthe MICA2DOT with the 4400 Ws available by thecr2354 cell battery If the calculation if followed bytransmission the values are about 1 per cent worseRSA-1024 signature generationNode duty cycle lifetime[%] [h]every 30sMICA2DOT 734333 10091MICA2/MICAz 401333 15573TelosB 188666 82818every 60sMICA2DOT 367166 20182MICA2/MICAz 200666 31146TelosB 94333 165637every 600sMICA2DOT 36716 201819MICA2/MICAz 20066 311462TelosB 09433 1656366every 3600sMICA2DOT 06119 1210982MICA2/MICAz 03344 1868772TelosB 01572 9938198Table 14: Estimated duty cycle and lifetime forECC-160 signature generation on a MICA2/MICAzand TelosB with the 6750 Ws of energy availableby the double AA battery pack as well as on theMICA2DOT with the 4400 Ws available by thecr2354 cell battery If the calculation if followed bytransmission the values are about 1 per cent worseECC-160 signature generationNode duty cycle lifetime[%] [h]every 5sMICA2DOT 330000 22455MICA2/MICAz 178000 35112TelosB 104000 150240every 30sMICA2DOT 55000 134727MICA2/MICAz 29666 210674TelosB 17333 901442every 300sMICA2DOT 05500 1347273MICA2/MICAz 02966 2106741TelosB 01733 9014423every 600sMICA2DOT 02750 2694545MICA2/MICAz 01483 4213448TelosB 00866 180288465 CONCLUSIONSBased on the data presented in this article we can con-clude that transmission power is not an important factorwhen comparing cryptographic algorithms Even sending a2048 bit RSA signature by a transceiver that requires 10µWs/bit needs not more than 2 mWs for one signatureThis is at least one order of magnitude less than the energyconsumption required for the computation of the crypto-graphic operations In large multi–hop networks it mightbecome a factor In that case a large signature increases theoverall transmission power consumption in the networkIndeed transmission power becomes more important ifthe energy required for the cryptographic computations isreduced It can be assumed that due to improved hardwaredesigns and smaller design structures the power consump-tion for the actual computation can be reduced Anotherpossibility of reducing the required energy for cryptographicoperations is the application of cryptographic co–processorsSuch dedicated hardware solutions perform the required op-erations much faster—three orders of magnitude Due tothe shorter duty time the total energy consumption is alsomuch lower For example applying a 233 bit ECC acceler-ator the signature generation requires merely 30 µWs Inthis case the several hundred µWs for the transmission ofthe 466 bit signature do have a significant impactActually these considerations lead to the conclusion thatenergy consumption of the computation of public key cryp-tography on WSNs is not a such an important issue as ex-pected Either the operations are performed so seldom thatthe required energy can be more or less ignored—for exam-ple in case a node is read once the year Alternatively per-formance requirements enforce dedicated hardware whichreduces the power consumption to a non relevant factor re-garding the power consumption needed for the transmissionWhat still remains an issue is the energy source Onesolution to avoid the loss of energy is to use boost voltageDC/DC converters that can work with input voltage as lowas 09 V and deliver constant 3 V output voltage In thiscase the energy from the batteries can be used in a moreefficient way ie even if the voltage goes below the accept-able value the remaining energy can still be used Howeverthis solution causes additional current consumption causedby the converter According to the documentation of TexasInstruments’ DC/DC converter family TPS61000 [9] the to-tal losses in the converter are less than 50 mW what isanyway too expensive for a wireless sensor node Thus thissolution is acceptable if the converter is enabled only in casethe voltage drops below acceptable level Intelligent powermanagement solutions can help extending the lifetime of thesensor node not only in case of public key cryptography ap-plications but can dramatically increase its applicabilityOur further work includes more empiric investigationsWe are going to design a sensor node and study its en-ergy consumption parameters regarding the application ofpublic key cryptography The node will be based on theMSP430 microcontroller since its power efficiency is muchhigher compared to similar solutions We are also going toinvestigate the influence of DC/DC converters to the batteryusage efficiency compared to simple low voltage solutions1756 REFERENCES[1] ATMEL Corporation ATmega128(L) - 8-bit AVRMicrocontroller with 128K Bytes In-SystemProgrammable Flash 2006 Available at:http://wwwatmelcom/dyn/resources/prod documents/doc2467pdf[2] Moteiv Corporation Tmote sky - ultra low powerIEEE 802154 compliant wireless sensor module2006 Available at:http://wwwmoteivcom/products/docs/tmote-sky-datasheetpdf[3] Panasonic Industrial Europe GmbH CR2354 LithiumBattery datasheet Available at:http://wwwpanasonic-industrialcom/2464pdf[4] Vipul Gupta Matthew Millard Stephen FungYu Zhu Nils Gura Hans Eberle and Sheueling ChangShantz Sizzle: A standards-based end-to-end securityarchitecture for the embedded internet (best paper)In PERCOM ’05: Proceedings of the Third IEEEInternational Conference on Pervasive Computing andCommunications pages 247–256 Washington DCUSA 2005 IEEE Computer Society[5] CrossBow Technology Inc TelosB Mote PlatformDatasheet Available at:http://wwwxbowcom/Products /Prod-uct pdf files/Wireless pdf/TelosB Datasheetpdf[6] CrossBow Technology Inc MPR / MIB User’sManual 2005 Available at: http://wwwxbowcom/Support/Support pdf files/MPR-MIB Series Users Manualpdf[7] Texas Instruments Inc Single-Chip 24 GHz IEEE802154 Compliant and ZigBee(TM) Ready RFTransceiver Available at:http://www-sticom/sc/ds/cc2420pdf[8] Texas Instruments Inc Single-Chip Very Low PowerRF Transceiver Available at:http://www-sticom/sc/ds/cc1000pdf[9] Texas Instruments Inc TPS61000 SINGLE- ANDDUAL-CELL BOOST CONVERTER WITHSTART-UP INTO FULL LOAD 2003 Available at:http://www-sticom/sc/ds/tps61003pdf[10] Texas Instruments Inc MSP430 Family ofUltra-lowpower 16-bit RISC Processors 2005Available at:http://www-sticom/sc/ds/msp430f1611pdf[11] David J Malan Matt Welsh and Michael D Smith Apublic-key infrastructure for key distribution in tinyosbased on elliptic curve cryptography In Proceedings ofthe First IEEE International Conference on Sensorand Ad Hoc Communications and NetworksWashington DC USA 2004 IEEE Computer Society[12] Arvinderpal S Wander Nils Gura Hans Eberle VipulGupta and Sheueling Chang Shantz Energy analysisof public-key cryptography for wireless sensornetworks In PERCOM ’05: Proceedings of the ThirdIEEE International Conference on PervasiveComputing and Communications pages 324–328Washington DC USA 2005 IEEE Computer Society[13] Ronald Watro Derrick Kong Sue fen Cuti CharlesGardiner Charles Lynn and Peter Kruus Tinypk:securing sensor networks with public key technologyIn SASN ’04: Proceedings of the 2nd ACM workshopon Security of ad hoc and sensor networks pages59–64 New York NY USA 2004 ACM Press176
On the energy cost cryptography WSN-pdf,On the Energy Cost of Communication andCryptography in Wireless Sensor NetworksGiacomo de Meulenaer Franc¸ois Gosset Franc¸ois-Xavier Standaert and Olivier PereiraUCL/DICE Crypto GroupPlace du Levant 3Louvain-la-Neuve Belgium{giacomodemeulenaer francoisgosset fstandae olivierpereira }@uclouvainbeAbstract—Energy is a central concern in the deployment ofwireless sensor networks In this paper we investigate the energycost of cryptographic protocols both from a communication anda computation point of view based on practical measurementson the MICAz and TelosB sensors We focus on the cost oftwo key agreement protocols: Kerberos and the Elliptic CurveDiffie-Hellman key exchange with authentication provided bythe Elliptic Curve Digital Signature Algorithm (ECDH-ECDSA)We find that in our context Kerberos is around one order ofmagnitude less costly than the ECDH-ECDSA key exchange andconfirm that it should be preferred in situations where a trustedthird party is available We also observe that the power dedicatedto communications can become a central concern when the nodesneed to stay in listen mode eg between the protocol roundseven when reduced using a Low Power Listening (LPL) protocolTherefore listening should be considered when assessing the costof cryptographic protocols on sensor nodesI INTRODUCTIONWireless Sensor Networks (WSN) are composed of smallautonomous devices that process and communicate data ac-quired from the environment in which they are deployed Theirlow cost and rapidity of deployment make them particularly at-tractive for many applications such as health monitoring build-ing protection pollution detection battlefield management   For such applications there is a need of strong security How-ever sensor nodes being usually powered through batteries theenergy cost of security techniques can be prohibitive and musttherefore be minimized Various techniques can be adoptedto perform the cryptographic tasks in WSN As an examplekey exchange can be carried out by relying on methods fromsymmetric key cryptography (eg through Kerberos [16]) orfrom public-key cryptography (eg through various modes ofSSL/TLS [3]) Besides in order to provide better security fea-tures while preserving low communication and memory costdifferent techniques have been proposed that allow tradingbetween security communication and computation (eg [12]and [4]) In order to appreciate the practical effectivenessof these trading techniques in a specific WSN the cost ofcommunication and computation must be well understoodContradictions appear in previous works concerning the im-portance of the communication energy cost For instancetwo works ([18] and [21]) assessing the cost of public-keycryptography on similar hardware have opposed conclusionconcerning the importance of the communication energy costwhen comparing cryptographic algorithms in WSN Our goalis to assess and analyze the real cost of cryptography on WSNnodes This will help choosing directions to optimize the costof cryptography in low power WSN For this purpose weinvestigate the cost of cryptography through a case study basedon measurements on the MICAz [11] and TelosB [11] sensornodes We focus on two key agreement protocols Kerberosand ECDH-ECDSA the Elliptic Curve Diffie-Hellman keyexchange with authentication provided by the Elliptic CurveDigital Signature Algorithm (ie the ECC-based SSL/TLShandshake see [1]) We assess their energy cost using energymodels of the sensors based on measurements Our maincontributions are :1 a methodology to assess the real cost of cryptography onWSN nodes which makes it possible to establish the relativecosts of computation and communication2 the estimates of the key agreement protocols obtainedfor the MICAz and TelosB nodes They allow us to comparesymmetric and asymmetric techniques They point out theimportance of the idle listening consumptionThis paper is structured as follows Section II presents theprevious related works Then Section III explains how wedetermined the energy models of the sensors MICAz andTelosB Next Section IV provides an assessment and analysisof energy cost of Kerberos and ECDH-ECDSA followed bya comparison with related results in Section V Finally theconclusion is given in Section VIII PREVIOUS WORKSMany recent works investigate the usability of cryptographicalgorithms in the context of wireless sensor networks Forinstance symmetric encryption using AES is discussed in eg[9] and [13] For public-key cryptography implementationsof Elliptic Curve Cryptography (ECC [8]) on such sensorsare described in eg [6] and [14] Several previous worksfocused on the energy cost of key agreement protocols forWSN Based on the first implementations of ECC and RSAon 8-bit microprocessors by Gura et al [7] Wander et al [21]quantified the energy costs of ECC and RSA based digitalsignature and key exchange with mutual authentication fornetworks composed of Mica2dot sensors [11] They concludedthat these operations are affordable for such sensors In [18]Piotrowski et al assessed the energy consumption of mostcommon RSA and ECC operations for other sensor nodesIEEE International Conference on Wireless & Mobile Computing Networking & Communication978-0-7695-3393-3/08 $2500 © 2008 IEEEDOI 101109/WiMob200816580They based their assessments on the implementation resultsof [6] and on the datasheets of the sensors They found thatthe energy consumed by transmissions was at least one orderof magnitude less than the one required for the computation ofthe cryptographic operations Therefore they concluded thatit was not an important factor Hodjat and Verbauwhede [10]compared the cost of the protocols Kerberos and ECDH on32-bit WINS sensor nodes The cost of Diffie-Hellman wasfound between one to two orders of magnitude larger thanAES-based Kerberos Later Großscha¨dl et al [5] performedthe same comparison but with another version of Diffie-Hellman ECMQV on WINS nodes They found that the costof ECMQV was only up to twice the cost of Kerberos Toquantify the communication energy costs these two worksused transmission and reception per-bit costs based on mea-surements However this excludes the energy consumption ofpractical elements such as listening which happens when nodesare waiting for incoming packets of which the exact timesof arrival are uncertain We believe that this could result inunderestimated communication costs Therefore compared tothese previous works we take more into account the practicalaspects of the energy consumption for communicationIII ENERGY MODEL OF THE SENSORSIn this section we determine the energy models of thesensors MICAz and TelosB that we later use to estimate andanalyze the energy consumption of cryptographic protocolsThe MICAz is based on the low-power 8-bit microcontrollerATmega128L with a clock frequency of 737 MHz TheTelosB features the 16-bit MSP430 microcontroller running at4 MHz Both nodes run TinyOS and embed a IEEE 802154compliant CC2420 transceiver with a claimed data rate of 250kbpsTABLE IMEASURED POWER CONSUMPTION OF THE MICAZ RUNNING AT 737MHZ AND TELOSB AT 4 MHZ IN DIFFERENT OPERATING MODES THETRANSMIT POWER IS -5 DBMPower consumption MICAz TelosBTransmit 65 mW 54 mWListen 68 mW 60 mWReceive 72 mW 61 mWCompute 26 mW 48 mWSleep 25 µW 35 µWTable I presents the measured consumption of the mainoperating modes for both platforms The energy models areestablished in the following way For the cost of computationwe make the approximation that the overall power consump-tion of the node while computing remains constant with thetype of microcode operation performed Therefore the costof a particular computation can be assessed knowing the per-cycle mean energy consumption and the total number of cyclesof the computation This simplifying assumption was verifiedby Law et al in [13] for the sensor node used in the EYESproject [2] which is quite similar to the TelosB This assump-tion is also used in the power estimator PowerTOSSIM [20]TABLE IIENERGY COSTS OF COMMON OPERATIONS ON THE MICAZ RUNNING AT737 MHZ AND TELOSB AT 4 MHZ FOR APPLICATION DATA RATES OFRESPECTIVELY 108 KBPS AND 75 KBPS THE EQUIVALENCE IN NUMBEROF CYCLES OF COMPUTATION IS INDICATED IN PARENTHESISEnergy cost MICAz TelosBCompute for 1 Tclk 35 nJ (1) 12 nJ (1)Transmit 1 bit 060 µJ (170) 072 µJ (600)Receive 1 bit 067 µJ (190) 081 µJ (680)Listen for 1 Tclk 92 nJ (3) 150 nJ (13)Sleep for 1 Tclk 3 pJ (10−3) 9 pJ (10−2)for the Mica2 sensor node (similar to the MICAz) with amean error of 5% For the communication cost we measuredthe effective data rates and the consumption in the transmitlisten and receive modes The measured data rates 121 kbpsand 94 kbps for the MICAz and TelosB respectively are farbelow the claimed rates (250 kbps) The important differencewith the claimed data rate (250 kbps) has also been reportedin [17] The presence of footers and headers and the useof acknowledgment further decrease the rates available forapplication data to respectively 108 kbps and 75 kbps Ourenergy costs of Table II based on the measurement results ofTable I assume these data rates and a typical transmit powerof -5 dBmThe consumption in the listening mode is almost as highas for reception (see Table I) because the transceiver is alsoactive in this mode This mode could cause considerableenergy losses if nodes need to listen during long periodsTherefore it should be avoided as much as possible in orderto save energy That is the goal of Low Power Listening(LPL) protocols that save energy at the expense of greaterlatencies in the communications They make the time spentin listen mode less important from an energy point of viewIn TinyOS the LPL protocol available for nodes equippedwith a CC2420 radio (see [15]) is based on B-MAC [19]In this protocol the receiving radio modules are periodicallyturned on to check for activity on the channel and remainactive only if a packet is being transmitted Sending nodesmust be kept retransmitting the same packets until the checksof the receivers The consumption of a listening node canarbitrary be reduced by increasing the sleep interval (iethe delay between two checks) However this is done at theexpense of increased synchronization energy costs for sendersthat have to retransmit during a longer period before thechecks of the receivers After a successful transmission boththe sender and the receiver keep their radio on for a smalldelay (the delay after transmission) in case of a consecutivepacket transmission This generates a post-transmission costfor both the sender and the receiver In this work we chosethe typical values of respectively 10 ms and 100 ms for thedelay after transmission and the sleep interval while the checkduration is a constant of 5 ms Accordingly we estimatedthe energy costs due to LPL as indicated in Table III basedon measurements Note that the send synchronization cost is amean cost (based on the mean delay of almost 50 ms before the581TABLE IIIENERGY COSTS OF THE LPL PROTOCOL FOR THE MICAZ AND TELOSBTHE EQUIVALENCE IN NUMBER OF CYCLES OF COMPUTATION ISINDICATED IN PARENTHESISEnergy cost MICAz TelosBListen for 1 Tclk 04 nJ (01) 07 nJ (06)Send synchronization 309 mJ (11 M) 257 mJ (26 M)Post-transmission 068 mJ (02 M) 060 mJ (05 M)ATB12341: AB nA2: {kAB  B tS  tE  nA} kAT  {kAB  A tS  tE}kBT3: {kAB  A tS  tE}kBT  {A tA}kAB4: {tA}kABFig 1 The simplified Kerberos protocolcheck of the receiver) The post-transmission cost refers to theenergy spent by both sender and receiver during the delay aftertransmission We use the energy costs of Table II and Table IIIas energy models to predict the energy cost of protocols on theMICAz and TelosB platforms It takes as input the number ofcycles of computation the number of bits communicated thenumber of synchronizations and transmissions (if using LPL)and the time spent in listen modeIV ENERGY CONSUMPTION OF KEY AGREEMENTPROTOCOLSIn this section we use the energy models of Section III toassess and analyze the energy cost of cryptographic protocolsAs an example we focus on two key agreement protocolsKerberos and ECDH-ECDSA We first describe these proto-cols then assess the cost of the cryptographic operations andcommunicationsA Protocols descriptionThe establishment of shared secret keys between nodes is afirst step to provide other security services such as encryptionin WSN This could be achieved by means of pre-deployedshared keys but it raises problems of storage of the keys inlarge networks and of resiliency to node compromise There-fore a solution is to use key distribution or key agreementprotocols after the deployment of the nodes In this work wecompare two of these protocolsThe first protocol is Kerberos [16] a key distributionscheme built on secret-key cryptography which authenticatesthe participants We use its simplified version described in[5] In this protocol (see Figure 1) the two entities A and Bwishing to establish a shared secret key kAB already sharea secret key (kAT and kBT respectively) with a trusted thirdparty T There is first an exchange of messages between A andT The request of A contains the identities of A and B In theA B(kA QA) (kB  QB)nAnB  certBcertA FinishedFinishedVerify certBVerify certAPremaster= kA ·QBPremaster= kB ·QAFig 2 The ECDH-ECDSA protocolreply the key kAB generated by T is encrypted with the keyskAT and kBT  Then A recovers the key kAB and forwardsto B the piece of the message encrypted with kBT togetherwith its identity encrypted with kAB  Finally B recovers kABand sends back to A a timestamp encrypted with kAB  Replayattacks are avoided thanks to a timestamp tA a nonce nA andexpiration times tS  tE The second protocol is ECDH [8] the Diffie-Hellman keyagreement based on Elliptic Curve Cryptography (ECC [8])which does not need any trusted third party In its standardform ECDH does not provide authentication Therefore weuse the version known as ECDH-ECDSA in [1] In thisversion authentication is provided through certificates ver-ified using the Elliptic Curve Digital Signature Algorithm(ECDSA [8]) Thus the two parties A and B must possessa certificate generated by an authority They agree to use thesame curve parameters and generate in advance their privatekeys kA and kB and corresponding public keys QA = kA ·Gand QB = kB ·G where G is the generator of the group definedby the elliptic curve This protocol is described in Figure 2First A and B exchange random nonces Then B sends itscertificate to A (its public key signed by the authority usingECDSA) After the certificate verification A uses his privatekey and B’s public key to perform a point multiplication andarrive to a common secret kA · kB · G which is used withthe exchanged nonces to derive a shared secret key Then Asends its certificate to B who performs the same operationsto obtain the shared secret (kA · kB · G = kB · kA · G) andderive the shared secret key The possession of the sharedsecret key is proved in the ability of both parties to encryptthe hash of the exchanged nonces and their identities withthe shared secret key (ie {hash(nA nB  A)}kAB for A and{hash(nA nB  B)}kAB for B) These results forming thecontent of Finished messages are exchanged at the end ofthe protocol Remark that ECDH-ECDSA could be performedin three rounds only This is possible if A adds its certificate inthe first message In this case B can generate the Finishedmessage at this point and add it in its reply Therefore thelast message of the protocol becomes unnecessary In thefollowing we refer to the 4-round version of the protocolunless otherwise specified582TABLE IVESTIMATED ENERGY COSTS OF CRYPTOGRAPHIC OPERATIONS FOR THEMICAZ AND TELOSB THE NUMBER OF CYCLES OF COMPUTATION ISINDICATED IN PARENTHESISEnergy cost MICAz TelosBAES-128 128-bit encrypt 38 µJ (10742) 9 µJ (7483)ECC-160 point mult 55 mJ (156 M) 17 mJ (140 M)ECDSA-160 sign 52 mJ (147 M) 15 mJ (127 M)ECDSA-160 verify 63 mJ (180 M) 19 mJ (162 M)B Cost of cryptographic operationsWe assess the energy costs of the cryptographic operationsplaying a part in Kerberos and ECDH-ECDSA using theenergy model of the sensors (cf Section III) and the numberof cycles of computation from known implementations Forthe symmetric encryption employed in Kerberos we use theimplementation results of Healy et al [9] They implementedAES (128-bit keys) on the microcontrollers of both MICAzand TelosB nodes We assess the ECC point multiplicationsand ECDSA verifications involved in ECDH-ECDSA relyingon the results of Liu et al [14] They implemented ECC andECDSA in TinyOS for many platforms including MICAz andTelosB We use their results for the secp160r1 elliptic curvedomain parameters (160-bit keys) While the performances ofTinyECC are worse in terms of speed than the implementationof Gura et al [7] the code is publicly available ECDSAoperations include the cost of hashing 512 bits using SHA-1 Table IV shows the estimated energy costs of these crypto-graphic operations The cost of symmetric encryption is negli-gible compared to elliptic curve operations ECDSA signatureinvolving one point multiplication is however less costly thana full point multiplication thanks to pre-computations Thenumber of cycles for elliptic curve computations does notdiminish much on the TelosB (however based on a 16-bitmicrocontroller) because the implementation available for thisplatform is less optimizedWe estimate the cost of the computations for both protocolsbased on the assessments of Table IV For Kerberos thecomputations consist in the encryption and decryption of 8blocks of 128 bits (assuming 64-bit timestamps and nodeIDs and a 32-bit nonce) As a result the cost of Kerberos isrespectively 061 mJ and 014 mJ on the MICAz and TelosBFor ECDH-ECDSA each party mainly achieves an ECDSAverification and a point multiplication The key derivation andsymmetric encryption of the nonces and nodes IDs can beneglected considering the relative small cost of AES withrespect to ECC operations (see Table IV) It leads to an energycost for ECDH-ECDSA of respectively 236 mJ and 72 mJ onthe MICAz and TelosB ECDH-ECDSA is more than 2 ordersof magnitude more costly than Kerberos on both platformsThis was expected as elliptic curve operations are much morecostly than AES-based encryption The costs of both protocolsare around 4 times lower on the more energy-efficient TelosBTABLE VESTIMATED COMMUNICATION ENERGY COSTS OF KERBEROS FOR THEMICAZ AND TELOSBCommunication cost MICAz TelosBKerberos (mJ)Send 09 11Receive 11 13LPL listen 02 02LPL synchro 116 99Total 138 125TABLE VIESTIMATED COMMUNICATION ENERGY COSTS OF ECDH-ECDSA FORTHE MICAZ AND TELOSBCommunication cost MICAz TelosBECDH-ECDSA (mJ)Send 13 16Receive 15 18LPL listen 295 43LPL synchro 147 125Total 470 589C Communication and total energy assessmentHere we assess the communication energy costs of theprotocols Together with the computation costs of the previoussection they make it possible to obtain the total costs ofthe protocols The communication costs are composed of thecost of transmission reception and listening For transmissionand reception we make use of the per-bit costs presented inTable II The total number of bits communicated in Kerberosis 1568 and 2208 in ECDH-ECDSA (assuming 86-byte cer-tificates 32-byte nonces and 20-byte Finished messages asin [6]) For listening we use the energy costs (see Table III)of the LPL protocol of Section III and the total listeningdurations of the protocols During the run of a protocol a partyis listening during a delay corresponding to the processingof the preceding message by the other party and the latencyof the communications For the MICAz and TelosB thelistening durations are respectively 91 s and 151 s for ECDH-ECDSA and 70 ms and 80 ms for Kerberos The largerdurations for ECDH-ECDSA is due to longer computationswith respect to Kerberos Synchronization costs appear foreach transmission except when the nodes answer a previoustransmission within the delay after transmission of 10 ms (egB immediately answers the first message of A in ECDH-ECDSA) The estimated communication costs for Kerberosand ECDH-ECDSA on the MICAz and TelosB nodes areshown in Tables V and VI They are higher for ECDH-ECDSAmainly because of the high listening cost due to the longcomputation delays of this protocol However one could savethe major part of the LPL listening energy loss by temporarilyincreasing the sleep interval when waiting for cryptographicresults This requires to know in advance the durations of thecomputations If the sleep intervals fit the durations of thecomputations (with a security margin of 025 s) 90% of theLPL listening energy cost can be saved in ECDH-ECDSA Bydoing this the communication costs of ECDH-ECDSA would583not be much more than those of Kerberos That would be doneat the expense of loosing connectivity during the run of theprotocol what may not be desirable to preserve the abilityto quickly react in case of emergency It seems difficult toobtain further reduction of the energy consumed by the LPLprotocol available in TinyOS Other LPL protocols could beinvestigated such as eg S-MAC [22] In this protocol nodesare synchronized on sleep schedules However this approachrequires the periodic exchange of synchronization informationwhat also consumes energyRemark that besides the energy aspect the long durationsof the computations in ECDH-ECDSA can be unpractical egin situations where a node has to perform several runs of theprotocol in a rowGathering the computation and communication costs foundabove provides the total costs for the protocols shown inTables VII and VIII ECDH-ECDSA is close to respectively20 times and 10 times more costly than Kerberos on MICAzand TelosB Communications compose almost exclusively thecost of Kerberos as opposed to ECDH-ECDSA For bothprotocols the relative importance of communications growsfor the TelosB which has a lower computational costTABLE VIIESTIMATED TOTAL ENERGY COSTS OF KERBEROS FOR THE MICAZ ANDTELOSBKerberos MICAz TelosBcost (mJ)Comp 06 (4%) 014 (1%)Comm 138 (96%) 125 (99%)Total 144 1264TABLE VIIIESTIMATED TOTAL ENERGY COSTS OF ECDH-ECDSA FOR THE MICAZAND TELOSBECDH-ECDSA MICAz TelosBcost (mJ)Comp 236 (83%) 72 (55%)Comm 47 (17%) 589 (45%)Total 283 1309With the LPL protocol employed the synchronization costof ECDH-ECDSA would not decrease much if it was per-formed using three messages as described at the end ofSection IV-A It would be only a slight reduction since in the3-message version B is no more able to quickly answer afterthe first message of the protocol (at this point B must performthe computations) Consequently an extra synchronizationcost would be required at this point what would almostcounterbalance the reduction This is due to a feature of theLPL protocol employed which allows quick replies withoutloosing the synchronization between the nodesV COMPARISON WITH RELATED RESULTSAs described in Section II two previous works alreadycompared the energy cost of Kerberos and the Diffie-Hellmankey exchange on sensor nodes First there is the work byHodjat and Verbauwhede They used the standard version ofECDH which does not provide any authentication They foundthat ECDH was between one to two orders of magnitudelarger than Kerberos on WINS nodes This is similar toour results of preceding section on the MICAz and TelosBHowever for the same amount of energy (140 mJ) WINSnodes can run Kerberos while TelosB nodes can perform anECDH-ECDSA key exchange This illustrates the importantimpact of the hardware The WINS node which contains amore powerful microprocessor (32-bit 133 MHz) consumesmuch more energy than the TelosB The authors obtainedthe energy cost of computations by measuring the timingperformances of their implementations of both protocols onthe WINS node For the communications they used a per-bit cost obtained through measurements in a previous workThey did not include the cost of listening in their estimatesThey obtained a cost of ECDH composed of more than 98%of computation and a cost of Kerberos made of more than75% of communications Compared to our results the relativeimportance of communication in the costs is much lowerSecond Großscha¨dl et al also compared AES-based Ker-beros with ECMQV a variant of ECDH that provides au-thentication on WINS nodes Their goal was to update theresults of Hodjat and Verbauwhede as progress had beenmade in efficient implementation of ECC since then Theyfound that the ECMQV was only up to twice as costly asKerberos on the WINS node ECMQV assumes that bothparticipants have already exchanged their long-term publickeys For large networks this means a large number of storedkeys per node which may not be desirable Therefore theexchange and verification of the long-term public keys couldbe included in the cost of this protocol The authors estimatedthe cost of computations and communications as Hodjat andVerbauwhede Similarly they did not take the listening costinto account They found that the cost of Kerberos was almostexclusively composed of computation and that the cost ofECMQV was made of around two thirds of communicationsIncluding the cost of listening in their estimates is likely tohave a more important impact for both protocols as the relativecost of communications is higher than in the results of Hodjatand VerbauwhedeTwo other works assessed the energy cost of ECC operationson sensors similar to the MICAz and TelosB First Wander etal [21] quantified the energy costs of ECDSA operations andECC-based certified key exchange (similar to ECDH-ECDSA)on a platform similar to the MICAz the Mica2dot [11]They found a cost of 188 mJ for the key exchange on theMica2dot This is lower than our estimation on the MICAzbecause they used a faster implementation (of which the codeis not publicly available) They based their estimations onperformance measurement of the ECC point multiplicationpresented in [7] for the computations The cost of communica-tion was estimated based on measurements on the Mica2dotThe authors mentioned the importance of listening Howeverthey did not include this element in the communication costwhich still amounts to 22% of the total cost Interestingly they584examined the relative importance of the costs of computationand communication pointing out that computation is cheapcompared to data transmissionSecond Piotrowski et al [18] extended the results of Wan-der et al on other sensor nodes including MICAz and TelosBThey deduced the processing times and energy consumptionsfor ECDSA operations and the computational part of theuncertified key exchange from the results of Wander et alFor this purpose they made use of performance and powerconsumption ratios They found a cost of respectively 53 mJand 12 mJ for the computations of ECDH on the MICAzand the TelosB Compared to our results it is much lowersince the uncertified key exchange is computationally muchless costly Moreover these results also refer to the moreefficient implementations of [7] Piotrowski et al assessedthe communication energy costs based on the datasheets ofthe transceivers They concluded that the communication costwas not an important factor when comparing cryptographicalgorithms on WSN We showed that this conclusion does notapply when practical elements were taken into account suchas listening the consumption of the microcontroller duringtransmissions and the real datarateVI CONCLUSIONOur work provides a methodology to assess the real cost ofcryptography on WSN nodes Special care was dedicated toconsider practical elements to assess the cost of communica-tions Using this methodology we assessed the energy costs oftwo key agreement protocols Kerberos and ECDH-ECDSAon the MICAz and TelosB nodes Our estimates confirm theadvantage of Kerberos what was noted in previous works Wefind that Kerberos is around respectively 20 times and 10 timesless costly than ECDH-ECDSA on the MICAz and TelosBTherefore it should be preferred in situations where a trustedthird party is available (eg a secure base station) As opposedto previous works the energy cost of listening is includedin our assessments resulting in higher communication costsIt can remain significant even when minimized using a LPLprotocol Therefore it should be considered when assessingthe cost of cryptographic protocols on WSN nodes A highlistening cost makes that the number of exchanged messagesin the protocol is very important Our work also providespractical insights on the relative costs of computation andcommunication in WSN It could therefore be useful to studythe interest of techniques trading the cost of computations forcommunications Eg the energy models we provide couldbe used as a base to study the interest of techniques tradingthe cost of computations for communications such as [4]For the nodes considered the relatively high communicationcost suggests that such schemes could be less efficient thanexpected A thorough analysis of the energy gain of suchtechniques could be a part of a future workREFERENCES[1] S Blake-Wilson T Dierks and C Hawk ECC cipher suites for TLSTransport Layer Security Working Group Internet draft available fromhttp://toolsietforg/id/draft-ietf-tls-ecc-01txt 2001[2] EYES European research project on self-organizing and collaborativeenergy-efficient sensor networks http://wwweyeseuorg/[3] A Freier P Karlton and P Kocher The SSL protocol version 30Transport Layer Security Working Group Internet draft available fromhttp://wpnetscapecom/eng/ssl3/draft302txt November 1996[4] M Girault and D Lefranc Server-aided verification: theory and practiceIn Bimal Roy editor Advances in Cryptology - Asiacrypt’05 number3788 in Lecture Notes in Computer Science pages 605–623 Springer2005[5] J Großscha¨dl A Szekely and S Tillich The Energy Cost of Crypto-graphic Key Establishment in Wireless Sensor Networks In Robert HDeng and Pierangela Samarati editors Proceedings of the 2nd ACMSymposium on Information Computer and Communications Security(ASIACCS 2007) pages 380–382 ACM Press 2007[6] V Gupta M Millard S Fung Y Zhu N Gura H Eberle and S CShantz Sizzle: A standards-based end-to-end security architecture forthe embedded Internet In PERCOM ’05: Proceedings of the Third IEEEInternational Conference on Pervasive Computing and Communicationspages 247–256 Washington DC USA 2005 IEEE Computer Society[7] N Gura A Patel A Wander H Eberle and S C Shantz ComparingElliptic Curve Cryptography and RSA on 8-bit CPUs In CHES pages119–132 2004[8] D Hankerson A Menezes and S Vanstone Guide to Elliptic CurveCryptography Springer-Verlag New York Inc Secaucus NJ USA2003[9] M Healy T Newe and E Lewis Efficiently securing data on a wirelesssensor network In Journal of Physics Conference Series volume 76Issue 1 2007[10] A Hodjat and I Verbauwhede The energy cost of secrets in ad-hocnetworks In Proc IEEE Circuits and Systems Workshop on WirelessCommunications and Networking page 4 2002[11] Crossbow Technology Inc Crossbow product information Available athttp://wwwxbowcom/Products/productdetailsaspx?sid=156[12] BC Lai D Hwang S Kim and I Verbauwhede Reducing radioenergy consumption of key management protocols for wireless sensornetworks In Proc ACM/IEEE International Symposium on Low PowerElectronics and Design (ISLPED 2004) pages 351–356 ACM Press2004[13] Y Law J Doumen and P Hartel Survey and benchmark of blockciphers for wireless sensor networks ACM Trans Sen Netw 2(1):65–93 2006[14] A Liu and P Ning TinyECC: A configurable library for Elliptic CurveCryptography in Wireless Sensor Networks Technical Report TR-2007-36 North Carolina State University Department of Computer Science2007[15] D Moss J Hui P Levis and J Choi Cc2420 radio stack TinyOSCore Working Group draft available at http://wwwtinyosnet/tinyos-2x/doc/pdf/tep126pdf 2007[16] B Neuman and T Ts’o Kerberos: An authentication service forcomputer networks IEEE Communications 32(9):33–38 1994[17] J Paek K Chintalapudi R Govindan J Caffrey and S Masri Awireless sensor network for structural health monitoring: performanceand experience In EmNets ’05: Proceedings of the 2nd IEEE workshopon Embedded Networked Sensors pages 1–9 Washington DC USA2005 IEEE Computer Society[18] K Piotrowski P Langendoerfer and S Peter How public key cryptogra-phy influences wireless sensor node lifetime In SASN ’06: Proceedingsof the fourth ACM workshop on Security of ad hoc and sensor networkspages 169–176 New York NY USA 2006 ACM[19] J Polastre J Hill and D Culler Versatile low power media accessfor wireless sensor networks In SenSys ’04: Proceedings of the 2ndinternational conference on Embedded networked sensor systems pages95–107 New York NY USA 2004 ACM Press[20] V Shnayder M Hempstead B Chen and M Welsh PowerTOSSIM:Efficient power simulation for TinyOS applications In ACM Conferenceon Embedded Networked Sensor Systems (SenSys) 2004[21] A Wander N Gura H Eberle V Gupta and S C Shantz Energyanalysis of public-key cryptography for wireless sensor networks InPervasive Computing and Communications 2005 PerCom 2005 ThirdIEEE International Conference on pages 324–328 2005[22] W Ye J Heidemann and D Estrin An energy-efficient MAC protocolfor wireless sensor networks In Proceedings 21st International AnnualJoint Conference of the IEEE Computer and Communications SocietiesNew York New York USA 2002585
The energy cost of secrests in Ad-Hoc networks-pdf,The Energy Cost of Secrets in Ad-hoc Networks (Short Paper)  Alireza Hodjat ahodjat@eeuclaedu  Ingrid Verbauwhede ingrid@eeuclaeduDepartment of Electrical Engineering University of California Los Angeles Los Angeles CA-90024  Abstract  Energy consumption of cryptographic algorithms and security protocols is a crucial factor in wireless ad-hoc networks This work explores the energy cost of a key agreement process between two parties of an ad-hoc network using public-key encryption techniques and compares the results with regular networks which use secret-key based key-exchange protocols Elliptic Curve public-key and Rijndael AES secret-key algorithms are chosen to explore the energy cost of Diffie-Hellman and Kerberos key agreement protocols on a WINS sensor network The results show that the total energy cost of the Diffie-Hellman key agreement process using Elliptic Curve point-multiplication in an ad-hoc network is between one to two orders of magnitude larger than the key exchange process based on the AES secret-key algorithm in a regular non ad-hoc network  1 Introduction  Low-energy security is a crucial requirement for wireless networks The very first step in providing security to a wireless network is the key distribution and key agreement process Symmetric or asymmetric techniques can be used for key exchange between parties in a wireless network Protocols based on asymmetric-key encryption algorithms are the main solution for ad-hoc wireless networks because there is no need for a trusted third party in these protocols On the other hand symmetric-key encryption algorithms are applicable to the wireless networks with base stations      The main goal of this paper is to compare the energy cost of security for wireless ad-hoc networks versus non ad-hoc networks which use base stations as their trusted parties In order to achieve this we explore the energy consumption of the key agreement process between two parties using both symmetric-key and asymmetric-key encryption algorithms     The platform used for this purpose is the Wireless Integrated Network Sensor WINS is a StrongARM based wireless sensor network which was developed at Rockwell Scientific [1] In the first step symmetric-key and asymmetric-key encryption algorithms are implemented on the WINS nodes More specifically the Rijndael AES secret-key and Elliptic Curve public-key encryption algorithms are chosen The energy consumption for these algorithms is measured for different data and key lengths      In the next step we explore the energy cost of a public-key and a secret-key based key exchange protocol and examine their suitability for low-power wireless networks In the implementation of the whole security protocol the cost of communication between nodes must be considered as well  Therefore the whole energy cost consists of the energy consumption of computation and communication The number of packets exchanged between parties and the energy cost of radio transmission influences the overall communication cost and the type of encryption algorithm affects the energy cost of computation in each protocol      The rest of this paper is organized as follows: In section 2 we explain the Rijndael AES secret-key and Elliptic Curve public-key cryptography algorithms and present their energy cost on WINS nodes Section 3 discusses the energy cost of communication for the WINS nodes In section 4 the Diffie-Hellman and Kerberos key distribution protocols are presented and the energy cost of implementing these protocols on ad-hoc and non ad-hoc networks is explored Sections 5 and 6 present our conclusion and future work   2 Energy results for AES and ECC  In this section we explore the energy cost for the underlying encryption algorithms - Rijndael AES and Elliptic Curve Cryptography (ECC) AES is the secret-key encryption standard most recently accepted by NIST Other choices for secret-key techniques are DES and RC4 AES was chosen due to the fact that it is more secure and more complex compared to DES and RC4 Moreover it is more useful in exploring the upper bound of energy for non ad-hoc networks As for public-key algorithms the choices are RSA and ECC ECC has recently gained prominence among public-key algorithms Furthermore RSA is more complex and will require much more energy than ECC and hence is not suitable for ad-hoc networks   Rijndael Symmetric-key Algorithm     This algorithm was accepted as the Advanced Encryption Standard by NIST [2] It consists of key scheduling encryption and decryption primitives [3] Key scheduling produces a long array of sub-keys by key expansion and round key selection routines This long array of sub-keys is used in each round of encryption or decryption phase to be added to data Depending on the key and data size encryption and decryption algorithms are repeated between 10 to 14 rounds In the encryption primitive byte substitution transformation shift row transformation mix column transformation and round key addition are performed [3] In decryption the steps are the same as those performed in encryption However they are called in reverse order and the substitute table shift indexes and fixed polynomials used in the decryption steps are the reverse of those used in encryption      Figure 1 shows the energy consumption of Rijndael AES encryption and decryption algorithms for different data and key lengths In the original Rijndael algorithm the input data and key blocks are in the range of 128 192 or 256 bits and the output has the corresponding size The energy consumption for encryption and key scheduling varies from 031 mJoules to 085 mJoules depending on the choice of data and key size For decryption and key scheduling the variation is from 036 mJoules to 101 mJoules The energy consumption of decryption is 30% more than encryption The main reason for this difference is the number of shifts performed in the shift row routine and the larger GF(28) elements used in mix column transformation routine Elliptic Curve Asymmetric-key Algorithm     This algorithm is based on the IEEE P1363/D1 public-key cryptography standard [4] We use the efficient double-add-subtract point-multiplication algorithm defined by this standard Elliptic Curve point-multiplication refers to calculating kP when k is an integer and P is a point on the Elliptic Curve The theory of the Elliptic Curve Public-key cryptography is based on the mathematical mapping of an Elliptic Curve on a Galois field The Elliptic Curve points on GF(2n) and the point in infinity form a group with a specific addition operation [4] With this definition kP is equivalent to adding P to itself k times by the group operation     Figures 2 3 and 4 show the energy consumption of point multiplication for key lengths of 128 192 and 256 bits respectively The execution time and the energy for the ECC algorithm strictly depend on the bit pattern of the initial random key k Therefore the upper bound and lower bound of energy was measured In order to calculate the lower bound of energy there should be only doubles in the point-multiplication calculation Similarly in order to calculate the upper bound there should be a full number of doubles and the maximum number of additions and/or subtractions     In these figures the X-axis shows the size of the initial random key k of point-multiplication This is identical to Encryption                                             Decryption 002040608112256 192 128 256 192 128Data SizeEnergy (mJoules)256-bit Key 192-bit Key 128-bit KeyFigure 1: The energy cost of Rijndael AES algorithm on WINS (key scheduling + encryption or decryption) 4134702819132622623237351025284890681774601002003004005006007008000 16 32 48 64 80 96 112 128 144Size of the initial key (k)Energy (mJoule)Figure 2: The energy cost of ECC point-multiplication for 128-bit session key133224052032072093114188151130760380051152250 32 64 96 128 160 192 224Size of the initial key (k)Energy (Joule)Figure 3: The energy cost of ECC point-multiplication for 192-bit session key3062732382031681320970625194543883232581951306401234560 32 64 96 128 160 192 224 256 288Size of the initial key (k)Energy (Joule)Figure 4: The energy cost of ECC point-multiplication for 256-bit session keythe number of doubles for each experiment Also in the case of the upper bound this axis shows twice the number of adds and/or subtracts The Y-axis shows the energy consumption in terms of mJoules or Joules For instance if the size of k is 64 for 128-bit point multiplication (figure 2) then the energy consumption will be between 2262 and 35102 mJoules depending on the 0 and 1 pattern in k In this case 64 doubles are performed for the lower limit and 64 doubles and 32 adds or subtracts are performed for the upper limit      The results show that the energy consumption of one Elliptic Curve point-multiplication for the 128-bit key varies from 0082 to 0702 Joules For the 192-bit key the variation is between 032 to 224 Joules In the case of the 256-bit key the energy cost range is between 062 to 519 Joules Also the average energy cost is 030 107 and 234 Joules for the 128 192 and 256-bit key respectively All of the above measurements are done on StrongARM based WINS node running at 133 MHz   3 Communication costs  [5] presents the power consumption of the radio transmission on WINS nodes Radio’s power consumption varies between 396 to 711 mWatts depending on the transmission power level This corresponds to a consumption of 771 to 1080 mWatts for the whole sensor node The power consumption of the receive mode is 376 mWatts for the radio and 751 mWatts for the whole node All these numbers are at a transmission rate of 100 kbits/s  4 Key-exchange energy consumption  [6] introduces Diffie-Hellman and basic Kerberos as two solutions for the key distribution and key agreement problem Diffie-Hellman key agreement protocol is implemented using a public-key encryption algorithm It is applicable to ad-hoc networks due to the fact that it does not require a trusted third party in the key agreement process Using this protocol any two nodes in an ad-hoc network can agree on their common session key without any trusted node or secure link On the other hand basic Kerberos is a key-distribution protocol that is based on a secret-key encryption technique It is suitable for non ad-hoc networks with base stations since it requires a trusted party in the key-exchange process In this experiment on WINS nodes the Diffie-Hellman protocol is implemented using the Elliptic Curve public-key cryptography technique and the Kerberos protocol is based on the Rijndael AES secret-key cryptography algorithm In the following paragraphs these protocols are described and their energy consumption is explored It is assumed that the two nodes performing the key-agreement process are called Alice and Bob and if needed their trusted party is called Trent     In the Diffie-Hellman protocol based on Elliptic Curve point-multiplication there is a common elliptic curve and a  Diffie-Hellman 128-bits 192-bits 256-bits Four times point multiplication with average energy cost  4 × 300 mJoules  4 × 1070 mJoules  4 × 2340 mJoules Packet size 128+256 192+256 256+256 Energy cost per packet transmission at maximum power level  405 mJoules  4725 mJoules  108 mJoules Energy cost per packet arrival 280 mJoules 325 mJoules 751 mJoules Total (mJoules) 12137 4296 93783 Table 1: Diffie-Hellman based on Elliptic-Curve  specific point on it that is publicly known Alice and Bob each generate a random initial key called a and b They apply point-multiplication on the common elliptic curve point P They exchange their results Then they apply point-multiplication on the received data (aP or bP)  with their own random initial key again and generate abP This is their common session key Both can generate abP but no one else can generate it without knowing a and b It can be shown that it is practically infeasible to generate abP from aP bP and P      In this protocol Alice does two elliptic curve point-multiplications (calculating aP and abP) once transmits her results to Bob (aP) and once listens to receive Bob’s results (bP) Bob also follows the same process Therefore this protocol requires four Elliptic Curve point-multiplications as the computation part and two data transmissions and two data receptions for the communication part      Table 1 shows the energy exploration of Diffie-Hellman protocol using Elliptic Curve point-multiplication A header of 256 bits wide is used for each data transmission and the data is either 128 192 or 256 bits wide As it is shown the average energy consumption of point-multiplication is used in each case based on the results of section 2 Transmission is at the rate of 100 kbits/s and the energy is calculated based on the maximum transmission power level From section 3 it is observed that the transmission costs maximum 1080 mWatts and the reception 751 mWatts As shown in Table 1 the whole energy cost of one Diffie-Hellman key-agreement protocol in an ad-hoc network is 12137 mJoules 4296 mJoules and 93783 mJoules for key lengths of 128 192 and 256 bits respectively     In the basic Kerberos protocol based on the AES secret-key encryption technique Alice and Bob agree on a common session key with the help of their trusted third party Trent Here we focus on the original basic Kerberos key agreement protocol using secret-key encryption technique [6] We do not discuss the Kerberos network authentication protocol that is used in client/server applications     Alice and Bob want to agree on a common session key At the beginning both have a secret key to communicate securely with Trent For key agreement one of them suppose Alice sends a message to Trent asking for a secret session key This message includes Alice’s and Bob’s identities Trent generates the random session key K and encrypts it along with timestamp T and lifetime L and Alice or Bob’s identity separately The message for Alice is encrypted with Alice’s secret-key and Bob’s identity and vice versa The results are EA(KBTL) and EB(KATL) These messages are sent to Alice  Now Alice can decrypt her received message to recover K Then she makes a message including her identity and timestamp T and encrypts it with K (EK(AT)) She sends both EB(KATL) and EK(AT) to Bob Now Bob can decrypt the received messages and recover K He also verifies Alice’s identity and then forms a message with T+1 and encrypts it with K and sends it again to Alice Alice decrypts this message and verifies the timestamp T Now Alice and Bob have a secret common shared key K This process is shown in figure 5     In this protocol there are four data encryptions on the transmitted data and four decryptions on the received data The total number of transmissions and receptions is six each Table 2 shows the upper bound energy consumption of this protocol using the Rijndael AES secret-key algorithm The packets of size 1 kbits include the header Alice and Bob’s identity the timestamp the lifetime and the generated random session key K K can be 128 192 or 256 bits wide In order to calculate the upper bound of energy consumption the maximum power level is considered in transmission Therefore the transmission power of 1080 mWatts results in energy consumption of 108 mJoules for the transmission of 1-kbit packet at 100 kbits/s Accordingly the reception power is 751 mWatts which shows the energy consumption of 751 mJoules  The encryption and decryption are performed on the block of data with 256-bit length that consumes maximum of 085 mJoules and 101 mJoules for encryption and decryption respectively Table 2 shows that the energy consumption for Kerberos key-agreement protocol is less than 140 mJoules This is true for key length of 128 192 or 256 bits  5 Conclusion  Our measurements on WINS nodes show an energy cost of maximum 1 mJoule for the AES symmetric-key cryptography algorithm For the Elliptic Curve public-key cryptography algorithm the average energy consumption of one point multiplication varies between 300 to 2340 mJoules This cost is between two to three orders of magnitude larger than the AES algorithm This ratio influences the energy cost of the key agreement protocol on an ad-hoc network Diffie-Hellman key agreement protocol using Elliptic Curve point-multiplication in a typical ad-hoc network costs between 1214 to 9400 mJoules On the other hand it costs less than 140 mJoules to exchange keys with an AES-based Kerberos key distribution protocol in non ad-hoc networks This shows that on WINS nodes the energy cost of a key agreement process in an ad-hoc network using a public-key encryption technique like ECC is between one to two orders of magnitude larger than key agreement in regular networks with symmetric-key encryption algorithms like AES Therefore providing security for ad-hoc wireless networks with public-key algorithms is not only harder than non ad-hoc networks based on secret-key techniques but also it might cost between 10 to 100 times more energy  Kerboros Packet Size 1 kbits Upper bound of energy for encryption of  one packet 4 × 085 = 34 mJoules Upper bound of energy for decryption of one packet 4 × 101 = 404 mJoules Upper bound of energy for encryption in the whole protocol 4 × 34 = 136 mJoules Upper bound of energy for decryption in the whole protocol 4 × 404 = 1616 mJoules Total energy cost of transmission for full size packet 6 × 108 = 648 mJoules Total energy cost of reception for full size packet 6 × 751 = 4506 mJoules Total Energy (mJoules) 13962 Table 2: Kerberos based on Rijndael AES  6 Future Work  In order to generalize the conclusion it is helpful to explore the energy cost of the key agreement process for different cases Other radios such as Bluetooth or 80211 can be used Bluetooth’s transmission rate is on the order of a hundred kbits/s and its power consumption is in the range of mWatts For 80211 radio the transmission rate is in the range of Mbits/s and its power consumption is in the order of a hundred mWatts Therefore the communication cost is more for these radios Other encryption algorithms like DES RC4 or RSA can be used in software on processors or in hardware as ASICs This results in different costs for computation Exploring the energy cost of the above cases can guide us to find a security model for ad-hoc networks based on the communication/computation trade-off   References  [1] http://winsrockwellscientificcom/ [2] http://csrcnistgov/encryption/aes [3] J Daemen V Rijmen “AES Proposal: Rijndael” [4] IEEE P1363/D1 Standard Specification for Public-Key Cryptography November 1999 [5]   Savvides Park Sirvastava “On Modeling Networks of Wireless Microsensors” ACM Sigmetrics 02 [6] D R Stinson “Cryptography Theory and Practice” First Edition CRC Press 1995  Figure 5: Kerberos key agreement protocol (A  B) EA(KBTL)EB(KATL)EK(AT)     EB(KATL) EK(T+1) AliceTrent Bob
energy diffie-hellman-ECC-pdf,On the Energy Cost of Communication andCryptography in Wireless Sensor NetworksGiacomo de Meulenaer Franc¸ois Gosset Franc¸ois-Xavier Standaert and Olivier PereiraUCL/DICE Crypto GroupPlace du Levant 3Louvain-la-Neuve Belgium{giacomodemeulenaer francoisgosset fstandae olivierpereira }@uclouvainbeAbstract—Energy is a central concern in the deployment ofwireless sensor networks In this paper we investigate the energycost of cryptographic protocols both from a communication anda computation point of view based on practical measurementson the MICAz and TelosB sensors We focus on the cost oftwo key agreement protocols: Kerberos and the Elliptic CurveDiffie-Hellman key exchange with authentication provided bythe Elliptic Curve Digital Signature Algorithm (ECDH-ECDSA)We find that in our context Kerberos is around one order ofmagnitude less costly than the ECDH-ECDSA key exchange andconfirm that it should be preferred in situations where a trustedthird party is available We also observe that the power dedicatedto communications can become a central concern when the nodesneed to stay in listen mode eg between the protocol roundseven when reduced using a Low Power Listening (LPL) protocolTherefore listening should be considered when assessing the costof cryptographic protocols on sensor nodesI INTRODUCTIONWireless Sensor Networks (WSN) are composed of smallautonomous devices that process and communicate data ac-quired from the environment in which they are deployed Theirlow cost and rapidity of deployment make them particularly at-tractive for many applications such as health monitoring build-ing protection pollution detection battlefield management   For such applications there is a need of strong security How-ever sensor nodes being usually powered through batteries theenergy cost of security techniques can be prohibitive and musttherefore be minimized Various techniques can be adoptedto perform the cryptographic tasks in WSN As an examplekey exchange can be carried out by relying on methods fromsymmetric key cryptography (eg through Kerberos [16]) orfrom public-key cryptography (eg through various modes ofSSL/TLS [3]) Besides in order to provide better security fea-tures while preserving low communication and memory costdifferent techniques have been proposed that allow tradingbetween security communication and computation (eg [12]and [4]) In order to appreciate the practical effectivenessof these trading techniques in a specific WSN the cost ofcommunication and computation must be well understoodContradictions appear in previous works concerning the im-portance of the communication energy cost For instancetwo works ([18] and [21]) assessing the cost of public-keycryptography on similar hardware have opposed conclusionconcerning the importance of the communication energy costwhen comparing cryptographic algorithms in WSN Our goalis to assess and analyze the real cost of cryptography on WSNnodes This will help choosing directions to optimize the costof cryptography in low power WSN For this purpose weinvestigate the cost of cryptography through a case study basedon measurements on the MICAz [11] and TelosB [11] sensornodes We focus on two key agreement protocols Kerberosand ECDH-ECDSA the Elliptic Curve Diffie-Hellman keyexchange with authentication provided by the Elliptic CurveDigital Signature Algorithm (ie the ECC-based SSL/TLShandshake see [1]) We assess their energy cost using energymodels of the sensors based on measurements Our maincontributions are :1 a methodology to assess the real cost of cryptography onWSN nodes which makes it possible to establish the relativecosts of computation and communication2 the estimates of the key agreement protocols obtainedfor the MICAz and TelosB nodes They allow us to comparesymmetric and asymmetric techniques They point out theimportance of the idle listening consumptionThis paper is structured as follows Section II presents theprevious related works Then Section III explains how wedetermined the energy models of the sensors MICAz andTelosB Next Section IV provides an assessment and analysisof energy cost of Kerberos and ECDH-ECDSA followed bya comparison with related results in Section V Finally theconclusion is given in Section VIII PREVIOUS WORKSMany recent works investigate the usability of cryptographicalgorithms in the context of wireless sensor networks Forinstance symmetric encryption using AES is discussed in eg[9] and [13] For public-key cryptography implementationsof Elliptic Curve Cryptography (ECC [8]) on such sensorsare described in eg [6] and [14] Several previous worksfocused on the energy cost of key agreement protocols forWSN Based on the first implementations of ECC and RSAon 8-bit microprocessors by Gura et al [7] Wander et al [21]quantified the energy costs of ECC and RSA based digitalsignature and key exchange with mutual authentication fornetworks composed of Mica2dot sensors [11] They concludedthat these operations are affordable for such sensors In [18]Piotrowski et al assessed the energy consumption of mostcommon RSA and ECC operations for other sensor nodesIEEE International Conference on Wireless & Mobile Computing Networking & Communication978-0-7695-3393-3/08 $2500 © 2008 IEEEDOI 101109/WiMob200816580They based their assessments on the implementation resultsof [6] and on the datasheets of the sensors They found thatthe energy consumed by transmissions was at least one orderof magnitude less than the one required for the computation ofthe cryptographic operations Therefore they concluded thatit was not an important factor Hodjat and Verbauwhede [10]compared the cost of the protocols Kerberos and ECDH on32-bit WINS sensor nodes The cost of Diffie-Hellman wasfound between one to two orders of magnitude larger thanAES-based Kerberos Later Großscha¨dl et al [5] performedthe same comparison but with another version of Diffie-Hellman ECMQV on WINS nodes They found that the costof ECMQV was only up to twice the cost of Kerberos Toquantify the communication energy costs these two worksused transmission and reception per-bit costs based on mea-surements However this excludes the energy consumption ofpractical elements such as listening which happens when nodesare waiting for incoming packets of which the exact timesof arrival are uncertain We believe that this could result inunderestimated communication costs Therefore compared tothese previous works we take more into account the practicalaspects of the energy consumption for communicationIII ENERGY MODEL OF THE SENSORSIn this section we determine the energy models of thesensors MICAz and TelosB that we later use to estimate andanalyze the energy consumption of cryptographic protocolsThe MICAz is based on the low-power 8-bit microcontrollerATmega128L with a clock frequency of 737 MHz TheTelosB features the 16-bit MSP430 microcontroller running at4 MHz Both nodes run TinyOS and embed a IEEE 802154compliant CC2420 transceiver with a claimed data rate of 250kbpsTABLE IMEASURED POWER CONSUMPTION OF THE MICAZ RUNNING AT 737MHZ AND TELOSB AT 4 MHZ IN DIFFERENT OPERATING MODES THETRANSMIT POWER IS -5 DBMPower consumption MICAz TelosBTransmit 65 mW 54 mWListen 68 mW 60 mWReceive 72 mW 61 mWCompute 26 mW 48 mWSleep 25 µW 35 µWTable I presents the measured consumption of the mainoperating modes for both platforms The energy models areestablished in the following way For the cost of computationwe make the approximation that the overall power consump-tion of the node while computing remains constant with thetype of microcode operation performed Therefore the costof a particular computation can be assessed knowing the per-cycle mean energy consumption and the total number of cyclesof the computation This simplifying assumption was verifiedby Law et al in [13] for the sensor node used in the EYESproject [2] which is quite similar to the TelosB This assump-tion is also used in the power estimator PowerTOSSIM [20]TABLE IIENERGY COSTS OF COMMON OPERATIONS ON THE MICAZ RUNNING AT737 MHZ AND TELOSB AT 4 MHZ FOR APPLICATION DATA RATES OFRESPECTIVELY 108 KBPS AND 75 KBPS THE EQUIVALENCE IN NUMBEROF CYCLES OF COMPUTATION IS INDICATED IN PARENTHESISEnergy cost MICAz TelosBCompute for 1 Tclk 35 nJ (1) 12 nJ (1)Transmit 1 bit 060 µJ (170) 072 µJ (600)Receive 1 bit 067 µJ (190) 081 µJ (680)Listen for 1 Tclk 92 nJ (3) 150 nJ (13)Sleep for 1 Tclk 3 pJ (10−3) 9 pJ (10−2)for the Mica2 sensor node (similar to the MICAz) with amean error of 5% For the communication cost we measuredthe effective data rates and the consumption in the transmitlisten and receive modes The measured data rates 121 kbpsand 94 kbps for the MICAz and TelosB respectively are farbelow the claimed rates (250 kbps) The important differencewith the claimed data rate (250 kbps) has also been reportedin [17] The presence of footers and headers and the useof acknowledgment further decrease the rates available forapplication data to respectively 108 kbps and 75 kbps Ourenergy costs of Table II based on the measurement results ofTable I assume these data rates and a typical transmit powerof -5 dBmThe consumption in the listening mode is almost as highas for reception (see Table I) because the transceiver is alsoactive in this mode This mode could cause considerableenergy losses if nodes need to listen during long periodsTherefore it should be avoided as much as possible in orderto save energy That is the goal of Low Power Listening(LPL) protocols that save energy at the expense of greaterlatencies in the communications They make the time spentin listen mode less important from an energy point of viewIn TinyOS the LPL protocol available for nodes equippedwith a CC2420 radio (see [15]) is based on B-MAC [19]In this protocol the receiving radio modules are periodicallyturned on to check for activity on the channel and remainactive only if a packet is being transmitted Sending nodesmust be kept retransmitting the same packets until the checksof the receivers The consumption of a listening node canarbitrary be reduced by increasing the sleep interval (iethe delay between two checks) However this is done at theexpense of increased synchronization energy costs for sendersthat have to retransmit during a longer period before thechecks of the receivers After a successful transmission boththe sender and the receiver keep their radio on for a smalldelay (the delay after transmission) in case of a consecutivepacket transmission This generates a post-transmission costfor both the sender and the receiver In this work we chosethe typical values of respectively 10 ms and 100 ms for thedelay after transmission and the sleep interval while the checkduration is a constant of 5 ms Accordingly we estimatedthe energy costs due to LPL as indicated in Table III basedon measurements Note that the send synchronization cost is amean cost (based on the mean delay of almost 50 ms before the581TABLE IIIENERGY COSTS OF THE LPL PROTOCOL FOR THE MICAZ AND TELOSBTHE EQUIVALENCE IN NUMBER OF CYCLES OF COMPUTATION ISINDICATED IN PARENTHESISEnergy cost MICAz TelosBListen for 1 Tclk 04 nJ (01) 07 nJ (06)Send synchronization 309 mJ (11 M) 257 mJ (26 M)Post-transmission 068 mJ (02 M) 060 mJ (05 M)ATB12341: AB nA2: {kAB  B tS  tE  nA} kAT  {kAB  A tS  tE}kBT3: {kAB  A tS  tE}kBT  {A tA}kAB4: {tA}kABFig 1 The simplified Kerberos protocolcheck of the receiver) The post-transmission cost refers to theenergy spent by both sender and receiver during the delay aftertransmission We use the energy costs of Table II and Table IIIas energy models to predict the energy cost of protocols on theMICAz and TelosB platforms It takes as input the number ofcycles of computation the number of bits communicated thenumber of synchronizations and transmissions (if using LPL)and the time spent in listen modeIV ENERGY CONSUMPTION OF KEY AGREEMENTPROTOCOLSIn this section we use the energy models of Section III toassess and analyze the energy cost of cryptographic protocolsAs an example we focus on two key agreement protocolsKerberos and ECDH-ECDSA We first describe these proto-cols then assess the cost of the cryptographic operations andcommunicationsA Protocols descriptionThe establishment of shared secret keys between nodes is afirst step to provide other security services such as encryptionin WSN This could be achieved by means of pre-deployedshared keys but it raises problems of storage of the keys inlarge networks and of resiliency to node compromise There-fore a solution is to use key distribution or key agreementprotocols after the deployment of the nodes In this work wecompare two of these protocolsThe first protocol is Kerberos [16] a key distributionscheme built on secret-key cryptography which authenticatesthe participants We use its simplified version described in[5] In this protocol (see Figure 1) the two entities A and Bwishing to establish a shared secret key kAB already sharea secret key (kAT and kBT respectively) with a trusted thirdparty T There is first an exchange of messages between A andT The request of A contains the identities of A and B In theA B(kA QA) (kB  QB)nAnB  certBcertA FinishedFinishedVerify certBVerify certAPremaster= kA ·QBPremaster= kB ·QAFig 2 The ECDH-ECDSA protocolreply the key kAB generated by T is encrypted with the keyskAT and kBT  Then A recovers the key kAB and forwardsto B the piece of the message encrypted with kBT togetherwith its identity encrypted with kAB  Finally B recovers kABand sends back to A a timestamp encrypted with kAB  Replayattacks are avoided thanks to a timestamp tA a nonce nA andexpiration times tS  tE The second protocol is ECDH [8] the Diffie-Hellman keyagreement based on Elliptic Curve Cryptography (ECC [8])which does not need any trusted third party In its standardform ECDH does not provide authentication Therefore weuse the version known as ECDH-ECDSA in [1] In thisversion authentication is provided through certificates ver-ified using the Elliptic Curve Digital Signature Algorithm(ECDSA [8]) Thus the two parties A and B must possessa certificate generated by an authority They agree to use thesame curve parameters and generate in advance their privatekeys kA and kB and corresponding public keys QA = kA ·Gand QB = kB ·G where G is the generator of the group definedby the elliptic curve This protocol is described in Figure 2First A and B exchange random nonces Then B sends itscertificate to A (its public key signed by the authority usingECDSA) After the certificate verification A uses his privatekey and B’s public key to perform a point multiplication andarrive to a common secret kA · kB · G which is used withthe exchanged nonces to derive a shared secret key Then Asends its certificate to B who performs the same operationsto obtain the shared secret (kA · kB · G = kB · kA · G) andderive the shared secret key The possession of the sharedsecret key is proved in the ability of both parties to encryptthe hash of the exchanged nonces and their identities withthe shared secret key (ie {hash(nA nB  A)}kAB for A and{hash(nA nB  B)}kAB for B) These results forming thecontent of Finished messages are exchanged at the end ofthe protocol Remark that ECDH-ECDSA could be performedin three rounds only This is possible if A adds its certificate inthe first message In this case B can generate the Finishedmessage at this point and add it in its reply Therefore thelast message of the protocol becomes unnecessary In thefollowing we refer to the 4-round version of the protocolunless otherwise specified582TABLE IVESTIMATED ENERGY COSTS OF CRYPTOGRAPHIC OPERATIONS FOR THEMICAZ AND TELOSB THE NUMBER OF CYCLES OF COMPUTATION ISINDICATED IN PARENTHESISEnergy cost MICAz TelosBAES-128 128-bit encrypt 38 µJ (10742) 9 µJ (7483)ECC-160 point mult 55 mJ (156 M) 17 mJ (140 M)ECDSA-160 sign 52 mJ (147 M) 15 mJ (127 M)ECDSA-160 verify 63 mJ (180 M) 19 mJ (162 M)B Cost of cryptographic operationsWe assess the energy costs of the cryptographic operationsplaying a part in Kerberos and ECDH-ECDSA using theenergy model of the sensors (cf Section III) and the numberof cycles of computation from known implementations Forthe symmetric encryption employed in Kerberos we use theimplementation results of Healy et al [9] They implementedAES (128-bit keys) on the microcontrollers of both MICAzand TelosB nodes We assess the ECC point multiplicationsand ECDSA verifications involved in ECDH-ECDSA relyingon the results of Liu et al [14] They implemented ECC andECDSA in TinyOS for many platforms including MICAz andTelosB We use their results for the secp160r1 elliptic curvedomain parameters (160-bit keys) While the performances ofTinyECC are worse in terms of speed than the implementationof Gura et al [7] the code is publicly available ECDSAoperations include the cost of hashing 512 bits using SHA-1 Table IV shows the estimated energy costs of these crypto-graphic operations The cost of symmetric encryption is negli-gible compared to elliptic curve operations ECDSA signatureinvolving one point multiplication is however less costly thana full point multiplication thanks to pre-computations Thenumber of cycles for elliptic curve computations does notdiminish much on the TelosB (however based on a 16-bitmicrocontroller) because the implementation available for thisplatform is less optimizedWe estimate the cost of the computations for both protocolsbased on the assessments of Table IV For Kerberos thecomputations consist in the encryption and decryption of 8blocks of 128 bits (assuming 64-bit timestamps and nodeIDs and a 32-bit nonce) As a result the cost of Kerberos isrespectively 061 mJ and 014 mJ on the MICAz and TelosBFor ECDH-ECDSA each party mainly achieves an ECDSAverification and a point multiplication The key derivation andsymmetric encryption of the nonces and nodes IDs can beneglected considering the relative small cost of AES withrespect to ECC operations (see Table IV) It leads to an energycost for ECDH-ECDSA of respectively 236 mJ and 72 mJ onthe MICAz and TelosB ECDH-ECDSA is more than 2 ordersof magnitude more costly than Kerberos on both platformsThis was expected as elliptic curve operations are much morecostly than AES-based encryption The costs of both protocolsare around 4 times lower on the more energy-efficient TelosBTABLE VESTIMATED COMMUNICATION ENERGY COSTS OF KERBEROS FOR THEMICAZ AND TELOSBCommunication cost MICAz TelosBKerberos (mJ)Send 09 11Receive 11 13LPL listen 02 02LPL synchro 116 99Total 138 125TABLE VIESTIMATED COMMUNICATION ENERGY COSTS OF ECDH-ECDSA FORTHE MICAZ AND TELOSBCommunication cost MICAz TelosBECDH-ECDSA (mJ)Send 13 16Receive 15 18LPL listen 295 43LPL synchro 147 125Total 470 589C Communication and total energy assessmentHere we assess the communication energy costs of theprotocols Together with the computation costs of the previoussection they make it possible to obtain the total costs ofthe protocols The communication costs are composed of thecost of transmission reception and listening For transmissionand reception we make use of the per-bit costs presented inTable II The total number of bits communicated in Kerberosis 1568 and 2208 in ECDH-ECDSA (assuming 86-byte cer-tificates 32-byte nonces and 20-byte Finished messages asin [6]) For listening we use the energy costs (see Table III)of the LPL protocol of Section III and the total listeningdurations of the protocols During the run of a protocol a partyis listening during a delay corresponding to the processingof the preceding message by the other party and the latencyof the communications For the MICAz and TelosB thelistening durations are respectively 91 s and 151 s for ECDH-ECDSA and 70 ms and 80 ms for Kerberos The largerdurations for ECDH-ECDSA is due to longer computationswith respect to Kerberos Synchronization costs appear foreach transmission except when the nodes answer a previoustransmission within the delay after transmission of 10 ms (egB immediately answers the first message of A in ECDH-ECDSA) The estimated communication costs for Kerberosand ECDH-ECDSA on the MICAz and TelosB nodes areshown in Tables V and VI They are higher for ECDH-ECDSAmainly because of the high listening cost due to the longcomputation delays of this protocol However one could savethe major part of the LPL listening energy loss by temporarilyincreasing the sleep interval when waiting for cryptographicresults This requires to know in advance the durations of thecomputations If the sleep intervals fit the durations of thecomputations (with a security margin of 025 s) 90% of theLPL listening energy cost can be saved in ECDH-ECDSA Bydoing this the communication costs of ECDH-ECDSA would583not be much more than those of Kerberos That would be doneat the expense of loosing connectivity during the run of theprotocol what may not be desirable to preserve the abilityto quickly react in case of emergency It seems difficult toobtain further reduction of the energy consumed by the LPLprotocol available in TinyOS Other LPL protocols could beinvestigated such as eg S-MAC [22] In this protocol nodesare synchronized on sleep schedules However this approachrequires the periodic exchange of synchronization informationwhat also consumes energyRemark that besides the energy aspect the long durationsof the computations in ECDH-ECDSA can be unpractical egin situations where a node has to perform several runs of theprotocol in a rowGathering the computation and communication costs foundabove provides the total costs for the protocols shown inTables VII and VIII ECDH-ECDSA is close to respectively20 times and 10 times more costly than Kerberos on MICAzand TelosB Communications compose almost exclusively thecost of Kerberos as opposed to ECDH-ECDSA For bothprotocols the relative importance of communications growsfor the TelosB which has a lower computational costTABLE VIIESTIMATED TOTAL ENERGY COSTS OF KERBEROS FOR THE MICAZ ANDTELOSBKerberos MICAz TelosBcost (mJ)Comp 06 (4%) 014 (1%)Comm 138 (96%) 125 (99%)Total 144 1264TABLE VIIIESTIMATED TOTAL ENERGY COSTS OF ECDH-ECDSA FOR THE MICAZAND TELOSBECDH-ECDSA MICAz TelosBcost (mJ)Comp 236 (83%) 72 (55%)Comm 47 (17%) 589 (45%)Total 283 1309With the LPL protocol employed the synchronization costof ECDH-ECDSA would not decrease much if it was per-formed using three messages as described at the end ofSection IV-A It would be only a slight reduction since in the3-message version B is no more able to quickly answer afterthe first message of the protocol (at this point B must performthe computations) Consequently an extra synchronizationcost would be required at this point what would almostcounterbalance the reduction This is due to a feature of theLPL protocol employed which allows quick replies withoutloosing the synchronization between the nodesV COMPARISON WITH RELATED RESULTSAs described in Section II two previous works alreadycompared the energy cost of Kerberos and the Diffie-Hellmankey exchange on sensor nodes First there is the work byHodjat and Verbauwhede They used the standard version ofECDH which does not provide any authentication They foundthat ECDH was between one to two orders of magnitudelarger than Kerberos on WINS nodes This is similar toour results of preceding section on the MICAz and TelosBHowever for the same amount of energy (140 mJ) WINSnodes can run Kerberos while TelosB nodes can perform anECDH-ECDSA key exchange This illustrates the importantimpact of the hardware The WINS node which contains amore powerful microprocessor (32-bit 133 MHz) consumesmuch more energy than the TelosB The authors obtainedthe energy cost of computations by measuring the timingperformances of their implementations of both protocols onthe WINS node For the communications they used a per-bit cost obtained through measurements in a previous workThey did not include the cost of listening in their estimatesThey obtained a cost of ECDH composed of more than 98%of computation and a cost of Kerberos made of more than75% of communications Compared to our results the relativeimportance of communication in the costs is much lowerSecond Großscha¨dl et al also compared AES-based Ker-beros with ECMQV a variant of ECDH that provides au-thentication on WINS nodes Their goal was to update theresults of Hodjat and Verbauwhede as progress had beenmade in efficient implementation of ECC since then Theyfound that the ECMQV was only up to twice as costly asKerberos on the WINS node ECMQV assumes that bothparticipants have already exchanged their long-term publickeys For large networks this means a large number of storedkeys per node which may not be desirable Therefore theexchange and verification of the long-term public keys couldbe included in the cost of this protocol The authors estimatedthe cost of computations and communications as Hodjat andVerbauwhede Similarly they did not take the listening costinto account They found that the cost of Kerberos was almostexclusively composed of computation and that the cost ofECMQV was made of around two thirds of communicationsIncluding the cost of listening in their estimates is likely tohave a more important impact for both protocols as the relativecost of communications is higher than in the results of Hodjatand VerbauwhedeTwo other works assessed the energy cost of ECC operationson sensors similar to the MICAz and TelosB First Wander etal [21] quantified the energy costs of ECDSA operations andECC-based certified key exchange (similar to ECDH-ECDSA)on a platform similar to the MICAz the Mica2dot [11]They found a cost of 188 mJ for the key exchange on theMica2dot This is lower than our estimation on the MICAzbecause they used a faster implementation (of which the codeis not publicly available) They based their estimations onperformance measurement of the ECC point multiplicationpresented in [7] for the computations The cost of communica-tion was estimated based on measurements on the Mica2dotThe authors mentioned the importance of listening Howeverthey did not include this element in the communication costwhich still amounts to 22% of the total cost Interestingly they584examined the relative importance of the costs of computationand communication pointing out that computation is cheapcompared to data transmissionSecond Piotrowski et al [18] extended the results of Wan-der et al on other sensor nodes including MICAz and TelosBThey deduced the processing times and energy consumptionsfor ECDSA operations and the computational part of theuncertified key exchange from the results of Wander et alFor this purpose they made use of performance and powerconsumption ratios They found a cost of respectively 53 mJand 12 mJ for the computations of ECDH on the MICAzand the TelosB Compared to our results it is much lowersince the uncertified key exchange is computationally muchless costly Moreover these results also refer to the moreefficient implementations of [7] Piotrowski et al assessedthe communication energy costs based on the datasheets ofthe transceivers They concluded that the communication costwas not an important factor when comparing cryptographicalgorithms on WSN We showed that this conclusion does notapply when practical elements were taken into account suchas listening the consumption of the microcontroller duringtransmissions and the real datarateVI CONCLUSIONOur work provides a methodology to assess the real cost ofcryptography on WSN nodes Special care was dedicated toconsider practical elements to assess the cost of communica-tions Using this methodology we assessed the energy costs oftwo key agreement protocols Kerberos and ECDH-ECDSAon the MICAz and TelosB nodes Our estimates confirm theadvantage of Kerberos what was noted in previous works Wefind that Kerberos is around respectively 20 times and 10 timesless costly than ECDH-ECDSA on the MICAz and TelosBTherefore it should be preferred in situations where a trustedthird party is available (eg a secure base station) As opposedto previous works the energy cost of listening is includedin our assessments resulting in higher communication costsIt can remain significant even when minimized using a LPLprotocol Therefore it should be considered when assessingthe cost of cryptographic protocols on WSN nodes A highlistening cost makes that the number of exchanged messagesin the protocol is very important Our work also providespractical insights on the relative costs of computation andcommunication in WSN It could therefore be useful to studythe interest of techniques trading the cost of computations forcommunications Eg the energy models we provide couldbe used as a base to study the interest of techniques tradingthe cost of computations for communications such as [4]For the nodes considered the relatively high communicationcost suggests that such schemes could be less efficient thanexpected A thorough analysis of the energy gain of suchtechniques could be a part of a future workREFERENCES[1] S Blake-Wilson T Dierks and C Hawk ECC cipher suites for TLSTransport Layer Security Working Group Internet draft available fromhttp://toolsietforg/id/draft-ietf-tls-ecc-01txt 2001[2] EYES European research project on self-organizing and collaborativeenergy-efficient sensor networks http://wwweyeseuorg/[3] A Freier P Karlton and P Kocher The SSL protocol version 30Transport Layer Security Working Group Internet draft available fromhttp://wpnetscapecom/eng/ssl3/draft302txt November 1996[4] M Girault and D Lefranc Server-aided verification: theory and practiceIn Bimal Roy editor Advances in Cryptology - Asiacrypt’05 number3788 in Lecture Notes in Computer Science pages 605–623 Springer2005[5] J Großscha¨dl A Szekely and S Tillich The Energy Cost of Crypto-graphic Key Establishment in Wireless Sensor Networks In Robert HDeng and Pierangela Samarati editors Proceedings of the 2nd ACMSymposium on Information Computer and Communications Security(ASIACCS 2007) pages 380–382 ACM Press 2007[6] V Gupta M Millard S Fung Y Zhu N Gura H Eberle and S CShantz Sizzle: A standards-based end-to-end security architecture forthe embedded Internet In PERCOM ’05: Proceedings of the Third IEEEInternational Conference on Pervasive Computing and Communicationspages 247–256 Washington DC USA 2005 IEEE Computer Society[7] N Gura A Patel A Wander H Eberle and S C Shantz ComparingElliptic Curve Cryptography and RSA on 8-bit CPUs In CHES pages119–132 2004[8] D Hankerson A Menezes and S Vanstone Guide to Elliptic CurveCryptography Springer-Verlag New York Inc Secaucus NJ USA2003[9] M Healy T Newe and E Lewis Efficiently securing data on a wirelesssensor network In Journal of Physics Conference Series volume 76Issue 1 2007[10] A Hodjat and I Verbauwhede The energy cost of secrets in ad-hocnetworks In Proc IEEE Circuits and Systems Workshop on WirelessCommunications and Networking page 4 2002[11] Crossbow Technology Inc Crossbow product information Available athttp://wwwxbowcom/Products/productdetailsaspx?sid=156[12] BC Lai D Hwang S Kim and I Verbauwhede Reducing radioenergy consumption of key management protocols for wireless sensornetworks In Proc ACM/IEEE International Symposium on Low PowerElectronics and Design (ISLPED 2004) pages 351–356 ACM Press2004[13] Y Law J Doumen and P Hartel Survey and benchmark of blockciphers for wireless sensor networks ACM Trans Sen Netw 2(1):65–93 2006[14] A Liu and P Ning TinyECC: A configurable library for Elliptic CurveCryptography in Wireless Sensor Networks Technical Report TR-2007-36 North Carolina State University Department of Computer Science2007[15] D Moss J Hui P Levis and J Choi Cc2420 radio stack TinyOSCore Working Group draft available at http://wwwtinyosnet/tinyos-2x/doc/pdf/tep126pdf 2007[16] B Neuman and T Ts’o Kerberos: An authentication service forcomputer networks IEEE Communications 32(9):33–38 1994[17] J Paek K Chintalapudi R Govindan J Caffrey and S Masri Awireless sensor network for structural health monitoring: performanceand experience In EmNets ’05: Proceedings of the 2nd IEEE workshopon Embedded Networked Sensors pages 1–9 Washington DC USA2005 IEEE Computer Society[18] K Piotrowski P Langendoerfer and S Peter How public key cryptogra-phy influences wireless sensor node lifetime In SASN ’06: Proceedingsof the fourth ACM workshop on Security of ad hoc and sensor networkspages 169–176 New York NY USA 2006 ACM[19] J Polastre J Hill and D Culler Versatile low power media accessfor wireless sensor networks In SenSys ’04: Proceedings of the 2ndinternational conference on Embedded networked sensor systems pages95–107 New York NY USA 2004 ACM Press[20] V Shnayder M Hempstead B Chen and M Welsh PowerTOSSIM:Efficient power simulation for TinyOS applications In ACM Conferenceon Embedded Networked Sensor Systems (SenSys) 2004[21] A Wander N Gura H Eberle V Gupta and S C Shantz Energyanalysis of public-key cryptography for wireless sensor networks InPervasive Computing and Communications 2005 PerCom 2005 ThirdIEEE International Conference on pages 324–328 2005[22] W Ye J Heidemann and D Estrin An energy-efficient MAC protocolfor wireless sensor networks In Proceedings 21st International AnnualJoint Conference of the IEEE Computer and Communications SocietiesNew York New York USA 2002585
Identitiy based parallel key insulated signature w_o random oracles-pdf,JOURNAL OF INFORMATION SCIENCE AND ENGINEERING 24 1143-1157 (2008) 1143  Identity-Based Parallel Key-Insulated Signature Without Random Oracles*  JIAN WENG12 XIANG-XUE LI3 KE-FEI CHEN2 AND SHENG-LI LIU2 1Department of Computer Science  Jinan University Guangzhou 510632 PR China 2Department of Computer Science and Engineering  3School of Information Security Engineering Shanghai Jiao Tong University Shanghai 200240 PR China  We extend Hanaoka et al’s parallel key-insulated mechanism to identity-based sig-nature scenarios and propose an identity-based parallel key-insulated signature scheme The proposed scheme enjoys several attractive features: (i) it is provably secure without random oracles; (ii) it is strong key-insulated and even if one of a user’s helper key and some of his temporary secret keys are exposed it is still impossible for an adversary to derive all of this user’s temporary secret keys; (iii) it allows frequent key-updates with-out increasing the risk of helper key-exposure and thus enhances the security of the sys-tem      Keywords: parallel key-insulated identity-based signature key-exposure random oracle model bilinear paring    1 INTRODUCTION  In 1984 Shamir [1] introduced an innovative concept called identity-based crypto-   graphy where an entity’s public key is determined as his identity such as email address and the corresponding private key is generated by a private key generator (PKG) The identity is a natural link to a user hence it can eliminate the need for certificates as used in the traditional public key infrastructure So far a large number of papers have been published in this area (see [2] for some of these) including many ID-based signatures Standard ID-based signatures rely on the assumption that secret keys are kept perfectly secure However with more and more cryptographic primitives being applied to insecure environments key-exposure seems inevitable This problem is perhaps the most devas-  tating attack on a cryptosystem since it typically means that security is entirely lost Key-evolving protocol is a practical method to deal with the key-exposure problem This mechanism includes forward security [3 4] intrusion-resilience [5] and key-insula- tion [6] The latter was introduced by Dodis Katz Xu and Yung [6] In this model a physically-secure but computationally-limited device named helper is involved The full-   fledged secret key is divided into two parts: a helper key and a temporary secret key The former is stored in the helper and the latter is kept by the user The lifetime of the system is divided into discrete time periods The public key remains unchanged throughout the lifetime while temporary secret keys are updated periodically: at the beginning of each Received October 20 2006; revised March 6 2007; accepted April 3 2007  Communicated by Tzong-Chen Wu * This paper was partially supported by NSFC under grants No 90104005 60573030 and 60673077 JIAN WENG XIANG-XUE LI KE-FEI CHEN AND SHENG-LI LIU  1144  time period the user obtains from the helper an update key for the current time period; combining this update key with the temporary secret key for the previous time period he can derive the temporary secret key for the current time period A temporary secret key is used to sign a message during the corresponding time period without further access to the helper Exposure of the temporary secret key at a given time period will not enable an adversary to derive temporary secret keys for the remaining time periods More precisely in a (l N)-key-insulated system the compromise of temporary secret keys for up to l time periods does not expose temporary secret keys for any of the remaining N − l time peri-ods Therefore there is no need to revoke the public key unless l time periods have been exposed If l = N − 1 then the scheme is called perfectly key-insulated This is a desirable property for dealing with the key-exposure problem in ID-based signatures Additionally strong key-insulated security guarantees that the helper is unable to derive the temporary secret key for any time period  Following the pioneering work due to Dodis et al [6] several elegant key-insulated encryption schemes including some ID-based key-insulated encryptions have been pro-posed [7-12] Following Dodis et al’s key-insulated signature schemes [13] efforts have also been devoted to the key-insulated signatures eg [14-17] To minimize the damage caused by key-exposure in ID-based signatures Zhou et al [18] proposed an ID-based key-insulated signature (IBKIS) scheme (ZCC06 for short) However the full-fledged secret key in ZCC06 scheme is just wholly stored in the helper Consequently it can not satisfy the strong key-insulated security That is if an adversary compromises a user’s helper he can derive all of this user’s temporary secret keys Sub-sequently Weng et al [19] proposed a new IBKIS scheme with strong key-insulated security (WLCL06 for short) However both ZCC06 and WLCL06 schemes are prova-bly secure in the random oracle model As pointed out in [20] a proof in the random ora-cle model can only serve as a heuristic argument since it does not imply the security in the implementation Moreover there exist some situations that are hard for standard IB-KIS schemes to deal with For example when key-exposure occurs in IBKIS cryptosys-tems the temporary secret key has to be updated at very short intervals to alleviate the damage Unfortunately this in turn increases the frequency of helper’s connection to insecure environments and thus increases the risk of helper key-exposure Keep in mind that even for an IBKIS scheme with strong key-insulated security once a user’s helper key and one of his temporary secret keys are exposed the adversary can derive all of this user’s temporary secret keys   For deeper understanding let’s consider another example Suppose a person works in a company’s head office in the odd days while in the even days he works in a branch To alleviate the damage in case of key-exposure he decides to update his secret key at very short intervals eg once per day Now some problems exist: firstly it is inconven-ient but necessary for him to remind himself to bring the helper to the head office in odd days and to the branch in even days; secondly bringing the helper back and forth means a frequent connection to insecure environments and thus the risk of helper key-exposure is increased; thirdly the short renewal interval also increases the risk of helper key-expo-   sure We notice that Hanaoka et al [11] proposed an ID-based hierarchical key-insulated encryption where the helper is formed into a hierarchical structure to improve its secu-rity However it might not be a desirable solution to this example Because this user still has to bring the first level helper back and forth and the risk of helper key-exposure will ID-BASED SIGNATURE  1145  be increased accordingly In PKC’06 Hanaoka et al [12] introduced a very clever method named parallel key-insulation to deal with this problem for key-insulated public- key encryptions: based on Boneh-Franklin’s ID-based encryption scheme [21] they pro-posed a parallel key-insulated public-key encryption scheme secure in the random oracle model Being different from the original key-insulated encryptions their scheme intro-duces two distinct helpers that are alternately used to update the secret keys The helper keys are independent of each other and they can successfully enhance the security of the system by allowing frequent key-updates without increasing the risk of helper key-  exposure Weng et al [22] extended this mechanism to ID-based encryptions and pro-posed an ID-based parallel key-insulated encryption scheme Since it’s worthwhile to deal with the key-exposure problem in ID-based signatures in this paper we extend the parallel key-insulated mechanism to ID-based signature scenarios and proposed an iden-tity-based parallel key-insulated signature (IBPKIS) scheme The rest of this paper is organized as follows Section 2 gives an introduction to bi-linear pairings and computational Diffie-Hellman (CDH) assumption We formalize the definition and security model for IBPKIS in section 3 In section 4 a concrete IBPKIS scheme is proposed Section 5 gives the security proof for our proposed scheme Section 6 concludes this paper  2 PRELIMINARIES Notations Throughout this paper let Zq denote the set {0 1 2 … q − 1} and *qZ  denote Zq − {0 1} Let d[i] denote the ith bit of an integer d in a binary representation For a set S we let |S| denote its cardinality By ∈R S it means choosing a random element from the set S with a uniform distribution We use x ← A to denote that algorithm A is executed on some specified input and its output is assigned to the variable x 21 Bilinear Pairings Let G1 be a cyclic multiplicative group of prime order q and G2 be a cyclic multi-plicative group of the same order q A bilinear pairing is a map e: G1 × G1 → G2 with the following properties: − Bilinearity: ∀g1 g2 ∈ G1 ∀a b ∈ * qZ  we have 1 2 1 2(  ) (  )a b abe g g e g g= ; − Non-degeneracy: There exist g1 g2 ∈R G1 such that e(g1 g2) ≠ 1; − Computability: There exists an efficient algorithm to compute e(g1 g2) for ∀g1 g2 ∈ G1 21 CDH Assumption Definition 1  The CDH problem in group G1 is given (g ga gb) ∈ 31G  for some un-known a b ∈ * qZ  to compute gab For a probabilistic polynomial-time adversary A we define his advantage against the CDH problem in group G1 as *1Adv Pr[   : (   ) ]CDH a b abA R R qg G a b Z A g g b g= ∈ ∈ =  where the probability is taken over the random coins consumed by A JIAN WENG XIANG-XUE LI KE-FEI CHEN AND SHENG-LI LIU  1146  Definition 2  We say that the (t ε)-CDH assumption holds in group G1 if no t-time adversary A has advantage at least ε in solving the CDH problem in G1 3 FRAMEWORK OF IBPKIS We first give an overview for the IBPKIS model As original key-insulated signa-tures the lifetime of IBPKIS systems is divided into discrete time periods A user’s iden-tity acts as his public key and is fixed for all the lifetime while his temporary secret key is updated in every time period Every user may have arbitrary number of helpers (for an easy explanation in the subsequent depiction we assume that every user ID has two helpers which store HKID1 and HKID0 respectively We also remark that the framework of IBPKIS in this section and our proposed scheme in the next section can be easily ex-tended to support arbitrary number of helpers for any user trivially) The two helper keys are alternately used to update this user’s temporary secret keys namely HKID1 is used in odd time periods while HKID0 is involved in even time periods At time period t user ID obtains an update key UKIDt from the ith helper (here i = t mod 2) Combining UKIDt with the temporary secret key TSKIDt-1 for the previous time period he can derive the temporary secret key TSKIDt for the current time period  Definition 3  An IBPKIS scheme consists of a tuple of six polynomial-time algorithms:  − Setup: Takes as input the security parameter k and (possibly) the total number of time periods N It returns a public parameter param and a master key msk We write (param msk) ← Setup(k N); − Extract: Takes as input msk param and a user’s identity ID It returns the initial se-cret key TSKID0 and two helper keys (HKID1 HKID0) We write (TSKID0 (HKID1 HKID0)) ← Extract(msk param ID); − UpdH: Takes as input a time period index t a user’s identity ID and the ith helper key HKIDi with i = t mod 2 It returns an update key UKIDt We write UKIDt ← UpdH(t ID HKIDi); − UpdT: Takes as input t a user’s identity ID the temporary secret key TSK IDt-1 and the updated key UKIDt It returns a temporary secret key TSKIDt We write TSKIDt ←  UpdT(t ID UKIDt TSKIDt-1); − Sign: Takes as input a time period index t a message m and the temporary secret key TSKIDt It returns a pair (t σ) composed of the time period t and a signature σ We write (t σ) ← Sign(t m TSKIDt); − Verify: Takes as input a message m a candidate signature (t σ) on m and an identity ID It returns 1 if (t σ) is a valid signature and 0 otherwise We write (1 or 0) ← Ver-ify((t σ) m ID)  Before giving the security notions for IBPKIS we consider the following oracles which together model the abilities of an adversary:  − KEO(⋅): a key-extraction oracle upon receiving a user’s identity ID returns this user’s initial secret key TSKID0 and two helper keys (HKID1 HKID0); ID-BASED SIGNATURE  1147  − HKO(⋅⋅): a helper key oracle upon receiving a tuple <ID i> consists of a user’s iden-tity ID and an index i of the helper returns the helper key HKIDi; − TKO(⋅⋅): a temporary secret key oracle upon receiving a tuple <ID t> consists of a user’s identity ID and a time period index t returns the temporary secret key TSKIDt − SO(⋅⋅⋅): a signing oracle upon receiving a tuple <ID t m> consists of a user’s iden-tity ID a time period index t and a message m returns a signature Sign(t m TSKIDt) To model the key-insulated security for IBPKIS besides oracles TKO and SO we further provide oracle KEO for him Moreover we even provide oracle HKO for the ad-versary and allow him to compromise one of the helper keys for the challenged identity Definition 4  Let ∏ be an IBPKIS scheme For a polynomial-time adversary A his ad-vantage is defined as  * * * * ( ); (  ); (  ); (   ) * * * *(  ) Setup(  ); ((  )  )Adv ( ) Pr ( ) : Verify((  )  ) 1A KI KEO HKO TKO SOparam msk k N t ID mkA param t ID mσσ∏⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅⎡ ⎤← ←= ⎢ ⎥=⎣ ⎦ where it is mandated that: (1) A can not submit <ID* t* m*> to oracle SO; (2) <ID* t*> was never submitted to oracle TKO; (3) ID* was never submitted to KEO; (4) A can not submit <ID* t* − 1> to oracle TKO and <ID* t* mod 2> to oracle HKO simultaneously; (5) A can not submit <ID* t* + 1> to oracle TKO and <ID* (t* + 1) mod 2> to oracle HKO simultaneously; (6) A can not compromise both of ID*’s helper keys We say that  ∏ is perfectly key-insulated if for any polynomial-time adversary A  ( )A KIAdv kΠ  is negli-gible Remark 1: For those non-challenged identities oracle TKO is of no help for adversary A since he can derive any temporary secret key for these identities by querying oracle KEO Therefore without loss of generality we require that adversary A only query oracle TKO on the challenged identity To model the strong key-insulated security for IBPKIS We provide oracle HKO for the attacker and allow him to query all the helper keys for any identity even including the challenged identity However the adversary is disallowed to query oracle TKO on the challenged identity for any time period Note that we allow the adversary to query oracle TKO on the non-challenged identities for any time period Since these queries are im-plied by the KEO queries we do not explicitly provide oracle TKO for the adversary in the following definition Definition 5  Let ∏ be an IBPKIS scheme For a polynomial-time adversary A his ad-vantage is defined as * * * * ( ); (  ); (   ) * * * *(  ) Setup(  ); ((  )  )Adv ( ) Pr ( ) : Verify((  )  ) 1A SKI KEO HKO SOparam msk k N t ID mkA param t ID mσσ∏⋅ ⋅ ⋅ ⋅ ⋅ ⋅⎡ ⎤← ←= ⎢ ⎥=⎣ ⎦ where it is mandated that: (1) A can not query oracle SO on <ID* t* m*>; (2) ID* was never submitted to oracle KEO We say that ∏ is strong key-insulated if for any polyno-mial-time adversary A  ( )A SKIAdv kΠ is negligible JIAN WENG XIANG-XUE LI KE-FEI CHEN AND SHENG-LI LIU  1148  Finally as in [13] we address an adversary who compromises the user’s storage while a key is being updated from TSKIDt-1 to TSKIDt and we call it a key-update expo-sure at (ID t) When this occurs the adversary gets TSKIDt-1UKIDt and TSKIDt We say an IBPKIS scheme has secure key-updates if a key-update exposure at (ID t) is of no more help to the adversary than issuing TKO queries on <ID t − 1> and <ID t> Definition 6  An IBPKIS scheme has secure key-updates if the view of any adversary A making a key-update exposure at <ID t> can be perfectly simulated by an adversary A′ making TKO queries on <ID t − 1> and <ID t> 4 OUR PROPOSED IBPKIS SCHEME 41 Construction To describe our scheme some global parameters are required to be defined in ad-vance Let G1 and G2 be two groups with prime order q of size k g be a random generator of G1 and e be a bilinear map such that e: G1 × G1 → G2 Let H1: {0 1}* → {0 1}nu and H1: {0 1}* → {0 1}nm be two collision-resistant hash functions for some nu nm ∈ Z Let F be a pseudo-random function (PRF) such that given a k-bit seed s and a k-bit input x it outputs a k-bit string Fs(x) (refer to [23] for details about PRF) Based on Paterson- Schuldt’s ID-based signature scheme [24] which is based on Water’s ID-based encryp-tion scheme [25] our proposed IBPKIS scheme consists of the following six algorithms: Setup: The PKG picks α ∈ *qZ  g2 ∈R G1 and defines g1 = gα Next it chooses u′ m′ ∈R  G1 It also chooses a nu-dimensional vector ˆ( )iU u=G with ûi ∈R G1 for i = 1 … nu An- other nm-dimensional vector ˆ( )jM m=G with 1ˆ j Rm G∈  for i = 1 … nu is also chosen  The public parameter is 1 2 1 2(         )param g g g u m U M H H′ ′=G G and the master key  is 2 msk gα=  For convenience we define two functions L1 and L2 such that 1 ˆ( ) ii SL S u u∈′= ∏  L2(S)  ˆ jj Sm m′∈′= ∏  where S ⊆ {1 … nu} and S′ ⊆ {1 … nm} Furthermore to make the no-  tation easy to follow for a given identity ID time period t and message m we hereafter use UIDt to denote the set {i | S1[i] = 1 S1 = H1(ID || t)} IDU ′  to denote {j | S2[i] = 1 S2 = H1(ID)} and Mm to denote {k | S3[k] = 1 S3 = H2(m)}  Extract: Given an identity ID the PKG randomly chooses two helper keys HKID1 HKID0 ∈R {01}k and computes 1 1 ( 1 || )IDID HKk F ID− = − 00 (0 || )IDID HKk F ID=  Next it  chooses r ∈R *qZ  and defines the initial secret key to be  1 0  1 00 2 1 1  1 1 0( ( ) ( ) ( )    )ID ID ID IDk k k kr rID ID ID IDTSK g L U L U L U g g gα − −−′=     (1) Finally it outputs the initial secret key TSKID0 and the two helper keys HKID1 and HKID0 UpdH: given an identity ID and a time period index t the ith (here i = t mod 2) helper for ID-BASED SIGNATURE  1149  ID defines and returns the update key as   2  1  1  2( ( ) ( )  )ID t ID t ID tk k kID t ID t ID tUK L U L U g−−=  where  2 ( 2 || )ID iID t HKk F t ID− = −  ( || )ID iID t HKk F t ID=  UpdT: Given a time period index t an update key   ˆ ˆ(  )ID t ID t ID tUK Q R=  and a tempo- rary secret key TSKIDt-1 = (QIDt-1 RIDt-1 RIDt-2 R) this algorithm returns the temporary  secret key for user ID in time period t as   1   1 ˆ ˆ(    )ID t ID t ID t ID t ID tTSK Q Q R R R− −= ⋅  Note that if let i = t mod 2 and j = (t − 1) mod 2 then the temporary secret key is always set to be  1   1  2 1 1  1 1 ( ( ) ( ) ( )    )ID t ID t ID t ID tk k k kr rID t ID ID t ID tTSK g L U L U L U g g gα − −−′=     (2) where  1 ( 1 || )ID jID t HKk F t ID− = −  ( || )ID iID t HKk F t ID=   Sign: To produce a signature on m during time period t the user ID with temporary se-  cret key TSKIDt = (QIDt RIDt-1 RIDt R) first chooses *1  t t m R ql l r Z−′ ′ ∈  and then com-  putes 1 1  1 tlID t ID tS R g −′− −= ⋅   tlID t ID tS R g ′= ⋅ mrmS g=  and 1 1  1 1 ( ) ( )t tl lID t ID t ID tV Q L U L U−′ ′−= ⋅   2 ( ) mrmL M  The signature is σ = (t V SIDt-1 SIDt R Sm)  Note that let i = t mod 2 and j = (t − 1) mod 2 the signature is always set to be  1   1 2 1 1  1 1  2( ( ) ( ) ( ) ( )     )ID t ID t ID t ID tm mk k k kr rr rID ID t ID t mg L U L U L U L M g g g gασ − −−′=  (3) where   1 1 ( 1 || ) ( || )ID j ID jID t t HK ID t t HKl l F t ID l l F t ID− −′ ′= + − = +  Verify: given a purported signature σ = (t V SIDt-1 SIDt R Sm) of an identity ID on a message m a verifier accepts σ iff the following equality holds:  e(g V) = e(g1 g2)e(R L1(U′I D))e(SIDt−1 L1(UIDt−1))e(SIDt L1(UIDt))e(Sm L2(Mm))  (4) Remark 2: There exist some implicit relations in the above scheme: (i) according to Eqs (1)-(3) a given user’s initial secret key all of his temporary secret keys and all the sig-nature signed by him share the same exponent r; (ii) all the temporary secret keys for a given user ID are mutually dependent on one another namely TSKIDt-1 and TSKIDt share the same exponent kIDt-1 while TSKIDt and TSKIDt+1 share the same exponent kIDt 42 Comparison with IBKIS Scheme In this subsection we give a comparison between our IBPKIS scheme and IBKIS schemes In our IBPKIS scheme every user has two helper keys to alternately update his temporary secret key As to the aforementioned person who works in both the head office and a branch now he can put the first helper key in the head office and the second one in the branch Then he no longer needs to remind himself to bring the helper back and forth Moreover since the two helper keys are alternately used even if the frequency of tem-porary secret key-updates in our scheme is twice as those in IBKIS schemes the risk of each helper’s key-exposure is still the same as those of IBKIS schemes This means that our proposed IBPKIS scheme allows frequent key-updates without increasing the risk of JIAN WENG XIANG-XUE LI KE-FEI CHEN AND SHENG-LI LIU  1150  helper key-exposure Besides even if one of a user’s helper key and some of his tempo-rary secret keys are exposed it is still impossible for an adversary to derive all of this user’s temporary secret keys On the contrary even for the strong key-insulated IBKIS scheme once a user’s helper key and one of his temporary secret keys are exposed all of his temporary secret keys will be exposed In the next section we will prove that the proposed scheme enjoys desirable features such as secure key-updates perfectly key- insulation and strong key-insulation in the standard model We give a comparison be-tween the proposed scheme and existing IBKIS schemes in Table 1  Table 1 Comparison of the proposed IBPKIS scheme and existing IBKIS schemes  Proposed Scheme ZCC06 [18] WLCL06 [19] Perfectly Key-Insulated √ √ √ Strong Key-Insulated √ × √ Secure Key-Updates √ √ √ Without Random Oracles √ × × Allow Frequent Key-Updates √ × × “Allow Frequent Key-Updates” means allowing frequent key-updates without increasing the risk of helper key-exposure  We can use Naccache and Sarkar-Chatterjee’s technique [26 27] to reduce the size of public parameters (see section 6 in [24] for more details) However we are quite aware that since our proposed scheme is based on Paterson-Schuldt’s IBS scheme [24] our IBPKIS scheme is a little more expensive than ZCC06 and WLCL06 schemes It’s an open question to construct an IBPKIS scheme satisfying both high efficiency and prov-able security without random oracles 5 SECURITY ANALYSIS Theorem 1  The proposed scheme is perfectly key-insulated in the standard model un-der the CDH assumption in G1 Concretely given an adversary A that has advantage ε against the perfectly key-insulated security of our scheme by running within time T ask-ing at most qk (qh qt qs resp) queries to oracle KEO (HKO TKO SO resp) there exists a (T ′ ε′) adversary B that breaks the CDH assumption in G1 with T' ≤ T + O((qk + qt + qs) te + (nu(qk + qt) + (nu + nm)qs)tm) and ε′ ≥ 9ε/1024(qk + qt + 3qs)3(nu + 1)3qs(nu + 1) where te and tm denote the running time of an exponentiation and a multiplication in G1 respec-tively  Proof: We will show how to construct a (T' ε′)-adversary B against the CDH assumption  in group G1 Suppose B is given a tuple (g ga gb) ∈ 31G  for some unknown a b ∈ *qZ  B’s  goal is to derive gab by interacting with A B flips a fair coin COIN ∈ {0 1} If COIN = 1 B plays Game 1 with A else he plays Game 2  Game 1: In this game B acts as a challenger expecting that A will never corrupt the helper key of the challenged identity Note that in this game B can randomly choose the exponent kIDt on his own for the challenged identity ID and a time period index t since ID-BASED SIGNATURE  1151  kIDt is the output of a PRF and A does not know the corresponding seeds HKID1 and HKID0 B interacts with A in the following way:  Setup: B randomly chooses two integers ku and km such that 0 ≤ ku ≤ nu 0 ≤ km ≤ nm Let lu = 4(qk + qt + 3qs)/3 and lm = 2qs We here assume that lu(nu + 1) < q and lm(nm + 1) < q Next it randomly chooses x′ ∈R Zlu z′ ∈R Zlm y′ w′ ∈R Zq and assigns g1 = ga g2 = gb u′  = g2x′-lukugy′ and m′ = g2x′-lmkmgw′ It also chooses ˆ ˆ ui i R lx y Z∈  and assigns ˆ( )iU u=G with  ˆ ˆ2ˆ i ix yiu g g=  for i = 1 … nu Besides it chooses ˆˆ  mj j R lz w Z∈  and assigns ˆ( )iM m=G  with ˆ ˆ2ˆj jz wjm g g=  for j = 1 … nu Finally B returns the public parameters to A Observe that from the perspective of the adversary the distributions of these public parameters are identical to the real construction Note that the master key is implicitly set  to be 2 2 a abg g gα = =    To make the notation easy to follow we define four functions J1 J2 K1 and K2 such  that 1 1 2 2ˆ ˆ ˆ( )  ( )  ( )  ( )u u i i m m ji S i S j SK S x l k x J S y y K S z l k z J S w′∈ ∈ ∈′ ′ ′ ′ ′= − + = + = − + = +∑ ∑ ∑  ˆ jj Sw′∈∑  where S ⊆ {1 … nu} S ′  ⊆ {1 … nm} Note that the following equalities always  hold: 1 21 2( ) ( )( ) ( )1 22 2( ) ( )K S K SJ S J Sg g L S g g L S′ ′ ′= =   To embody the implicit relations mentioned in Remark 2 B forms a list named Rlist as explained below For easy explanation an algorithm named RQuery is also defined  Algorithm  RQuery(ID t): If there exists a tuple in Rlist for this input then output the predefined value Else if t = ‘−’ then choose *ˆ R qr Z∈  add (ID ‘−’ ˆ)r on Rlist return ˆr  Else choose *ˆID t R qk Z∈  add ˆ(   )ID tID t k  on Rlist return ˆ ID tk  End if End if  Oracles Simulations: B answers a series of oracle queries for A in the following way: Oracle HKO simulation B maintains a list HKlist which is initially empty Upon receiving a helper key query <ID i> with i ∈ {0 1} B first checks whether HKlist contains a tuple (ID i HKIDi) If it does HKIDi is returned to A Otherwise B chooses HKIDi ∈R {01 }k adds (ID i HKIDi) into HKlist and returns HKIDi to A Oracle KEO simulation Upon receiving a KEO query on identity ID B outputs “failure” and aborts if 1( ) 0 modIDK U q′ ≡  (denote this event by E1) Otherwise B issues HKO queries on <ID 1> and <ID 0> to obtain HKID1 and HKID0 Next it computes rˆ  = RQuery (ID ‘−’) and assigns the initial secret key TSKID0 to be   1 0  1 01 1 1( ) ( ) ˆ ˆ1 ( )1 1  1 1 01( ( ) ( ) ( )    )ID ID ID IDID ID IDk k k kJ U K U K Ur rID ID IDg L U L U L U g g g g− −′ ′ ′−−′  where 1 0 1 0( 1 || ) and (0 || )ID IDID HK ID HKk F ID k F ID− = − =  Finally B returns (TSKID0  HKID1 HKID0) to A JIAN WENG XIANG-XUE LI KE-FEI CHEN AND SHENG-LI LIU  1152      Observe that if let 1ˆ / ( )IDr r a K U ′= −  then in a similar analysis as in [25] it can be  verified that TSKID0 has the correct form as Eq (1)  Oracle TKO queries As argued in Remark 1 we require that A just queries oracle TKO on the challenged identity Upon receiving a TKO query <ID t> (Wlog we assume t is even note that an odd t can be handled in a similar manner) B outputs “failure” and  aborts if K1(U′ID) ≡ K1(UIDt-1) ≡ 0 mod q holds (denote this event by E2 Note that to embody the mutually dependent relation mentioned in Remark 2 we do not make use of  the case K1(UIDt-1) ≠ 0 mod q for an odd t − 1) Otherwise it first computes rˆ  = RQuery  (ID ‘−’) ˆ (  )ID tk RQuery ID t=  and  1ˆ (  1)ID tk RQuery ID t− = −  Next if K1(U′ID) ≠ 0 mod  q it defines and returns TSKIDt as  1   1 1 1 1ˆ ˆ ˆ ˆ( ) ( ) ˆ ˆ1 ( )1 1  1 1 1( ( ) ( ) ( )    )ID t ID t ID t ID tID ID IDk k k kJ U K U K Ur rID ID t ID tg L U L U L U g g g g− −′ ′ ′−−′ (5) else if K1(UIDt) ≠ 0 mod q it defines and returns TSKIDt as 1  1   1   1 1  ˆ ˆ ˆ ˆ( ) ( ) 1 ( )ˆ ˆ1 1  1 1 1( ( ) ( ) ( )    )ID t ID t ID t ID t ID t ID t ID tJ U K U k k k K U kr rID ID t ID tg L U L U L U g g g g− −−−′ (6) Observe that in both cases TSKIDt has the correct form as Eq (2) and is indeed a valid temporary secret key  Oracle SO simulation Upon receiving a SO query <ID t m> B outputs “failure” and aborts if 1 1  1 1  1( ) ( ) ( ) ( ) 0 mod  ID ID t ID t mK U K U K U K M q−′ ≡ ≡ ≡ ≡  holds (denote this event by E3) Otherwise B first computes ˆ (  ' ')r RQuery ID= −  and then constructs the signature for A according to four cases:  − K1(U′ID) ≠ 0 mod q: Choose lIDt-1 lID t rm ∈R *qZ  and assigns the signature σ as  1   1 1 1 1( ) ( ) ˆ ˆ1 ( )1 1  1 1  21(  ( ) ( ) ( ) ( )     )ID t ID t ID t ID tID ID m mIDl l l lJ U K U r rK Ur rID ID t ID t mt g L U L U L U L M g g g g g− −′ ′ ′−−′  − (K1(U′ID) ≡ 0 mod q) ^ (K1(UIDt-1) ≠ 0 mod q): Choose * 1 ˆ  ID t ID t m R ql l r Z− ∈  and as-signs the signature σ as ( )( )1  1 1( ) ( )1  1  1  1  1  1 ˆ ˆˆ ˆ1 1  1 1  21  ( ) ( ) ( ) ( )    J UID tK U K UID t ID t ID t ID t ID t ID tm ml l l lr rr rID ID t ID t mt g L U L U L U L M g g g g g− −− − − −−′  − (K1(U′ID) ≡ K1(UIDt-1) ≡ 0 mod q) ^ (K1(UIDt) ≠ 0 mod q): Choose  1 ˆ ID t ID t m Rl l r− ∈   *qZ  and assigns the signature σ as ( )( )1  1( ) ( )1   1   1 1  ˆ ˆˆ ˆ1 1  1 1  21  ( ) ( ) ( ) ( )    J UID tK U K UID t ID t ID t ID t ID t ID tm ml l l lr rr rID ID t ID t mt g L U L U L U L M g g g g g−− −−′  − (K1(U′ID) ≡ K1(UIDt-1) ≡ K1(UIDt) ≡ 0 mod q) ^ (K2(Mm) ≠ 0 mod q): Choose  1  ID t ID tl l−   *mˆ R qr Z∈  and assigns the signature σ as ID-BASED SIGNATURE  1153  ( )( )2 1( ) ( ) 1   1 2 2ˆ ˆˆ ˆ1 1  1 1  21  ( ) ( ) ( ) ( )    J MmK M K MID t ID t ID t ID tm m m ml l l lr rr rID ID t ID t mt g L U L U L U L M g g g g g−− −−′  In all cases it can be verified thatσhas the correct form as Eq (3) Forge: Eventually B returns a forged signature σ* = (t* V* SID*t*-1 SID*t* R* Sm*) on an identity ID* a time period index t* and a message m* with the constraints described in Definition 4 B first checks whether A has corrupted one of ID*’s helper keys during this game If it does B outputs “failure” and aborts (denote this event by E4) Otherwise B further checks whether K1(U′ID*) ≡ K1(UID*t*-1) ≡ K1(UID*t*) ≡ K2(Mm*) ≡ mod q holds holds If not B outputs “failure” and aborts (denote this event by E5); otherwise B can  successfully compute gab as 1 * * 1 * * 2 *1 *  1 * * * * *( ) ( ) ( )* ( )* 1 ID t ID t mIDJ U J U J MJ UID t ID t mV R S S S−′−  Game 2: In this game B acts as a challenger expecting that A will corrupt exactly one of the helper keys on the challenged identity B picks γ ∈R {0 1} and bets on that A queries on the γth helper Wlog we assume γ = 1 (the case of γ = 0 can be handled in a similar manner) Then for the challenged identity ID and an even time period index t B can ran-domly choose the exponent kIDt since F is a PRF and A does not know the corresponding seed HKID0 B provides the simulation of Setup oracles HKO KEO and SO for A in the same way as Game 1 Here we let F1 and F3 denote the abort events in oracle KEO simulation and oracle SO simulation respectively B provides oracle TKO simulation for A as follows: Oracle TKO simulation As argued in Remark 1 we also require that A just query oracle TKO on the challenged identity For a TKO query <ID t> we explain how to deal with the case of an even t (the case of an odd t can be handled in a similar manner): B outputs “failure” and aborts if K1(U′ID) ≡ K1(UIDt) ≡ 0 mod q holds (denote this event by F2) Oth- erwise B first computes ˆ (  ' ')r RQuery ID= −  ˆ (  )ID tk RQuery ID t=  and lIDt-1 = FHKIDt(t  − 1 || ID) If K1(U′ID) ≡ 0 mod q it defines TSKIDt similarly to Eq (5) else if K1(UIDt) ≠ 0 mod q it defines TSKIDt similarly to Eq (6) It can be verified that in both cases TSKIDt has the correct form as Eq (2) Forge: Eventually A returns a forged signature σ* = (t* V* SID*t*-1 SID*t* R* Sm*) on identity ID* messages m* and time period index t* with the constraints described in Defi-nition 4 B first checks whether A has corrupted HKID*1 during this game If not B out-puts “failure” and aborts (denote this event by F4) Otherwise B further checks whether K1(U ′I D*) ≡ K1(UID*t*-1) ≡ K1(UID*t*) ≡ (Mm*-1) ≡ 0 mod q holds If not B outputs “failure” and aborts (denote this event by F5); else B can successfully compute gab in the same way as Game 1 This completes the simulation From the description of B we know that the time complexity of B is dominated by the exponentiations and the multiplications in the simu-lation of oracles TKO KEO and SO Since there are O(1) exponentiations in each stage and O(nu)O(nu) and O(nu + nm) multiplications in the above three oracle simulations respectively we know that the time complexity of B is bounded by T' ≤ T + O((qk + qt + qs)te + (nu(qk + qt) + (nu + nm)qs)tm) JIAN WENG XIANG-XUE LI KE-FEI CHEN AND SHENG-LI LIU  1154  Next we bound B’s advantage against the CDH assumption in G1 Let Pr[¬abort1] and Pr[¬abort2] denote the probabilities of B’s not aborting in Games 1 and 2 respec-tively Similarly to the analysis in [24] we have the following claim  Claim 1: Pr[¬abort1] ≥ 9/1024(qk + qt + 3qs)3(nu + 1)3qs(nm + 1)  Pr[¬abort2] ≥ 9/1024(qk + qt + 3qs)3(nu + 1)3qs(nm + 1)  From the description of the simulation we know that if B does not abort the Setup phase and the responds to A’s HKO KEO TKO and SO queries are valid and the im-plicit relations mentioned in Remark 2 are also satisfied Therefore if B does not abort A can successfully return a valid forged signature with advantage ε then B can solve the CDH problem instance Since COIN is a fair coin we know that B can solve the CDH problem instance with advantage ε′ = ½Pr[¬abort1] ⋅ ε + ½Pr[¬abort2] ⋅ ε ≥ 9ε/1024(qk + qt + 3qs)3(nu + 1)3qs(nm + 1)                                               Theorem 2  The proposed scheme is strong key-insulated in the standard model under the CDH assumption in group G1 Concretely given an adversary A that has advantage ε against the strong key-insulated security of our proposed scheme by running within time T asking at most qk (qh qs resp) queries to oracle KEO (HKO SO resp) there exists a (T ′ ε′) adversary B that breaks the CDH assumption in group G1 with T' ≤ T + O((qk + qs)te + (nuqk + (nu + nm)qs)tm) and ε′ ≥ 9ε/1024(qk + 3qs)3(nu + 1)3qs(nm + 1) where te and tm has the same meaning as Theorem 1  Proof: (Sketch) On input (g ga gb) ∈ 31G for some unknown a b ∈ * qZ  B’s goal is to compute gab B interacts with A as follows:  Setup: The same as Theorem 1 except that lu is set to be lu = 4(qk + 3qs)/3  Oracle Simulation: To embody the implicit relations mentioned in Remark 2 we also define the algorithm RQuery as in Theorem 1 B provides the simulation of oracles HKO KEO and SO for A in the same way as Game 1 in Theorem 1 Note that we need not pro-vide oracle TKO for A  Forge: Eventually A returns a forged signature σ* with the constraints described in Defi-nition 4 B can derive gab in the same way as Game 1 in Theorem 1  As the proof of Theorem 1 we can see that B’s running time is bounded by T ′ ≤ T + O((qk + qs)te + (nuqk + (nu + nm)qs)tm) Similarly the advantage of B can be bounded by ε′ ≥ 9ε/1024(qk + 3qs)3(nu + 1)3qs(nm + 1)                                        Theorem 3  The proposed scheme has secure key-updates  This theorem follows from the fact that for any time period t and any identity ID the update key UKIDt can be derived from TSKIDt and TSKIDt-1   ID-BASED SIGNATURE  1155  6 CONCLUSION Classical ID-based signatures rely on the assumption that secret keys are kept per-fectly secure In practice however key-exposure seems inevitable No matter how strong these ID-based signatures are once the secret keys are exposed their security is entirely lost Thus it is worthwhile to deal with the key-exposure problem in ID-based signatures In this paper we have extended the parallel key-insulated mechanism to ID-based signatures and minimized the damage caused by key-exposure in ID-based signatures We formalized the definition and security model for IBPKIS and at the same time pro-posed an IBPKIS scheme The proposed scheme can allow frequent key-updates without increasing the risk of helper key-exposure and eventually enhance the security of the system This is an attractive advantage which the standard IBKIS schemes do not possess Our scheme is provably secure without resorting to the random oracle methodology which is also a desirable feature since a proof in the random oracle model can only serve as heuristic argument and does not imply the security in the implementation REFERENCES 1 A Shamir “Identity-based cryptosystems and signature schemes” in Proceedings of CRYPTO on Advances in Cryptology LNCS 196 Springer-Verlag 1984 pp 47-53   2 P Barreto “The pairing-based crypto lounge” http://paginasterracombr/informatica/ paulobarreto/pbloungehtml   3 R Anderson “Two remarks on public-key cryptology” in Proceedings of the 4th ACM Conference on Computer and Communications Security 1997 http:// wwwcl camacuk/users/rja14/  4 M Bellare and S Miner “A forward-secure digital signature scheme” in Proceed-ings of CRYPTO on Advances in Cryptology LNCS 1666 Springer-Verlag 1999 pp 431-448  5 G Itkis and L Reyzin “SiBIR: signer-base intrusion-resilient signatures” in Pro-ceedings of CRYPTO on Advances in Cryptology LNCS 2442 Springer-Verlag 2002 pp 499-514    6 Y Dodis J Katz S Xu and M Yung “Key-insulated public-key cryptosystems” in Proceedings of EUROCRYPT on Advances in Cryptology LNCS 2332 Springer- Verlag 2002 pp 65-82   7 M Bellare and A Palacio “Protecting against key exposure: strongly key-insulated encryption with optimal threshold” http://eprintiacrorg/2002/064   8 Y Hanaoka G Hanaoka J Shikata and H Imai “Unconditionally secure key insu-lated cryptosystems: models bounds and constructions” in Proceedings of the 4th International Conference on Information and Communications Security LNCS 2513 Springer-Verlag 2002 pp 85-96   9 Y Dodis and M Yung “Exposure-resilience for free: the hierarchical ID-based en-cryption case” in Proceedings of the 1st International IEEE Security in Storage Workshop 2002 pp 45-52    10 J H Cheon N Hopper Y Kim and I Osipkov “Authenticated key-insulated pub-lic key encryption and timed-release cryptography” http://eprintiacrorg/2004/231    JIAN WENG XIANG-XUE LI KE-FEI CHEN AND SHENG-LI LIU  1156  11 Y Hanaoka G Hanaoka J Shikata and H Imai “Identity-based hierarchical strongly key-insulated encryption and its application” in Proceedings of ASIA-CRYPT on Advances in Cryptology LNCS 3788 Springer-Verlag 2005 pp 495- 514    12 G Hanaoka Y Hanaoka and H Imai “Parallel key-insulated public key encryp-tion” in Proceedings of Public Key Cryptography LNCS 3958 Springer-Verlag 2006 pp 105-122     13 Y Dodis J Katz S Xu and M Yung “Strong key-insulated signature schemes” in Proceedings of Public Key Cryptography LNCS 2567 Springer-Verlag 2003 pp 130-144   14 Z Le Y Ouyang J Ford and F Makedon “A hierarchical key-insulated signature scheme in the CA trust model” in Proceedings of the 7th International Conference on Information Security LNCS 3225 Springer-Verlag 2004 pp 280-291   15 N González-Deleito O Markowitch and E Dall’Olio “A new key-insulated sig-nature scheme” in Proceeding of the 6th International Conference on Information and Communications Security LNCS 3269 Springer-Verlag pp 465-479    16 D H Yum and P J Lee “Efficient key updating signature schemes based on IBS” in Proceedings of Cryptography and Coding LNCS 2898 Springer-Verlag 2003  pp 16-18    17 J Liu and D Wong “Solutions to key exposure problem in ring signature” http:// eprintiacrorg/2005/427   18 Y Zhou Z Cao and Z Chai “Identity based key insulated signature” in Proceed-ings of Information Security Practice and Experience Conference LNCS 3903 Springer-Verlag 2006 pp 226-234   19 J Weng S Liu K Chen and X Li “Identity-based key-insulated signature with secure key-updates” in Proceedings of Information Security and Cryptology LNCS 4318 Springer-Verlag 2006 pp 13-26  20 R Canetti O Goldreich and S Halevi “The random oracle methodology revis-ited” Journal of the ACM Vol 51 2004 pp 557-594   21 D Boneh and M Franklin “Identity based encryption from the Weil pairing” in Proceedings of CRYPTO on Advances in Cryptology LNCS 2139 Springer-Verlag 2001 pp 213-229   22 J Weng S Liu K Chen and C Ma “Identity-based parallel key-insulated encryp-tion without random oracles: security notions and construction” in Proceedings of INDOCRYPT LNCS 4329 Springer-Verlag 2006 pp 409-423    23 O Goldreich S Goldwasser and S Micali “How to construct random functions” Journal of the ACM Vol 33 1984 pp 792-807    24 K Paterson and J Schuldt “Efficient identity-based signatures secure in the standard model” in Proceedings of Australasian Conference on Information Security and Privacy LNCS 4058 Springer-Verlag 2006 pp 207-222     25 B Waters “Efficient identity-based encryption without random oracles” in Pro-ceedings of EUROCRYPT LNCS 3494 Springer-Verlag 2005 pp 114-127   26 D Naccache “Secure and practical identity-based encryption” http://eprintiacrorg /2005/369    27 P Sarkar and S Chatterjee “Trading time for space: towards an efficient IBE scheme with short(er) public parameters in the standard model” in Proceedings of ID-BASED SIGNATURE  1157  International Conference on Information Security and Cryptology LNCS 3935 Springer-Verlag 2005 pp 424-440       Jian Weng (翁健) received his MS and BS degrees in Computer Science and engineering from South China University of Technology Guangzhou PR China in 2004 and 2000 re-spectively He is currently a PhD candidate at Shanghai Jiaotong University His research interests include key-exposure protec-tion mechanism provable security and pairing-based cryptogra-phy     Xiang-Xue Li (李祥學) received the BS degree in Funda-mental Mathematics from Nanjing Normal University Nanjing in 1997 He received the MS degree in Mathematics from Nan-jing University Nanjing PR China in 2000 He received the PhD degree in Computer Science and Engineering from Shang-hai Jiaotong University Shanghai in 2006 Since then he has been with the Department of Computer Science and Engineering of Shanghai Jiaotong University His areas of research include provable security and pairing-based cryptography   Ke-Fei Chen (陳克非) received his PhD degree from Justus Liebig University Giessen Germany in 1994 Since 1996 he came to Shanghai Jiao Tong University and became the Pro-fessor at the Department of Computer Science and Engineering His areas of research include classical and modern cryptography theory of network security etc      Sheng-Li Liu (劉勝利) received her first PhD degree in Xidian University Xian PR China in 2000 and received her second PhD degree in Eindhoven University of Technology Holland in 2002 Since 2002 she came to Shanghai Jiao Tong University and became the Associate Professor at the Department of Computer Science and Engineering Her areas of research in-clude cryptography and information security 
identity based encryption scheme-weing-pdf,Identity-Based Encryption from the Weil PairingDan Boneh1? and Matt Franklin2??1 Computer Science Department Stanford University Stanford CA 94305-9045dabo@csstanfordedu2 Computer Science Department University of California Davis CA 95616-8562franklin@csucdaviseduAbstract We propose a fully functional identity-based encryptionscheme (IBE) The scheme has chosen ciphertext security in the randomoracle model assuming an elliptic curve variant of the computationalDie-Hellman problem Our system is based on the Weil pairing Wegive precise denitions for secure identity based encryption schemes andgive several applications for such systems1 IntroductionIn 1984 Shamir [27] asked for a public key encryption scheme in which the publickey can be an arbitrary string In such a scheme there are four algorithms: (1)setup generates global system parameters and a master-key (2) extract uses themaster-key to generate the private key corresponding to an arbitrary public keystring ID 2 f0; 1g (3) encrypt encrypts messages using the public key ID and(4) decrypt decrypts messages using the corresponding private keyShamir’s original motivation for identity-based encryption was to simplifycerticate management in e-mail systems When Alice sends mail to Bob atbob@hotmailcom she simply encrypts her message using the public key string\bob@hotmailcom" There is no need for Alice to obtain Bob’s public key cer-ticate When Bob receives the encrypted mail he contacts a third party whichwe call the Private Key Generator (PKG) Bob authenticates himself to the PKGin the same way he would authenticate himself to a CA and obtains his privatekey from the PKG Bob can then read his e-mail Note that unlike the existingsecure e-mail infrastructure Alice can send encrypted mail to Bob even if Bobhas not yet setup his public key certicate Also note that key escrow is inherentin identity-based e-mail systems: the PKG knows Bob’s private key We discusskey revocation as well as several new applications for IBE schemes in the nextsectionSince the problem was posed in 1984 there have been several proposals forIBE schemes (eg [7292821]) However none of these are fully satisfactorySome solutions require that users not collude Other solutions require the PKGto spend a long time for each private key generation request Some solutions? Supported by DARPA contract F30602-99-1-0530 and the Packard Foundation?? Supported by an NSF Career AwardJ Kilian (Ed): CRYPTO 2001 LNCS 2139 pp 213{229 2001c© Springer-Verlag Berlin Heidelberg 2001214 D Boneh and M Franklinrequire tamper resistant hardware It is fair to say that constructing a usableIBE system is still an open problem Interestingly the related notions of identity-based signature and authentication schemes also introduced by Shamir [27] dohave satisfactory solutions [1110]In this paper we propose a fully functional identity-based encryption schemeThe performance of our system is comparable to the performance of ElGamalencryption in Fp The security of our system is based on a natural analogueof the computational Die-Hellman assumption on elliptic curves Based onthis assumption we show that the new system has chosen ciphertext security inthe random oracle model Using standard techniques from threshold cryptogra-phy [1415] the PKG in our scheme can be distributed so that the master-key isnever available in a single location Unlike common threshold systems we showthat robustness for our distributed PKG is freeOur IBE system can be built from any bilinear map e : G1  G1 ! G2between two groups G1;G2 as long as a variant of the Computational Die-Hellman problem in G1 is hard We use the Weil pairing on elliptic curves asan example of such a map Until recently the Weil pairing has mostly beenused for attacking elliptic curve systems [2213] Joux [17] recently showed thatthe Weil pairing can be used for \good" by using it in a protocol for threeparty one round Die-Hellman key exchange Using similar ideas Verheul [30]recently constructed an ElGamal encryption scheme where each public key hastwo corresponding private keys In addition to our identity-based encryptionscheme we show how to construct an ElGamal encryption scheme with \built-in"key escrow ie where one global escrow key can decrypt ciphertexts encryptedunder any public keyTo argue about the security of our IBE system we dene chosen ciphertextsecurity for identity-based encryption Our model is slightly stronger than thestandard model for chosen ciphertext security [251] While mounting a chosenciphertext attack on the public key ID the attacker could ask the PKG forthe private key of some public key ID0 6= ID This private key might help theattacker Hence during the chosen ciphertext attack we allow the attacker toobtain the private key for any public key of her choice other than the one onwhich the attacker is being challenged Even with the help of such queries theattacker should have negligible advantage in defeating the semantic security ofthe systemThe rest of the paper is organized as follows Several applications of identity-based encryption are discussed in Section 11 We then give precise denitionsand security models in Section 2 Basic properties of the Weil pairing { sucientfor an understanding of our constructions { are discussed in Section 3 Our mainidentity-based encryption scheme is presented in Section 4 Some extensions andvariations (eciency improvements distribution of the master-key) are consid-ered in Section 5 Our construction for ElGamal encryption with a global escrowkey is described in Section 6 Conclusions and open problems are discussed inSection 7Identity-Based Encryption from the Weil Pairing 21511 Applications for Identity-Based EncryptionThe original motivation for identity-based encryption is to help the deploymentof a public key infrastructure In this section we show several other unrelatedapplicationsRevocation of Public Keys Public key certicates contain a preset expira-tion date In an IBE system key expiration can be done by having Alice encrypte-mail sent to Bob using the public key: \bob@hotmailcom k current-year"In doing so Bob can use his private key during the current year only Once ayear Bob needs to obtain a new private key from the PKG Hence we get theeect of annual private key expiration Note that unlike the existing PKI Alicedoes not need to obtain a new certicate from Bob every time Bob refreshes hiscerticateOne could potentially make this approach more granular by encrypting e-mailfor Bob using \bob@hotmailcom k current-date" This forces Bob to obtaina new private key every day This might be feasible in a corporate PKI wherethe PKG is maintained by the corporation With this approach key revocationis quite simple: when Bob leaves the company and his key needs to be revokedthe corporate PKG is instructed to stop issuing private keys for Bob’s e-mailaddress The interesting property is that Alice does not need to communicatewith any third party to obtain Bob’s daily public key This approach enablesAlice to send messages into the future: Bob will only be able to decrypt thee-mail on the date specied by Alice (see [268] for methods of sending messagesinto the future using a stronger security model)Delegation of Decryption Keys Another application for IBE systems isdelegation of decryption capabilities We give two example applications In bothapplications the user Bob plays the role of the PKG Bob runs the setup algorithmto generate his own IBE system parameters params and his own master-key Herewe view params as Bob’s public key Bob obtains a certicate from a CA for hispublic key params When Alice wishes to send mail to Bob she rst obtains Bob’spublic key params and public key certicate1 Delegation to a laptop Suppose Alice encrypts mail to Bob using thecurrent date as the IBE encryption key (she uses Bob’s params as the IBEsystem parameters) Since Bob has the master-key he can extract the privatekey corresponding to this IBE encryption key and then decrypt the messageNow suppose Bob goes on a trip for seven days Normally Bob would put hisprivate key on his laptop If the laptop is stolen the private key is compromisedWhen using the IBE system Bob could simply install on his laptop the sevenprivate keys corresponding to the seven days of the trip If the laptop is stolenonly the private key for those seven days are compromised The master-key isunharmed This is analogous to the delegation scenario for signature schemesconsidered by Goldreich et al [16]216 D Boneh and M Franklin2 Delegation of duties Suppose Alice encrypts mail to Bob using the subjectline as the IBE encryption key Bob can decrypt mail using hismaster-key Nowsuppose Bob has several assistants each responsible for a dierent task (egone is ‘purchasing’ another is ‘human-resources’ etc) Bob gives one privatekey to each of his assistants corresponding to the assistant’s responsibilityEach assistant can then decrypt messages whose subject line falls within itsresponsibilities but it cannot decrypt messages intended for other assistantsNote that Alice only obtains a single public key from Bob (params) and sheuses that public key to send mail with any subject line of her choice The mailcan only be read by the assistant responsible for that subjectMore generally IBE can simplify various systems that manage a large numberof public keys Rather than storing a big database of public keys the systemcan either derive these public keys from usernames or simply use the integers1; : : : ; n as distinct public keys2 DenitionsBilinear Map Let G1 and G2 be two cyclic groups of order q for some largeprime q In our system G1 is the group of points of an elliptic curve over Fpand G2 is a subgroup of Fp2  Therefore we view G1 as an additive group andG2 as a multiplicative group A map e^ : G1  G1 ! G2 is said to be bilinearif e^(aP; bQ) = e^(P; Q)ab for all P; Q 2 G1 and all a; b 2 Z As we will seein Section 3 the Weil pairing is an example of an eciently computable non-degenerate bilinear mapWeil Die-Hellman Assumption (WDH) Our IBE system can be built from anybilinear map e^ : G1 G1 ! G2 for which the following assumption holds: thereis no ecient algorithm to compute e^(P; P )abc 2 G2 from P; aP; bP; cP 2 G1where a; b; c 2 Z This assumption is precisely dened in Section 3 We note thatthis WDH assumption implies that the Die-Hellman problem is hard in thegroup G1Identity-Based Encryption An identity-based encryption scheme is specied byfour randomized algorithms: Setup Extract Encrypt Decrypt:Setup: takes a security parameter k and returns params (system parameters) andmaster-key The system parameters include a description of a nite messagespace M and a description of a nite ciphertext space C Intuitively thesystem parameters will be publicly known while the master-key will be knownonly to the \Private Key Generator" (PKG)Extract: takes as input params master-key and an arbitrary ID 2 f0; 1g andreturns a private key d Here ID is an arbitrary string that will be used asa public key and d is the corresponding private decryption key The Extractalgorithm extracts a private key from the given public keyEncrypt: takes as input params ID and M 2 M It returns a ciphertext C 2 CIdentity-Based Encryption from the Weil Pairing 217Decrypt: takes as input params ID C 2 C and a private key d It returnM 2 MThese algorithms must satisfy the standard consistency constraint namely whend is the private key generated by algorithm Extract when it is given ID as thepublic key then8M 2 M : Decrypt(params; ID; C; d) = M where C = Encrypt(params; ID; M)Chosen ciphertext security Chosen ciphertext security (IND-CCA) is the stan-dard acceptable notion of security for a public key encryption scheme [2519]Hence it is natural to require that an identity-based encryption scheme also sat-isfy this strong notion of security However the denition of chosen ciphertextsecurity must be strengthened a bit The reason is that when an attacker attacksa public key ID in an identity-based system the attacker might already possessthe private keys of users ID1; : : : ; IDn of her choice The system should remainsecure under such an attack Hence the denition of chosen ciphertext securitymust allow the attacker to obtain the private key associated with any identityIDi of her choice (other than the public key ID being attacked) We refer to suchqueries as private key extraction queries Another dierence is that the attackeris challenged on a public key ID of her choice (as opposed to a random publickey)We say that an identity-based encryption scheme is semantically secureagainst an adaptive chosen ciphertext attack (IND-ID-CCA) if no polynomiallybounded adversary A has a non-negligible advantage against the Challenger inthe following game:Setup: The challenger takes a security parameter k and runs the Setup algo-rithm It gives the adversary the resulting system parameters params It keepsthe master-key to itselfPhase 1: The adversary issues queries q1; : : : ; qm where query qi is one of:{ Extraction query hIDii The challenger responds by running algorithm Extractto generate the private key di corresponding to the public key hIDii It sendsdi to the adversary{ Decryption query hIDi; Cii The challenger responds by running algorithmExtract to generate the private key di corresponding to IDi It then runsalgorithm Decrypt to decrypt the ciphertext Ci using the private key di Itsends the resulting plaintext to the adversaryThese queries may be asked adaptively that is each query qi may depend onthe replies to q1; : : : ; qi−1Challenge: Once the adversary decides that Phase 1 is over it outputs twoplaintexts M0; M1 2 M and an identity ID on which it wishes to be challengedThe only constraint is that ID did not appear in any private key extractionquery in Phase 1The challenger picks a random bit b 2 f0; 1g and sets C =Encrypt(params; ID; Mb) It sends C as the challenge to the adversary218 D Boneh and M FranklinPhase 2: The adversary issues more queries qm+1; : : : ; qn where query qi is oneof:{ Extraction query hIDii where IDi 6= ID Challenger responds as in Phase 1{ Decryption query hIDi; Cii 6= hID; Ci Challenger responds as in Phase 1These queries may be asked adaptively as in Phase 1Guess: Finally the adversary outputs a guess b0 2 f0; 1g The adversary winsthe game if b = b0We refer to such an adversary A as an IND-ID-CCA attacker We dene adversaryA’s advantage in attacking the scheme as: Adv(A) = Pr[b = b0] − 12The probability is over the random bits used by the challenger and the adversaryWe say that the IBE system is semantically secure against an adaptive chosenciphertext attack (IND-ID-CCA) if no polynomially bounded adversary has anon-negligible advantage in attacking the scheme As usual \non-negligible"should be understood as larger than 1=f(k) for some polynomial f (recall k isthe security parameter) Note that the standard denition of chosen ciphertextsecurity (IND-CCA) [251] is the same as above except that there are no privatekey extraction queries and the attacker is challenged on a random public key(rather than a public key of her choice)Private key extraction queries are related to the denition of chosen cipher-text security in the multiuser settings [4] After all our denition involves mul-tiple public keys belonging to multiple users In [4] the authors show that thatmultiuser IND-CCA is reducible to single user IND-CCA using a standard hybridargument This does not hold in the identity-based settings IND-ID-CCA sincethe attacker gets to choose which public keys to corrupt during the attack Toemphasize the importance of private key extraction queries we note that our IBEsystem can be easily modied (by removing one of the hash functions) into asystem which has chosen ciphertext security when private extraction queries aredisallowed However the scheme is completely insecure when extraction queriesare allowedOne way identity-based encryption The proof of security for our IBE systemmakes use of a weak notion of security called one-way encryption (OWE) [12]OWE is dened for standard public key encryption schemes (not identity based)as follows: the attacker A is given a random public key Kpub and a ciphertext Cwhich is the encryption of a random message M using Kpub The attacker’s goalis to recover the corresponding plaintext It has advantage  in attacking thesystem if Pr[A(Kpub; C) = M ] =  We say that the public key scheme is a one-way encryption scheme (OWE) if no polynomial time attacker has non-negligibleadvantage in attacking the scheme See [12] for precise denitionsFor identity-based encryption we strengthen the denition as follows We saythat an IBE scheme is a one-way identity-based encryption scheme (ID-OWE)if no polynomially bounded adversary A has a non-negligible advantage againstthe Challenger in the following game:Identity-Based Encryption from the Weil Pairing 219Setup: The challenger takes a security parameter k and runs the Setup algo-rithm It gives the adversary the resulting system parameters params It keepsthe master-key to itselfPhase 1: The adversary issues private key extraction queries ID1; : : : ; IDm Thechallenger responds by running algorithm Extract to generate the private keydi corresponding to the public key IDi It sends di to the adversary Thesequeries may be asked adaptivelyChallenge: Once the adversary decides that Phase 1 is over it outputs a publickey ID 6= ID1; : : : ; IDm on which it wishes to be challenged The challengerpicks a random M 2 M and encrypts M using ID as the public key It thensends the resulting ciphertext C to the adversaryPhase 2: The adversary issues more extraction queries IDm+1; : : : ; IDn Theonly constraint is that IDi 6= ID The challenger responds as in Phase 1Guess: Finally the adversary outputs a guess M 0 2 M The adversary wins thegame if M = M 0We refer to such an attacker A as an ID-OWE attacker We dene adversary’sA’s advantage in attacking the scheme as: Adv(A) = Pr[M = M 0] The prob-ability is over the random bits used by the challenger and the adversary Notethat the denitions of OWE is the same as ID-OWE except that there are noprivate key extraction queries and the attacker is challenged on a random publickey (rather than a public key of her choice)3 Properties of the Weil PairingThe bilinear map e^ : G1  G1 ! G2 discussed in Section 2 is implemented viathe Weil pairing In this section we describe the basic properties of this pairingand the complexity assumption needed for the security of our system To makethe presentation concrete we consider a specic supersingular elliptic curve InSection 5 we describe several extensions and observations for our approach Thecomplete denition and algorithm for computing the pairing are given in the fullversion of the paper [2]Let p be a prime satisfying p = 2 mod 3 and p = 6q−1 for some prime q LetE be the elliptic curve dened by the equation y2 = x3 + 1 over Fp We state afew elementary facts about this curve:Fact 1: Since x3+1 is a permutation on Fp it easily follows that E=Fp containsp+1 points We let O denote the point at innity Let P 2 E=Fp be a generatorof the group of points of order q = (p + 1)=6 We denote this group by GqFact 2: For any y0 2 Fp there is a unique point (x0; y0) on E=Fp Hence if(x; y) is a random non-zero point on E=Fp then y is uniform in Fp We usethis property to simplify the proof of securityFact 3: Let 1 6=  2 Fp2 be a solution of x3 − 1 = 0 mod p Then the map(x; y) = (x; y) is an automorphism of the group of points on the curveE Note that when P = (x; y) 2 E=Fp we have that (P ) 2 E=Fp2  but(P ) 62 E=Fp Hence P 2 E=Fp is linearly independent of (P ) 2 E=Fp2 220 D Boneh and M FranklinFact 4: Since the points P and (P ) are linearly independent they generate agroup isomorphic to Zq  Zq We denote this group of points by E[q]Let q be the subgroup of Fp2 containing all elements of order q = (p + 1)=6The Weil pairing on the curve E=Fp2 is a mapping e : E[q]  E[q] ! q Wedene the modied Weil pairing e^ : Gq  Gq ! q to be:e^(P; Q) = e(P; (Q))The modied Weil pairing satises the following properties:1 Bilinear: For all P; Q 2 Gq and for all a; b 2 Z we have e^(aP; bQ) = e^(P; Q)ab2 Non-degenerate: e^(P; P ) 2 Fp2 is an element of order q and in fact a generatorof q3 Computable: Given P; Q 2 Gq there is an ecient algorithm due to Miller tocompute e^(P; Q) This algorithm is described in [2] Its run time is comparableto a full exponentiation in Fp31 Weil Die-Hellman AssumptionJoux and Nguyen [18] point out that although the Computational Die-Hellmanproblem (CDH) appears to be hard in the group Gq the Decisional Die-Hellman problem (DDH) is easy in Gq Observe that given P; aP; bP; cP 2 Gqwe havec = ab mod q () e^(P; cP ) = e^(aP; bP )Hence the modied Weil pairing provides an easy test for Die-Hellman tuplesConsequently one cannot use the DDH assumption to build cryptosystems in thegroup Gq The security of our system is based on the following natural variantof the Computational Die-Hellman assumptionWeil Die-Hellman Assumption (WDH): Let p = 2 mod 3 be a k-bit prime andp = 6q−1 for some prime q Let E=Fp be the curve y2 = x3+1 and let P 2 E=Fpbe a point of order q The WDH problem is as follows: Given hP; aP; bP; cP i forrandom a; b; c 2 Zq compute W = e^(P; P )abc 2 Fp2  The WDH Assumptionstates that when p is a random k-bit prime there is no probabilistic polynomialtime algorithm for the WDH problem An algorithm A has advantage  in solvingWDH if PrA(P; aP; bP; cP ) = e^(P; P )abc   Joux [17] previously used ananalogue of the WDH assumption to construct a one-round three party Die-Hellman protocol Verheul [30] recently used a related hardness assumptionTo conclude this section we point out that the discrete log problem in Gq iseasily reducible to the discrete log problem in Fp2 (see [2213]) To see this observethat given P 2 Gq and Q = aP we can dene g = e^(P; P ) and h = e^(Q; P )Then h = ga and h; g 2 Fp2  Hence computing discrete log in Fp2 is sucientfor computing discrete log in Gq For proper security of discrete log in Fp oneoften uses primes p that are 1024-bits long Since we need discrete log in Gq tobe dicult our system also uses primes p that are at least 1024-bits longIdentity-Based Encryption from the Weil Pairing 2214 Our Identity-Based Encryption SchemeWe describe our scheme in stages First we give a basic identity-based encryptionscheme which is not secure against an adaptive chosen ciphertext attack Theonly reason for describing the basic scheme is to make the presentation easierto follow Our full scheme described in Section 43 extends the basic scheme toget security against an adaptive chosen ciphertext attack (IND-ID-CCA) in therandom oracle model41 MapToPointLet p be a prime satisfying p = 2 mod 3 and p = 6q−1 for some prime q > 3 LetE be the elliptic curve y2 = x3+1 over Fp Our IBE scheme makes use of a simplealgorithm for converting an arbitrary string ID 2 f0; 1g to a point QID 2 E=Fpof order q We refer to this algorithm as MapToPoint We describe one of severalways of doing so Let G be a cryptographic hash function G : f0; 1g ! Fp (inthe security analysis we view G as a random oracle) Algorithm MapToPointGworks as follows:1 Compute y0 = G(ID) and x0 = (y20 − 1)1=3 = (y20 − 1)(2p−1)=3 mod p2 Let Q = (x0; y0) 2 E=Fp Set QID = 6Q Then QID has order q as requiredThis completes the description of MapToPoint We note that there are 5 valuesof y0 2 Fp for which 6Q = (x0; y0) = O (these are the non-O points of orderdividing 6) When G(ID) is one of these 5 values QID will not have order q Sinceit is extremely unlikely for G(ID) to hit one of these ve points for simplicitywe say that such ID’s are invalid It is easy to extend algorithm MapToPoint tohandle these ve y0 values as well42 BasicIdentTo explain the basic ideas underlying our IBE system we describe the followingsimple scheme called BasicIdent We present the scheme by describing the fouralgorithms: Setup Extract Encrypt Decrypt We let k be the security parametergiven to the setup algorithmSetup: The algorithm works as follows:Step 1: Choose a large k-bit prime p such that p = 2 mod 3 and p = 6q − 1 forsome prime q > 3 Let E be the elliptic curve dened by y2 = x3 + 1 overFp Choose an arbitrary P 2 E=Fp of order qStep 2: Pick a random s 2 Zq and set Ppub = sP Step 3: Choose a cryptographic hash function H : Fp2 ! f0; 1gn for somen Choose a cryptographic hash function G : f0; 1g ! Fp The securityanalysis will view H and G as random oraclesThe message space is M = f0; 1gn The ciphertext space is C = E=Fpf0; 1gnThe system parameters are params = hp; n; P; Ppub; G; Hi The master-key iss 2 Zq222 D Boneh and M FranklinExtract: For a given string ID 2 f0; 1g the algorithm builds a private key d asfollows:Step 1: Use MapToPointG to map ID to a point QID 2 E=Fp of order qStep 2: Set the private key dID to be dID = sQID where s is the master keyEncrypt: To encrypt M 2 M under the public key ID do the following: (1)use MapToPointG to map ID into a point QID 2 E=Fp of order q (2) choose arandom r 2 Zq and (3) set the ciphertext to beC = hrP; M  H(grID)i where gID = e^(QID; Ppub) 2 Fp2Decrypt: Let C = hU; V i 2 C be a ciphertext encrypted using the public keyID If U 2 E=Fp is not a point of order q reject the ciphertext Otherwise todecrypt C using the private key dID compute:V  H(e^(dID; U)) = MThis completes the description of BasicIdent We rst verify consistency Wheneverything is computed as above we have:1 During encryption M is Xored with the hash of: grID2 During decryption V is Xored with the hash of: e^(dID; U)These masks used during encryption and decryption are the same since:e^(dID; U) = e^(sQID; rP ) = e^(QID; P )sr = e^(QID; Ppub)r = grIDThus applying decryption after encryption produces the original message Mas required We note that there is no need to devise attacks against this basicscheme since it is only presented for simplifying the exposition The next sectiondescribes the full schemePerformance Algorithms Setup and Extract are very simple algorithms At theheart of both algorithms is a standard multiplication on the curve E=Fp Algo-rithm Encrypt requires that the encryptor compute the Weil pairing of QID andPpub Note that this computation is independent of the message and hence canbe done once and for all Once gID is computed the performance of the system isalmost identical to standard ElGamal encryption We also note that the cipher-text length is the same as in regular ElGamal encryption in Fp Decryption is asimple Weil pairing computationSecurity Next we study the security of this basic scheme The following theoremshows that the scheme is a one-way identity based encryption scheme (ID-OWE)assuming WDH is hardTheorem 1 Let the hash functions H; G be random oracles Suppose there is anID-OWE attacker A that has advantage  against the scheme BasicIdent SupposeA make at most qE > 0 private key extraction queries and qH > 0 hash queriesThen there is an algorithm B for computing WDH with advantage at leaste(1+qE)qH − 1qH 2n  Here e  2:71 is the base of the natural logarithm Therunning time of B is O(time(A))Identity-Based Encryption from the Weil Pairing 223To prove the theorem we need to dene a related Public Key Encryptionscheme (not an identity scheme) called PubKeyEnc PubKeyEnc is described bythree algorithms: keygen encrypt decryptkeygen: The algorithm works as follows:Step 1: Choose a large k-bit prime p such that p = 2 mod 3 and p = 6q − 1for some prime q > 3 Let E be the elliptic curve dened by y2 = x3 + 1over Fp Choose an arbitrary P 2 E=Fp of order qStep 2: Pick a random s 2 Zq and set Ppub = sP Pick a random point QID 2 E=Fp of order q Then QID is in the groupgenerated by P Step 3: Choose a cryptographic hash function H : Fp2 ! f0; 1gn for some nStep 4: The public key is hp; n; P; Ppub; QID; Hi The private key is dID = sQIDencrypt: To encrypt M 2 f0; 1gn choose a random r 2 Zq and set the ciphertextto be:C = hrP; M  H(gr)i where g = e^(QID; Ppub) 2 Fp2decrypt: Let C = hU; V i 2 C be a ciphertext encrypted using the public keyhp; n; P; Ppub; QID; Hi To decrypt C using the private key dID compute:V  H(e^(dID; U)) = MThis completes the description of PubKeyEnc We now prove Theorem 1 in twosteps We rst show that an ID-OWE attack on BasicIdent can be converted to aOWE attack on PubKeyEnc This step shows that private key extraction queriesdo not help the attacker We then show that PubKeyEnc is OWE if the WDHassumption holds The proofs of these two lemmas appear in the full version ofthe paper [2]Lemma 1 Let G be a random oracle from f0; 1g to Fp Let A be an ID-OWEattacker that has advantage  against BasicIdent Suppose A makes at mostqE > 0 private key extraction queries Then there is a OWE attacker B thathas advantage =e(1 + qE) against PubKeyEnc Its running time is O(time(A))Lemma 2 Let H be a random oracle from Fp2 to f0; 1gn Let A be a OWEattacker that has advantage  against PubKeyEnc Suppose A makes a total ofqH > 0 queries to H Then there is an algorithm B that solves the WDH problemwith advantage at least ( − 12n )=qH and a running time O(time(A))Proof of Theorem 1 The theorem follows directly from Lemma 1 andLemma 2 Composing both reductions shows that an ID-OWE attacker onBasicIdent with advantage  gives an algorithm for WDH with advantage(=e(1 + qE) − 1=2n)=qH  as required 224 D Boneh and M Franklin43 Identity-Based Encryption with Chosen Ciphertext SecurityWe use a technique due to Fujisaki-Okamoto [12] to convert the BasicIdentscheme of the previous section into a chosen ciphertext secure IBE system (in thesense of Section 2) in the random oracle model Let E be a public key encryptionscheme We denote by Epk(M ; r) the encryption of M using the random bits runder the public key pk Fujisaki-Okamoto dene the hybrid scheme Ehy as:Ehypk (M) = Epk(;H1(; M))∥∥∥∥ G1()  MHere  is generated at random and H1; G1 are cryptographic hash functionsFujisaki-Okamoto show that if E is a one-way encryption scheme then Ehy is achosen ciphertext secure system (IND-CCA) in the random oracle model (assum-ing Epk satises some natural constraints)We apply this transformation to BasicIdent and show that the resulting IBEsystem is IND-ID-CCA We obtain the following IBE scheme which we call FullI-dent Recall that n is the length of the message to be encryptedSetup: As in the BasicIdent scheme In addition we pick a hash function H1 :f0; 1gn  f0; 1gn ! Fq and a hash function G1 : f0; 1gn ! f0; 1gnExtract: As in the BasicIdent schemeEncrypt: To encrypt M 2 f0; 1gn under the public key ID do the following: (1)use algorithm MapToPointG to convert ID into a point QID 2 E=Fp of orderq (2) choose a random  2 f0; 1gn (3) set r = H1(; M) and (4) set theciphertext to beC = hrP;   H(grID); M  G1()i where gID = e^(QID; Ppub) 2 Fp2Decrypt: Let C = hU; V; W i 2 C be a ciphertext encrypted using the publickey ID If U 2 E=Fp is not a point of order q reject the ciphertext To decryptC using the private key dID do:1 Compute V  H(e^(dID; U)) = 2 Compute W  G1() = M 3 Set r = H1(; M) Test that U = rP  If not reject the ciphertext4 Output M as the decryption of CThis completes the description of FullIdent Note that M is encrypted as W =M  G1() This can be replaced by W = EG1()(M) where E is a semanticallysecure symmetric encryption scheme (see [12])Security The following theorem shows that FullIdent is a chosen ciphertext se-cure IBE (ie IND-ID-CCA) assuming WDH is hardTheorem 2 Let A be a t-time IND-ID-CCA attacker on FullIdent that achievesadvantage  Suppose A makes at most qE extraction queries at most qD decryp-tion queries and at most qH ; qG1; qH1 queries to the hash functions H; G1; H1Identity-Based Encryption from the Weil Pairing 225respectively Then there is a t1-time algorithm for WDH that achieves advantage1 wheret1 = FOtime(t; qG1 ; qH1)1 =FOadv(( 1eqE −qDq ); qG1 ; qH1 ; qD) − 1=2n=qHwhere the functions FOtime and FOadv are dened in Theorem 3The proof of the theorem is based on the theorem below due to Fujisaki andOkamoto (Theorem 14 in [12]) We state their theorem as it applies to the publickey encryption scheme PubKeyEnc of the previous section Let PubKeyEnchy bethe result of applying the Fujisaki-Okamoto transformation to PubKeyEncTheorem 3 (FO) Suppose there is a (t; qG1 ; qH1 ; qD) IND-CCA attacker thatachieves advantage  when attacking PubKeyEnchy Then there is a (t1; 1) OWEattacker on PubKeyEnc wheret1 = FOtime(t; qG1 ; qH1) = t + O((qG1 + qH1)  n); and1 = FOadv(; qG1 ; qH1 ; qD) =12(qG1 + qH1)[( + 1)(1 − 2=q)qD − 1]We also need the following lemma to translate between an IND-ID-CCA cho-sen ciphertext attack on FullIdent and an IND-CCA chosen ciphertext attack onPubKeyEnchy The proof appears in the full version of the paper [2]Lemma 3 Let A be an IND-ID-CCA attacker that has advantage  against theIBE scheme FullIdent Suppose A makes at most qE > 0 private key extractionqueries and at most qD decryption queries Then there is an IND-CCA attackerB that has advantage at least ( 1eqE −qDq ) against PubKeyEnchy Its running timeis O(time(A))Proof of Theorem 2 By Lemma 3 an IND-ID-CCA attacker on FullIdentimplies an IND-CCA attacker on PubKeyEnchy By Theorem 3 an IND-CCAattacker on PubKeyEnchy implies a OWE attacker on PubKeyEnc By Lemma 2a OWE attacker on PubKeyEnc implies an algorithm for WDH Composing allthese reductions gives the required bounds 5 Extensions and ObservationsTate pairing and other curves Our IBE system has some flexibility in termsof the curves being used and the denition of the pairing For example onecould use the curve y2 = x3 + x with its endomorphism  : (x; y) ! (−x; iy)where i2 = −1 We do not explore this here but note that both encryption anddecryption in FullIdent can be made faster by using the Tate pairing In generalone can use any eciently computable bilinear pairing e^ : G1  G1 ! G2between two groups G1;G2 as long as the WDH assumption holds One wouldalso need a way to map identities in f0; 1g uniformly onto G1226 D Boneh and M FranklinDistributed PKG In the standard use of an IBE in an e-mail system themaster-key stored at the PKG must be protected in the same way that the pri-vate key of a CA is protected One way of protecting this key is by distributingit among dierent sites using techniques of threshold cryptography [14] OurIBE system supports this in a very ecient and robust way Recall that themaster-key is some s 2 Fq in order to generate a private key the PKG com-putes Qpriv = sQID where QID is derived from the user’s public key ID This caneasily be distributed in a t-out-of-n fashion by giving each of the n PKGs oneshare si of a Shamir secret sharing of s mod q When generating a private keyeach of the t chosen PKGs simply responds with Q(i)priv = siQID The user canthen construct Qpriv as Qpriv =PiQ(i)priv where the i’s are the appropriateLagrange coecientsFurthermore it is easy to make this scheme robust against dishonest PKGsusing the fact that DDH is easy in Gq (the group generated by P ) Duringsetup each of the n PKGs publishes P (i)pub = siP  During a key generationrequest the user can verify that the response from the i’th PKG is valid bytesting that:e^(Q(i)priv; P ) = e^(QID; P(i)pub)Thus a misbehaving PKG will be immediately caught There is no need forzero-knowledge proofs as in regular robust threshold schemes The PKG’smaster-key can be generated in a distributed fashion using the techniquesof [15]Note that a distributed master-key also enables decryption on a per-messagebasis without any need to derive the corresponding decryption key For exam-ple threshold decryption of BasicIdent ciphertext (U; V ) is straightforward ifeach PKG responds with e^(siQID; U)Working in subgroups The performance of our IBE system can be improvedif we work in a small subgroup of the curve For example choose a 1024-bitprime p = 2 mod 3 with p = aq − 1 for some 160-bit prime q The point Pis then chosen to be a point of order q Each public key ID is converted to agroup point by hashing ID to a point Q on the curve and then multiplying thepoint by a The system is secure if the WDH assumption holds in the groupgenerated by P  The advantage is that Weil computations are done on pointsof small order and hence is much fasterIBE implies signatures Moni Naor has observed that an IBE scheme canbe immediately converted into a public key signature scheme The intuitionis as follows The private key for the signature scheme is the master key forthe IBE scheme The public key for the signature scheme is the global systemparameters for the IBE scheme The signature on a message M is the IBEdecryption key for ID = M  To verify a signature choose a random messageM 0 encrypt M 0 using the public key ID = M  and then attempt to decryptusing the given signature on M as the decryption key If the IBE scheme isIND-ID-CCA then the signature scheme is existentially unforgeable againsta chosen message attack Note that unlike most signature schemes the sig-Identity-Based Encryption from the Weil Pairing 227nature verication algorithm here is randomized This shows that secure IBEschemes require both public key encryption and digital signatures We notethat the signature scheme derived from our IBE system has some interestingproperties [3]6 Escrow ElGamal EncryptionIn this section we note that the Weil pairing enables us to add a global escrowcapability to the ElGamal encryption system A single escrow key enables thedecryption of ciphertexts encrypted under any public key Paillier and Yunghave shown how to add a global escrow capability to the Paillier encryptionsystem [24] Our ElGamal escrow system works as follows:Setup: The algorithm works as follows:Step 1: Choose a large k-bit prime p such that p = 2 mod 3 and p = 6q − 1 forsome prime q > 3 Let E be the elliptic curve dened by y2 = x3 + 1 overFp Choose an arbitrary P 2 E=Fp of order qStep 2: Pick a random s 2 Zq and set Q = sP Step 3: Choose a cryptographic hash function H : Fp2 ! f0; 1gnThe message space is M = f0; 1gn The ciphertext space is C = E=Fpf0; 1gnThe system parameters are params = hp; n; P; Q; Hi The escrow key is s 2 Zqkeygen: A user generates a public/private key pair for herself by picking arandom x 2 Zq and computing Ppub = xP  Her private key is x her publickey is PpubEncrypt: To encrypt M 2 f0; 1gn under the public key Ppub do the following:(1) pick a random r 2 Zq and (2) set the ciphertext to be:C = hrP; M  H(gr)i where g = e^(Ppub; Q) 2 Fp2Decrypt: Let C = hU; V i be a ciphertext encrypted using Ppub If U 2 E=Fpis not a point of order q reject the ciphertext To decrypt C using the privatekey x do:V  H(e^(U; xQ)) = MEscrow-decrypt: To decrypt C = hU; V i using the escrow key s do:V  H(e^(U; sPpub)) = MA standard argument shows that assuming WDH the system has semanticsecurity in the random oracle model (recall that since DDH is easy we cannotprove semantic security based on DDH) Yet the escrow agent can decrypt anyciphertext encrypted using any user’s public key The decryption capability of theescrow agent can be distributed using the PKG distribution techniques describedin Section 5Using a similar hardness assumption Verheul [30] has recently describedan ElGamal encryption system with non-global escrow Each user constructs a228 D Boneh and M Franklinpublic key with two corresponding private keys and gives one of the private keysto the trusted third party Although both private keys can be used to decryptonly the user’s private key can be used simultaneously as the signing key for adiscrete logarithm based signature scheme7 Summary and Open ProblemsWe dened chosen ciphertext security for identity-based systems and proposeda fully functional IBE scheme The scheme has chosen ciphertext security inthe random oracle model assuming WDH a natural analogue of the compu-tational Die-Hellman problem The WDH assumption deserves further studyconsidering the powerful cryptosystems derived from it For example it couldbe interesting to see whether the techniques of [20] can be used to prove thatthe WDH assumption is equivalent to the discrete log assumption on the curvefor certain primes pIt is natural to try and build chosen ciphertext secure identity based systemsthat are secure under standard complexity assumptions (rather than the ran-dom oracle model) One might hope to use the techniques of Cramer-Shoup [6]to provide chosen ciphertext security based on DDH Unfortunately as men-tioned in Section 2 the DDH assumption is false in the group of points on thecurve E However a natural variant of DDH does seem to hold In particularthe following two distributions appear to be computationally indistinguishable:hP; aP; bP; cP; abcP i and hP; aP; bP; cP; rP i where a; b; c; r are random in Zq Werefer to this assumption as WDDH It is natural to ask whether there is a chosenciphertext secure identity-based system strictly based on WDDH Such a schemewould be the analogue of the Cramer-Shoup systemReferences1 M Bellare A Desai D Pointcheval P Rogaway \Relations among notions ofsecurity for public-key encryption schemes" Proc Crypto ’98 pp 26{45 19982 D Boneh M Franklin \Identity based encryption from the Weil pairing" Fullversion available at http://cryptostanfordedu/ibe3 D Boneh B Lynn H Shacham \Short signatures from the Weil pairing"manuscript4 M Bellare A Boldyreva S Micali \Public-key Encryption in a Multi-UserSetting: Security Proofs and Improvements" Proc Eurocrypt 2000 LNCS 180720005 J Coron \On the exact security of Full-Domain-Hash" Proc of Crypto 20006 R Cramer and V Shoup \A practical public key cryptosystem provably secureagainst adaptive chosen ciphertext attack" in proc Crypto ’98 pp 13{257 Y Desmedt and J Quisquater \Public-key systems based on the diculty oftampering" Proc Crypto ’86 pp 111-117 19868 G Di Crescenzo R Ostrovsky and S Rajagopalan \Conditional ObliviousTransfer and Timed-Release Encryption" Proc of Eurocrypt ’99Identity-Based Encryption from the Weil Pairing 2299 D Dolev C Dwork M Naor \Non-malleable cryptography" SIAM J of Com-puting Vol 30(2) pp 391{437 200010 U Feige A Fiat and A Shamir \Zero-knowledge proofs of identity" J Cryp-tology vol 1 pp 77{94 198811 A Fiat and A Shamir \How to prove yourself: Practical solutions to identi-cation and signature problems" Proc Crypto ’86 pp 186{194 198612 E Fujisaki and T Okamoto \Secure integration of asymmetric and symmetricencryption schemes" Proc Crypto ’99 pp 537{554 199913 G Frey M Mu¨ller H Ru¨ck \The Tate pairing and the discrete logarithmapplied to elliptic curve cryptosystems" IEEE Tran on Info Th Vol 45 pp1717{1718 199914 P Gemmell \An introduction to threshold cryptography" in CryptoBytes atechnical newsletter of RSA Laboratories Vol 2 No 7 199715 R Gennaro S Jarecki H Krawczyk T Rabin \Secure Distributed Key Gen-eration for Discrete-Log Based Cryptosystems" Advances in Cryptology { Eu-rocrypt ’99 Springer-Verlag LNCS 1592 pp 295{310 199916 O Goldreich B Ptzmann and R Rivest \Self-delegation with controlled prop-agation -or- What if you lose your laptop" proc Crypto ’98 pp 153{168 199817 A Joux \A one round protocol for tripartite Die-Hellman" Proc of ANTS4 LNCS 1838 pp 385{394 200018 A Joux K Nguyen \Separating Decision Die-Hellman from Die-Hellmanin cryptographic groups" available from eprintiacrorg19 S Lang \Elliptic functions" Addison-Wesley Reading 197320 U Maurer \Towards proving the equivalence of breaking the Die-Hellmanprotocol and computing discrete logarithms" Proc Crypto ’94 pp 271{28121 U Maurer and Y Yacobi \Non-interactive public-key cryptography" procEurocrypt ’91 pp 498{50722 A Menezes T Okamoto S Vanstone \Reducing elliptic curve logarithms tologarithms in a nite eld" IEEE Tran on Info Th Vol 39 pp 1639{1646199323 V Miller \Short programs for functions on curves" unpublished manuscript24 P Paillier and M Yung \Self-escrowed public-key infrastructures" in ProcICISC pp 257{268 199925 C Racko D Simon \Noninteractive zero-knowledge proof of knowledge andchosen ciphertext attack" in proc Crypto ’91 pp 433{444 199126 R Rivest A Shamir and D Wagner \Time lock puzzles and timed releasecryptography" Technical report MIT/LCS/TR-68427 A Shamir \Identity-based cryptosystems and signature schemes" Proc Crypto’84 pp 47{5328 S Tsuji and T Itoh \An ID-based cryptosystem based on the discrete logarithmproblem" IEEE Journal on Selected Areas in Communication vol 7 no 4 pp467{473 198929 H Tanaka \A realization scheme for the identity-based cryptosystem" ProcCrypto ’87 pp 341{349 198730 E Verheul \Evidence that XTR is more secure than supersingular elliptic curvecryptosystems" Proc Eurocrypt 2001
key insulated public key cryptosystem-pdf,Key-Insulated Public Key CryptosystemsYevgeniy Dodis1 Jonathan Katz2 Shouhuai Xu3 and Moti Yung41 Department of Computer Science New York Universitydodis@csnyuedu2 Department of Computer Science Columbia Universityjkatz@cscolumbiaedu3 Department of Information and Software Engineering George Mason Universitysxu1@gmuedu4 CertCo Incmoti@cscolumbiaeduAbstract Cryptographic computations (decryption signature genera-tion etc) are often performed on a relatively insecure device (eg amobile device or an Internet-connected host) which cannot be trustedto maintain secrecy of the private key We propose and investigate thenotion of key-insulated security whose goal is to minimize the damagecaused by secret-key exposures In our model the secret key(s) storedon the insecure device are refreshed at discrete time periods via inter-action with a physically-secure – but computationally-limited – devicewhich stores a “master key” All cryptographic computations are stilldone on the insecure device and the public key remains unchanged In a(tN)-key-insulated scheme an adversary who compromises the insecuredevice and obtains secret keys for up to t periods of his choice is unableto violate the security of the cryptosystem for any of the remaining N−tperiods Furthermore the scheme remains secure (for all time periods)against an adversary who compromises only the physically-secure deviceWe focus primarily on key-insulated public-key encryption We constructa (tN)-key-insulated encryption scheme based on any (standard) public-key encryption scheme and give a more efficient construction based onthe DDH assumption The latter construction is then extended to achievechosen-ciphertext security1 IntroductionMotivation Exposure of secret keys is perhaps the most devastating attack on acryptosystem since it typically means that security is entirely lost This problemis probably the greatest threat to cryptography in the real world: in practiceit is typically easier for an adversary to obtain a secret key from a naive userthan to break the computational assumption on which the system is based Thethreat is increasing nowadays with users carrying mobile devices which allowremote access from public or foreign domainsTwo classes of methods exist to deal with this problem The first tries to pre-vent key exposure altogether While this is an important goal it is not alwayspractical For example when using portable devices to perform cryptographicLR Knudsen (Ed): EUROCRYPT 2002 LNCS 2332 pp 65–82 2002c© Springer-Verlag Berlin Heidelberg 200266 Yevgeniy Dodis et aloperations (eg decrypting transmissions using a mobile phone) one must ex-pect that the device itself may be physically compromised in some way (eg lostor stolen) and thus key exposure is inevitable Furthermore complete preven-tion of key exposure – even for non-mobile devices – will usually require somedegree of physical security which can be expensive and inconvenient The secondapproach assumes that key exposure will inevitably occur and seeks instead tominimize the damage which results when keys are obtained by an adversarySecret sharing [35] threshold cryptography [1312] proactive cryptography [32]exposure-resilient cryptography [9] and forward-secure signatures [35] may allbe viewed as different means of taking this approachThe most successful solution will involve a combination of the above ap-proaches Physical security may be ensured for a single device and thus we mayassume that data stored on this device will remain secret On the other handthis device may be computationally limited or else not suitable for a particularapplication and thus we are again faced with the problem that some keys willneed to be stored on insecure devices which are likely to be compromised duringthe lifetime of the system Therefore techniques to minimize the damage causedby such compromises must also be implementedOur Model We focus here on a notion we term key-insulated security Ourmodel is the following (the discussion here focuses on public-key encryption yetthe term applies equally-well to the case of digital signatures) The user beginsby registering a single public key PK A “master” secret key SK∗ is storedon a device which is physically secure and hence resistant to compromise Alldecryption however is done on an insecure device for which key exposure isexpected to be a problem The lifetime of the protocol is divided into distinctperiods 1     N (for simplicity one may think of these time periods as being ofequal length; eg one day) At the beginning of each period the user interactswith the secure device to derive a temporary secret key which will be used todecrypt messages sent during that period; we denote by SKi the temporary keyfor period i On the other hand the public key PK used to encrypt messagesdoes not change at each period; instead ciphertexts are now labeled with thetime period during which they were encrypted Thus encrypting M in period iresults in ciphertext 〈i C〉The insecure device which does all actual decryption is vulnerable to re-peated key exposures; specifically we assume that up to t < N periods can becompromised (where t is a parameter) Our goal is to minimize the effect suchcompromises will have Of course when a key SKi is exposed an adversary willbe able to decrypt messages sent during time period i Our notion of security(informally) is that this is all an adversary can do In particular the adversarywill be unable to determine any information about messages sent during all timeperiods other than those in which a compromise occurred This is the strongestlevel of security one can expect in such a model We call a scheme satisfying theabove notion (tN)-key-insulatedIf the physically-secure device is completely trusted we may have this devicegenerate (PKSK∗) itself keep SK∗ and publish PK When a user requestsKey-Insulated Public Key Cryptosystems 67a key for period i the device may compute SKi and send it to the user Moreinvolved methods are needed when the physically-secure device is not trustedby the user In this more difficult case (which we consider here) the user maygenerate (PKSK) himself publish PK and then derive keys SK∗ SK0 Theuser then sends SK∗ to the device and stores SK0 himself When the userrequests a key for period i the device sends “partial” key SK ′i to the user whomay then compute the “actual” key SKi using SKi−1 and SK ′i In this way theuser’s security is guaranteed during all time periods with respect to the deviceitself provided that the knowledge of SK∗ alone is not sufficient to derive anyof the actual keys SKi We note that this strong security guarantee is essentialwhen a single device serves many different users offering them protection againstkey exposure In this scenario users may trust this device to update their keysbut may not want the device to be able to read their encrypted traffic Thusthere is no reason this device should have complete (or any!) knowledge of their“actual” keys Finally we note that assuring that the devices are synchronized tothe same period (so that only one secret key per period is given by the physicallysecure device) and that they handle proper authenticated interaction is takencare of by an underlying protocol (which is outside our model)Other Applications Besides the obvious application to minimizing the risk ofkey exposures across multiple time periods key-insulated security may also beused to protect against key exposures across multiple locations or users Forexample a company may establish a single public key and distribute (different)secret keys to its various employees; each employee is differentiated by his “non-cryptographic ID” i (eg a social security number or last name) and can usehis own secret key SKi to perform the desired cryptographic operation Thisapproach could dramatically save on the public key size and has the propertythat the system remains secure (for example encrypted messages remain hidden)for all employees whose keys are not exposedA key-insulated scheme may also be used for purposes of delegation [22];here a user (who has previously established a public key) delegates his rightsin some specified limited way to a second party In this way even if up to t ofthe delegated parties’ keys are lost the remaining keys – and in particular theuser’s secret key – are secureFinally we mention the application of key escrow by legal authorities Forexample consider the situation in which the FBI wants to read email sent toa particular user on a certain date If a key-insulated scheme (updated daily)is used the appropriate key for up to t desired days can be given to the FBIwithout fear that this will enable the FBI to read email sent on other days Asimilar application (with weaker security guarantees) was considered by [2]Our Contributions We introduce the notion of key-insulated security and con-struct efficient schemes secure under this notion Although our definition may beapplied to a variety of cryptographic primitives we focus here on public-key en-cryption In Section 3 we give a generic construction of a (tN)-key-insulated en-cryption scheme based on any (standard) public-key encryption scheme Section4 gives a more efficient construction which is secure under the DDH assumption68 Yevgeniy Dodis et alBoth of these schemes achieve semantic security; however we show in Section 5how the second scheme can be improved to achieve chosen-ciphertext security Ina companion paper [15] we consider key-insulated security of signature schemesRelated Work Arriving at the right definitions and models for the notion we putforth here has been somewhat elusive For example Girault [21] considers a no-tion similar to key-insulated security of signature schemes However [21] does notpresent any formal definitions nor does it present schemes which are provablysecure Recently and concurrently with our work other attempts at formaliz-ing key-insulated public-key encryption have been made [3630] However theseworks consider only a non-adaptive adversary who chooses which time periods toexpose at the outset of the protocol whereas we consider the more natural andrealistic case of an adaptive adversary who may choose which time periods toexpose at any point during protocol execution Furthermore the solution of [36]for achieving chosen-ciphertext security is proven secure in the random oraclemodel; our construction of Section 5 is proven secure against chosen-ciphertextattacks in the standard model ([30] does not address chosen-ciphertext securityat all) Finally our definition of security is stronger than that considered in[3630] Neither work considers the case of an untrusted physically-secure de-vice Additionally [30] require only that an adversary cannot fully determine anun-exposed key SKi; we make the much stronger requirement that an adversarycannot break the underlying cryptographic scheme for any (set of) un-exposedperiodsOur notion of security complements the notion of forward security for digi-tal signatures1 In this model [35] an adversary who compromises the systemduring a particular time period obtains all the secret information which existsat that point in time Clearly in such a setting one cannot hope to prevent theadversary from signing messages associated with future time periods (since theadversary has all relevant information) even though no explicit key exposureshappen during those periods Forward-secure signatures however prevent theadversary from signing messages associated with prior time periods Many im-proved constructions of forward-secure signatures have subsequently appeared[1282531]Our model uses a stronger assumption in that we allow for (a limited amountof) physically-secure storage which is used exclusively for key updates and is notused for the actual cryptographic computations As a consequence we are ableto obtain a much stronger level of security in that the adversary is unable tosign/decrypt messages at any non-compromised time period both in the futureand in the pastAn identity-based encryption scheme may be converted to an (N − 1 N)-key-insulated encryption scheme by viewing the period number as an “identity”and having the physically-secure device implement the trusted third party In1 Although forward-security also applies to public-key encryption forward-secure en-cryption schemes are not yet known The related notion of “perfect forward se-crecy” [14] where the parties exchange ephemeral keys on a per-session basis isincomparable to our notion hereKey-Insulated Public Key Cryptosystems 69fact our notion of (tN)-key-insulated encryption with a fully trusted device canbe viewed as a relaxation of identity-based encryption where we do not insiston t = N − 1 Only recently Boneh and Franklin [7] have proposed a practicalidentity-based encryption scheme; they also mention the above connection Itshould be noted however that the security of their scheme is proven in therandom oracle model under a very specific number-theoretic assumption Byfocusing on key-insulated security for t  N  as we do here schemes based onalternate assumptions and/or with improved efficiency and functionality may bedesigned2 Definitions21 The ModelWe now provide a formal model for key-insulated security focusing on the case ofpublic-key encryption (other key-insulated primitives can be defined similarly;eg signature schemes are treated in [15]) Our definition of a key-updatingencryption scheme parallels the definition of a key-evolving signature schemewhich appears in [5] with one key difference: in a key-updating scheme thereis some data (in particular SK∗) which is never erased since it is stored on aphysically-secure device However since the physically-secure device may not befully trusted new security concerns ariseDefinition 1 A key-updating (public-key) encryption scheme is a 5-tuple ofpoly-time algorithms (GU∗U  E D) such that:– G the key generation algorithm is a probabilistic algorithm which takes asinput a security parameter 1k and the total number of time periods N  Itreturns a public key PK a master key SK∗ and an initial key SK0– U∗ the device key-update algorithm is a deterministic algorithm whichtakes as input an index i for a time period (throughout we assume 1 ≤i ≤ N) and the master key SK∗ It returns the partial secret key SK ′i fortime period i– U  the user key-update algorithm is a deterministic algorithm which takesas input an index i secret key SKi−1 and a partial secret key SK ′i It returnssecret key SKi for time period i (and erases SKi−1 SK ′i)– E the encryption algorithm is a probabilistic algorithm which takes as inputa public-key PK a time period i and a message M  It returns a ciphertext〈i C〉– D the decryption algorithm is a deterministic algorithm which takes asinput a secret key SKi and a ciphertext 〈i C〉 It returns a message M orthe special symbol ⊥We require that for all messages M  DSKi(EPK(iM)) =M A key-updating encryption scheme is used as one might expect A user beginsby generating (PKSK∗ SK0)← G(1k N) registering PK in a central location70 Yevgeniy Dodis et al(just as he would for a standard public-key scheme) storing SK∗ on a physically-secure device and storing SK0 himself At the beginning of time period i theuser requests SK ′i = U∗(i SK∗) from the secure device Using SK ′i and SKi−1the user may compute SKi = U(i SKi−1 SK ′i) This key may be used to decryptmessages sent during time period i without further access to the device Aftercomputation of SKi the user must erase SK ′i and SKi−1 Note that encryptionis always performed with respect to a fixed public key PK which need not bechanged Also note that the case when the device is fully trusted corresponds toSK0 =⊥ and SKi = SK ′iRandom-Access Key Updates All the schemes we construct will have a usefulproperty we call random-access key updates For any current period j and anydesired period i it is possible to update the secret key from SKj to SKi in“one shot” Namely we can generalize the key updating algorithms U∗ and Uto take a pair of periods i and j such that U∗((i j) SK∗) outputs the partialkey SK ′ij and U((i j) SKj  SK ′ij) outputs SKi Our definition above implicitlyfixes j = i − 1 We remark that random-access key updates are impossible toachieve in the forward-security model22 SecurityThe are three types of exposures we protect against: (1) ordinary key exposurewhich models (repeated) compromise of the insecure storage (ie leakage ofSKi); (2) key-update exposure which models (repeated) compromise of the in-secure device during the key-updating step (ie leakage of SKi−1 and SK ′i);and (3) master key exposure which models compromise of the physically-securedevice (ie leakage of SK∗; this includes the case when the device itself is un-trusted)To formally model key exposure attacks we give the adversary access to two(possibly three) types of oracles The first is a key exposure oracle ExpSK∗SK0(·)which on input i returns the temporary secret key SKi (note that SKi isuniquely defined by SK∗ and SK0) The second is a left-or-right encryption ora-cle [4] LRPKb(···) where b = b1    bN ∈ {01}N  defined as: LRPKb(iM0M1)def= EPK(iMbi) This models encryption requests by the adversary for time pe-riods and message pairs of his choice We allow the adversary to interleave en-cryption requests and key exposure requests and in particular the key exposurerequests of the adversary may be made adaptively and in any order Finally wemay also allow the adversary access to a decryption oracle D∗SK∗SK0(·) that oninput 〈i C〉 computes DSKi(〈i C〉) This models a chosen-ciphertext attack bythe adversaryThe vector b for the left-or-right oracle will be chosen randomly and theadversary succeeds by guessing the value of bi for any un-exposed time period iInformally a scheme is secure if any probabilistic polynomial time (ppt) adver-sary has success negligibly close to 1/2 More formally:Key-Insulated Public Key Cryptosystems 71Definition 2 Let Π = (GU∗U  E D) be a key-updating encryption schemeFor adversary A define the following:SuccAΠ(k)def= Pr[(PKSK∗ SK0)← G(1k N); b← {0 1}N ;(i b′)← ALRPKb(···)ExpSK∗SK0 (·)O(·)(PK) : b′ = bi]where i was never submitted to ExpSK∗SK0(·) and O(·) =⊥ for a plaintext-only attack and O(·) = D∗SK∗SK0(·) for a chosen-ciphertext attack (in the lattercase the adversary is not allowed to query D∗(〈i C〉) if 〈i C〉 was returned byLR(i · ·)) Π is (tN)-key-insulated if for any ppt A who submits at most trequests to the key-exposure oracle |SuccAΠ(k)− 1/2| is negligibleAs mentioned above we may also consider attacks in which an adversarybreaks in to the user’s storage while a key update is taking place (ie theexposure occurs between two periods i − 1 and i); we call this a key-updateexposure at period i In this case the adversary receives SKi−1 SK ′i and (cancompute) SKi Informally we say a scheme has secure key updates if a key-update exposure at period i is equivalent to key exposures at periods i− 1 andi and no more More formally:Definition 3 Key-updating encryption scheme Π has secure key updates if theview of any adversary A making a key-update exposure request at period i canbe perfectly simulated by an adversary A′ who makes key exposure requests atperiods i− 1 and iThis property is desirable in real-world implementations of a key-updating en-cryption scheme since an adversary who gains access to the user’s storage is likelyto have access for several consecutive time periods (ie until the user detects orre-boots) including the key updating stepsWe also consider attacks which compromise the physically-secure device (thisincludes attacks in which this device is untrusted) Here our definition requiresthat the encryption scheme be secure against an adversary which is given SK∗as input Note that we do not require security against an adversary who com-promises both the user’s storage and the secure device – in our model this isimpossible since given SK∗ and SKi an adversary can compute SKj (at leastfor j > i) by himselfDefinition 4 Let Π be a key-updating scheme which is (tN)-key-insulatedFor any adversary B define the following:SuccBΠ(k)def= Pr[(PKSK∗ SK0)← G(1k N); b← {0 1}N ;(i b′)← BLRPKb(···)O(·)(PKSK∗) : b′ = bi]where O(·) =⊥ for a plaintext-only attack and O(·) = D∗SK∗SK0(·) for a chosen-ciphertext attack (in the latter case the adversary is not allowed to query D∗(〈iC〉)if 〈i C〉 was returned by LR(i · ·)) Π is strongly (tN)-key-insulated if for anyppt B |SuccBΠ(k)− 1/2| is negligible72 Yevgeniy Dodis et al3 Generic Semantically-Secure ConstructionLet (GED) be any semantically secure encryption scheme Rather than givinga separate (by now standard) definition we may view it simply as a (0 1)-key-insulated scheme Namely only one secret key SK is present and any pptadversary given PK and the left-or-right-oracle LRPKb cannot predict b withsuccess non-negligibly different from 1/2 Hence our construction below can beviewed as an amplification of a (0 1)-key-insulated scheme into a general (tN)-key-insulated schemeWe will assume below that t logN = O(poly(k)) where k is our securityparameter Thus we allow exponentially-many periods and can tolerate expo-sure of any polynomial number of keys We assume that E operates on messagesof length  = (k) and construct a (tN)-key-insulated scheme operating onmessages of length L = L(k)Auxiliary Definitions We need two auxiliary definitions: that of an all-or-nothing transform [348] (AONT) and a cover-free family [1816] Informally anAONT splits the message M into n secret shares x1     xn (and possibly onepublic share z) and has the property that (1) the message M can be efficientlyrecovered from all the shares x1     xn z but (2) missing even a single sharexj gives “no information” about M  As such it is a generalization of (n− 1 n)-secret sharing We formalize this modifying the conventional definitions [89] toa form more compatible with our prior notationDefinition 5 An efficient randomized transformation T is called an (L  n)-AONT if: (1) on input M ∈ {0 1}L T outputs (X z) def= (x1     xn z) wherexj ∈ {0 1}; (2) there exists an efficient inverse function I such that I(X z) =M ; (3) T satisfies the indistinguishability property described belowLet X−j = (x1     xj−1 xj+1     xn) and T−j(M) = (X−j  z) where (X z)←T (M) Define the left-or-right oracle LRb(jM0M1) def= T−j(Mb) where b ∈{0 1} For any ppt A we let SuccAT (k) def= Pr[b← {0 1}; b′ ← ALRb(···)(1k) :b′ = b] We require that |SuccAT (k)− 1/2| is negligibleA family of subsets S1    SN over some universe U is said to be t-cover-freeif no t subsets Si1      Sit contain a (different) subset Si0 ; in other words forall {i0     it} with i0 ∈ {i1     it} we have Si0 ⊆ ∪tj=1Sij  A family is said tobe (t α)-cover-free where 0 < α < 1 if for all {i0     it} with i0 ∈ {i1     it}we have |Si0\ ∪tj=1 Sij | ≥ α|Si0 | Such families are well known and have beenused several times in cryptographic applications [102920] In what follows wefix α = 1/2 for simplicity and will use the following (essentially optimal) resultnon-constructively proven by [18] and subsequently made efficient by [2924]Theorem 1 ([182924]) For any N and t one can efficiently construct a(t 12 )-cover-free collection of N subsets S1     SN of U = {1     u} with |Si| =n for all i satisfying: u = Θ(t2 logN) and n = Θ(t logN)Since we assumed that t logN = O(poly(k)) we have u n = O(poly(k)) as wellKey-Insulated Public Key Cryptosystems 73Construction For simplicity we first describe the scheme which is not stronglysecure (see Definition 4) and then show a modification making it strongly secureLet S1     SN ⊂ [u] def= {1    u} be the (t 12 )-cover-free family of n-elementsets as given by Theorem 1 Also let T be a secure (L  n)-AONT Our (tN)-key-insulated scheme will have a set of u independent encryption/decryptionkeys (skr pkr) for our basic encryption E of which only the subset Si will beused at time period i Specifically the public key of the scheme will be PK ={pk1     pku} the secret key at time i will be SKi = {skr : r ∈ Si} and themaster key (for now) will be SK∗ = {sk1     sku} We define the encryption ofM ∈ {0 1}L at time period i as:EPK(iM) = 〈 i (Epkr1 (x1)     Epkrn (xn) z) 〉where (x1    xnz)← T (M) and Si = {r1    rn} To decrypt 〈i(y1    ynz)〉using SKi = {skr : r ∈ Si} the user first recovers the xj ’s from the yj ’s usingDand then recovers the messageM = I(x1     xn z) Key updates are trivial: thedevice sends the new key SKi and the user erases the old key SKi−1 Obviouslythe scheme supports secure key updates as well as random-access key updatesSecurity We informally argue the (tN)-key-insulated security of this scheme(omitting the formal proof due to space limitations) The definition of the AONTimplies that the system is secure at time period i provided the adversary missesat least one key skr where r ∈ Si Indeed semantic security of E implies thatthe adversary completely misses the shares encrypted with skr in this caseand hence has no information about the message M  On the other hand ifthe adversary learn any t keys SKi1      SKit  he learns the auxiliary keys{skr : r ∈ Si1 ∪ Si2    ∪ Sit} Hence the necessary and sufficient conditionfor (tN)-key-insulated security is exactly the t-cover freeness of the Si’s! Theparameter α = 12 is used to improve the exact security of our reductionTheorem 2 The generic scheme Π described above is (tN)-key-insulated withsecure key updates provided (GED) is semantically-secure T is a secure(L  n)-AONT and the family S1     SN is (t 12 )-cover-free Specifically break-ing the security of Π with advantage ε implies the same for either (GED) orT with advantage at least Ω(ε/t)Strong Key-Insulated Security The above scheme is not strongly (tN)-key-insulated since the device stores all the secret keys (sk1     sku) However wecan easily fix this problem The user generates one extra key pair (sk0 pk0) Itpublishes pk0 together with the other public keys but keeps sk0 for itself (nevererasing it) Assuming now that T produces n+1 secret shares x0     xn ratherthan n we just encrypt the first share x0 with pk0 (and the others as beforewith the corresponding keys in Si) Formally let S′i = Si ∪ {0} the master keyis still SK∗ = {sk1     sku} but now PK = {pk0 pk1     pku} and the i-thsecret key is SKi = {skr : r ∈ S′i} Strong key-insulated security of this schemefollows a similar argument as in Theorem 2Efficiency The main parameters of the scheme are: (1) the size of PK and SK∗are both u = O(t2 logN); and (2) the user’s storage and the number of local74 Yevgeniy Dodis et alencryptions per global encryption are both n = O(t logN) In particular thesurprising aspect of our construction is that it supports an exponential numberof periods N and the main parameters depend mainly on t the number ofexposures we allow Since t is usually quite small (say t = O(1) and certainlyt N) we obtain good parameters considering the generality of the scheme (InSection 4 we use a specific encryption scheme and achieve |PK| |SK∗| = O(t)and |SKi| = O(1))Additionally the choice of a secure (L  n)-AONT defines the tradeoff be-tween the number of encrypted bits L compared to the total encryption sizewhich is (βn + |z|) where β is the expansion of E and |z| is the size of thepublic share In particular if L =  we can use any traditional (n− 1 n)-secretsharing scheme (eg Shamir’s scheme [35] or even XOR-sharing: pick randomxj ’s subject to M =⊕xj) This way we have no public part but the ciphertextincreases by a factor of βn as compared to the plaintext Computationally-secureAONT’s allow for better tradeoffs For example using either the computationalsecret sharing scheme of [27] or the AONT constructions of [9] we can achieve|z| = L while  can be as small as the security parameter k (in particular  L) Thus we get additive increase βn which is essentially independentof L Finally in the random oracle model we could use the construction of [8]achieving |z| = 0 L = (n − 1) so the ciphertext size is βn ≈ βL Finally inpractice one would use the above scheme to encrypt a random key K (which ismuch shorter than M) for a symmetric-key encryption scheme and concatenateto this the symmetric-key encryption of M using KAdaptive vs Non-adaptive Adversaries Theorem 2 holds for an adaptive adver-sary who makes key exposure requests based on all information collected so farWe notice however that both the security and the efficiency of our construc-tion could be somewhat improved for non-adaptive adversaries who choose thekey-exposure periods i1     it at the outset of the protocol (which is the modelof [36302]) For example it is easy to see that we no longer lose the factor t inthe security of our reduction in Theorem 2 As for the efficiency instead of usingan AONT (which is essentially an (n− 1 n)-secret sharing scheme) we can nowuse any (n/2 n)-“ramp” secret sharing scheme [6] This means that n sharesreconstruct the secret but any n/2 shares yield no information about the secretIndeed since our family is (t 12 )-cover-free any non-exposed period will have theadversary miss more than half of the relevant secret keys For non-adaptive ad-versaries we know at the outset which secret keys are non-exposed and can usea simple hybrid argument over these keys to prove the security of the modifiedscheme For example we can use the “ramp” generalization of Shamir’s secretsharing scheme2 proposed by Franklin and Yung [19] and achieve L = n/2instead of L =  resulting from regular Shamir’s (n− 1 n)-scheme2 Here the message length L = n/2 and the -bit parts m1    mn/2 of M areviewed as the n/2 lower order coefficients of an otherwise random polynomial ofdegree (n− 1) over GF [2] This polynomial is then evaluated at n points of GF [2]to give the final n sharesKey-Insulated Public Key Cryptosystems 754 Semantic Security Based on DDHIn this section we present an efficient strongly (tN)-key-insulated schemewhose semantic security can be proved under the DDH assumptionWe first describe the basic encryption scheme we build upon The key genera-tion algorithm Gen(1k) selects a random prime q with |q| = k such that p = 2q+1is prime This defines a unique subgroup G ⊂ Z∗p of size q in which the DDHassumption is assumed to hold; namely it is hard to disinguish a random tuple(g h u v) of four independent elements in G from a random tuple satisfyinglogg u = logh v Given group G key generation proceeds by selecting randomelements g h ∈ G and random x y ∈ Zq The public key consists of g h and thePedersen commitment [33] to x and y: z = gxhy The secret key contains bothx and y To encrypt M ∈ G choose random r ∈ Zq and compute (gr hr zrM)To decrypt (u v w) compute M = w/uxvy This scheme is very similar to ElGamal encryption [17] except it uses two generators It has been recently usedby [26] in a different contextOur Scheme Our (tN)-key-insulated scheme builds on the above basic encryp-tion scheme and is presented in Figure 1 The key difference is that after choos-ing G g h as above we select two random polynomials fx(τ)def=∑tj=0 x∗jτjand fy(τ)def=∑tj=0 y∗j τj over Zq of degree t The public key consists of g h andPedersen commitments {z∗0      z∗t } to the coefficients of the two polynomials(see Figure 1) The user stores the constant terms of the two polynomials (iex∗0 and y∗0) and the remaining coefficients are stored by the physically-securedevice To encrypt during period i first zi is computed from the public key aszidef= Πtj=0(z∗j )ij  Then (similar to the basic scheme) encryption of messageM is done by choosing r ∈ Zq at random and computing (gr hr zriM) Usingour notation from above it is clear that zi = gfx(i)hfy(i) Thus as long as theuser has secret key SKi = (fx(i) fy(i)) during period i decryption during thatperiod may be done just as in the basic scheme As for key evolution the userbegins with SK0 = (x∗0 y∗0) = (fx(0) fy(0)) At the start of any period i thedevice transmits partial key SK ′i = (x′i y′i) to the user Note that (cf Figure 1)x′i = fx(i) − fx(i − 1) and y′i = fy(i) − fy(i − 1) Thus since the user alreadyhas SKi−1 the user may easily compute SKi from these values At this pointthe user erases SKi−1 and uses SKi to decrypt for the remainder of the timeperiodTheorem 3 Under the DDH assumption the encryption scheme of Figure 1is strongly (tN)-key-insulated under plaintext-only attacks Furthermore it hassecure key updates and supports random-access key updatesProof Showing secure key updates is trivial since an adversary who exposeskeys SKi−1 and SKi can compute the value SK ′i by itself (and thereby perfectlysimulate a key-update exposure at period i) Similarly random-access key up-dates can be done using partial keys SK ′ij = (x′ij  y′ij) where x′ij = fx(i)−fx(j)y′ij = fy(i)− fy(j) The user can then compute xi = xj + x′ij and yi = yj + y′ij 76 Yevgeniy Dodis et alG(1k): (g h q)← Gen(1k); x∗0 y∗0      x∗t  y∗t ← Zqz∗0 := gx∗0hy∗0      z∗t := gx∗t hy∗t ; PK := (g h z∗0      z∗t )SK∗ := (x∗1 y∗1      x∗t  y∗t ); SK0 := (x∗0 y∗0)return PKSK∗ SK0U∗(i SK∗ = (x∗1 y∗1      x∗t  y∗t )):x′i :=∑tj=1 x∗j(ij − (i− 1)j)y′i :=∑tj=1 y∗j(ij − (i− 1)j)return SK′i = (x′i y′i)U(i SKi−1 = (xi−1 yi−1) SK′i = (x′i y′i)):xi := xi−1 + x′iyi := yi−1 + y′ireturn SKi = (xi yi)E(ghz∗0 z∗y)(iM):zi := Πtj=0(z∗j )ijr ← ZqC := (gr hr zriM)return 〈i C〉D(xiyi)(〈i C = (u v w)〉):M := w/uxivyireturn MFig 1 Semantically-secure key-updating encryption scheme based on DDHWe now show that the scheme satisfies Definition 2 By a standard hybridargument [4] it is sufficient to consider an adversary A who asks a single query toits left-or-right oracle (for some time period i of A’s choice) and must guess thevalue bi So we assume Amakes only a single query to the LR oracle during periodi for which it did not make a key exposure request In the original experiment (cfFigure 1) the output of LRPKb(iM0M1) is defined as follows: choose r ∈ Zqat random and output (gr hr zriMbi) Given a tuple (g h u v) which is eithera DDH tuple or a random tuple modify the original experiment as follows: theoutput of LRPKb(iM0M1) will be (u v uxivyiMb) Note that if (g h u v) is aDDH tuple then this is a perfect simulation of the original experiment On theother hand if (g h u v) is a random tuple then under the DDH assumptionthe success of any ppt adversary in this modified experiment cannot differ bymore than a negligible amount from its success in the original experiment It isimportant to note that in running the experiment we can answer all of A’s keyexposure requests correctly since all secret keys are known Thus in contrast to[3630] we may handle an adaptive adversary who chooses when to make keyexposure requests based on all information seen during the experimentAssume now that (g h u v) is a random tuple and logg h = logu v (this willoccur with all but negligible probability) We claim that the adversary’s view inthe modified experiment is independent of b Indeed the adversary knows onlyt values of fx(·) and fy(·) (at points other than i) and since both fx(·) andfy(·) are random polynomials of degree t the values xi yi (= fx(i) fy(i)) areinformation-theoretically uniformly distributed subject only to:logg zi = xi + yi logg h (1)Consider the output of the encryption oracle (u v uxivyiMb) Since:logu(uxivyi) = xi + yi logu v (2)Key-Insulated Public Key Cryptosystems 77and (1) and (2) are linearly independent the conditional distribution of uxivyi(conditioned on bi and the adversary’s view) is uniform Thus the adversary’sview is independent of bi (and hence b) This implies that the success probabilityof A in this modified experiment is 1/2 and hence the success probability of Ain the original experiment is at most negligibly different from 1/2We now consider security against the physically-secure device; in this casethere are no key exposure requests but the adversary learns SK∗ Again it issufficient to consider an adversary who asks a single query to its left-or-rightoracle (for time period i of its choice) and must guess the value bi Since SK∗only contains the t highest-order coefficients of t-degree polynomials the pair(xi yi) is information-theoretically uniformly distributed (for all i) subject toxi+ yi logg h = logg zi An argument similar to that given previously shows thatthe success probability of the adversary is at most negligibly better than 1/2and hence the scheme satisfies Definition 45 Chosen-Ciphertext Security Based on DDHWe may modify the scheme given in the previous section so as to be resistantto chosen-ciphertext attacks In doing so we build upon the chosen-ciphertext-secure (standard) public-key encryption scheme of Cramer and Shoup [11]G(1k): (g; h; q) Gen(1k); H  UOWH(1k)for i = 0 to t and n = 0 to 2:xi;n; yi;n Zqfor i = 0 to t:zi:= gxi;0hyi;0; ci:= gxi;1hyi;1; di:= gxi;2hyi;2PK := (g; h; H; fzi; ci; dig0it)SK:= (fxi;n; yi;ng2it; 0n2); SK0:= (fxi;n; yi;ng0i1; 0n2)return PK; SK; SK0U(i; SK):for n = 0 to 2:x0i;n:=Ptj=2xj;n ij  (i  1)jy0i;n:=Ptj=2yj;n ij  (i   1)jreturn SK 0i= (fx0i;n; y0i;ng0n2)U(i; SKi 1; SK0i):for n = 0 to 2:xi;n= xi 1;n+ x0i;n+ x1;nyi;n= yi 1;n+ y0i;n+ y1;nreturn SKi= (fxi;n; yi;n; x1;n; y1;ng0n2)EPK(i;M):zi:= tj=0(zj)ij; ci:= tj=0(cj)ijdi:= tj=0(dj)ijr ZqC := (gr; hr; zriM; (cidi)r);where  def= H(gr; hr; zriM)return hi; CiDSKi(hi; C = (u; v; w; e)i): := H(u; v; w)if uxi;1+xi;2vyi;1+yi;2 6= ereturn?else M := w=uxi;0vyi;0return MFig 2 Chosen-ciphertext-secure key-updating encryption scheme based on DDH78 Yevgeniy Dodis et alWe briefly review the “basic” Cramer-Shoup scheme (in part to conform tothe notation used in Figure 2) Given generators g h of group G (as describedin the previous section) secret keys {xn yn}0≤n≤2 are chosen randomly fromZq Then public-key components z = gx0hy0  c = gx1hy1  and d = gx2hy2are computed In addition a function H is randomly chosen from a family ofuniversal one-way hash functions The public key is (g h z c dH)To encrypt a message M ∈ G a random element r ∈ Zq is chosen andthe ciphertext is: (gr hr zrM (cdα)r) where α = H(gr hr zrM) To decrypta ciphertext (u v w e) we first check whether ux1+x2αvy1+y2α = e If not weoutput ⊥ Otherwise we output M = w/ux0vy0 In our extended scheme (cf Figure 2) we choose six random degree-t poly-nomials (over Zq) fx0  fy0  fx1  fy1  fx2  fy2  where fxn(τ)def=∑tj=0 x∗jnτj andfyn(τ)def=∑tj=0 y∗jnτj for 0 ≤ n ≤ 2 The public key consists of g hH and Ped-ersen commitments to the coefficients of these polynomials The user stores theconstant term and the coefficient of the linear term for each of these polynomialsand the remaining coefficients are stored by the physically-secure deviceTo encrypt during period i a user first computes zi ci and di by evalu-ating the polynomials “in the exponent” (see Figure 2) Then just as in thebasic scheme encryption of M is performed by choosing random r ∈ Zq andcomputing (gr hr zriM (cidαi )r) where α def= H(gr hr zriM) Notice that zi =gfx0 (i)hfy0 (i) ci = gfx1 (i)hfy1 (i) and di = gfx2 (i)hfy2 (i) Thus the user can de-crypt (just as in the basic scheme) as long as he has fxn(i) fyn(i) for 0 ≤ n ≤ 2In fact the secret key SKi includes these values; in addition the secret key atall times includes the linear coefficients x∗10 y∗10     x∗12 y∗12 These values areused to help update SKiTheorem 4 Under the DDH assumption the encryption scheme of Figure 2 isstrongly (t − 2 N)-key-insulated under chosen-ciphertext attacks Furthermorethe scheme has secure key updates and supports random-access key updatesProof That the scheme has secure key updates is trivial since SK ′i may be com-puted from SKi−1 and SKi Random-access key updates are done analogouslyto the scheme of the previous section We now show the key-insulated securityof the scheme (cf Definition 2) A standard hybrid argument [4] shows that itis sufficient to consider an adversary A who makes only a single request to itsleft-or-right oracle (for time period i of the adversary’s choice) and must guessthe value bi We stress that polynomially-many calls to the decryption oracle areallowedAssume A makes a single query to the LR oracle during period i for whichit did not make a key exposure request In the original experiment (cf Figure2) the output of LRPKb(iM0M1) is as follows: choose r ← Zq and output(gr hr zriMbi  (cidαi )r) where α is as above As in the proof of Theorem 3 wenow modify the experiment Given a tuple (g h u v) which is either a DDH tupleor a random tuple we define the output of LRPKb(iM0M1) to be (u v w˜ =uxi0vyi0Mbi  e˜ = uxi1+xi2αvyi1+yi2α) where α def= H(u v w˜) Note that if(g h u v) is a DDH tuple then this results in a perfect simulation of the originalKey-Insulated Public Key Cryptosystems 79experiment On the other hand if (g h u v) is a random tuple then under theDDH assumption the success of any ppt adversary cannot differ by a non-negligible amount from its success in the original experiment As in the proofof Theorem 3 note that in running the experiment we can answer all of A’skey exposure queries Thus the proof handles an adaptive adversary whose keyexposure requests may be made based on all information seen up to that pointAssume now that (g h u v) is a random tuple and logg h = logu v (thishappens with all but negligible probability) We show that with all but negligibleprobability the adversary’s view in the modified experiment is independent of bThe proof parallels [11 Lemma 2] Say a ciphertext 〈i (u′ v′ w′ e′)〉 is invalidif logg u′ = logh v′ Then:Claim If the decryption oracle outputs ⊥ for all invalid ciphertexts during theadversary’s attack then the value of bi (and hence b) is independent of theadversary’s viewThe adversary knows at most t − 2 values of fx0(·) and fy0(·) (at points otherthan i) and additionally knows the values x∗10 and y∗10 (the linear terms of thesepolynomials) Since fx0(·) and fy0(·) are random polynomials of degree t thevalues xi0 yi0 (= fx0(i) fy0(i)) are uniformly distributed subject to:logg zi = xi0 + yi0 logg h (3)Furthermore when the decryption oracle decrypts valid ciphertexts 〈i(u′v′w′e′)〉the adversary only obtains linearly-dependent relations r′ logg zi = r′xi0 +r′yi0 logg h (where r′def= logg u′) Similarly decryptions of valid ciphertexts atother time periods do not further constrain xi0 yi0 Now consider the thirdcomponent uxi0vyi0Mbi of the encryption oracle (the only one which dependson bi) Since:logu(uxi0vyi0) = xi0 + yi0 logu v (4)and (3) and (4) are linearly independent the conditional distribution of uxi0vyi0(conditioned on bi and the adversary’s view) is uniform Thus the adversary’sview is independent of bi The following claim now completes the proof of key-insulated security:Claim With all but negligible probability the decryption oracle will output ⊥for all invalid ciphertextsConsider a ciphertext 〈j (u′ v′ w′ e′)〉 where j represents a period during whicha key exposure request was not made We show that with all but negligibleprobability this ciphertext is rejected if it is invalid There are two cases toconsider: (1) j = i (recall that i is the period during which the call to the LRoracle is made) and (2) j = iWhen j = i the proof of the claim follows the proof of [11 Claim 2] exactlyThe adversary knows at most t − 2 values of fx1(·) fy1(·) fx2(·) and fy2(·)(at points other than i) and additionally knows the linear coefficients of these80 Yevgeniy Dodis et alpolynomials Since these are all random polynomials of degree t the values(xi1 yi1 xi2 yi2) are uniformly distributed subject to:logg ci = xi1 + yi1 logg h (5)logg di = xi2 + yi2 logg h (6)logu e˜ = xi1 + αxi2 + (logu v) yi1 + (logu v)α yi2 (7)where (7) comes from the output of the encryption oracle If the submitted ci-phertext 〈i (u′ v′ w′ e′)〉 is invalid and (u′ v′ w′ e′) = (u v w˜ e˜) there arethree possibilities:Case 1 (u′ v′ w′) = (u v w˜) In this case v′ = v˜ ensures that the decryptionoracle will rejectCase 2 (u′ v′ w′) = (u v w˜) but H(u′ v′ w′) = H(u v w˜) This violates thesecurity of the universal one-way hash family and hence cannot occur with non-negligible probability See [11]Case 3 H(u′ v′ w′) = H(u v w˜) The decryption oracle will reject unless:logu′ e′ = xi1 + α′xi2 + (logu′ v′) yi1 + (logu′ v′)α′ yi2 (8)But (5)–(8) are all linearly independent from which it follows that the decryptionoracle rejects except with probability 1/q (As in [11] each rejection furtherconstrains the values (xi1 yi1 xi2 yi2); however the kth query will be rejectedexcept with probability at most 1/(q − k + 1))When j = i the values (xi1 yi1 xi2 yi2 xj1 yj1 xj2 yj2) are uniformlydistributed subject only to (5)–(7) and:logg cj = xj1 + yj1 logg h (9)logg dj = xj2 + yj2 logg h (10)Here we make crucial use of the fact that the adversary has made at mostt − 2 key exposure requests – had the adversary learned t − 1 points on thepolynomials this (along with knowledge of the linear coefficients) would yieldadditional linear relations (eg between xi1 and xj1) and the proof of securitywould not go throughIf the ciphertext 〈j (u′ v′ w′ e′)〉 submitted by the adversary is invalid thedecryption oracle will reject unless:logu′ e′ = xj1 + α′xj2 + (logu′ v′) yj1 + (logu′ v′)α′ yj2 (11)Clearly however (5)–(7) and (9)–(11) are all linearly independent from whichit follows that the decryption oracle rejects except with probability 1/q Thiscompletes the proof of (t− 2 N)-key-insulated securityThe key to the proof above (informally) is that the adversary learns onlyt − 1 “pieces of information” about the polynomials fx1(·) fy1(·) fx2(·) andKey-Insulated Public Key Cryptosystems 81fy2(·) (ie their values at t − 2 points and their linear coefficients) Hencebefore any calls to the decryption oracle have been made the pair (xi1 xj1)(for example) is uniformly distributed The proof of strong key-insulated securityfollows exactly the same arguments given above once we notice that SK∗ givesonly t− 1 “pieces of information” as well (ie the t− 1 leading coefficients) Weomit further detailsWe note that a trivial modification to the scheme achieves (t − 1 N)-key-insulated security with minimal added complexity: choose random elements{x˜1n y˜1n}0≤n≤2 then set xˆ1n = x1n+x˜1n and yˆ1n = y1n+y˜1n for 0 ≤ n ≤ 2Now include {x˜1n y˜1n}0≤n≤2 with SK∗ and store {xˆ1n yˆ1n}0≤n≤2 as part ofSK0 (and have these values be part of SKi at all time periods) Key updates aredone in the obvious way Note that SK∗ only stores t−1 “pieces of information”about the random degree-t polynomials; furthermore t− 1 key exposures onlyreveal t− 1 “pieces of information” as well Thus a proof of security follows theproof of the above theoremAcknowledgmentShouhuai Xu was partially supported by an NSF grant to the Laboratory forInformation Security Technology at George Mason UniversityReferences1 M Abdalla and L Reyzin A New Forward-Secure Digital Signature SchemeAsiacrypt’002 M Abe and M Kanda A Key Escrow Scheme with Time-Limited Monitoring forOne-Way Communication ACISP ’003 R Anderson Invited lecture ACM CCCS ’974 M Bellare A Desai E Jokipii and P Rogaway A Concrete Security Treatmentof Symmetric Encryption: Analysis of the DES Modes of Operation FOCS ’975 M Bellare and SK Miner A Forward-Secure Digital Signature Scheme Crypto’996 G Blakley and C Meadows Security of Ramp Schemes Crypto ’847 D Boneh and M Franklin Identity-Based Encryption from the Weil PairingCrypto ’018 V Boyko On the Security Properties of the OAEP as an All-or-Nothing Trans-form Crypto ’999 R Canetti Y Dodis S Halevi E Kushilevitz and A Sahai Exposure-ResilientFunctions and All-Or-Nothing-Transforms Eurocrypt ’0010 B Chor A Fiat and M Naor Tracing Traitors Crypto ’9411 R Cramer and V Shoup A Practical Public-Key Cryptosystem Provably Secureagainst Adaptive Chosen-Ciphertext Attacks Crypto ’9812 A De Santis Y Desmedt Y Frankel and M Yung How to Share a FunctionSecurely STOC 9413 Y Desmedt and Y Frankel Threshold cryptosystems Crypto’8914 W Diffie P van Oorschot and M Wiener Authentication and AuthenticatedKey Exchanges Designs Codes and Cryptography 2:107–125 199282 Yevgeniy Dodis et al15 Y Dodis J Katz S Xu and M Yung Key-Insulated Signature SchemesManuscript 200216 A Dyachkov and V Rykov A Survey of Superimposed Code Theory In Problemsof Control and Information Theory vol 12 no 4 198317 T El Gamal A Public-Key Cryptosystem and a Signature Scheme Based on theDiscrete Logarithm IEEE Transactions of Information Theory 31(4): 469–472198518 P Erdos P Frankl and Z Furedi Families of Finite Sets in which no Set isCovered by the Union of r Others In Israel J Math 51(1-2): 79–89 198519 M Franklin M Yung Communication Complexity of Secure ComputationSTOC ’9220 E Gafni J Staddon and Y L Yin Efficient Methods for Integrating Traceabilityand Broadcast Encryption Crypto ’9921 M Girault Relaxing Tamper-Resistance Requirements for Smart Cards Using(Auto)-Proxy Signatures CARDIS ’9822 O Goldreich B Pfitzmann and RL Rivest Self-Delegation with ControlledPropagation – or – What if You Lose Your Laptop? Crypto ’9823 S Goldwasser S Micali and RL Rivest A Digital Signature Scheme SecureAgainst Adaptive Chosen-Message Attacks SIAM J Computing 17(2): 281–308(1988)24 P Indyk Personal communication25 G Itkis and L Reyzin Forward-Secure Signatures with Optimal Signing andVerifying Crypto ’0126 S Jarecki and A Lysyanskaya Concurrent and Erasure-Free Models inAdaptively-Secure Threshold Cryptography Eurocrypt ’0027 H Krawczyk Secret Sharing Made Short Crypto ’9328 H Krawczyk Simple Forward-Secure Signatures From any Signature SchemeACM CCCS ’0029 R Kumar S Rajagopalan and A Sahai Coding Constructions for BlacklistingProblems without Computational Assumptions Crypto ’9930 C-F Lu and SW Shieh Secure Key-Evolving Protocols for Discrete LogarithmSchemes RSA 2002 to appear31 T Malkin D Micciancio and S Miner Efficient Generic Forward-Secure Signa-tures With an Unbounded Number of Time Periods These proceedings32 R Ostrovsky and M Yung How to Withstand Mobile Virus Attacks PODC ’9133 T Pedersen Non-Interactive and Information-Theoretic Secure Verifiable SecretSharing Crypto ’9134 R Rivest All-or-Nothing Encryption and the Package Transform FSE ’9735 A Shamir How to share a secret Comm ACM 22(11):612–613 197936 W-G Tzeng and Z-J Tzeng Robust Key-Evolving Public-Key EncryptionSchemes Available at http://eprintiacrorg
KeyInsulation insecure channel-pdf,A preliminary version of this paper appears in Topics in Cryptology CT-RSA ’09 Lecture Notesin Computer Science Vol ??  M Fischlin ed Springer-Verlag 2009 This is the full versionKey Insulation and Intrusion ResilienceOver a Public ChannelMihir Bellare∗ Shanshan Duan† Adriana Palacio‡AbstractKey insulation (KI) and Intrusion resilience (IR) are methods to protect a user’s key againstexposure by utilizing periodic communications with an auxiliary helper But existing workassumes a secure channel between user and helper If we want to realize KI or IR in practicewe must realize this secure channel This paper looks at the question of how to do this whenthe communication is over what we are more likely to have in practice namely a public channelsuch as the Internet or a wireless network We explain why this problem is not trivial introducemodels and definitions that capture the desired security in a public channel setting and providea complete (and surprising) answer to the question of when KI and IR are possible over a publicchannel The information we provide is important to guide practitioners with regard to theusage of KI and IR and also to guide future research in this area∗Dept of Computer Science & Engineering University of California at San Diego 9500 Gilman Drive La JollaCalifornia 92093 USA E-Mail: mihir@csucsdedu URL: http://www-cseucsdedu/users/mihir Supported inpart by NSF grant CNS 0524765 and CNS 0627779 and a gift from Intel corporation†Dept of Computer Science & Engineering University of California at San Diego 9500 Gilman Drive La JollaCalifornia 92093 USA E-Mail: shduan@csucsdedu URL: http://www-cseucsdedu/users/shduan Supportedin part by the grants of the first author‡Computer Science Department Bowdoin College 8650 College Station Brunswick ME 04011-8486 USA E-Mail: apalacio@bowdoinedu URL: http://academicbowdoinedu/faculty/A/apalacio/Contents1 Introduction 311 Background                                          312 Realizing the secure channel                                 313 Our model                                           414 Our results                                          415 Extensions                                           616 Discussion                                           62 Definitions 63 Key insulation in the secure-channel model 74 Key insulation in the public-channel model 85 Impossibility of public-channel KI under active attack 116 Possibility of public-channel KI under passive attack 127 Intrusion resilience in the secure-channel model 178 Intrusion resilience in the public-channel model 199 Possibility of public-channel IR under passive attack 20References 2621 IntroductionKey Insulation (KI) [15 16] and Intrusion Resilience (IR) [13 20] are technologies to protect againstkey exposure They have been extensively researched in the cryptographic community and we havelots of schemes variations and extensions [13 14 15 16 18 19 20] However all this work assumesa secure communication channel between the parties If we want to realize KI or IR in practice wemust realize this secure channel How can this be done? Surprisingly this fundamental questionhas received no attention until now We address it and turn up some surprising answers which haveimportant implications for the realizability of KI and IR in practice11 BackgroundAn important threat to the security of cryptography-using applications is exposure of the secret keydue to viruses worms or other break-ins allowed by operating-system holes Forward security [12 7 10] is one way to counter this or at least mitigate the damage caused Here the user has asingle fixed public key pk whose lifetime is divided into stages 1     N  The secret (signing ordecryption) key evolves with time: at the start of stage i the user computes its stage i secret keyuski as a function of its stage i − 1 secret key uski−1 and then discards the latter The securitycondition is that for j < i a break-in during stage i (resulting in exposure of uski) does not allowthe adversary to compute uskj or compromise its uses (Meaning that forgery of documents withdate j or decryption of ciphertexts sent in stage j remains hard) Once uski is exposed howeveruski+1    uskN are automatically compromised (they can be computed from uski) and the bestthe user can hope to do about this is detect the break-in and revoke the public keyKey-insulated (KI) security as introduced by Dodis Katz Xu and Yung [15 16] and refinedby [4] attempts to provide both forward and backward security meaning a break-in during stage ileaves uskj uncompromised for all j 6= i More generally break-ins for all stages i ∈ I leave uskjand its uses secure for all j ∈ [N ] \ I where [N ] = {1     N} To accomplish this an auxiliaryparty called a helper is introduced The secret key uski of stage i is now computed by the usernot merely as a function of uski−1 but also of a key hski sent by the helper to the user at thestart of stage i The advantage of this system (over a merely forward-secure one) is that the publickey is never revoked Intrusion resilience (IR) [20 13] is an extension where forward and backwordsecurity are provided even if both user and helper are compromised as long as the compromise isnot simultaneous and even in the latter case forward security is assured Further extensions andvariants include KI with parallel helpers [18] and KI (hierarchical) identity-based encryption [19]Our discussion below will focus on the simpler KI case We will discuss the extension to IR laterKI security requires that the communication channel between user and helper is secure Indeedif not meaning if an adversary could obtain the helper keys hsk1    hskN sent over the channela single break-in in a stage i would allow it to compute all subsequent user secret keys by simplyusing the key-update process of the user and KI would end up providing no more than forwardsecurity which does not even need a helper In previous works this secure-channel assumption isbuilt into the model which denies the adversary hskj unless it has broken in during stage j12 Realizing the secure channelTo deploy KI in practice we must have some way to realize the secure channel In some settingsit may be possible to do this through physical means but such settings are rare The range ofapplication for KI would be greatly increased if the communication between user and helper couldflow over a public channel such as the Internet or a wireless network This would allow the helper3to be for example a server on the Internet Alternatively the helper could be your cell phone withthe user being your laptop (In this case even though the devices may be in close proximity thecommunication would be over a public wireless phone network)While definitely important for applications enabling KI over public channels looks at first to besomething trivial This is because we would appear to know very well how to implement a securechannel over a public one After all isn’t this the main task of basic cryptography? Specificallylet us just use encryption and authentication either under a symmetric key shared by the partiesor under public keysHowever we make the important observation that this standard solution runs into an inherentproblem here where the name of the game is break-in and key exposure Namely if the adversarybreaks in during some stage i one should realistically assume it exposes not just uski but also anykeys used to secure the channel (Meaning either the shared key or the user’s decryption key) Thisrenders the channel insecure from then on and key-insulated security vanishes (more accuratelyone has only forward security) as explained aboveThe above indicates that realizing KI over a public channel is nontrivial but not (yet) that it isimpossible The reason is that we have not yet exploited the full power of the model Specificallythere are two capabilities one can offer the parties First since we are already in a setting wherekeys evolve instead of trying to secure the channel with static keys we could allow channel-securingkeys to evolve as well Second we could allow the update process to be an interactive protocolrather than merely a single flow13 Our modelWhat the above reflects is that we need a new model to formally investigate the possibility ofKI over a public channel Providing such a model is the first contribution to our paper In ourmodel the user in stage i has (in addition to uski) a stage i channel-securing key ucki while thehelper has a corresponding hcki At the start of stage i + 1 the parties engage in an arbitraryinteractive channel-update protocol This protocol uses —and aims to get its security from— thecurrent channel keys ucki hcki Its goal is two-fold: to (securely) communicate hski+1 from helperto user and to “refresh” the channel keys meaning deal the helper with a new key hcki+1 andthe user with a corresponding new key ucki+1 Once the protocol terminates the user can updateuski to uski+1 using hski+1 as before install ucki+1 as its new channel key and discard both uskiand ucki As an example the protocol could begin with an authenticated session-key exchangebased on its current channel keys and then use the session key to securely transfer hski+1 and freshchannel keys But now a break-in during period i exposes not only uski and hski but also uckiActually we go further allowing the adversary to even obtain the user coins underlying the stagei channel-update protocol execution This is realistic because the intruder could be on the systemwhen the protocol executes but this added adversary capability will make our proofs harder Whilethe core elements of the new model are natural and clear there are subtle details In Section 4 wedescribe our model and provide a formal definition of KI security over a public channel14 Our resultsNow that we have a model we ask whether it is possible to design KI schemes secure in this publicchannel model Interestingly the answer turns out to depend on whether the adversary is activeor merely passive Specifically the answer is “no” in the first case and “yes” in the second Let usnow elaborate on these results4Active security The communication security model cryptographers prefer to consider is thatof an active adversary who has full control of the channel It can not only see all transmissionsbut stop inject or alter any transmission This is the model adopted for example in the workof Canetti and Krawczyk defining notions of secure channels [11 12] and also in work on session-key exchange [5 11] It would be desirable to achieve public-channel KI security in the face ofsuch an adversary We show that this is impossible That is even in our above-described modelwhich allows an interactive channel-update protocol and evolving channel-security keys an activeadversary can always succeed in breaking the scheme The reason is that after it breaks in it obtainsthe user’s channel-security key and can thus impersonate the user We note that authentication(such as an authenticated session-key exchange) does not prevent this since the adversary acquiresall the user’s credentials via the break-in This negative result is particularly strong because ourpublic-channel KI model is as generous as one can get while keeping in the spirit of KIThere seem to be only two ways to circumvent the negative result The first is to revoke thepublic key upon break-in discovery but if one is willing to do this one may as well just use forwardsecurity and avoid the helper altogether Indeed the whole point of the helper and KI is to neverhave to revoke the public key The other possibility is to use an out-of-band method to redistributechannel-securing keys after break-in discovery such as a physically secure channel But this is justan assumed secure channel under another name exactly what we are trying to avoid In conclusionour result suggests that it would be inadvisable to implement any form of KI when the channelmay be open to active attackPassive security On the positive side we show that public-channel KI is possible against anadversary that is allowed only a passive attack on the communication channel (Meaning it caneavesdrop but not inject messages) Our method is general meaning it yields a compiler that cantake any KI scheme secure in the secure-channel model and turn it into a KI scheme secure inour public-channel model under passive attack The transformation is simple Our channel-updateprotocol begins with a secure key exchange (eg Diffie-Hellman) to get a session key under whichthe helper encrypts the data it needs to transmit The key exchange is not authenticated: this isnot necessary for security against passive attack and given the above would not help to achievesecurity against active attack We clarify that our choice of channel-update protocol is purelyillustrative The reader can surely think of others that will workThis positive result is significant for two reasons First it shows that KI is at least possibleover a channel where the adversary may be able to eavesdrop but finds it hard to inject or corrupttransmissions Second the result shows that our new method allowing an interactive channel-update protocol has borne fruit Indeed even KI under passive attack is not possible when thecommunication consists of a single transmission from helper to userAlthough the protocol is simple there are subtleties in the proof arising from the strength ofour model which allows the adversary to obtain the user coins from the channel-update protocolexecution in any stage in which it breaks in A consequence of this is that the starting secure-channel KI scheme needs to have optimal threshold meaning be secure even if there are break insin all but one stage Some early secure-channel KI encryption schemes [15] were threshold and didnot have this property and in this case we cannot offer security over a public channel even in thepresence of a passive adversary Luckily secure-channel KI schemes with optimal threshold existfor both encryption [4] and signatures [16]Practical implications Our results imply that KI will only work if one has a channel whosephysical properties preclude active attack Anyone contemplating actual usage of KI needs to beaware of this limitation and the need to be careful about the choice of channel515 ExtensionsThe intrusion resilience (IR) setting of [20 13] continues to make the secure-channel assumptionand our results extend to it However the model is considerably more complex due to the presenceof both refreshes and updates and again there are subtle details to be careful about in creatingthe public channel analog We recall the secure-channel IR model in Section 7 and then provide adetailed description of our public-channel IR model in Section 8 When this is done the negativeresult showing the impossibility of IR over a public channel in the presence of an active adversarycarries over easily from the KI case We need to extend the previous positive result however We areable to show that secure key exchange can still be used for both refresh and update to transform anysecure-channel IR scheme into a public-channel IR scheme secure against passive adversaries Theproof is however more complex than in the KI case and is given in Section 9 Similar extensionshold for the many variant notions in this area including strong KI security [15 16] and KI withparallel helpers [18]16 DiscussionCryptographic protocols commonly make the assumption that parties are connected by securechannels This abstraction would seem both natural and convenient; after all isn’t this exactlywhat standard cryptography (encryption and authentication) gives us? Yet there are settings wheresecure channels are surprisingly difficult to realize One example is secure computation where asecure channel between each pair of parties is a standard assumption [8] Yet this channel isastonishingly difficult to realize at least in the public-key setting due in part to the selective-decryption problem [17] Solutions were finally given by [9] Our work provides another example2 DefinitionsWe let N = {1 2   } be the set of positive integers and for N ∈ N we let [N ] = {1     N} Theempty string is denoted ε The notation x $← S denotes that x is selected randomly from set SUnless otherwise indicated an algorithm may be randomized An adversary is an algorithm IfA is an algorithm then the notation x $← A(a1 a2   ) denotes that x is assigned the outcome ofthe experiment of running A on inputs a1 a2    with fresh coins If A is deterministic we mightwrite x← A(a1 a2   ) insteadGames We will use code-based games [6] in definitions and some proofs We recall some back-ground here A game —see Figure 1 for an example— has an Initialize procedure proceduresto respond to adversary oracle queries and a Finalize procedure A game G is executed with anadversary A as follows First Initialize executes and its outputs are the inputs to A Then Aexecutes its oracle queries being answered by the corresponding procedures of G When A termi-nates its output becomes the input to the Finalize procedure The output of the latter denotedGA is called the output of the game and we let “GA ⇒ y” denote the event that this game outputtakes value y Variables not explicitly initialized or assigned are assumed to have value ⊥ exceptfor booleans which are assumed initialized to falseInteractive algorithms We will model each party in a two-party protocol as an interactivealgorithm Such an algorithm I takes as input an incoming message Min a current state St  anda decision d which can be acc rej or ⊥ Its output denoted I(MinSt  d) is a triple (MoutSt ′ d′)consisting of an outgoing message an updated state and an updated decision We require that ifd 6= ⊥ then Mout = ⊥ St ′ = St  and d′ = d Our convention is that the initial state provided to6an interactive algorithm is its local input and random coins Given a pair of interactive algorithms(I J) we assume that the first move in the interaction always belongs to I The first incomingmessage for I is set to ε An interactive algorithm terminates when its decision becomes acc or rejOnce it terminates it outputs ⊥ as its outgoing message in response to any incoming message andits state and decision stay the same The local output of an interactive algorithm is its final stateGiven a pair of interactive algorithms (I J) with local inputs xI  xJ and coins ωI  ωJ respec-tively we define Run(I xI  J xJ ;ωI  ωJ) to be the quintuple (ConvStI  dI StJ  dJ) consisting ofthe conversation transcript (meaning the sequence of messages exchanged between the parties) I’slocal output I’s decision J ’s local output and J ’s decision respectively after an interaction inwhich I has local input xI and random coins ωI and J has local input xJ and random coins ωJ  Welet Run(I xI  J xJ) be the random variable whose value is Run(I xI  J xJ ;ωI  ωJ) when ωI  ωJare chosen at random3 Key insulation in the secure-channel modelWe will take a modular approach to KI over a public channel where a public-channel KI schemeconsists of a (standard) secure-channel KI scheme —meaning one in the model of an assumed-securechannel— together with a channel-key-update protocol We will then be able to give “compiler”style results which transform any secure-channel KI scheme into a public-channel KI scheme forsuitable channel-key-update protocols (Of course this is only for passive adversaries since inthe active case we will show that KI over public channels is impossible) To enable this we firstrecall a definition of secure-channel KI The latter has been defined for both encryption [15 4]and signatures [16] For simplicity we will treat the case of signatures The case of encryption isentirely analogous and all our results carry over Our definition below differs from that of [16] insome details but this does not affect the resultsA key-updating signature scheme KUS = (KGHKUUKU SigVer) is specified by five algorithmswith the following functionality The randomized key-generation algorithm KG returns (pkusk0hsk) where pk is the user public key usk0 is the stage 0 user secret key and hsk is the masterhelper key The user is initialized with pkusk0 while the helper is initialized with pkhsk Atthe start of stage a ≥ 1 the helper applies the deterministic helper key-update algorithm HKU toapkhsk to obtain a stage a helper key hska which is then assumed to be conveyed to the uservia a secure channel The user receives hska from the helper and then applies the deterministicuser key-update algorithm UKU to apkhska uska−1 to obtain the stage a user secret key uskaThe user then discards (erases) uska−1 In stage a the user can apply the signing algorithm Sig toa its stage a secret key uska and a message M ∈ {0 1}∗ to obtain a pair (a σ) consisting of thestage number a and a signature σ During stage a anyone can apply the deterministic verificationalgorithm Ver to pk a message M  and a pair (i σ) to obtain either 1 indicating acceptance or0 indicating rejection We require that if (i σ) where 1 ≤ i ≤ a was produced by applying thesigning algorithm to iuskiM then Ver(pkM (i σ)) = 1Security Consider game KIS of Figure 1 The Initialize procedure provides adversary A withinput pk A can call its Next oracle to move the system into the next stage It may break induring the current stage by calling its Expose oracle and getting back the user and helper keysfor that stage A may obtain signatures for messages of its choice during the current stage bycalling its Sign oracle To win A must output a message M and a signature (j σ) such that j isan unexposed stage Ver(pkM (j σ)) = 1 and M was not queried to Sign during stage j A’s7procedure Initialize(pk usk0hsk)$← KG ; a← 0 ; S ← ∅ ; E ← ∅Return pkprocedure Next()a← a+ 1hska ← HKU(apkhsk)uska ← UKU(apkhska uska−1)procedure Expose()E ← E ∪ {a}Return (uska hska)procedure Sign(M)(a σ) $← Sig(auskaM)S ← S ∪ {(aM)}Return (a σ)procedure Finalize(M (j σ))Return (j 6∈ E ∧ (jM) 6∈ S ∧ Ver(pkM (j σ)) = 1)Figure 1: Game KIS used to define KI signatures in the secure-channel modeladvantage isAdvkiKUS(A) = Pr[KISA ⇒ true ] We adopt the convention that the running time of an adversary A is the execution time of theentire game including the time taken for initialization the time taken by the oracles to computereplies to the adversary’s queries and the time taken for finalizationThe implicit secure-channel assumption As discussed in Section 1 the secure-channel as-sumption is implicit in the above model This is due to the fact that A is not given hska for stagesa in which it did not make an Expose query Also note that the assumption is necessary for if Ahad an additional oracle Get that returned hska but the rest of the game was the same it couldwin viaNext() ; (hsk1 usk1)← Expose() ; Next()hsk2 ← Get() ; usk2 ← UKU(2pk hsk2usk1)(2 σ)← Sig(2 usk2 0) ; return (0 (2 σ))4 Key insulation in the public-channel modelWe saw above that a secure channel between helper and user is both assumed and necessary in theexisting notion of KI Here we consider how the channel can be implemented Let us first discusshow key exposure implies failure of the obvious way to secure the channelStatic keys won’t secure the channel The obvious solution is to use standard cryptographyLet the helper have a signing key sk whose corresponding verification key vk is held by the userand correspondingly let the user have a decryption key dk whose corresponding encryption key ekis held by the helper (These keys are generated and distributed honestly and securely along withusk0 hsk when the system is initialized The cryptography could be symmetric or asymmetricIn the first case the signature is a MAC and encryption is symmetric so that sk = vk anddk = ek In the second case the signature and encryption are public-key based) Now in stagea the helper sends (C σ) to the user where C is an encryption of hska under ek and σ is asignature of C under sk The user verifies the signature using vk and decrypts C using dk toget hska This however fails completely to provide security in the key-exposure setting even foran adversary that is merely passive with regard to channel access (That is it can eavesdrop the8communication but not send messages itself) This is because one must realistically assume that abreak-in in a stage a exposes all information the user has which includes not only uska but alsodk Equipped with uska dk via the break-in the adversary can now obtain the stage a+ 1 channeltransmission (Ca+1 σa+1) via its channel access decrypt Ca+1 using dk to get hska+1 and computeuska+1 = UKU(a+ 1 pkhska+1uska) Continuing in this fashion it can obtain uski for all i ≥ aEvolving channel-securing keys The above is already something of which potential imple-menters should be aware but not yet enough to give up hope of obtaining KI for there is an obviousnext step which we take Namely let us allow the channel to be secured not under keys that arestatic but which themselves evolve so that a break-in exposes only the current keys This sectionintroduces and formalizes a very general model to this end where an interactive protocol (such asa secure key exchange) may be used in each step to provide a secure channel and also update thechannel keysPublic-channel key updating signature schemes A public-channel key-updating signaturescheme is a triple PCKUS = (KUSCKG (UH)) where KUS = (KGHKUUKU SigVer) is a key-updating signature scheme CKG is the channel-key-generation algorithm and the channel-key-update protocol (UH) is a pair of interactive algorithms to be run by user and helper respectivelyLet us now explain how the system runsAlgorithm CKG returns (uck0 hck0) where uck0 is the stage 0 user channel key and hck0 isthe stage 0 helper channel key When the user is initialized in addition to the public key pk andstage 0 user secret key usk0 produced by KG the user is given uck0 When the helper is initializedin addition to pk and the master helper key hsk (also generated by KG) the helper is given hck0In any stage a (a ≥ 0) the user holds not only its stage a user secret key uska but also astage a user channel key ucka The helper holds hsk and a stage a helper channel key hcka Atthe start of stage a + 1 the helper computes hska+1 = HKU(a + 1 pkhsk) The parties thenengage in the channel-key-update protocol (UH) The local input of U is the stage a user secretkey uska the stage a user channel key ucka and some random coins ωUa  while the local input ofH is the stage a + 1 helper key hska+1 the stage a helper channel key hcka and some randomcoins ωHa  After the interaction the expected local output of U is hska+1 plus the stage a + 1user channel key ucka+1 while the expected local output of H is the stage a + 1 helper channelkey hcka+1 Once the protocol has completed the user can update its key as before namelyit computes uska+1 = UKU(a + 1pkhska+1 uska) It then discards not only uska but also itsprevious channel key ucka We require the natural correctness condition namely that the stagea + 1 helper key produced by U in the interaction in which U has input uskaucka ωUa and H hasinput hska+1 hcka ωHa  is hska+1 with probability one In addition we require that at the end ofthe interaction U’s decision dUa+1 and H’s decision dHa+1 are both accSecurity We proceed to formalize two notions of security for public-channel key-updating sig-nature schemes: key insulation under active and passive attacks We first provide definitions andthen explanations Let PCKUS = ((KGHKUUKU SigVer)CKG (UH)) be a public-channel key-updating signature scheme We consider an adversary A interacting with the games of Figure 2The Initialize procedure gives A input pk In an active attack A is provided with oracles NextExpose SendU SendH and Sign while in a passive attack it is provided with oracles NextExpose Conv and Sign It may query the oracles adaptively in any order it wants with thefollowing restriction: In the case of an active adversary as soon as SendU returns dUa+1 = accand SendH returns dHa+1 = acc A makes a query to oracle Next In the case of a passive adver-sary every query to oracle Conv is immediately followed by a query to oracle Next EventuallyA outputs a message M and a signature (j σ) and halts An active (resp passive) adversary9procedure Initialize(pkusk0hsk)$← KG(uck0hck0)$← CKGhsk1 ← HKU(1pkhsk)ωU0$← COINS ; ωH0 $← COINSStU1 ← (usk0uck0 ωU0 )StH1 ← (hsk1hck0 ωH0 )a← 0 ; S ← ∅ ; E ← ∅Return pkprocedure Next()a← a+ 1If ( dUa = acc ) then(hskaucka)← StUauska ← UKU(apkhskauska−1)ωUa$← COINSStUa+1 ← (uskaucka ωUa )If ( dHa = acc ) thenhcka ← StHahska+1 ← HKU(a+ 1pkhsk)ωHa$← COINSStHa+1 ← (hska+1hcka ωHa )procedure Expose()E ← E ∪ {a}Return (uskahskaucka ωUa )procedure SendU(Min)Mout ← ⊥If ( dUa = rej ) then dUa+1 ← rejIf ( dUa+1 = ⊥ ) then(MoutStUa+1dUa+1)← U(MinStUa+1dUa )Return (MoutdUa+1)procedure SendH(Min)Mout ← ⊥If ( dHa = rej ) then dHa+1 ← rejIf ( dHa+1 = ⊥ ) then(MoutStHa+1dHa+1)← H(MinStHa+1dHa )Return (MoutdHa+1)procedure Sign(M)(a σ) $← Sig(auskaM)S ← S ∪ {(aM)}Return (a σ)procedure Finalize(M (j σ))Return (j 6∈ E ∧ (jM) 6∈ S∧Ver(pkM (j σ)) = 1)procedure Conv()If ( dUa+1 = ⊥ ∧ dHa+1 = ⊥ ) then(ConvStUa+1dUa+1StHa+1dHa+1)$← Run(UStUa+1HStHa+1)Return (ConvdUa+1dHa+1)Figure 2: Games used to define public-channel key insulation under active and passive attackGame PCKI-aa includes all of the procedures except Conv while game PCKI-pa includes all exceptSendU and SendH10is said to win if game PCKI-aa (resp PCKI-pa) returns true meaning j is an unexposed stageVer(pkM (j σ)) = 1 and M was not queried to oracle Sign during stage j For atk ∈ {aa pa}A’s atk-advantage isAdvpcki-atkPCKUS (A) = Pr[PCKI-atkA ⇒ true ] Again we adopt the convention that the running time of an adversary A is the execution timeof the entire game including the time taken for initialization the time taken by the oracles tocompute replies to the adversary’s queries and the time taken for finalizationExplanation An active adversary has full control over the communication between the helperand the user It can deliver messages out of order modify messages or inject messages of its ownchoosing This is modeled by providing the adversary access to oracles SendU and SendH whichrepresent the user and helper respectively running the channel-key-update protocol Once thisprotocol terminates the adversary is required to call its Next oracle to move the system into thenext stage This models the user updating his keys as soon as he obtains the helper secret keyfor the next stage As in the case of key insulation in the secure-channel model the adversarymay break in during the current stage by calling its Expose oracle but here it gets back the usersecret key the helper key the user channel key and the user’s coins for that stage As before theadversary may obtain signatures for messages of its choice during the current stage by calling itsSign oracle To win it must output a valid forgery for an unexposed stageA passive adversary cannot modify or inject messages but it can eavesdrop on the communica-tion channel obtaining transcripts of conversations between the user and the helper We model thisby providing the adversary access to oracle Conv which runs the channel-key-update protocol andreturns the conversation transcript and the decisions of U and H In all other respects a passiveadversary is like an active adversary: as soon as the channel-key-update protocol terminates theadversary is required to call its Next oracle to move the system into the next stage the adversarycan break in during the current stage it can obtain signatures for messages of its choice during thecurrent stage and its goal is to produce a valid forgery for an unexposed stage5 Impossibility of public-channel KI under active attackWe show that the notion of public-channel key insulation under active attack is unachievablemeaning all public-channel key-updating signature schemes are vulnerable to an active attack Theprecise statement of our result is the followingTheorem 51 Let PCKUS = ((KGHKUUKU SigVer)CKG (UH)) be a public-channel key-updating signature scheme Let tKG tHKU tUKU tSig tVer and tCKG denote the running timesof the corresponding algorithms and t(UH) denote the running time of protocol (UH) Let m bethe maximum number of moves in this protocol Then there exists an adversary A against PCKUSthat makes one query to oracle Next one Expose query at most dm/2e SendU queries at most2dm/2e SendH queries and no Sign queries such thatAdvpcki-aaPCKUS(A) = 1 Furthermore the running time of A is tKG + tCKG + 2tHKU + 2tUKU + 2t(UH) + tSigThe proof of the above theorem is simple as is not uncommon for impossibility results where thekey insights are in the development of the model and the question posedProof: A is defined in Figure 311Adversary A(pk)Min ← ε ; decU1 ← ⊥ ; decH1 ← ⊥While ( decU1 = ⊥ ∨ decH1 = ⊥ ) do(MoutdecU1 )$← SendU(Min) ; (Min decH1 ) $← SendH(Mout)Next() ; (usk1hsk1 uck1)← Expose()StU2 ← uck1 ; Min ← ε ; decU2 ← ⊥ ; decH2 ← ⊥While ( decU2 = ⊥ ∨ decH2 = ⊥ ) doMout ← ⊥If ( decU1 = rej ) then decU2 = rejIf ( decU2 = ⊥ ) then (MoutdecU2  StU2 ) $← U(MinStU2  decU1 )(MindecH1 )$← SendH(Mout)(hsk2uck2)← StU2 ; usk2 ← UKU(2pk hsk2usk1) ; (2 σ) $← Sig(2 usk2 0)Return 0 (2 σ)Figure 3: Adversary A for the proof of Theorem 51First A simulates the execution of the channel-key-update protocol using oracles SendU andSendH by delivering messages faithfully between them starting with message ε delivered toSendU Then A makes a query to oracle Next which results in the computation of the stage1 user secret key usk1 It then makes a query to Expose obtaining (usk1hsk1 uck1 ωU1 ) SettingStU2 = (usk1uck1 ωU1 ) A then plays the role of the user in an interaction with oracle SendH bycomputing U itself At the end of the interaction A obtains hsk2uck2 It can then compute usk2by applying the user key-update algorithm UKU Finally it computes a valid signature (2 σ) formessage 0 by applying the signing algorithm Sig with user secret key usk2 and it outputs a forgery0 (2 σ) A clearly satisfies the claims in the theorem6 Possibility of public-channel KI under passive attackGiven a KI signature scheme in the secure-channel model we show in this section how to transformit into a KI signature scheme secure against passive attack in the public-channel model We firstdiscuss the primitives we use namely an arbitrary secret-key-exchange protocol and an arbitraryone-time symmetric encryption schemeSecret-key-exchange (SKE) Protocol An SKE protocol with key length k is a pair ofinteractive algorithms (I J) each of which has local output a k bit string We require thatPr[(ConvKI dI KJ  dJ)$← Run(I ε J ε) : (KI = KJ) ∧ (dI = dJ = acc)]= 1 meaning the parties agree on a common key For security we require that the common key becomputationally indistinguishable from random This is captured by defining the ske-advantage ofan adversary A asAdvske(IJ)(A) = 2 · Pr[SKEA(IJ) ⇒ true]− 1 where game SKE(IJ) is defined in Figure 4One example of a suitable SKE protocol is a Diffie-Hellman key exchange (The DH key needsto be suitably hashed to a k bit string) Another possibility based on any asymmetric encryption12procedure Initializeb$← {0 1}procedure Conv()(ConvK1 dI K1 dJ)$← Run(I ε J ε)K0$← {0 1}kReturn (ConvdI dJ Kb)procedure Finalize(d)Return (b = d)procedure InitializeK$← {0 1}kb$← {0 1}procedure LR(M0M1)C$← SEnc(KMb)Return Cprocedure Finalize(d)Return (b = d)Figure 4: Game SKE(IJ) on the left is used to define security of SKE protocol (I J) and gameINDCPASE on the right is used to define security of symmetric encryption scheme SE = (SEnc SDec)In both cases the key length is kscheme (AKgAEncADec) works as follows I picks a public/secret key pair (pk sk) by runningAKg and sends pk to J The latter selects a random k-bit string K encrypts it under pk usingAEnc and sends the ciphertext to I I decrypts the ciphertext with sk using ADec to obtain KSymmetric encryption A symmetric encryption scheme SE = (SEnc SDec) with key lengthk consists of two algorithms The encryption algorithm SEnc takes a k bit key K and plaintextM ∈ {0 1}∗ to return a ciphertext C The decryption algorithm SDec takes K and C to returneither a plaintext M or the symbol ⊥ We requirePr[K$← {0 1}k : SDec(KSEnc(KM)) = M]= 1for all M ∈ {0 1}∗ We also require standard IND-CPA security except that it need only beone-time This is captured by lettingAdvind-cpaSE (A) = 2 · Pr[INDCPAASE ⇒ true]− 1 where game INDCPASE is in Figure 4 and A is required to make only one LR query (this is how theone-time requirement is captured) consisting of a pair of equal-length messagesConstruction Let KUS = (KGHKUUKU SigVer) be a key-updating signature scheme Wetransform it into a public-channel key-updating signature scheme PCKUS = (KUSCKG (UH))where CKG always returns (ε ε) by defining the channel-key-update protocol (UH) in terms ofany secret-key-exchange protocol (I J) and symmetric encryption scheme SE = (SEncSDec) bothwith the same key length k as follows The parties first run the secret-key-exchange protocol withU playing the role of I and H playing the role of J to agree on a common key K The helper thenencrypts hski under K using SEnc to obtain a ciphertext C which it sends to the user The latterdecrypts C under K using SDec to obtain hskiWe clarify that this particular channel-update protocol is chosen for illustrative purposes Manyothers are possible as the reader will probably see However it does include several differentinstantiations arising from the different available choices of SKE protocols mentioned aboveSecurity of our construction We prove that if the given key-updating signature schemeis KI in the secure-channel model and the secret-key-exchange protocol as well as the symmetricencryption scheme are secure then the public-channel key-updating signature scheme obtainedusing our construction is KI under passive attack in the public-channel model13Theorem 61 Let KUS = (KGHKUUKUSigVer) be a key-updating signature scheme LetPCKUS = ((KGHKUUKUSigVer)CKG (UH)) be the public-channel key-updating signaturescheme constructed from KUS secret-key-exchange protocol (I J) and symmetric encryption schemeSE = (SEnc SDec) as described above Let tKG tHKU tUKU tSig tVer and tCKG denote the runningtimes of the corresponding algorithms and t(UH) denote the running time of protocol (UH) LetA be an adversary against PCKUS making q queries to oracles Conv and Next qE queries toExpose and qS queries to Sign Then there exist adversaries E B S such thatAdvpcki-paPCKUS(A) ≤ q ·Advske(IJ)(E) + q ·Advind-cpaSE (B) + q ·AdvkiKUS(S)  (1)Furthermore the running times of E B are both tKG+tCKG+qN ·tHKU+qN ·tUKU+qS ·tSig+q ·t(UH)and the running time of S is tCKG +O(q + qS + qE) + q · t(UH) Also S makes q − 1 queries to itsExpose oracle and q queries to its Next oracleProof overview The proof that our construction achieves public-channel KI security underpassive attack seems easy at first but there are subtle difficulties arising from the fact that ourmodel allows the adversary to obtain the user coins from the channel-update protocol executionin any stage in which it breaks in This means that the adversary obtains the session key andcan check whether the ciphertext transmitted by the helper decrypts to the helper secret key forthe stages in question a value it also has from its break-in Of course in the real protocol thiswill always be true But the natural simulation is to consider a protocol in which rather thanencrypting the helper key under the session key yielded by the session-key exchange protocol thehelper encrypts a constant under a new random key The security of the session-key exchangeprotocol and the encryption scheme should imply that this makes no difference However theadversary can in fact detect the difference between the simulation and the real game because as wesaid above it can obtain the real session key and decrypt the ciphertext under it To get aroundthis we guess a stage in which the adversary does not break in and switch to the simulated keyand message only in this stage using the real key and real message in other stages But to dothis our simulation needs to know the real message which is the helper secret key and the onlyway to get this is to break in Luckily it can do so by consequence of the assumed security ofthe underlying secure-channel KI scheme but the result is a discrepancy in resources: even if theadversary against the public channel protocol does very few break-ins the adversary against thesecure-channel protocol breaks-in to N − 1 out of N stages Therefore it is required that thegiven secure-channel scheme be secure against N − 1 break-ins Luckily we have such schemesFor signatures the schemes of [16] have the desired property For encryption some of the originalschemes of [15] are threshold and don’t have the property but the scheme of [4] doesProof: We use games G0 G1 G2 G3 G4 defined in Figure 5 We assume without loss of generalitythat A never asks an oracle query twice and its output (j (Mσ)) always satisfies 1 ≤ j ≤ q Weassume that A always makes exactly (as opposed to at most) q Conv oracle queries Game G0 issimply game PCKI-pa of Figure 2 for the case where the channel-key-update protocol is the one wehave defined and so we haveAdvpcki-paPCKUS(A) = Pr[GA0 ⇒ true] (2)Games G0 and G1 are identical except for the boxed code in Finalize and on the other handG0 does not use g anywhere and thus the events GA0 ⇒ true and g = j are independent and theprobability of the latter is 1/q HencePr[GA1 ⇒ true]= Pr[GA0 ⇒ true ∧ g = j]14procedure Initialize(pkusk0hsk)$← KG(uck0hck0)$← CKGhsk1 ← HKU(1pkhsk)ωU0$← COINS; ωH0 $← COINSStU1 ← (usk0uck0 ωU0 )StH1 ← (hsk1hck0 ωH0 )a← 0 ; S ← ∅ ; E ← ∅g$← {1     q}Return pkprocedure Next()a← a+ 1If ( dUa = acc ) then(hskaucka)← StUauska ← UKU(apkhskauska−1)ωUa$← COINSStUa+1 ← (uskaucka ωUa )If ( dHa = acc ) thenhcka ← StHahska+1 ← HKU(a+ 1pkhsk)ωHa$← COINSStHa+1 ← (hska+1hcka ωHa )procedure Sign(M)(a σ) $← Sig(auskaM)S ← S ∪ {(aM)}Return (a σ)procedure Expose() // G0 G1 G2  G3  G4E ← E ∪ {a}x← (uskahska ε ωUa )If ( a = g ) then x←⊥Return xprocedure Conv() // G0 G1 G2If ( dIa+1 = ⊥ ∧ dJa+1 = ⊥ ) thenParse ωHa as ωJa ||r(ConvK1dIa+1K1dJa+1)← Run(I ε J ε ;ωUa  ωJa )C ← SEnc(K1hska+1; r)StUa+1 ← (hska+1 ε) ; StHa+1 ← εReturn (Conv ‖ C dIa+1dJa+1)procedure Conv() // G3If ( dIa+1 = ⊥ ∧ dJa+1 = ⊥ ) thenParse ωHa as ωJa ||r(ConvK1dIa+1K1dJa+1)← Run(I ε J ε ;ωUa  ωJa )C ← SEnc(K1hska+1; r)If ( a+ 1 = g ) thenK0$← {0 1}k ; C $← SEnc(K0hska+1)StUa+1 ← (hska+1 ε) ; StHa+1 ← εReturn (Conv ‖ C dIa+1dJa+1)procedure Conv() // G4If ( dIa+1 = ⊥ ∧ dJa+1 = ⊥ ) thenParse ωHa as ωJa ||r(ConvK1dIa+1K1dJa+1)← Run(I ε J ε ;ωUa  ωJa )C ← SEnc(K1hska+1; r)If ( a+ 1 = g ) thenK0$← {0 1}k ; C $← SEnc(K0 0|hska+1|)StUa+1 ← (hska+1 ε) ; StHa+1 ← εReturn (Conv ‖ C dIa+1dJa+1)procedure Finalize(M (j σ)) // G0 G1  G2  G3  G4Return ( g = j ∧ j 6∈ E ∧ (jM) 6∈ S ∧ Ver(pkM (j σ)) = 1)Figure 5: Games G0G1G2G3G4 used for the proof of Theorem 61 The boxed code in Finalizeis omitted in G0 but present for the other games The boxed code in Expose is omitted in G0 G1but present for the other games= Pr[GA0 ⇒ true] · Pr [ g = j ]= Pr[GA0 ⇒ true] · 1q (3)The difference between G2 and G1 is that the former includes the boxed code in Expose Howeverany execution of G2 with A in which the outcome is true must have g = j and j 6∈ E so the boxed15code would not have been executed This means thatPr[GA2 ⇒ true]= Pr[GA1 ⇒ true] (4)From equations (2) (3) and (4) we haveAdvpcki-paPCKUS(A) = q · Pr[GA1 ⇒ true]= q · Pr [GA2 ⇒ true ]  (5)We will build E B S so thatPr[GA2 ⇒ true]− Pr [GA3 ⇒ true ] ≤ Advske(IJ)(E) (6)Pr[GA3 ⇒ true]− Pr [GA4 ⇒ true ] ≤ Advind-cpaSE (B) (7)Pr[GA4 ⇒ true] ≤ AdvkiKUS(S)  (8)Assuming this for now we show how to conclude By adding equations (6) (7) and (8) we havePr[GA2 ⇒ true] ≤ Advske(IJ)(E) + Advind-cpaSE (B) + AdvkiKUS(S)  (9)From equations (9) and (5) we have equation (1)We now show how to build adversary E against game SKE(IJ) Adversary E begins by executingthe code of the Initialize procedure of G2 thereby defining for itself all the variables there It thenstarts running A on input pk which is one of the variables it just defined It answers A’s queriesto its Next Expose and Sign oracles exactly as G2 does and answers queries to the Conv oraclevia the following procedure:procedure Conv()If ( dIa+1 = ⊥ ∧ dJa+1 = ⊥ ) thenParse ωHa as ωJa ||r(ConvK1 dIa+1K1 dJa+1)← Run(I ε J ε;ωUa  ωJa ) ; C ← SEnc(K1hska+1; r)If ( a+ 1 = g ) then (ConvdIa+1dJa+1Kb)$← Conv() ; C $← SEnc(Kb hska+1)Return (Conv ‖ CdIa+1 dJa+1)In the 4th line of the code above E invokes its own Conv oracle Finally A outputs (j (Mσ))Adversary E outputs 1 if g = j ∧ j 6∈ E ∧ (jM) 6∈ S ∧ Ver(pkM (j σ)) = 1 and otherwise itoutputs 0 We havePr[SKEEIJ ⇒ true | b = 1]= Pr[GA2 ⇒ true]Pr[SKEEIJ ⇒ true | b = 0]= Pr[GA3 ⇒ true]Subtracting we get equation (6)Next we show how to build adversary B against game INDCPASE Adversary B begins by executingthe code of the Initialize procedure of G3 thereby defining for itself all the variables there Itthen starts running A on input pk It answers A’s queries to its Next Expose and Sign oraclesexactly as G3 does and answers queries to the Conv oracle via the following procedure:procedure Conv()If ( dIa+1 = ⊥ ∧ dJa+1 = ⊥ ) then16Parse ωHa as ωJa ||r(ConvK1 dIa+1K1dJa+1)← Run(I ε J ε;ωUa  ωJa ) ; C ← SEnc(K1hska+1; r)If ( a+ 1 = g ) then C $← LR(hska+1 0|hska+1|)Return (Conv ‖ CdIa+1dJa+1)In the 4th line of the code above B queries its LR oracle Finally A outputs (j (Mσ)) AdversaryB outputs 1 if g = j ∧ j 6∈ E ∧ (jM) 6∈ S ∧ Ver(pkM (j σ)) = 1 and otherwise it outputs 0 WehavePr[INDCPABSE ⇒ true | b = 0]= Pr[GA3 ⇒ true]Pr[INDCPABSE ⇒ true | b = 1]= Pr[GA4 ⇒ true]Subtracting we get equation (7)Finally we show how adversary S works against game KIS S is given input pk It selects ωU0  ωH0 ∈COINS and g ∈ {1     q} independently at random sets a = 0 and starts running A on input pkS answers A’s queries to the Conv oracle via the following procedure:procedure Conv()If ( dIa+1 = ⊥ ∧ dJa+1 = ⊥ ) thenParse ωHa as ωJa ||r(ConvK1 dIa+1K1dJa+1)← Run(I ε J ε;ωUa  ωJa )Next()If ( a+ 1 = g ) then K0$← {0 1}k ; C $← SEnc(K0 0|hska+1|)else (uska+1hska+1)← Expose() ; C ← SEnc(K1hska+1; r)Return (Conv ‖ CdIa+1dJa+1)In the 4th line of the code above S queries its Next oracle and in the 6th line it queries its Exposeoracle S answers A’s queries to the Next oracle by incrementing a and selecting ωUa  ωHa ∈ COINSindependently at random It answers A’s queries to its Expose and Sign oracles via its owncorresponding oracles (setting ucka = ε) Finally A outputs (j (Mσ)) and S returns this sameoutput From the above we know that if A wins game G4 the event of g = j must happen Inaddition S never queries its own Expose oracle in stage g Thus S can output the same signature(g (Mσ)) as A and win the game KIS So we have equation (8)7 Intrusion resilience in the secure-channel modelIn an intrusion-resilient signature scheme both the user’s and the helper’s secret keys evolve withtime In addition these schemes include a refresh procedure for helper and user such that if arefresh is run between the compromise of the user or helper and the compromise of the other thenthe system remains secure except for the current stage In our security definition below we denotethe number of refreshes per stage by RN  Our definition differs from that of [20] in some detailsbut this does not affect the resultsA signer-base key-updating signature scheme SBKUS = (KGHKUUKUHKRUKRSigVer) isspecified by seven algorithms with the following functionality The randomized key-generationalgorithm KG returns (pkusk00hsk00) where pk is the user public key usk00 is the stage 0 usersecret key and hsk00 is the stage 0 helper key The user is initialized with pkusk00 while the17procedure Initialize(pkusk00hsk00)$← KGa← 0 ; r ← 0 ; S ← ∅Return pkprocedure Next()a← a+ 1(hska0hskua)$← HKU(apkhsk(a−1)r)uska0$← UKU(apkhskuausk(a−1)r)(hska1hskra1)$← HKR(apkhska0)uska1$← UKR(apkhskra1uska0)r ← 1procedure Finalize(M (j σ))If ((jM) ∈ S ∨ Ver(pkM (j σ)) = 0) thenReturn falseIf ∃s(1 ≤ s ≤ RN ∧ ExpU js) then Return falseIf ∃i∃s(1 ≤ i < j ∧ 1 ≤ s ≤ RN ∧ExpU is ∧ ExpH is) then Return falseReturn trueprocedure Refresh()r ← r + 1(hskarhskrar)$← HKR(apkhska(r−1))uskar$← UKR(apkhskraruska(r−1))procedure Expose(Type)If (Type = “U”) thenExpUar ← true ; Return uskarIf (Type = “H”) thenExpHar ← true ; Return hskarIf (Type = “P”) thenIf (ExpU (a−1)RN ) thenExpUa1 ← true ; Return (hskuahskra1)If (Type = “R”) thenIf (ExpUa(r−1)) thenExpUar ← true ; Return hskrarReturn ⊥procedure Sign(M)(a σ) $← Sig(auskarM)S ← S ∪ {(aM)}Return (a σ)Figure 6: Game IRS used to define IR signatures in the secure-channel modelhelper is initialized with pk hsk00 At the start of stage a ≥ 1 if r refreshes have been made sincethe last update where 0 ≤ r ≤ RN  the helper applies the randomized helper key-update algorithmHKU to apkhsk(a−1)r to obtain a stage a helper key hska0 and a stage a helper update key hskuaThe helper discards (erases) hsk(a−1)r Then it applies the randomized helper key-refresh algorithmHKR to apkhska0 to obtain a stage a helper key hska1 and a stage a helper refresh key hskra1 Itdiscards hska0 The helper update key hskua and the helper refresh key hskra1 are then assumedto be conveyed to the user via a secure channel The user receives hskua and hskra1 from thehelper and applies the randomized user key-update algorithm UKU to apk hskuausk(a−1)r toobtain a stage a user secret key uska0 The user then discards usk(a−1)r Then the user appliesthe randomized user key-refresh algorithm UKR to apkhskra1uska0 to obtain a stage a usersecret key uska1 The user then discards uska0 In stage a if r refreshes have been made where1 ≤ r < RN  the helper can apply the helper key-refresh algorithm HKR to apkhskar to obtaina stage a helper key hska(r+1) and a stage a helper refresh key hskra(r+1) It then discards hskarThe helper refresh key hskra(r+1) is assumed to be conveyed to the user via a secure channelThe user receives hskra(r+1) from the helper and applies the user key-refresh algorithm UKR toapkhskra(r+1) uskar to obtain a stage a user secret key uska(r+1) The user then discards uskarIn stage a if r refreshes have been made where 1 ≤ r ≤ RN  the user can apply the randomizedsigning algorithm Sig to a stage a secret key uskar and a message M ∈ {0 1}∗ to obtain a pair(a σ) consisting of the stage number a and a signature σ During stage a anyone can apply thedeterministic verification algorithm Ver to pk a message M  and a pair (i σ) to obtain either 1indicating acceptance or 0 indicating rejection We require that if (i σ) where 1 ≤ i ≤ a wasproduced by applying the signing algorithm to iuskirM then Ver(pkM (i σ)) = 118Security Consider game IRS of Figure 6 The Initialize procedure provides adversary A withinput pk A can call its Next oracle to move the system into the next stage It can call its Refreshoracle to refresh the helper and user’s secret keys It may break in during the current stage bycalling its Expose oracle Four types of Expose queries are allowed Query “U” returns the usersecret key for the current stage Query “H” returns the helper key for that stage Query “P”returns the helper update and helper refresh keys for the current stage Query “R” returns thehelper refresh key for that stage A may obtain signatures for messages of its choice during thecurrent stage by calling its Sign oracleFor any stage a and any refresh number r 1 ≤ r ≤ RN  user secret key uskar is said to beexposed if ExpUar = true Helper key hskar is said to be exposed if ExpHar = true Signer-basekey-updating signature scheme SBKUS is said to be a-compromised if uskar is exposed for some r1 ≤ r ≤ RN  or there exists i < a such that uskir and hskir are exposed for some r 1 ≤ r ≤ RN To win A must output a message M and a signature (j σ) such that M was not queried toSign during stage j Ver(pkM (j σ)) = 1 and the scheme is not j-compromised A’s advantageisAdvirSBKUS(A) = Pr[IRSA ⇒ true ] We adopt the convention that the running time of an adversary A is the execution time of theentire game including the time taken for initialization the time taken by the oracles to computereplies to the adversary’s queries and the time taken for finalization8 Intrusion resilience in the public-channel modelPublic-channel signer-base key updating signature schemes A public-channel signer-base key-updating signature scheme is a tuple PCSBKUS = (SBKUSCKG (UUHU) (URHR))where SBKUS = (KGHKUUKUHKRUKRSigVer) is a signer-base key-updating signaturescheme CKG is the channel-key-generation algorithm and the channel-key-update protocol(UUHU) and channel-key-refresh protocol (URHR) are each pairs of interactive algorithms tobe run by user and helper respectively Let RN denote the number of refreshes per stage inSBKUS We now explain how the system runsAlgorithm CKG returns the stage 0 user channel key uck00 and the stage 0 helper channel keyhck00 When the user is initialized in addition to the public key pk and stage 0 user secret keyusk00 produced by KG the user is given uck00 When the helper is initialized in addition to pkand the stage 0 helper key hsk00 (also generated by KG) the helper is given hck00In any stage a ≥ 0 if r refreshes have been made since the last update where 0 ≤ r ≤ RN the user holds a stage a user secret key uskar and a stage a user channel key uckar The helperholds a stage a helper key hskar and a stage a helper channel key hckar At the start of stagea+ 1 the helper computes (hsk(a+1)0 hskua+1)$← HKU(a+ 1 pk hskar) discards (erases) hskarcomputes (hsk(a+1)1hskr(a+1)1)$← HKR(a + 1pkhsk(a+1)0) and discards hsk(a+1)0 Then theparties engage in the channel-key-update protocol (UUHU) The local input of UU is the stagea user secret key uskar the stage a user channel key uckar and some random coins ωUar; whilethe local input of HU is the stage a+ 1 helper update key hskua+1 the stage a+ 1 helper refreshkey hskr(a+1)1 the stage a helper channel key hckar and some random coins ωHar After theinteraction the expected local output of UU is hskua+1 hskr(a+1)1 plus the stage a + 1 userchannel key uck(a+1)1; while the expected local output of HU is the stage a + 1 helper channelkey hck(a+1)1 Once the protocol has completed the user immediately updates its secret key by19computing usk(a+1)0$← UKU(a+1 pkhskua+1uskar) discarding uskar computing usk(a+1)1 $←UKR(a+1 pkhskr(a+1)1usk(a+1)0) and discarding usk(a+1)0 The user also discards its previouschannel key uckar The helper discards its previous channel key hckar as well We require thenatural correctness condition namely that the stage a + 1 helper update key and the stage a + 1helper refresh key produced by UU in the interaction in which UU has input uskar uckar ωUarand HU has input hskua+1hskr(a+1)1hckar ωHar are respectively hskua+1 and hskr(a+1)1 withprobability one In addition we require that at the end of the interaction UU’s decision dU(a+1)1and HU’s decision dH(a+1)1 are both accIn stage a if r refreshes have been made where 1 ≤ r ≤ RN  the helper can compute(hska(r+1)hskra(r+1))$← HKR(apkhskar) and discard hskar Then the parties engage in thechannel-key-refresh protocol (URHR) The local input of UR is the stage a user secret key uskarthe stage a user channel key uckar and some random coins ωUar; while the local input of HR isthe stage a helper refresh key hskra(r+1) the stage a helper channel key hckar and some randomcoins ωHar After the interaction the expected local output of UR is hskra(r+1) plus the stage auser channel key ucka(r+1); while the expected local output of HR is the stage a helper channelkey hcka(r+1) Once the protocol has completed the user updates its secret key by computinguska(r+1)$← UKR(apk hskra(r+1)uskar) and discarding uskar The user also discards its previ-ous channel key uckar The helper discards its previous channel key hckar as well We require thenatural correctness condition namely that the stage a+1 helper refresh key produced by UR in theinteraction in which UR has input uskar uckar ωUar and HR has input hskra(r+1) hckar ωHar ishskra(r+1) with probability one In addition we require that at the end of the interaction UR’s de-cision dUa(r+1) and HU’s decision dHa(r+1) are both acc Security We proceed to formalize a notionof security for public-channel signer-base key-updating signature schemes: intrusion resilience underpassive attacks We first provide a definition and then explanations Let PCSBKUS = ((KGHKUUKUHKRUKRSigVer)CKG (UUHU) (URHR)) be a public-channel signer-base key-updatingsignature scheme We consider an adversary A interacting with the game of Figure 7The Initialize procedure gives A input pk A is provided with oracles Next Refresh ExposeUConv RConv and Sign It may query the oracles adaptively in any order it wants with thefollowing restrictions: every query to oracle UConv is immediately followed by a query to oracleNext every query to oracle RConv is immediately followed by a query to oracle Refresh and inevery stage the adversary makes exactly RN Refresh queries Eventually A outputs a message Mand a signature (j σ) and halts A passive adversary is said to win if game PCIR-pa returns truemeaning M was not queried to Sign during stage j Ver(pkM (j σ)) = 1 no Expose queries oftype “U” were made during stage j and during all previous stages i 1 ≤ i < j no Expose queriesof type “U” and type “H” were made without a refresh in between them A’s pa-advantage isAdvpcir-paPCSBKUS(A) = Pr[PCIR-paA ⇒ true ] Again we adopt the convention that the running time of an adversary A is the execution timeof the entire game including the time taken for initialization the time taken by the oracles tocompute replies to the adversary’s queries and the time taken for finalization9 Possibility of public-channel IR under passive attackGiven a signer-base key-updating signature scheme in the secure-channel model we show inthis section how to transform it into a signer-base key-updating signature scheme secure againstpassive attack in the public-channel model by using secret-key-exchange protocols and symmetric20procedure Initialize(pkusk00hsk00)$← KG(uck00 hck00)$← CKG(hsk10 hsku1)← HKU(1pk hsk00)(hsk11 hskr11)← HKR(1 pkhsk10)ωU00$← COINS ; ωH00$← COINSStU11 ← (usk00uck00 ωU00)StH11 ← (hsku1 hskr11hck00 ωH00)a← 0 ; r ← 0 ; S ← ∅Return pkprocedure Refresh()r ← r + 1If ( dUar = acc ) then(hskraruckar)← StUar ; ωUar $← COINSuskar ← UKR(a pk hskraruska(r−1))If ( r = RN ) thenStU(a+1)1 ← (uskar uckar ωUar)ElseStUa(r+1) ← (uskar uckar ωUar)If ( dHar = acc ) thenhckar ← StHar ; ωHar $← COINSIf ( r = RN ) then(hsk(a+1)0 hskua+1)$← HKU(a+ 1 pkhskar)(hsk(a+1)1 hskr(a+1)1)$← HKR(a+ 1pk hsk(a+1)0)StH(a+1)1 ← (hskua+1hskr(a+1)1 hckar ωHar)Else(hska(r+1) hskra(r+1))$← HKR(a pk hskar)StHa(r+1) ← (hskra(r+1) hckar ωHar)procedure Sign(M)(a σ)$← Sig(auskarM)S ← S ∪ {(aM)}Return (a σ)procedure Next()a← a+ 1If ( dUa1 = acc ) then(hskua hskra1 ucka1)← StUa1 ; ωUa1$← COINSuska0 ← UKU(apk hskua usk(a−1)r)uska1 ← UKR(a pk hskra1 uska0)StUa2 ← (uska1 ucka1 ωUa1)If ( dHa1 = acc ) thenhcka1 ← StHa1 ; ωHa1$← COINS(hska2 hskra2)$← HKR(apk hska1)StHa2 ← (hskra2hcka1 ωHa1)r ← 1procedure Expose(Type)If (Type = “U”) thenExpUar ← trueReturn (uskar hskua hskraruckar ωUar)If (Type = “H”) thenExpHar ← trueIf (r 6= 1 ∧ ExpUa(r−1)) then ExpUar ← trueIf (r = 1 ∧ ExpU(a−1)RN ) then ExpUar ← trueReturn (hskar hskua hskrar hckar ωHar)Return ⊥procedure Finalize(M (j σ))If ((jM) ∈ S ∨ Ver(pkM (j σ)) = 0) thenReturn falseIf ∃s(1 ≤ s ≤ RN ∧ ExpUjs) then Return falseIf ∃i∃s(1 ≤ i < j ∧ 1 ≤ s ≤ RN ∧ExpUis ∧ ExpHis) then Return falseReturn trueprocedure UConv()If ( dU(a+1)1= ⊥ ∧ dH(a+1)1= ⊥ ) then(ConvStU(a+1)1 dU(a+1)1StH(a+1)1 dH(a+1)1)$← Run(UUStU(a+1)1HUStH(a+1)1)Return (Conv dU(a+1)1 dH(a+1)1)procedure RConv()If ( dUa(r+1)= ⊥ ∧ dHa(r+1)= ⊥ ) then(ConvStUa(r+1)dUa(r+1)StHa(r+1) dHa(r+1))$← Run(URStUa(r+1)HRStHa(r+1))Return (Conv dUa(r+1) dHa(r+1))Figure 7: Game PCIR-pa used to define public-channel intrusion resilience under passive attackencryption schemesConstruction Let SBKUS = (KGHKUUKUHKRUKRSigVer) be a signer-base key-updatingsignature scheme We transform it into a public-channel signer-base key-updating signature schemePCSBKUS = (SBKUSCKG (UUHU) (URHR)) where CKG always returns (ε ε) by defining boththe channel-key-update protocol (UUHU) and the channel-key-refresh protocol (URHR) in terms21of any secret-key-exchange protocol (I J) and symmetric encryption scheme SE = (SEncSDec) theprotocol and the encryption with the same key length k as follows During each update (resprefresh) the parties first run the secret-key-exchange protocol with U playing the role of I andH playing the role of J to agree on a common key K The helper then encrypts (hskui hskri1)(resp hskrir) under K using SEnc to obtain a ciphertext C which it sends to the user The latterdecrypts C under K using SDec to obtain (hskuihskri1) (resp hskrir)Security of our construction We prove that if the given signer-base key-updating signaturescheme is intrusion-resilience in the secure-channel model and the secret-key-exchange protocolas well as the symmetric encryption scheme are secure then the public-channel signer-base key-updating signature scheme obtained using our construction is IR under passive attack in the public-channel modelTheorem 91 Let SBKUS = (KGHKUUKUHKRUKRSigVer) be a signer-base key-updatingsignature scheme Let PCSBKUS = (SBKUSCKG (UUHU) (URHR)) be the public-channelsigner-base key-updating signature scheme constructed from SBKUS secret-key-exchange proto-col (I J) and symmetric encryption scheme SE = (SEnc SDec) as described above Let tKG tHKUtUKU tHKR tUKR tSig tVer and tCKG denote the running times of the corresponding algorithms andt(UUHU) t(URHR) denote the running times of protocols (UUHU) and (URHR) respectively Let Abe an adversary against PCSBKUS making qU queries to oracle UConv and Next qR queries toRConv and Refresh qE queries to Expose qS queries to Sign Then there exist adversaries EB S such thatAdvpcir-paPCSBKUS(A) ≤ qU ·Advske(IJ)(E) + qU ·Advind-cpaSE (B) + qU ·AdvirSBKUS(S)  (10)Furthermore the running times of E B are both tKG + tCKG + qU · (tHKU + tUKU) + qR · (tHKR +tUKR) + qS · tSig + qU · t(UUHU) + qR · t(URHR) and the running time of S is tCKG +O(qU + qR + qS +qE) + qU · t(UUHU) + qR · t(URHR) Also S makes 3qE + qU + qR− 5 queries to its Expose oracle qUqueries to its Next oracle and qR queries to its Refresh oracleProof: We use games G0 G1 G2 G3 G4 defined in Figure 8 We assume without loss of generalitythat A never asks an oracle query twice and its output (j (Mσ)) always satisfies 1 ≤ j ≤ qU  Weassume that A always makes exactly (as opposed to at most) qU UConv oracle queries Game G0is simply the game PCIR-pa for the case where the channel-key-update protocol and channel-key-refresh protocol are what we have defined and so we haveAdvpcir-paPCSBKUS(A) = Pr[GA0 ⇒ true] (11)Games G0 and G1 are identical except for the boxed code in Finalize and on the other handG0 does not use g anywhere and thus the events GA0 ⇒ true and g = j are independent and theprobability of the latter is 1/qU  HencePr[GA1 ⇒ true]= Pr[GA0 ⇒ true ∧ g = j]= Pr[GA0 ⇒ true] · Pr [ g = j ]= Pr[GA0 ⇒ true] · 1qU (12)The difference between G2 and G1 is that the former includes the boxed code in Expose Howeverany execution of G2 with A in which the outcome is true must have g = j ∀s1 ≤ s ≤ RNExpUgs 6=22true and ∀i∀s 1 ≤ i < g ∧ 1 ≤ s ≤ RNExpU is 6= true∨ExpH is 6= true (we refer to such a forgerysatisfying these requirements later as a successful one) So the boxed code would not have beenexecuted This means thatPr[GA2 ⇒ true]= Pr[GA1 ⇒ true] (13)From equations (11) (12) and (13) we haveAdvpcir-paPCKUS(A) = qU · Pr[GA1 ⇒ true]= qU · Pr[GA2 ⇒ true] (14)We will build E B S so thatPr[GA2 ⇒ true]− Pr [GA3 ⇒ true ] ≤ Advske(IJ)(E) (15)Pr[GA3 ⇒ true]− Pr [GA4 ⇒ true ] ≤ Advind-cpaSE (B) (16)Pr[GA4 ⇒ true] ≤ AdvirSBKUS(S)  (17)Assuming this for now we show how to conclude By adding equations (15) (16) and (17) wehavePr[GA2 ⇒ true] ≤ Advske(IJ)(E) + Advind-cpaSE (B) + AdvirSBKUS(S)  (18)From equations (18) and (14) we have equation (10)We now show how to build adversary E against game SKE(IJ) Adversary E begins by executingthe code of the Initialize procedure of G2 thereby defining for itself all the variables there It thenstarts running A on input pk which is one of the variables it just defined It answers A’s queriesto its Next Refresh Expose and Sign oracles exactly as G2 does and answers queries to theUConv and RConv oracles via the following procedures:procedure UConv()If ( dI(a+1)1 = ⊥ ∧ dJ(a+1)1 = ⊥ ) thenParse ωHaRN as ωJaRN ‖ r(ConvK1 dI(a+1)1K1 dJ(a+1)1)$← Run(I ε J ε ;ωUaRN  ωJaRN )C ← SEnc(K1 (hskua+1hskr(a+1)1); r)If ( a+ 1 = g ∧ ExpUaRN ) then(Conv dI  dJ Kb)$← Conv() ; C $← SEnc(Kb (hskua+1hskr(a+1)1))Return (Conv ‖ CdI(a+1)1dJ(a+1)1)procedure RConv()If ( dIa(r+1) = ⊥ ∧ dJa(r+1) = ⊥ ) thenParse ωHar as ωJar ‖ r(ConvK1 dIa(r+1)K1dJa(r+1))$← Run(I ε J ε;ωUar ωJar)C ← SEnc(K1 hskra(r+1); r)If ( a = g ∧ ( ∃s 1 ≤ s ≤ RNExpUas )) then(Conv dI  dJ Kb)$← Conv() ; C $← SEnc(Kbhskra(r+1))Return (Conv ‖ CdIa(r+1)dJa(r+1))23In the 6th line of each procedure above E invokes its own Conv oracle Finally A outputs(j (Mσ)) Adversary E outputs 1 if (j (Mσ)) is successful and otherwise it outputs 0 We havePr[SKEEIJ ⇒ true | b = 1]= Pr[GA2 ⇒ true]Pr[SKEEIJ ⇒ true | b = 0]= Pr[GA3 ⇒ true]Subtracting we get equation (15)Next we show how to build adversary B against game INDCPASE Adversary B begins by executingthe code of the Initialize procedure of G3 thereby defining for itself all the variables there Itthen starts running A on input pk It answers A’s queries to its Next Refresh Expose andSign oracles exactly as G3 does and answers queries to the UConv and RConv oracles via thefollowing procedures:procedure UConv()If ( dI(a+1)1 = ⊥ ∧ dJ(a+1)1 = ⊥ ) thenParse ωHaRN as ωJaRN ‖ r(ConvK1dI(a+1)1K1dJ(a+1)1)$← Run(I ε J ε ;ωUaRN  ωJaRN )C ← SEnc(K1 (hskua+1hskr(a+1)1); r)If ( a+ 1 = g ∧ ExpUaRN ) then C $← LR((hskua+1 hskr(a+1)1) 0|hskua+1hskr(a+1)1|)Return (Conv ‖ CdI(a+1)1 dJ(a+1)1)procedure RConv()If ( dIa(r+1) = ⊥ ∧ dJa(r+1) = ⊥ ) thenParse ωHar as ωJar ‖ r(ConvK1dIa(r+1)K1 dJa(r+1))$← Run(I ε J ε;ωUar ωJar)C ← SEnc(K1 hskra(r+1); r)If ( a = g ∧ ( ∃s 1 ≤ s ≤ RNExpUas )) then C $← LR(hskra(r+1) 0|hskra(r+1)|)Return (Conv ‖ CdIa(r+1)dJa(r+1))In the 5th line of each procedures above B queries its LR oracle Finally A outputs (j (Mσ))Adversary B outputs 1 if the forgery is a successful one and otherwise it outputs 0 We havePr[INDCPABSE ⇒ true | b = 0]= Pr[GA3 ⇒ true]Pr[INDCPABSE ⇒ true | b = 1]= Pr[GA4 ⇒ true]Subtracting we get equation (16)Finally we show how adversary S works against game IRS Given input pk S begins by executingthe code of Initialize procedure of G4 defining all the variables there It then starts running Aon input pk It answers A’s queries to the UConv RConv and Expose oracles via the followingprocedures:procedure Expose(Type)If (Type = “U”) thenExpUar ← true24If ( a = g )∨( a < g ∧ ExpHar ) then Return ⊥uskar ← Expose(“U”) ; hskua ← Expose(“P”) ; hskrar ← Expose(“R”) ; uckar ← εReturn (uskarhskua hskrar uckar ωUar)If (Type = “H”) thenExpHar ← trueIf (r 6= 1 ∧ ExpUar−1) then ExpUar ← trueIf (r = 1 ∧ ExpUa−1RN ) then ExpUar ← trueIf ( a ≤ g ∧ ExpUar ) then Return ⊥hskar ← Expose(“H”) ; hskua ← Expose(“P”) ; hskrar ← Expose(“R”) ; hckar ← εReturn (hskarhskua hskrar hckar ωHar)Return ⊥In the 4th and 11th lines of the code above S queries its Expose oracleprocedure UConv()If ( dIa+1 = ⊥ ∧ dJa+1 = ⊥ ) thenParse ωHaRN as ωJaRN ‖ r(ConvK1 dIa+1K1dJa+1)← Run(I ε J ε;ωUa  ωJa )Next()If ( a+ 1 = g ∧ ExpUaRN ) then K0 $← {0 1}k ; C $← SEnc(K0 0|(hskua+1hskr(a+1)1)|)else (hskua+1hskr(a+1)1)← Expose(“P”) ; C ← SEnc(K1 (hskua+1hskr(a+1)1); r)Return (Conv ‖ CdIa+1dJa+1)In the 4th line of the code above S queries its Next oracle and in the 6th line of the code aboveS queries its Expose oracleprocedure RConv()If ( dIa(r+1) = ⊥ ∧ dJa(r+1) = ⊥ ) thenParse ωHar as ωJar ‖ r(ConvK1 dIa(r+1)K1 dJa(r+1))$← Run(I ε J ε;ωUar ωJar)Refresh()If ( a = g ∧ ( ∃s 1 ≤ s ≤ RNExpUas )) then K0 $← {0 1}k ; C $← SEnc(K0 0|hskra(r+1)|)else hskra(r+1) ← Expose(“R”) ; C ← SEnc(K1hskra(r+1); r)Return (Conv ‖ CdIa(r+1)dJa(r+1))In the 4th line of the code above S queries its Refresh oracle and in the 6th line of the codeabove S queries its Expose oracle In addition S answers A’s queries to the Next oracle byincrementing a and selecting ωUa1 ωHa1 ∈ COINS independently at random Similarly S answers A’squeries to the Refresh oracle by incrementing r and selecting ωUar ωHar ∈ COINS independentlyat randomIt answers A’s queries to the Sign oracle via its own corresponding oracles Finally Aoutputs (j (Mσ)) and S returns this same output From the above we know that if A wins gameG4 the event of g = j must happen In addition S never queries its own Expose oracle whichmakes its forgery unsuccessful Thus S can output the same signature (g (Mσ)) as A and win thegame IRS So we have equation (17)25References[1] R Anderson Two Remarks on Public-Key Cryptology Manuscript 2000 and Invited Lecture atthe Fourth Annual Conference on Computer and Communications Security Zurich Switzerland April1997[2] M Bellare and S Miner A forward-secure digital signature scheme Advances in Cryptology –CRYPTO ’99 Lecture Notes in Computer Science Vol 1666 M Wiener ed Springer-Verlag 1999[3] M Bellare S Duan and A Palacio Key Insulation and Intrusion Resilience Over a PublicChannel Topics in Cryptology – CT-RSA ’09 Lecture Notes in Computer Science Vol ??  M Fischlined Springer-Verlag 2009[4] M Bellare and A Palacio Protecting against Key Exposure: Strongly Key-Insulated Encryptionwith Optimal Threshold Applicable Algebra in Engineering Communication and Computing Vol 16No 6 Springer-Verlag 2006 pp 379–396[5] M Bellare and P Rogaway Entity Authentication and key distribution Advances in Cryptology– CRYPTO ’93 Lecture Notes in Computer Science Vol 773 D Stinson ed Springer-Verlag 1993[6] M Bellare and P Rogaway The Security of Triple Encryption and a Framework for Code-Based Game-Playing Proofs Advances in Cryptology – EUROCRYPT ’06 Lecture Notes in ComputerScience Vol 4004 S Vaudenay ed Springer-Verlag 2006[7] M Bellare and B Yee Forward-Security in Private-Key Cryptography Topics in Cryptology –CT-RSA ’03 Lecture Notes in Computer Science Vol 2612 M Joye ed Springer-Verlag 2003[8] M Ben-Or S Goldwasser and A Wigderson Completeness Theorems for Non-CryptographicFault-Tolerant Distributed Computation Proceedings of the 30th Annual Symposium on the Theoryof Computing ACM 1998[9] R Canetti U Feige O Goldreich and M Naor Adaptively Secure Multi-Party Computa-tion Proceedings of the 28th Annual Symposium on the Theory of Computing ACM 1996[10] R Canetti S Halevi and J Katz A Forward-Secure Public-Key Encryption Scheme Advancesin Cryptology – EUROCRYPT ’03 Lecture Notes in Computer Science Vol 2656 E Biham edSpringer-Verlag 2003[11] R Canetti and H Krawczyk Analysis of Key-Exchange Protocols and Their Use for BuildingSecure Channels Advances in Cryptology – EUROCRYPT ’01 Lecture Notes in Computer ScienceVol 2045 B Pfitzmann ed Springer-Verlag 2001[12] R Canetti and H Krawczyk Universally Composable Notions of Key Exchange and SecureChannels Advances in Cryptology – EUROCRYPT ’02 Lecture Notes in Computer Science Vol 2332L Knudsen ed Springer-Verlag 2002[13] Y Dodis M Franklin J Katz A Miyaji and M Yung Intrusion-Resilient Public-Key En-cryption Topics in Cryptology – CT-RSA ’03 Lecture Notes in Computer Science Vol 2612 M Joyeed Springer-Verlag 2003[14] Y Dodis M Franklin J Katz A Miyaji and M Yung A Generic Construction for Intrusion-Resilient Public-Key Encryption Topics in Cryptology – CT-RSA ’04 Lecture Notes in ComputerScience Vol 2964 T Okamoto ed Springer-Verlag 2004[15] Y Dodis J Katz S Xu and M Yung Key-Insulated Public Key Cryptosystems Advancesin Cryptology – EUROCRYPT ’02 Lecture Notes in Computer Science Vol 2332 L Knudsen edSpringer-Verlag 2002[16] Y Dodis J Katz S Xu and M Yung Strong Key-Insulated Signature Schemes Public-KeyCryptography ’03 Lecture Notes in Computer Science Vol 2567 Y Desmdedt ed Springer-Verlag200326[17] C Dwork M Naor O Reingold and L Stockmeyer Magic Functions Proceedings of the40th Symposium on Foundations of Computer Science IEEE 1999[18] G Hanaoka Y Hanaoka and H Imai Parallel Key-Insulated Public Key Encryption Public-KeyCryptography ’06 Lecture Notes in Computer Science Vol 3958 M Yung Y Dodis A Kiayias andT Malkin ed Springer-Verlag 2006[19] Y Hanaoka G Hanaoka J Shikata H Imai Identity-based Heirarchical Strongly Key-Insulated Encryption and its Application Advances in Cryptology – ASIACRYPT ’05 Lecture Notesin Computer Science Vol 3788 B Roy ed Springer-Verlag 2005[20] G Itkis and L Reyzin SiBIR: Signer-Base -Resilient Signatures Advances in Cryptology –CRYPTO ’02 Lecture Notes in Computer Science Vol 2442 M Yung ed Springer-Verlag 200227procedure Initialize(pk usk00 hsk00)$← KG(uck00 hck00)$← CKG(hsk10 hsku1)$← HKU(1 pk hsk00)(hsk11 hskr11)$← HKR(1 pkhsk10)ωU00$← COINS ; ωH00$← COINSStU11 ← (usk00uck00 ωU00)StH11 ← (hsku1 hskr11hck00 ωH00)a← 0 ; r ← 0 ; S ← ∅g$← {1     qU}Return pkprocedure Refresh()r ← r + 1If ( dUar = acc ) then(hskraruckar)← StUar ; ωUar $← COINSuskar ← UKR(a pk hskraruska(r−1))If ( r = RN ) thenStU(a+1)1 ← (uskar uckar ωUar)ElseStUa(r+1) ← (uskar uckar ωUar)If ( dHar = acc ) thenhckar ← StHar ; ωHar $← COINSIf ( r = RN ) then(hsk(a+1)0 hskua+1)$← HKU(a+ 1 pkhskar)(hsk(a+1)1 hskr(a+1)1)$← HKR(a+ 1pk hsk(a+1)0)StH(a+1)1 ← (hskua+1hskr(a+1)1 hckar ωHar)Else(hska(r+1) hskra(r+1))$← HKR(a pk hskar)StHa(r+1) ← (hskra(r+1) hckar ωHar)procedure Sign(M)(a σ)$← Sig(auskarM)S ← S ∪ {(aM)}Return (a σ)procedure Expose(Type) // G0 G1 G2  G3  G4x←⊥If (Type = “U”) thenExpUar ← truex← (uskar hskua hskrar uckar ωUar)If ( a = g )∨( a < g ∧ ExpHar ) then x←⊥If (Type = “H”) thenExpHar ← truex← (hskar hskua hskrar hckar ωHar)If (r 6= 1 ∧ ExpUar−1) then ExpUar ← trueIf (r = 1 ∧ ExpUa−1RN ) then ExpUar ← trueIf ( a ≤ g ∧ ExpUar ) then x←⊥Return xprocedure Next()a← a+ 1If ( dUa1 = acc ) then(hskua hskra1ucka1)← StUa1 ; ωUa1$← COINSuska0 ← UKU(a pk hskua usk(a−1)r)uska1 ← UKR(a pk hskra1uska0)StUa2 ← (uska1 ucka1 ωUa1)If ( dHa1 = acc ) thenhcka1 ← StHa1 ; ωHa1$← COINS(hska2 hskra2)$← HKR(a pk hska1)StHa2 ← (hskra2 hcka1 ωHa1)r ← 1procedure Finalize(M (j σ)) // G0 G1  G2  G3  G4If ((jM) ∈ S ∨ Ver(pkM (j σ)) = 0) then Return 0If ∃s(1 ≤ s ≤ RN ∧ ExpUjs) then Return 0If ∃i∃s(1 ≤ i < j ∧ 1 ≤ s ≤ RNi ∧ ExpUis ∧ExpHis) then Return 0Return g = j∧ 1procedure UConv() // G0G1G2If ( dI(a+1)1= ⊥ ∧ dJ(a+1)1= ⊥ ) thenParse ωHaRN as ωJaRN ‖ r(ConvK1dI(a+1)1K1dJ(a+1)1)$← Run(I ε J ε;ωUaRN  ωJaRN )C ← SEnc(K1 (hskua+1 hskr(a+1)1); r)StU(a+1)1 ← (hskua+1 hskr(a+1)1 ε) ; StH(a+1)1 ← εReturn (Conv ‖ CdI(a+1)1 dJ(a+1)1)procedure RConv() // G0G1G2If ( dIa(r+1)= ⊥ ∧ dJa(r+1)= ⊥ ) thenParse ωHar as ωJar ‖ r(ConvK1dIa(r+1)K1dJa(r+1))$← Run(I ε J ε;ωUar ωJar)C ← SEnc(K1 hskra(r+1); r)StUa(r+1) ← (hskra(r+1) ε) ; StHa(r+1) ← εReturn (Conv ‖ CdIa(r+1) dJa(r+1))Figure 8: Games used to used to prove security of public-channel intrusion resilience28procedure UConv() // G3If ( dI(a+1)1 = ⊥ ∧ dJ(a+1)1 = ⊥ ) thenParse ωHaRN as ωJaRN ‖ r(ConvK1dI(a+1)1K1dJ(a+1)1)$← Run(I ε J ε ;ωUaRN  ωJaRN )C ← SEnc(K1 (hskua+1hskr(a+1)1); r)If ( a+ 1 = g ∧ ExpUaRN ) thenK0$← {0 1}k ; C $← SEnc(K0 (hskua+1hskr(a+1)1))StU(a+1)1 ← (hskua+1hskr(a+1)1 ε) ; StH(a+1)1 ← εReturn (Conv ‖ CdI(a+1)1dJ(a+1)1)procedure RConv() // G3If ( dIa(r+1) = ⊥ ∧ dJa(r+1) = ⊥ ) thenParse ωHar as ωJar ‖ r(ConvK1dIa(r+1)K1dJa(r+1))$← Run(I ε J ε;ωUar ωJar)C ← SEnc(K1hskra(r+1); r)If ( a = g ∧ (∃s 1 ≤ s ≤ RNExpUas )) thenK0$← {0 1}k ; C $← SEnc(K0hskra(r+1))StUa(r+1) ← (hskra(r+1) ε) ; StHa(r+1) ← εReturn (Conv ‖ CdIa(r+1)dJa(r+1))procedure UConv() // G4If ( dI(a+1)1 = ⊥ ∧ dJ(a+1)1 = ⊥ ) thenParse ωHaRN as ωJaRN ‖ r(ConvK1dI(a+1)1K1dJ(a+1)1)$← Run(I ε J ε ;ωUaRN  ωJaRN )C ← SEnc(K1 (hskua+1hskr(a+1)1); r)If ( a+ 1 = g ∧ ExpUaRN ) thenK0$← {0 1}k ; C $← SEnc(K0 0|hskua+1hskr(a+1)1|)StU(a+1)1 ← (hskua+1hskr(a+1)1 ε) ; StH(a+1)1 ← εReturn (Conv ‖ CdI(a+1)1dJ(a+1)1)procedure RConv() // G4If ( dIa(r+1) = ⊥ ∧ dJa(r+1) = ⊥ ) thenParse ωHar as ωJar ‖ r(ConvK1dIa(r+1)K1dJa(r+1))$← Run(I ε J ε;ωUar ωJar)C ← SEnc(K1hskra(r+1); r)If ( a = g ∧ (∃s 1 ≤ s ≤ RNExpUas )) thenK0$← {0 1}k ; C $← SEnc(K0 0|hskra(r+1)|)StUa(r+1) ← (hskra(r+1) ε) ; StHa(r+1) ← εReturn (Conv ‖ CdIa(r+1)dJa(r+1))Figure 9: Procedures UConv() RConv() of games G3 and G429
Protecting against key exposure-pdf,Protecting against Key Exposure:Strongly Key-Insulated Encryptionwith Optimal ThresholdMihir Bellare∗ Adriana Palacio†June 26 2002AbstractA new framework for protection against key exposure was recently suggested by Dodiset al [16] We take its realization further towards practice by presenting simple new schemesthat provide benefits over previous ones in terms of scalability performance and security Ourfirst contribution is a simple practical scalable scheme called SKIE-OT that achieves the bestpossible security in their framework SKIE-OT is based on the Boneh-Franklin identity-basedencryption (IBE) scheme [10] and exploits algebraic properties of the latter We also show thatthe role of identity-based encryption is not coincidental by proving that IBE is equivalent to(not strongly) key-insulated encryption with optimal threshold and allowing random-access keyupdatesKeywords: Key exposure key update encryption identity-based encryption∗Dept of Computer Science & Engineering University of California at San Diego 9500 Gilman Drive La JollaCalifornia 92093 USA E-Mail: mihir@csucsdedu URL: http://www-cseucsdedu/users/mihir†Dept of Computer Science & Engineering University of California at San Diego 9500 Gilman Drive La JollaCalifornia 92093 USA E-Mail: apalacio@csucsdedu URL: http://www-cseucsdedu/users/apalacioContents1 Introduction 32 Definitions 521 Key-updating encryption schemes                              622 Security definitions                                      63 The SKIE-OT scheme 74 An equivalence result 105 Acknowledgments 11References 12A Definitions for IBE 14B Security theorems and proofs for SKIE-OT 15C On the notions of security for key-updating schemes 17D Implementation and system issues 1721 IntroductionIntrusion is an important threat to many real-world computer systems that if anything is grow-ing: CERT reports that we are seeing an increase in the speed automation and sophistication ofattacks coupled with an increase in the frequency of vulnerability reports that makes it more diffi-cult for system administrators to keep up to date with patches [13] In this environment the mostimportant threat to the security of public-key encryption in practice is exposure of the decryptionkey due to compromise of the underlying systemA new framework for protection against key exposure was recently suggested by Dodis et al [16]We take its realization further towards practice by presenting simple new schemes that providebenefits over previous ones in terms of scalability performance and securityKey-updating schemes and their security parameters Splitting a decryption key intoshares stored on different devices may make key exposure harder but also entails distributing thedecryption operation (cf [19 12]) which is not always practical A key-updating encryption scheme[16] combines key splitting with key evolution ideas as used in forward-secure signatures [2 4] withthe aim of obtaining some of the security benefits of splitting while leaving decryption a stand-aloneuser operation Initialization involves providing an auxiliary helper (this could be a smartcard or aremote device) with a master helper key hsk and the user with a stage 0 user secret key usk0 Theuser’s public encryption key pk is treated like that of an ordinary encryption scheme with regardto certification but its lifetime is divided into stages i = 1 2     N  with encryption in stage iperformed as a function of pk i and the plaintext and decryption in stage i performed by the userusing a stage i user secret key uski that is obtained by the following key-update process performedat the start of stage i: first the helper sends to the user over a secure channel a stage i helper keyhski computed as a function of hsk and i; second the user computes uski as a function of uski−1and hski; and third the user discards (erases) uski−1 The security intent is that: (1) if the helper isnot compromised user secret keys for more than t different stages must be exposed to compromiseciphertexts encrypted for any other stage and (2) even if the helper is compromised the user secretkey of at least one stage must be exposed to compromise a ciphertext The terminology of [16] isthat a scheme satisfying (1) is key insulated with threshold t while a scheme satisfying both (1) and(2) is strongly key insulated with threshold t1Previous schemes and their scalability For any given value of the threshold parameter tDodis et al [16] present a strongly key-insulated encryption scheme with threshold t2 However ithas costs proportional to t Namely the public key consists of 3t elements in a group whose discretelogarithm problem must be hard while encryption in stage i requires t2 lg(i) group multiplications(plus a few exponentiations) We suggest that this dependence on t represents a lack of scalabilityand leads to costs that could be prohibitive in practice Here are some arguments to support thisviewFirst the desired security threshold t depends on the particulars of the application includingthe frequency of updates and the total number of stages These parameters may not be known inadvance to the scheme designer Furthermore they may change with time as the security demandsof the application change in which case usage of a scheme such as the above would require theapplication to certify a new public key for each such parameter change Second a realistic risk1 Both these notions can be considered under either chosen-plaintext or chosen-ciphertext attack but we consideronly the latter due to the growing consensus that this is the more appropriate in practice [8 38 34 23 37] Section 2presents formalizations of the notions of security in detail2 They have numerous schemes but only one secure against chosen-ciphertext attack It is based on [15] and isthe one to which we refer3assessment leads one to desire security with a large value of t The reason is that once the user’ssystem is compromised it is likely to stay compromised through numerous successive stages untilsuch time as the compromise is discovered the hole is patched the intruder is evicted and thesystem is rebooted As an example suppose the public key is valid for a year and updates areperformed once per hour If we want to give a system a day to recover from compromise and wewant to tolerate 10 different compromises in the year then t must be at least 10 · 24 = 240 Thesize of the public key in the above-mentioned scheme of [16] is then 3 · 240 = 720 group elementswhich is quite prohibitiveOur target We suggest that in order to have a practical realization of key-updating encryptionwe should target a scheme that is strongly key insulated with optimal threshold This meansthat regardless of the number of user stages that are compromised ciphertexts intended for anyuncompromised stage remain secure (This is the case where the helper is uncompromised meaningit replaces condition (1) discussed above Condition (2) stays the same as before) This must betrue even if the total number of user stages is not known in advance and may depend on theadversary Notice that a scheme with this property is automatically scalable There is no thresholdparameter in the picture and since the total number of stages is not fixed the key sizes and thecosts of encryption and decryption will not depend on the threshold or the total number of stagesWith such a design an application can dynamically change its update frequency and yet be ableto tolerate compromise of the maximum possible number of user stages The next question is howto design such a schemeWhy IBE alone is not enough Recall that in an identity-based encryption (IBE) scheme [36]an entity’s public key is its identity i and a trusted authority holding a master key s can issueto this entity a secret decryption key si computed as a function of s and i The security attributeis that encryption under the public key of an entity remains secure even in the face of exposure ofthe secret keys of any number of other entities Such IBE schemes have been designed in [10 14]As noted in [16] any IBE scheme can be converted into a key-insulated encryption scheme inthe following trivial way: let the master helper key be master key s of the IBE scheme and let theuser’s stage i secret key be si which is computed by the helper using s and sent to the user at thestart of stage i This key-insulated scheme has optimal threshold but as [16] go on to point outit is not strongly key insulated Indeed if the helper is compromised the master key s is revealedand then the adversary can compute the user secret key for any stage This means there is a singlepoint of failure for the system exactly what key splitting was supposed to avoid in the first placeAlthough IBE does not directly yield a strongly key-insulated scheme with optimal thresholdour results illustrate that it plays a central (and unavoidable) role in the design of such schemesThe SKIE-OT scheme In Section 3 we present a key-updating scheme called SKIE-OT that isstrongly key insulated with optimal threshold SKIE-OT is based on the secure against chosen-ciphertext attack version of the Weil-pairing-based Boneh-Franklin [10] identity-based encryptionscheme (BF-IBE) and exploits the algebraic structure of the latter Key sizes in SKIE-OT are thesame as in BF-IBE (quite short) and encryption and decryption in SKIE-OT have the same costas in BF-IBE meaning each is roughly three exponentiations plus some hashingWe validate the security of SKIE-OT via proofs which show that SKIE-OT is secure (meaningstrongly key insulated with optimal threshold) as long as the underlying BF-IBE scheme is secure(meaning a secure identity-based encryption scheme under chosen-ciphertext attack as per thedefinition of [10]) In particular since Boneh and Franklin have shown that the BF-IBE scheme issecure in the random oracle model of [5] under the bilinear Diffie-Hellman (bilinear DH) assumptionthe same assumptions suffice to guarantee security of SKIE-OT4SKIE-OT like all the schemes in [16] allows “random-access key updates” Namely for anyi ≥ 1 and j ≥ 0 the user given uskj and hski can compute uski in polynomial time (In particularit does not need hskl for l 6= i)We remark that our design is simple based on appropriately combining different known tech-niques rather than introducing any fundamentally novel technique (We suggest however thatthe problem itself is nontrivial and that our ability to provide a simple effective solution at thisstage is in large part due to the availability of the powerful tools recently introduced by Boneh andFranklin [10]) However for practical purposes it is important to note the solution and provide thesupporting security analysesAn equivalence result and its implications A second contribution of this paper is a resultthat although more on the theoretical side helps shed light on the above We have already seenthat any IBE scheme trivially yields a (not strongly) key-insulated encryption scheme with optimalthreshold But perhaps key-insulated encryption is easier than IBE It turns out that it is notTheorem 41 says that IBE is equivalent to random-access key update allowing (not strongly) key-insulated encryption with optimal threshold Not only does one exist if and only if the other existsbut more pragmatically we show that either of these objects can be easily transformed into theother This means that the role played by IBE in our constructions is crucial and not coincidentalRandom oracles The proofs supporting the BF-IBE scheme [10] and thus ultimately supportingSKIE-OT are in the random oracle model [5] The proofs supporting the scheme of [16] not beingin the random oracle model are arguably providing better security guarantees (cf [11 31]) Butproofs in the random oracle model do have significant value in practice (cf [5]) and one mustweigh what one gives up on provable guarantees against the practical benefits of the new schemeswhich are considerable Furthermore obtaining an IBE scheme with a proof of security avoidingthe random oracle model is an open problem and hence by our equivalence result noted abovethe same is true for (strongly or not strongly) key-insulated encryption with optimal thresholdTowards practice The broad question of whether key-updating encryption could be practicalcan be viewed as having two parts One is to investigate the practicality of the model and conceptindependently of the cryptographic realization The other is to find effective cryptographic real-izations Our work has addressed only the second part It would be naive to think that this alonemakes key-updating encryption practical but it is a step towards this end Given the recognizedimportance of the key-exposure problem we feel that the research community should endeavor toassess the potential of new ideas to address itAs to whether the concept as a whole is practical it seems too early to tell Many of theimportant system level questions related to the model have yet to be seriously addressed As afinal contribution of this paper we point to some of the important issues in Appendix DSubsequent work Dan Boneh pointed out that it is possible to construct a strongly key-insulatedencryption scheme with optimal threshold starting from Cocks’s IBE scheme [14] but noted thatthis scheme would be less efficient than SKIE-OT since Cock’s IBE scheme is less efficient than theBF-IBE scheme2 DefinitionsWe detail the components of a key-updating encryption scheme and then provide definitions forsecurity in the complexity-theoretic or “provable-security” frameworkWe let N = {1 2   } be the set of positive integers and if N ∈ N then we let [N ] = {1     N}The notation x R← S denotes that x is selected randomly from set S If A is a possibly randomized5algorithm then the notation x R← A(a1 a2   ) denotes that x is assigned the outcome of theexperiment of running A on inputs a1 a2   21 Key-updating encryption schemesThis follows [16] which in turn extended [4] A key-updating encryption scheme KUS = (KGHKUUKUEncDec) is specified by five polynomial-time algorithms whose functionality is as follows:• The randomized key-generation algorithm KG takes input security parameter k and returns(pkusk0hsk) where pk is the user public key usk0 is the stage 0 user secret key and hsk isthe master helper key The user is initialized with pkusk0 while the helper is initialized withpkhsk• At the start of stage i ≥ 1 the helper applies the helper key-update algorithm HKU to ipkhskto obtain a stage i helper key hski which is then assumed to be conveyed to the user via asecure channel• At the start of stage i ≥ 1 the user receives hski from the helper and then applies the userkey-update algorithm UKU to i pkhskiuski−1 to obtain the stage i user secret key uski Theuser then discards (erases) uski−1• Anyone can apply the randomized encryption algorithm Enc to a stage number i the user publickey pk and message M ∈ {0 1}∗ to obtain a ciphertext C intended for the user to decrypt instage i• In stage i the user can apply the decryption algorithm Dec to ipk its stage i secret key uskiand a ciphertext C to obtain either a message M or the special symbol ⊥ indicating failureWe require that if C was produced by applying the encryption algorithm to ipkM thenDec(ipkuski C) = M 22 Security definitionsReaders not familiar with the provable-security approach might skip the current subsection andproceed directly to Section 3 The definitions here will be required only in conjunction with thesecurity proofs of Appendix BWe formalize the notion of a key-updating scheme being (strongly) key insulated with optimalthreshold This is based on the ideas of [16] but we introduce some simplifications For readersfamiliar with [16] Appendix C shows that the simplifications do not weaken the security require-mentsSecurity considers two types of attacks namely attacks on the user and attacks on the helperIn both cases we consider chosen-ciphertext attacks not just chosen-plaintext attacksAttacks on the user The formalization of security for the user requires a strong form of privacynamely indistinguishability as per [22 33] in the face of key-exposure and chosen-ciphertext attacksTo define it we consider the following experiment related to key-updating encryption scheme KUS =(KGHKUUKUEncDec) adversary A and security parameter k The key-generation algorithmKG is run on input k to produce (pkusk0hsk) Adversary A gets input pk and returns an integerN ∈ N specified in unary A challenge bit b is chosen at random and the execution of A is continuedwith A now being provided the following oracles:• A decryption oracle Dec(i pkuski ·) for each user stage i = 1     N  This models a chosen-ciphertext attack6• A key-exposure oracle Exp(·pkusk0hsk) which the adversary can query with any value i ∈ [N ]of its choice to get back the stage i user secret key uski and the stage i helper key hski Thismodels the ability of the adversary to compromise any user stage of its choice (We make theconservative assumption that when an adversary has compromised the user in stage i it notonly obtains uski but has compromised the channel between user and helper and thus also getshski)• A left-or-right oracle Enc(·pkLR(· · b)) [3] which given j ∈ [N ] and equal length messagesM0M1 returns a challenge ciphertext CR← Enc(j pkMb)The adversary may query these oracles adaptively in any order it wants subject only to therestriction that it make exactly one query to the left-or-right oracle Let j denote the stage numberof this query and let C denote the ciphertext returned by the left-or-right oracle in response tothis query Eventually A outputs a guess bit d and halts It is said to win if d = b ciphertextC was not queried to Dec(j pkuskj  ·) after it was returned by the left-or-right oracle and j wasnot queried to the key-exposure oracle The adversary’s advantage is the probability that it winsminus 1/2 and the key-updating scheme KUS is said to be key insulated with optimal threshold ifthe advantage of any polynomial-time adversary is negligibleWe stress that the number of stages N is a random variable depending on the adversaryand that there is no upper bound on the number of user stages that the adversary is allowedto corrupt This is in contrast to [16] where the total number of stages N  and the maximumnumber t of corrupted stages are parameters of the scheme fixed in advance One implication ofour strengthened requirement is scalability (This is directly implied by our definition and does nothave to be a separate requirement)Attacks on the helper Adversary A given pk is assumed to have compromised the helperand thus be in possession of the master helper key hsk The security requirement is that as longas none of the user stages is compromised ciphertexts intended for any user stage remain secureThe formalization follows the one aboveWe consider the following experiment related to key-updating encryption scheme KUS = (KGHKUUKUEncDec) adversary A and security parameter k The key-generation algorithm KG isrun on input k to produce (pkusk0hsk) Adversary A gets input pkhsk and returns an integerN ∈ N specified in unary A challenge bit b is chosen at random and the execution of A is continuedwith A now being provided the decryption oracles and a left-or-right oracle as above (But it isnot provided a key-exposure oracle) The adversary may query these oracles adaptively in anyorder it wants subject only to the restriction that it make exactly one query to the left-or-rightoracle Let j denote the stage number of this query and let C denote the ciphertext returned bythe left-or-right oracle in response to this query Eventually A outputs a guess bit d and halts Itis said to win if d = b and ciphertext C was not queried to Dec(j pkuskj  ·) after it was returnedby the left-or-right oracle The adversary’s advantage is the probability that it wins minus 1/2 andthe key-updating scheme KUS is said to be secure against attacks on the helper if the advantageof any polynomial-time adversary is negligible The scheme is strongly key insulated with optimalthreshold if it is key insulated with optimal threshold and also secure against attacks on the helper3 The SKIE-OT schemeOur strongly key-insulated scheme with optimal threshold is based on the Boneh-Franklin (BF)identity-based encryption (IBE) scheme and exploits some algebraic properties of the latter Inorder to avoid taking the reader through the full BF-IBE scheme we begin by presenting a simplified7abstraction of it in which we detail only a few items that are necessary for our transformation andtreat the rest as “black boxes” We then show how to build on this to construct SKIE-OT Thissection concludes with an informal security analysis showing that SKIE-OT is strongly key insulatedwith optimal threshold assuming the BF scheme is a secure IBE scheme under chosen-ciphertextattack as per [10] Corresponding security theorems and proofs are provided in Appendix BWhat BF supplies For our purposes we can view the BF-IBE scheme as providing us with atriple of algorithms IBES = (IBKG IBEnc IBDec) where• The key-generation algorithm IBKG takes input security parameter k and returns a pair (pk s)consisting of a parameter list pk = (qGH   ) and a master key s ∈ Z∗q  where q is a primenumber G is (the description of) an additive (cyclic) group of order q and H: N → G∗ is ahash function whose range is the nonzero elements of the group The “  ” indicates that theparameter list pk contains a few other parameters but for our purpose it does not matter whatthey are so we do not detail them3• The randomized encryption algorithm IBEnc takes input an identity i which could be an arbi-trary integer the parameter list pk and a message M ∈ {0 1}∗ and returns a ciphertext c4• A user holding the secret key ibski = s·H(i) ∈ G (this denotes the group element H(i) added toitself s times via the group operation) can apply the decryption algorithm IBDec to its identityi the parameter list pk the secret key ibski and ciphertext c to recover the message M Discussion of the BF-IBE scheme The identity i functions as the public key of the entityhaving this identity In the BF-IBE scheme the secret key ibski = s · H(i) is computed by atrusted party who holds the master key s and then given by this party to entity i The details ofhow encryption and decryption are performed in the IBE scheme are not important for us Whatwe will exploit is the fact that the secret key ibski is computed as a linear function of the masterkey s and that the scheme meets the notion of privacy against chosen-ciphertext attack defined in[10] Under this notion an adversary gets to compromise some number of entities of its choice andobtain their secret keys and yet it remains computationally infeasible to obtain the secret key ofany uncompromised entity or even to obtain partial information about messages encrypted underthat key all this being under a chosen-ciphertext attack It is shown in [10] that this security isachieved in the random oracle model under the bilinear DH assumptionOur SKIE-OT scheme The component algorithms of our key-updating scheme KUS = (KGHKUUKUEncDec) are depicted in Figure 1 Here we briefly explain the ideasWe recall that a key-updating encryption scheme that is key insulated with optimal thresholdbut not strongly key insulated can be trivially obtained from any IBE scheme as indicated in [16]The public key of a user is a parameter list pk = (qGH   ) for the IBE scheme The masterhelper key is the master key s of the IBE scheme View the stage number i as an identity for theIBE scheme The user secret key in stage i is ibski = s · H(i) the secret key corresponding toentity i in the IBE scheme Encryption is then performed as a function of ipk as per the IBEscheme except that we additionally include the value of i in the ciphertext Decryption in stage iuses s ·H(i) as the secret key to run the decryption algorithm of the IBE schemeThe weakness of the above scheme is that if the helper is compromised then the attacker obtainss and the security of all user stages is compromised We address this as follows In our scheme s3 For a reader familiar with [10] we remark that the quantities include a prime number p such that p = 6q − 1 agenerator of G and some more hash functions G is the group of points on an elliptic curve over a field of order p4 The basic version of the BF-IBE scheme only allows encryption of plaintext messages of a specific length whichis a parameter of the scheme but via standard hybrid encryption techniques we may extend the message space sothat strings of any length may be encrypted For simplicity we assume this is done here8Algorithm KG(k)(pk s) R← IBKG(k)Parse pk as (qGH   )uskR← Zq ; hsk ← (s− usk) mod qibsk0 ← s ·H(0) in G ; usk0 ← (usk ibsk0)Return (pkusk0hsk)Algorithm UKU(ipkhskiuski−1)Parse pk as (qGH   )Parse uski−1 as (usk ibski−1)ibski ← usk ·H(i) + hski in Guski ← (usk ibski)Return uskiAlgorithm HKU(i pkhsk)Parse pk as (qGH   )hski ← hsk ·H(i) in GReturn hskiAlgorithm Enc(ipkM)cR← IBEnc(ipkM)C ← (i c)Return CAlgorithm Dec(ipkuski C)Parse C as (j c)If j 6= i then return ⊥Parse uski as (usk ibski)M ← IBDec(ipk ibski c)Return MFigure 1: The component algorithms of our SKIE-OT scheme KUS = (KGHKUUKUEncDec)based on the algorithms IBES = (IBKG IBEnc IBDec) describing the Boneh-Franklin IBE schemeis not held by the helper but rather split into shares via a one-out-of-two secret-sharing schemewith one share held by the user and the other by the helper That is s ≡ usk+hsk (mod q) wherethe stage i user secret key is uski = (usk ibski) with ibski = (usk + hsk) · H(i) and the masterhelper key is hsk Update of the user secret key must be performed without reconstructing s sinceotherwise an adversary compromising the user at update time could obtain s and thus compromiseall stages We perform update without reconstruction of s by exploiting the fact that for any i themap x 7→ x ·H(i) is a homomorphism from the additive group Zq to the additive group G At thestart of stage i the helper uses hsk to compute hski = hsk · H(i) and sends it to the user Thelatter holding uski−1 = (usk ibski−1) sets ibski = usk ·H(i) + hski in G By the homomorphicproperty we haveusk ·H(i) + hski = usk ·H(i) + hsk ·H(i) = (usk + hsk) ·H(i) = ibski The user sets its updated secret key to uski = (usk ibski) and erases uski−1Key sizes and costs The public key in SKIE-OT (which is the parameter list of the BF-IBEscheme) consists of two k-bit primes p q where k is the security parameter and p = 6q − 1 andtwo elements of G where the latter is an elliptic curve group In addition the scheme has severalassociated public hash functions The sizes of the master helper key the user secret key for anystage and the helper key for any stage are all O(k) Encryption in stage i involves performingencryption as per the BF-IBE scheme which requires two exponentiations four hash functionapplications and one Weil-paring computation [10] Decryption requires one exponentiation threehash function applications and one Weil-paring computation As observed in [10] the Weil paringcan be computed efficiently using an algorithm due to Miller [30] whose running time is comparableto exponentiation in a prime-order fieldSecurity of SKIE-OT Here we present a a very rough analysis which provides an intuitivesecurity validation of our scheme In order to highlight the main ideas we ignore the chosen-ciphertext attack capability of the adversary and also focus on key recovery rather than indistin-guishability These informal arguments are supported by the security theorems and proofs pro-vided in Appendix B which validate SKIE-OT with respect to the full and demanding definitions9of Section 2As per Section 2 we must consider two types of attacks namely attacks on the user and attackson the helperFirst consider an attack on the user Since we wish security to hold for the optimal thresholdthe adversary is allowed to compromise all but one stage meaning it obtains uskj = (usk ibskj)and hskj = hsk · H(j) for all j 6= i for some value i of the adversary’s choice We let s denotethe value (usk + hsk) mod q The assumed security of the BF-IBE scheme tells us that possessionof {ibskj : j 6= i} does not compromise ibski as long as the adversary obtains no additionalinformation regarding the master key s The concern introduced by our modifications is that theadditional information available to the adversary over and above {ibskj : j 6= i} namely usk and{hskj : j 6= i} can provide useful information about s We argue that it cannot in two stepsFirst usk is distributed uniformly and independently of s and hence by itself is not helpful to theadversary Second hskj is not additional information to an adversary already possessing usk andibskj  because hskj = ibskj − usk ·H(j) in GNow consider an attack on the helper The adversary obtains hsk This however is distributedindependently of s = (usk + hsk) mod q and thus an adversary attempting to compromise theprivacy of encryption in some stage i of the user is reduced to attempting to compromise theassumed secure IBE scheme4 An equivalence resultLet KUS = (KGHKUUKUEncDec) be a key-updating scheme Having obtained pkusk0hsk byrunning KG on input k we know that the user secret keys for stages l = 1     j can be computedbased on the associated stage helper keys as follows:For l = 1     j do: hskl ← HKU(lpkhsk) ; uskl ← UKU(lpkhskluskl−1) We say that key-updating scheme KUS allows random-access key updates if there is a polynomial-time random-access user-key-update algorithm RUKU which takes input i j pkhskiuskj and out-puts uski for any i ≥ 1 and j ≥ 05 This is useful for error recovery Also it allows the user tomaintain its decryption capability for ciphertexts from the past despite having to erase the secretkey for one stage at the start of the next It is easy to see that SKIE-OT allows random-access keyupdates as do all the schemes in [16]Our result is that a (not strongly) key-insulated encryption scheme with optimal threshold thatallows random-access key updates is essentially the same thing as an identity-based encryptionscheme in that either of these objects can be easily turned into the other The following statesit more formally The definition of a secure identity-based encryption scheme used below is from[10] and is recalled in Appendix A The theorem is true both for chosen-plaintext attacks andchosen-ciphertext attacks although our formalization only refers to the latterTheorem 41 There exists a secure identity-based encryption scheme if and only if there exists akey-insulated encryption scheme with optimal threshold that allows random-access key updatesProof of Theorem 41: The proof is constructive showing how either object is easily transformedinto the other5 This a somewhat stronger requirement than the one made in [16] who replace hski as input to RUKU with avalue hskij computed by the helper based on another algorithm that takes inputs i jpkhsk We have preferred tosimplify the definition to require just one algorithm but the change makes no difference to any results All knownschemes both ours and theirs meet both definitions and Theorem 41 is true for both definitions10Algorithm IBKG(k)(pkusk0hsk)R← KG(k)s← (usk0hsk)Return (pk s)Algorithm IBKI(pk s i)Parse s as (usk0hsk)hski ← HKU(i pkhsk)ibski ← RUKU(i 0pkhskiusk0)Return ibskiAlgorithm IBEnc(ipkM)c← Enc(ipkM)Return cAlgorithm IBDec(ipk ibski c)M ← Dec(ipk ibski c)Return MFigure 2: The component algorithms of IBE scheme IBES = (IBKG IBKI IBEnc IBDec) constructedfrom the given key-insulated encryption scheme KUS = (KGHKUUKUEncDec) and its random-access user key-update algorithm RUKUFirst assume IBES = (IBKG IBKI IBEnc IBDec) is an IBE scheme specified according to the formatof Appendix A and meeting the notion of security specified there We construct from it the trivialkey-updating scheme that we have discussed often before It is easy to see that this is a key-insulatedscheme with optimal threshold that allows random-access key updates The novel direction is theconverseFor the converse assume KUS = (KGHKUUKUEncDec) is a key-insulated encryption schemewith optimal threshold that allows random-access key updates and let RUKU denote the random-access user key-update algorithm We now design an IBE scheme IBES = (IBKG IBKI IBEnc IBDec)The constituent algorithms are depicted in Figure 2 The idea is that the master secret key of thetrusted party in the IBE scheme contains both the stage 0 user secret key usk0 and the helper mas-ter key hsk The entity with identity i is identified with stage i of the user The trusted authoritywants to issue uski to user i as its secret decryption key In the absence of extra properties thetrusted authority could compute uski by starting from usk0hsk and computing usk1    uski inturn via the user key update and helper key update algorithms This however takes time polyno-mial in i which is not polynomial time (The trusted authority of the IBE scheme must issue ibskito i in time polynomial in lg(i) and k where k is the security parameter) This problem is solvedvia the assumption that the key-updating scheme allows random-access key updates The trustedauthority can issue a decryption key to i by using the random-access key-update algorithms to di-rectly compute ibski = uski given usk0hsk as shown in Figure 2 The encryption and decryptionalgorithms are unchangedFinally we have to argue that our constructed IBE scheme is secure under the assumption that thekey-updating scheme is key insulated with optimal threshold This is easy however and detailsare left to the final paper5 AcknowledgmentsWe thank Dan Boneh for his communication regarding a strongly key-insulated encryption schemewith optimal threshold based on Cock’s IBE schemeAn earlier version of this paper included a description of a general transform which took a(not strongly) key-insulated encryption scheme with optimal threshold and a standard encryptionscheme and combined them to obtain a strongly key-insulated encryption scheme with optimal11threshold We had claimed that if the base schemes were both secure against chosen-ciphertextattack then so was the resulting scheme Yevgeniy Dodis pointed out that this claim is false Infact the scheme resulting from our transform only resisted chosen-plaintext attack Rather thanpreserve this weakened result we have deleted the transform entirely We thank Dodis for thiscommunicationReferences[1] M Abdalla and L Reyzin A new forward-secure digital signature scheme Advances in Cryptology– ASIACRYPT ’00 Lecture Notes in Computer Science Vol 1976 T Okamoto ed Springer-Verlag2000[2] R Anderson Two Remarks on Public-Key Cryptology Manuscript 2000 and Invited Lecture atthe Fourth Annual Conference on Computer and Communications Security Zurich Switzerland April1997[3] M Bellare A Desai E Jokipii and P Rogaway A concrete security treatment of symmet-ric encryption: Analysis of the DES modes of operation Proceedings of the 38th Symposium onFoundations of Computer Science IEEE 1997[4] M Bellare and S Miner A forward-secure digital signature scheme Advances in Cryptology –CRYPTO ’99 Lecture Notes in Computer Science Vol 1666 M Wiener ed Springer-Verlag 1999[5] M Bellare and P Rogaway Random oracles are practical: A paradigm for designing efficientprotocols Proceedings of the 1st Annual Conference on Computer and Communications Security ACM 1993[6] M Bellare and P Rogaway Optimal asymmetric encryption: How to encrypt with RSA Ad-vances in Cryptology – EUROCRYPT ’94 Lecture Notes in Computer Science Vol 950 A De Santised Springer-Verlag 1994[7] G Blakley Safeguarding cryptographic keys Proceedings of AFIPS 1979 National Computer Con-ference AFIPS 1979[8] D Bleichenbacher A chosen ciphertext attack against protocols based on the RSA encryptionstandard PKCS #1 Advances in Cryptology – CRYPTO ’98 Lecture Notes in Computer ScienceVol 1462 H Krawczyk ed Springer-Verlag 1998[9] D Boneh Simplified OAEP for the RSA and Rabin functions Advances in Cryptology – CRYPTO’01 Lecture Notes in Computer Science Vol 2139 J Kilian ed Springer-Verlag 2001[10] D Boneh and M Franklin Identity-based encryption from the Weil pairing Advances in Cryp-tology – CRYPTO ’01 Lecture Notes in Computer Science Vol 2139 J Kilian ed Springer-Verlag2001[11] R Canetti O Goldreich and S Halevi The random oracle methodology revisited Proceedingsof the 30th Annual Symposium on the Theory of Computing ACM 1998[12] R Canetti and S Goldwasser An efficient threshold public-key cryptosystem secure againstadaptive chosen-ciphertext attack Advances in Cryptology – EUROCRYPT ’99 Lecture Notes inComputer Science Vol 1592 J Stern ed Springer-Verlag 1999[13] CERT Coordination Center Overview of attack trends April 8 2002 http://wwwcertorg/[14] C Cocks An identity based encryption based on quadratic residues Cryptography and CodingLecture Notes in Computer Science Vol 2260 Springer-Verlag 2002[15] R Cramer and V Shoup A practical public key cryptosystem provably secure against adaptivechosen ciphertext attack Advances in Cryptology – CRYPTO ’98 Lecture Notes in Computer ScienceVol 1462 H Krawczyk ed Springer-Verlag 199812[16] Y Dodis J Katz S Xu and M Yung Key-Insulated Public Key Cryptosystems Advances inCryptology – EUROCRYPT ’02 Lecture Notes in Computer Science Vol 2332  L Knudsen edSpringer-Verlag 2002[17] A Fiat and A Shamir How to prove yourself: Practical solutions to identification and signatureproblems Advances in Cryptology – CRYPTO ’86 Lecture Notes in Computer Science Vol 263A Odlyzko ed Springer-Verlag 1986[18] E Fujisaki T Okamoto D Pointcheval and J Stern RSA-OAEP is Secure under the RSAAssumption Advances in Cryptology – CRYPTO ’01 Lecture Notes in Computer Science Vol 2139J Kilian ed Springer-Verlag 2001[19] R Gennaro and V Shoup Securing threshold cryptosystems against chosen-ciphertext attackAdvances in Cryptology – EUROCRYPT ’98 Lecture Notes in Computer Science Vol 1403 K Nyberged Springer-Verlag 1998[20] M Girault An identity-based identification scheme based on discrete logarithms modulo a compositenumber Advances in Cryptology – EUROCRYPT ’90 Lecture Notes in Computer Science Vol 473I Damg˚ard ed Springer-Verlag 1990[21] M Girault Relaxing tamper-resistance requirements for smart cards using (auto)-proxy signaturesCARDIS 98[22] S Goldwasser and S Micali Probabilistic Encryption Journal of Computer and System ScienceVol 28 1984 pp 270–299[23] IEEE IEEE P1363: Standard Specifications For Public Key Cryptography http://grouperieeeorg/groups/1363/P1363/[24] G Itkis and L Reyzin Forward-secure signatures with optimal signing and verifying Advancesin Cryptology – CRYPTO ’01 Lecture Notes in Computer Science Vol 2139 J Kilian ed Springer-Verlag 2001[25] G Itkis and L Reyzin Intrusion-resilient signatures or towards obsoletion of certificate revocationAdvances in Cryptology – CRYPTO ’02 Lecture Notes in Computer Science Vol ??  M Yung edSpringer-Verlag 2002 Available as Cryptology eprint archive Report 2002/054 April 2002 http://eprintiacrorg/2002/054/[26] J Katz A forward-secure public-key encryption scheme Cryptology eprint archive Report 2002/060May 2002 http://eprintiacrorg/2002/060/[27] H Krawczyk Simple forward-secure signatures from any signature scheme Proceedings of the 7thAnnual Conference on Computer and Communications Security  ACM 2000[28] T Malkin D Micciancio and S Miner Efficient generic forward-secure signatures with anunbounded number of time periods Advances in Cryptology – EUROCRYPT ’02 Lecture Notes inComputer Science Vol 2332  L Knudsen ed Springer-Verlag 2002[29] U Maurer and Y Yacobi Non-interactive public-key cryptography Advances in Cryptology –EUROCRYPT ’91 Lecture Notes in Computer Science Vol 547 D Davies ed Springer-Verlag 1991[30] V Miller Short programs for functions on curves Unpublished manuscript 1986[31] J B Nielsen Separating random oracle proofs from complexity theoretic proofs: The non-committing encryption case Advances in Cryptology – CRYPTO ’02 Lecture Notes in ComputerScience Vol ??  M Yung ed Springer-Verlag 2002[32] H Ong and C Schnorr Fast signature generation with a Fiat Shamir–like scheme Advancesin Cryptology – EUROCRYPT ’90 Lecture Notes in Computer Science Vol 473 I Damg˚ard edSpringer-Verlag 1990[33] C Rackoff and D Simon Non-interactive zero-knowledge proof of knowledge and chosen cipher-text attack Advances in Cryptology – CRYPTO ’91 Lecture Notes in Computer Science Vol 576J Feigenbaum ed Springer-Verlag 199113[34] RSA Laboratories PKCS #1 – RSA Cryptography Standard http://wwwrsasecuritycom/rsalabs/pkcs/pkcs-1/indexhtml[35] A Shamir How to share a secret Communications of the ACM Vol 22 1979 pp 612–613[36] A Shamir Identity-based cryptosystems and signature schemes Advances in Cryptology – CRYPTO’84 Lecture Notes in Computer Science Vol 196 R Blakely ed Springer-Verlag 1984[37] V Shoup A Proposal for an ISO Standard for Public Key Encryption Cryptology eprint archiveReport 2001/112 Dec 2001 http://eprintiacrorg/2001/112/[38] V Shoup Why chosen ciphertext security matters IBM Research Report RZ 3076 November 1998http://wwwshoupnet[39] S Tsuji and T Itoh An ID-based cryptosystem based on the discrete logarithm problem IEEEJournal on Selected Areas in Communication Vol 7 No 4 1989 pp 467-473[40] H Tanaka A realization scheme for the identity-based cryptosystem Advances in Cryptology –CRYPTO ’87 Lecture Notes in Computer Science Vol 293 C Pomerance ed Springer-Verlag 1987A Definitions for IBEIBE schemes This follows [35 10] In general an IBE scheme IBES = (IBKG IBKI IBEnc IBDec)is specified by four polynomial-time algorithms whose functionality is as follows:• The key-generation algorithm IBKG takes input security parameter k and returns a pair (pk s)consisting of a parameter list pk and a master key s• Given a user-identity i ∈ N the trusted center can apply the (deterministic) decryption-keyissuance algorithm IBKI to pk s i to obtain a decryption key ibski that along with pk is thensent to user i over a secure channel• The randomized encryption algorithm IBEnc takes input an identity i ∈ N the parameter listpk and a message M ∈ {0 1}∗ and returns a ciphertext c• A user holding the secret key ibski can apply the (deterministic) decryption algorithm IBDecto its identity i the parameter list pk the secret key ibski and ciphertext c to recover themessage M Security of an IBE scheme The formalization of security against chosen-ciphertext attackfollows [10] We consider the following experiment related to IBE scheme IBES = (IBKG IBKIIBEnc IBDec) adversary A and security parameter k The key-generation algorithm IBKG is runon input k to produce (pk s) Adversary A gets input pk and returns an integer N ∈ N specifiedin unary A challenge bit b is chosen at random and the execution of A is continued with A nowbeing provided the following oracles:• Decryption oracles IBDec(ipk ibski ·) for all i = 1     N• A key-exposure oracle Exp(·pk s) that when queried with i ∈ [N ] returns the decryption keyibski = IBKI(pk s i) of user i This models the ability of the adversary to compromise anyuser of its choice• A left-or-right oracle IBEnc(·pkLR(· · b)) which given j ∈ [N ] and equal length messagesM0M1 returns a challenge ciphertext cR← IBEnc(jpkMb)The adversary may query these oracles adaptively in any order it wants subject only to therestriction that it make exactly one query to the left-or-right oracle Let j denote the user identityof this query and let c denote the ciphertext returned by the left-or-right oracle in response to this14query Eventually A outputs a guess bit d and halts It is said to win if d = b ciphertext c wasnot queried to IBDec(jpk ibskj  ·) after it was returned by the left-or-right oracle and j was notqueried to the key-exposure oracle The adversary’s advantage is the probability that it wins minus1/2 The IBE scheme IBES is said to be secure against chosen-ciphertext attack if the advantageof any polynomial-time adversary is negligibleB Security theorems and proofs for SKIE-OTWe adopt the convention that the time complexity of an adversary A is the execution time of theexperiment used to define the advantage of A including the time taken for key generation andinitializations and the time taken by the oracles to compute replies to the adversary’s queriesThis convention simplifies concrete security considerationsThe following two theorems show that the advantage of any adversary against the SKIE-OTscheme performing an attack on the user in the first case and an attack on the helper in thesecond can be upper bounded by the advantage of a related adversary against the BF-IBE schemeTheorem B1 Let A be an adversary of time complexity T against SKIE-OT attacking the userAssume that the adversary compromises t user stages Then there exists an adversary B performinga chosen-ciphertext attack against the underlying BF-IBE scheme with at least the same advantageFurthermore the time complexity of B is T and the number of entities compromised by B duringits attack is tProof: Let KUS = (KGHKUUKUEncDec) be the SKIE-OT scheme and IBES = (IBKG IBEncIBDec) be the BF-IBE scheme We construct an adversary B that uses A to perform a chosen-ciphertext attack against IBES Fix k ∈ N The experiment that defines the advantage of B beginsby running IBKG(k) to produce (pk s) On input pk = (qGH   ) adversary B randomly selectsan element usk ∈ Zq It then runs A on input pk until A outputs N ∈ N which B also returnsB is given access to decryption oracles IBDec(i pk ibski ·) for i = 1     N  a key-exposure oracleExp(·pk s) and a left-or-right oracle IBEnc(·pkLR(· · b)) where the challenge bit b was chosenat random The adversary’s goal is to guess bWhen the execution of B proceeds it continues to run A and uses its oracles to respond to A’squeries In response to a query (j c) to the decryption oracle Dec(ipkuski ·) where j 6= i Breturns ⊥ In response to a query (j c) to the decryption oracle Dec(jpkuskj  ·) B forwardsthe query to its decryption oracle IBDec(j pk ibskj  ·) and returns the answer M to A By thedefinition of algorithm Dec in both cases the answer is exactly what A’s decryption oracle wouldhave returned In response to a query i to the key-exposure oracle Exp(·pkusk0hsk) B makesthe query i to its key-exposure oracle Exp(·pk s) obtaining the decryption key ibski = s ·H(i)B then sets uski ← (usk ibski) and hski ← ibski − usk · H(i) in G and returns uski as thestage i user secret key and hski as the stage i helper key to A Since usk was chosen at randomhski = (s− usk) ·H(i) and ibski = usk ·H(i)+ hski A’s view is identical to its view in the attackagainst KUS In response to A’s query jM0M1 to the left-or-right oracle Enc(·pkLR(· · b))B forwards the query to its left-or-right oracle IBEnc(·pkLR(· · b)) obtaining a ciphertext c Itthen sets C ← (j c) and returns this to A By the definition of algorithm Enc the answer is exactlywhat A’s left-or-right oracle would have returned When A outputs its guess bit d and halts Breturns d and haltsSince B simulates A’s environment in its attack against KUS perfectly A behaves as it does thereand B wins as long as A does By our conventions for measuring time complexity the time15complexity of B is T  Furthermore B makes the same number of queries to its key-exposureoracle compromising that number of entities as user stages A compromises by querying its key-exposure oracle The conclusion followsTheorem B2 Let A be an adversary of time complexity T against SKIE-OT attacking the helperThen there exists an adversary B performing a chosen-ciphertext attack against the underlying BF-IBE scheme with at least the same advantage Furthermore the time complexity of B is T and thisadversary does not compromise any entities during its attackProof: Let KUS = (KGHKUUKUEncDec) be the SKIE-OT scheme and IBES = (IBKG IBEncIBDec) be the BF-IBE scheme We show how to construct an adversary B that runs A as asubroutine and performs a chosen-ciphertext attack against IBES Fix k ∈ N The experiment thatdefines the advantage of B begins by running IBKG(k) to produce (pk s) Adversary B is giveninput pk = (qGH   ) In order to simulate A’s environment in its attack against KUS B mustprovide A with a master helper key corresponding to the public key pk To do so it selects anelement hsk ∈ Zq at random It runs A on input pkhsk until A outputs N ∈ N which B alsoreturns B is then given access to decryption oracles IBDec(ipk ibski ·) for i = 1     N  a key-exposure oracle Exp(·pk s) and a left-or-right oracle IBEnc(·pkLR(· · b)) where the challengebit b was chosen at random The adversary’s goal is to guess bWhen the execution of B proceeds it continues to run A and uses its oracles to respond to A’squeries In response to a query (j c) to the decryption oracle Dec(ipkuski ·) where j 6= i Breturns ⊥ In response to a query (j c) to the decryption oracle Dec(jpkuskj  ·) B forwardsthe query to its decryption oracle IBDec(j pk ibskj  ·) and returns the answer M to A By thedefinition of algorithm Dec in both cases the answer is exactly what A’s decryption oracle wouldhave returned In response to A’s query jM0M1 to the left-or-right oracle Enc(·pkLR(· · b))B forwards the query to its left-or-right oracle IBEnc(·pkLR(· · b)) obtaining a ciphertext c Itthen sets C ← (j c) and returns this to A By the definition of algorithm Enc the answer is exactlywhat A’s left-or-right oracle would have returned When A outputs its guess bit d and halts Breturns d and haltsIt is easy to see that by the way hsk is chosen and the way B responds to A’s oracle queries A’sview is identical to its view in the attack against KUS Since the simulation is perfect A behaves asit does there and B wins as long as A does Our conventions for measuring time complexity implythat the time complexity of B is T  Furthermore B does not make any queries to its key-exposureoracle ie it does not compromise any entities during its attack The conclusion followsFrom these theorems we can obtain the following security result for our SKIE-OT schemeCorollary B3 If the BF-IBE scheme is secure against chosen-ciphertext attack then the key-updating scheme SKIE-OT is strongly key insulated with optimal thresholdProof: Let A be an adversary of polynomial time complexity against SKIE-OT attacking theuser Assume that A compromises all but one stage Then the adversary given by Theorem B1also has polynomial time complexity The assumption that the BF-IBE scheme is secure againstchosen-ciphertext attack implies that its advantage is negligible Hence the advantage of A isnegligible This shows that any polynomial-time adversary attacking the user who compromisesall stages but one has a negligible advantage which implies that SKIE-OT is key insulated withoptimal threshold Similarly Theorem B2 implies that SKIE-OT is secure against attacks on thehelper The conclusion follows immediately16C On the notions of security for key-updating schemesTypes of attacks on the user In our formulation of attacks on the user presented in Section 2an adversary compromising stage i obtains not only the stage i user secret key uski but also thestage i helper key hski We consider this to be appropriate because in practice if user stage i iscompromised then not only is uski exposed but one should assume the channel from helper to useris compromised for the duration of that stage as well and thus any communication over it includinghski should be assumed to be available to the adversary This issue is recognized but handled alittle differently in [16] who separate what we call attacks on the user into “key-exposure attacks”in which an adversary compromising stage i obtains uski and “key-update attacks” in which thesame adversary obtains hski We have lumped the two together both for simplicity and becauseof our contention that consideration of security against key exposure without security against keyupdate is impracticalNote it is assumed that as part of the process of discovering and ejecting intruders that leadsus to consider the possibility of secure stages at some point after compromise the secure channelover which the helper key for each stage is communicated is re-established as wellDodis et al [16] formalize security against key-update attacks by requiring that the informationsent by the helper to the user in stage i be simulatable from the point of view of an adversary thathas compromised stage i Instead we have simply packaged it into the same framework as key-exposure attacks asking that an adversary obtaining the information in question still be unableto compromise encryption in un-compromised stages The requirement of [16] is stronger but it ishard to see why one should require it rather than just require the appropriate and natural end-goalof user security as we have done In any cases all known schemes both ours and theirs meet theirstronger requirement For these reasons coupled with a desire for simplicity we did not requiresimulatability in the face of key-update attacks as part of our definitionOne challenge bit versus many The formalization of security against attacks on the usergiven in [16] provides the adversary with a left-or-right oracle [3]Enc(·pkLR(· ·b)) where b = (b[1]    b[N ]) ∈ {0 1}Nand N is the total number of stages A query has the form jM0M1 where j ∈ [N ] and M0are equal-length messages and in response the oracle returns C R← Enc(j pkMb[j]) On the otherhand our formalization provides the adversary with a left-or-right oracle Enc(·pkLR(· · b)) whereb ∈ {0 1} In response to query jM0M1 as above it returns C R← Enc(j pkMb) but only a singlequery is allowed to the oracle While our formulation is simpler one might think the resultingsecurity requirement is weaker In fact the two notions of security are equivalent in the sense thata key-updating scheme is secure against attacks on the user under the definition of [16] if and onlyif it is secure against attacks on the user under our definition This can be proved via a standardhybrid argument For completeness details will be provided in the final paperD Implementation and system issuesThere are numerous issues that would need to be considered with regard to implementing a key-updating system These issues are in some sense orthogonal to our paper since they are about themodel and concept of [16] We do not have answers to these questions but we feel it is importantfor the future to at least raise themObvious issues are the practicality of a two-device setup and the practicality of dividing thelifetime of a key into stages which implies that the person encrypting will have to be aware of the17current stage numberAn issue that we believe is tricky is the security of the channel from the helper to the user Thekeys sent by the helper to the user cannot be sent in the clear The very definition of key-updatingencryption implies that this is insecure because then if the adversary has corrupted just one userstage and not the helper it can use the helper stage keys to compute user secret keys for allsubsequent stages by applying the key-update algorithms Dodis et al [16] are well aware of thisas reflected in their formal security model on which ours is based The model does not give theadversary the helper keys for uncompromised stages which indicates they are assumed to be sentover a secure channel The question that we feel needs to be pursued is how this assumption can beimplemented There might be settings where a secure channel from helper to user exists naturallyas in the case where the helper is a smartcard But if the helper is simply some remote device thechannel may have to be implemented cryptographically In that case when a user compromise isdiscovered the channel should be assumed to be compromised as well and a secure channel mustbe re-established This may involve distributing new keys to the parties18
Resource Aware LQ WSAN-pdf,Resource-Aware and Link Quality Based RoutingMetric for Wireless Sensor and Actor NetworksV Cagri Gungor∗ Chellury Sastry† Zhen Song‡ and Ryan Integlia§∗Georgia Institute of Technology Atlanta GA 30332 USAEmail: gungor@ecegatechedu†Siemens Corporate Research Princeton NJ 08540 USAEmail: chellurysastry@siemenscom‡Utah State University Logan UT 84322 USAEmail: zhensong@ieeeorg§Rutgers University New Brunswick NJ 08901 USAEmail: integlia@ecerutgerseduAbstract—This paper presents a resource-aware and linkquality based (RLQ) routing metric to address energy limitationslink quality variations and node heterogeneities in wireless sensorand actor networks (WSANs) The RLQ metric is a combinedlink cost metric which is based on both energy efficiency and linkquality statistics The primary objective of the proposed metric isto adapt to varying wireless channel conditions while exploitingthe heterogeneous capabilities in WSANs Different from mostof the existing simulation based studies this research effort isguided by extensive field experiments of link quality dynamics atvarious locations over a long period of time using recent sensorplatforms which realistically addresses the real-world wirelesscommunication challenges in WSANs Performance evaluationsvia test-bed experiments show that the RLQ routing metricachieves high performance in terms of packet reception ratenetwork throughput and network lifetimeI INTRODUCTIONWireless Sensor and Actor Networks (WSANs) are charac-terized by the collective effort of heterogenous nodes calledsensors and actors [1] Typically in WSANs battery-poweredsensor nodes collect information from the physical world anddeliver their measurements to a central controller (sink node)which determines the event features and sends action com-mands to resource-rich actor nodes to initiate the actions uponthe sensed phenomenon The collaborative operation of energyconstrained sensors and resource-rich actors brings significantadvantages over traditional sensing including improved accu-racy; high aggregate intelligence via parallel processing; andexpanded spatial coverage of the environment The realizationof these potential gains however directly depends on energyefficient and reliable communication capabilities of the de-ployed sensor/actor networkRecent experimental studies [2] [3] [4] and [5] have shownthat in real sensor network deployments wireless link qualityvaries over space and time deviating to a large extent from theidealized unit disc graph models used in network simulationtools Based on these empirical studies and measurementsit is also found that the coverage area of sensor radios isneither circular nor convex and packet losses due to fadingand obstacles are common at a wide range of distances andkeep varying over time These studies provide valuable andsolid foundations for several sensor network protocols [6] [7]and have guided design decisions and tradeoffs for a widerange of sensor network applications [8]Although these early studies made many important observa-tions for the problems of reliable data transmission in wirelesssensor networks the challenges of integrating battery-poweredsensors with resource-rich actor nodes are yet to be efficientlystudied and addressed First of all all these experimentalstudies do not take node heterogeneity into account whenmaking routing decisions; they assume that all nodes areidentical in capabilities This assumption clearly leads towaste of valuable network resources in heterogenous sensornetworks especially in WSANsSecond since all these studies were conducted the designspace of sensor platforms and their radio hardware have ad-vanced significantly Recently many sensor platforms includ-ing Tmote Sky [9] and MicaZ [10] have gravitated towardsan international sensor network standard (IEEE 802154 [11])and even a single radio chip (CC2420 [12]) which providesan additional radio hardware link quality indicator (LQI)to several network services This newer technology differssignificantly from earlier radios and thus these recent 802154based sensor platforms may behave differently compared toearlier sensor platforms [13] [14] Consequently all thesenew advances in sensor radio hardware as well as link qualityvariations and node heterogeneities in WSANs call for newempirical measurements on recent sensor platforms and thedesign of resource-aware protocols for WSANsIn this paper we present a resource-aware and link qualitybased (RLQ) routing metric for WSANs to address the chal-lenges mentioned above as well as to exploit the unique fea-tures of WSANs The RLQ routing metric is a combined linkcost metric which is based on both energy efficiency and linkquality statistics The primary objective of the RLQ metric is toadapt to varying wireless channel conditions while exploitingthe heterogeneous capabilities in WSANs To accomplish this1-4244-0353-7/07/$2500 ©2007 IEEE This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the ICC 2007 proceedings 3364objective the proposed metric biases the use of resource-richactor nodes over energy-constrained sensor nodes for packetforwarding and processing in the network Specifically theproposed link cost metric captures expected energy cost totransmit receive and retransmit a packet while considering theresidual energy levels of the sensor nodes Also different frommost of the existing simulation based studies our researcheffort is guided by extensive field experiments of link qualitydynamics at various locations over a long period of time usingrecent sensor network platforms which realistically addressesthe real-world wireless communication challenges in WSANsIn summary we make the following contributions in this paper: We reveal the spatiotemporal impacts on wireless com-munication and identify the relationship between dynam-ics of link quality and radio hardware measurementsbased on several link quality measurements on recentsensor network platforms We present a resource-aware link cost metric which si-multaneously considers the energy consumption and linkquality statistics as well as the node heterogeneities in thenetwork An extensive set of test-bed experiments showthat the proposed metric balances the energy expenditureand network load across available paths accounting forenergy drain of individual nodes We consider realistic battery models in our evaluationswhich takes non-linear relationship between battery volt-age and the remaining energy level into account duringthe operation of the network We also make our ex-perimental data publicly available [15] which can helpdeveloping realistic link quality and battery models forsimulation-based studiesThe remainder of this paper is organized as follows In Sec-tion II we present the network architecture and describe thedesign principles and functionalities of the proposed routingmetric in detail Performance evaluation and simulation resultsare presented in Section III Finally the paper is concluded inSection IVII LINK QUALITY MEASUREMENTS IN WSANSIn the following sections we first describe the networkarchitecture and characteristics of WSANs and then based onthese characteristics we discuss the main design componentsof the proposed resource-aware and link quality based routingmetric in detail We also present a case study in order to gainmore insight regarding the link quality estimation in WSANsA Network ArchitectureWireless Sensor and Actor Networks (WSANs) are com-posed of heterogeneous nodes referred to as sensors con-trollers and actors Sensors are low-cost low-power multi-functional devices that communicate un-tethered in short dis-tances Controllers collect and process sensor data and sendaction commands to the actors in order to perform appropriateactions upon the environment Hence in a typical WSANarchitecture controllers and actors are resource-rich devices(a) (b)Fig 1 Experimental sites: (a) in a corridor (b) in an office environmentequipped with better processing capabilities high transmis-sion power and longer battery life time (or line powered)In WSANs a large number of sensor nodes ie on theorder of hundreds are deployed in a target area to performa collaborative sensing task Such a dense deployment isusually not necessary for controllers and actors since theyare sophisticated devices with higher capabilities that can acton large areasB Target ApplicationIn this study we focus on indoor wireless sensor/actornetwork applications such as advanced building automationsystems In such an integrated system several sensor nodesmonitor the ambient conditions of the indoor environmentto determine when to start or stop heaters and chillersmodulate air dampers activate pumps for freeze protectionAfter the sensors detect an event occurring in an indoorbuilding environment the event data is distributively processedand transmitted to the terminal equipment controllers whichgather process and eventually reconstruct the event data andcommunicate with actors to initiate the actions upon the envi-ronment Due to ever increasing installation and maintenancecosts energy efficient and reliable configuration of such sys-tems significantly reduces the operational expenses Althoughthese systems bring significant advantages over traditionalsensing and facilitate fine-grained monitoring and control ofindoor environments within a limited budget in a case studymade by Siemens Building Technologies [16] it is observedthat wireless link quality varies over space and time and ithas a significant impact on network performance includingnetwork throughput network lifetime and resource utiliza-tion Therefore the design of reliable and energy efficientcommunication protocols is of great importance to provideseveral economic and operational benefits This motivated usto design of resource-aware and link quality based routingmetrics for WSAN Note also that although our researcheffort is motivated by the challenges of building automationapplications the wireless link quality variations and energylimitations are common in several WSAN applications [1]and thus other real-world applications can benefit from ourexperimental observations and findingsThis full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the ICC 2007 proceedings 3365C Experimental Setup and ResultsIn WSANs rapid variations in the wireless channel pre-cludes an efficient mechanism for knowing instantaneous linkquality at the time of transmission thus making it difficult toestimate the instantaneous value of the link quality Moreoverin bandwidth limited and battery-operated sensor networksthere is a tradeoff between keeping the communication over-head and energy expense at a minimum which call for wire-less channel measurements with high period and obtaininga reliable estimate of link quality which requires frequentchannel measurements Striking a good balance in this tradeoffrequires a good understanding of the behavior of wirelesschannel quality during the operation of the network Thismotivates us to explore whether it is possible to obtain a goodestimate of the link quality based on only a few radio hardwaremeasurementsIn this study we first focused on how to characterizeand measure link quality in WSANs We have conductedexperiments with Tmote Sky nodes Tmote Sky nodes useCC2420 radio component which are apart from being moreadvanced than older radios and supports the IEEE 802154an emerging wireless sensor network standard [11] Specifi-cally CC2420 operates in 24 GHz ISM band with a nominaldata rate of 250 kbps a much higher rate than older radiosIn our experiments to measure the link quality during theoperation of the network two useful radio hardware linkquality metrics were used: i) link quality indicator (LQI) andii) received signal strength indicator (RSSI) More specificallyRSSI is the estimate of the signal power and is calculated over8 symbol periods while LQI can be viewed as chip error rateand is calculated over 8 bits following the start frame delimiterLQI values are usually between 110 and 50 and correspondto maximum and minimum quality frames respectivelyIn link quality measurements we use a pair of Tmote Skynodes in an indoor environment one as the sender and theother as the receiver In Fig 1 we present our experimentalsites in an indoor environment We vary the distance from thereceiver to the sender from 1 m to 30 m in steps of 1 mAt each distance the transmitter sends 100 data packets witha rate of 2 packets per second We deliberately chose a lowrate to avoid any potential interference so that the effect ofunreliable links can be isolated from that of congestionIn Figs 2 (a) and (b) we present our preliminary experimentresults to elaborate the relationship between packet receptionrate (PRR) and link quality metrics Here packet reception raterepresents the ratio of the number of successful packets to thetotal number of packets transmitted over a certain number oftransmissions We make two observations from these figuresFirst in Fig 2 (a) we observe that there is a clear trendthat PRR increases when average LQI measurements increaseThus there is a strong correlation between the average LQIvalues and the PRR at the receiver Statistical analysis of ourempirical measurements shows that the Pearson’ s correlationcoefficient is around 080 between these two variables Notethat we also observed some inconsistencies in Fig 2 (a)50 60 70 80 90 100 11000102030405060708091LQIPacket Reception Rate (PRR)PRR vs LQIRealFitted (a)−100 −95 −90 −85 −80 −75 −70 −6500102030405060708091RSSI (dbm)Packet Reception Rate (PRR)PRR vs RSSI(b)Fig 2 Test-bed measurements: a) PRR vs LQI b) PRR vs RSSIespecially when the received signal is weak These incon-sistencies clarify why the Pearson’ s coefficient is not 10However the observed correlation is still interesting since LQIis calculated only from the packets that are received whereasthe packet reception rate also considers those packets that aredropped This correlation implies that average LQI is a goodmeasurable indicator of the packet reception rate In Fig 2 (a)we also fitted a curve to the average LQI vs PRR and observedalthough the curve fits the data quite good there are still a fewoutliers which can be caused by environmental changes andinterference from 80211 networks in the deployment fieldSecond we have observed that there is a smaller correlationbetween RSSI and the packet reception rate as shown in Fig 2(b) The Pearson’ s correlation coefficient is only 055 betweenthe packet reception rate and the RSSI values Specifically itis found that when the signal is weak (especially when it isaround sensitivity threshold (−94dbm)) even though there is aconsiderable variation in the packet reception rate RSSI doesnot provide useful information to predict packet reception rateOn the other hand when the signal is higher than sensitivitythreshold RSSI is a promising link quality estimator since itshows small variance compared to LQI measurements Thisobservation is also consistent with the results in the relatedThis full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the ICC 2007 proceedings 3366literature [14] Therefore to minimize the estimation error andlink measurement costs one can use LQI measurements as alink quality metric as long as its variances are factored outD Resource Aware and Link Quality Based Routing MetricIn WSANs the wireless link quality between pairs of nodesvary during the lifetime of a network based on distancetransmit power radio interference and environmental factors(such as obstructions and people in the sensor network fieldattenuating radio signals) [3] Even if the locations of nodesin the network are fixed and each node is configured withan identical transmit power node inter-connectivity changesduring the life-time of the network Note also that in WSANsthe energy limitations of the sensors exacerbate the challengeof reliable wireless communicationIn order to alleviate these drawbacks we present a resource-aware and link quality based (RLQ) routing metric whichis based on both energy efficiency and link quality statis-tics RLQ routing metric adapts to varying wireless channelconditions while exploiting the heterogeneous capabilities inthe network Specifically it captures expected energy cost totransmit receive and retransmit a packet while considering theresidual energy levels of the sensor nodes Moreover for nodesthat have high energy resources eg actor nodes transmissionand reception of packets have negligible energy cost whichis also reflected in the proposed link cost metric Note thatthe actors in WSANs have longer network lifetime comparedto sensor nodes since the order of magnitude of the energyrequired for actions is much higher than that required forsensing and communicationTo calculate link cost let’s assume each node usesCSMA/CA MAC protocol with DATA/ACK exchange whichis supported by IEEE 802154 Then the energy cost (Clink)for a reliable transmission of a data packet over a single hopcan be typically calculated as follows:Clink = ηtx αtx + ηrx αrx (1)where ηtx and ηrx represent normalized energy cost for thetransmitter and receiver respectively The variables αtx andαrx are 1 for battery-powered sensor nodes and 0 for line-powered actor nodes In addition normalized energy costs ηtxand ηrx are calculated as follows:ηtx = [(Ctx−data + Crx−ack)Elink]x[1 + (1− Etx−resEtx−init)]y(2)ηrx = [(Crx−data + Ctx−ack)Elink]x[1 + (1− Erx−resErx−init)]y(3)where Ctx and Crx represent the energy consumption duringtransmission and reception respectively Also Etx−init andErx−res are the initial and remaining energy of the transmitterand Erx−init and Erx−res are the initial and remainingenergy of the receiver respectively Here Elink representsthe expected number of transmissions which is calculated asfollows:Elink =K∑i=0i (1 − PRR)i PRR (4)where PRR represents the packet reception rate and K isthe maximum number of re-transmissions before the packetis ignored To calculate PRR of a link we utilize linkquality indicator (LQI) reported by the physical layer of IEEE802154 [11] This way the nodes dynamically adapt tochanging wireless network conditions and select the paths withhigh quality linksNote also that with the use of normalized energy cost inthe proposed metric when the sensors have plenty of residualenergy eg at the beginning of the network deploymentthe energy consumption term in equations (2) and (3) isemphasized while if the residual energy of a node becomeslower then the residual energy term is more emphasizedThus we try to balance the energy expenditure and networkload across available paths accounting for energy drain ofindividual nodesIt is also important to note that in equations (2) and (3)the variables x and y are the weighting factors that can beadjusted to find the minimum energy path or the path withnodes having the most energy or combination of above Forexample if x=y=0 then the shortest cost path is minimumhop path and if x = 1 and y = 0 then the shortest pathis the minimum total energy consumption path Thus theseweighting factors provide flexibility to the user based on theapplication-specific requirements Note that in energy costcalculation of a link if both transmitter and receiver are notbattery-powered the equation (1) becomes equal to zero Inorder to avoid a link energy cost of zero we also take themaximum of the calculated link cost and a small constantfor these cases Overall with the use of proposed link costmetric we can choose paths that contain as few battery-powered data transmissions and receptions as possible and thusutilizes resource-rich nodes in the deployment field in orderto maximize the network lifetimeIII PERFORMANCE EVALUATIONIn order to gain more insight into link quality variationsand energy limitations in WSANs we first investigate theeffects of link quality indicator (LQI) on the overall networkperformance In the first set of experiments all the nodes in thenetwork are battery-powered Then we evaluate the impact ofenergy heterogeneity in the network where some nodes (actornodes) are line-powered and other nodes are battery-poweredFurthermore we compared the performance of differentrouting metrics on a physical test-bed including 21 TmoteSky nodes The experiments were carried out in a large officefloor with obstructions (people also move during the day) and80211b networks to mimic the realistic operating networkconditions Note that some of 802154 frequencies overlapwith 80211b frequencies [17] increasing the effects of externalThis full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the ICC 2007 proceedings 33670 01 02 03 04 05 06 07 08 09 10102030405060708090100Packet Reception RateCumulative percentage of node pairsShortest_PathLQI_InstantLQI_MovAvgRLQ0 01 02 03 04 05 06 07 08 09 10102030405060708090100Cumulative percentage of node pairs Throughput (packet/s)Shortest_PathLQI_Instant  LQI_MovAvg   RLQ           LQI_Inst LQI_MovAvg RLQ RLQ_Act(15%) RLQ_Act(20%) RLQ_Act(25%)0100200300400500600Increase in Network Lifetime (%)(a) (b) (c)Fig 3 Performance results: (a) CDF vs PRR (b) CDF vs Throughput and (c) The effect of line powered actor nodes on network lifetime HereRLQ Act(x%) represents RLQ routing when x% of nodes in the network are line powered actor nodesTABLE INETWORK PARAMETERS USED IN THE EXPERIMENTSArea of sensor field 20x30 m2Number of nodes 21Packet length 30 bytesBuffer size 64 packetsRe-transmission threshold (K) 5Traffic type CBRTransmission power -25 dbmWeighting factors (x y) (11)interference on link quality The parameters used in our per-formance measurements are listed in Table I To communicatesensor data to the sink node we employed a CSMA/CA MACprotocol with DATA/ACK exchange supported by 802154 Inour experiments we also consider energy heterogeneity in thenetwork and non-ideal battery behaviors In the evaluationswe investigate the following performance metrics: Throughput is the number of unique packets received atthe sink node divided by the interval between the startand the end of the experiment Packet Reception Rate is the ratio between the totalnumber of unique packets received at the sink node andthe total number of packets generated by all the sensornodes Network Lifetime is defined as the smallest time that ittakes for at least one node in the network to drain its en-ergy beyond the point where it can function normally Wealso normalize network lifetime to network throughput toavoid giving unfair advantage to less reliable networksIn our experiments each sensor node sends packets towardsa sink node with a rate of 1 packet per second We deliberatelychose a low rate to avoid any potential interference andnetwork congestion so that the effect of unreliable links canbe isolated from that of network congestion Multiple trialswere used in all experiments and the results are the averageof these trials The duration of each experiment trial was atleast 1500 seconds For each experiment we logged everypacket transmission and reception at each sensor node and atthe sink node respectively This fairly detailed logging helpsus to visualize the performance of different routing metricsin several ways In performance evaluations we have usedmultihop LQI routing algorithm [18] in TinyOS because thecode for the the Tmote Sky platform was available Usingmultihop LQI routing algorithm we have also implementedfour different routing algorithms: i) shortest path routing algo-rithm which we call Shortest Path; ii) multihop routing al-gorithm using instantaneous LQI measurements which we callLQI Instant; iii) multihop routing algorithm using movingaverage of LQI measurements which we call LQI MovAvg;iv) multihop routing algorithm using the proposed RLQ metricwhich we call RLQIn Shortest Path routing algorithm each sensor node usesa hop count metric as the sole link cost metric and prefers ashort path over (potentially) very poor radio links rather thana longer path over high-quality links Specifically when linkquality varies significantly it leads to low network through-put since it causes limited bandwidth to be consumed byretransmissions In LQI Instant and LQI MovAvg routingalgorithms each sensor node maintains a recent history of theLQI measurements to their neighbors and uses link qualityestimations to select the parent with the lowest cost path tothe sink node The only difference between LQI Instant andLQI MovAvg is that LQI MovAvg uses moving averageof LQI measurements with a window size of fifty in order toextract the variances of LQI measurements from the data InRLQ routing algorithm the routing metric captures expectedenergy cost to transmit receive and retransmit a packet whileconsidering the residual energy levels of the sensor nodesThis metric takes unreliable wireless links into account whileaccounting for residual energy of the sensors in order to extendthe network lifetimeThis full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the ICC 2007 proceedings 3368Figs 3 (a) and (b) show the cumulative distributive function(CDF) of the packet reception rate and throughput perfor-mance of the routing metrics under comparison for the setof twenty paths respectively As shown in Figs 3 (a) and(b) LQI MovAvg leads to the highest packet receptionrate and average network throughput over all paths with amedian of 60% and 108bps Compared to LQI MovAvgLQI Instant and Shortest Path are noticeably worse witha median packet reception rate of 30% and 10% and witha median average network throughput of 48bps and 26bpsrespectively It is also important to note that the networkperformance of the RLQ routing metric is slightly lower thanthat of LQI MovAvg This is because when the residualenergy of a node along the high quality path becomes lowerRLQ metric changes the path to improve the network life-time This way it aims to balance the energy expenditureand network load across available paths accounting for bothlink quality variations and energy drain of individual nodesOverall these test-bed results show that the routing selectionmetric has a large impact on overall network performanceThe LQI MovAvg and RLQ routing metric provide highnetwork performance using a simple model mapping fromaverage LQI measurements to packet reception rate Note thatin these experiments all the nodes in the network are battery-poweredIn the second set of experiments we also investigated theeffect of routing metrics and energy heterogeneity on networklifetime Fig 3 (c) shows the normalized network lifetime per-formance of different routing metrics under comparison Herewe present percentage of network lifetime increase comparedto the case when shortest path routing algorithm is used inthe network As shown in Fig 3 (c) when there is no line-powered actor nodes in the network the proposed RLQ metricachieves the best performance compared to LQI MovAvgand LQI Instant routing metrics For example we obtainthat the average network lifetime increase achieved by RLQmetric is 25% and 15% higher than that of LQI Instantand LQI MovAvg respectively When line powered actornodes are included in the network (RLQ Act(x%) cases) itis observed that network lifetime increases significantly sinceRLQ routing metric biases the use of resource-rich actor nodesover energy-constrained sensor nodes for packet forwardingand processing For example when 20% of nodes in thenetwork are line powered we obtain that the average networklifetime increases 40% compared to the case when RLQmetric is used In our experiments we have also observedthat the selection of the position of the line-powered actornodes affects the overall network performance Thereforein addition to resource-aware and link quality based routingmetrics optimal deployment strategies should be developed tofully utilize the potential of network heterogeneityIV CONCLUSIONWireless sensor and actor network protocol design is a chal-lenging task due to severe limitations of energy resources andnetwork bandwidth as well as wireless link quality variationsand node heterogeneities in the network In this paper toaddress these challenges we present a resource-aware and linkquality based (RLQ) routing metric for WSANs The RLQrouting metric is a combined link cost metric which is basedon both energy efficiency and link quality statistics Based onextensive empirical measurements and test-bed experimentswe also found that there exists a strong correlation betweenthe average LQI measurements and packet reception ratesComparative performance evaluations via test-bed experimentsshow that the RLQ routing metric achieves high performancein terms of packet reception rate network throughput and net-work lifetime Future work includes investigating the impact ofdifferent heterogenous resources such as transmission powernetwork bandwidth and processing power on overall networkperformance and optimal placement of these resources in thenetwork We also plan to make detailed statistical analysis ofour link quality measurementsREFERENCES[1] I F Akyildiz and I H Kasimoglu “Wireless Sensor and Actor Net-works: Research Challenges” Ad Hoc Networks (Elsevier) vol 2 no 4pp 351–367 October 2004[2] D Lal and et al “Measurement and Characterization of Link QualityMetrics in Energy Constrained Wireless Sensor Networks” in Proc ofIEEE GLOBECOM 2003 San Francisco USA December 2003[3] J Zhao and R Govindan “Understanding Packet Delivery Performancein Dense Wireless Sensor Networks” in Proc of ACM SENSYS 2003CA USA November 2003[4] D Son B Krishnamachari and J Heidemann “Experimental Analysisof Concurrent Packet Transmissions in Low-Power Wireless Networks”in Proc of ACM SENSYS 2006 November 2006[5] G Zhou T He J Stankovic and T Abdelzaher “RID: Radio In-terference Detection in Wireless Sensor Networks” in Proc of IEEEINFOCOM 2005 Miami USA March 2005[6] K Seada and et al “Energy-Efficient Forwarding Strategies for Geo-graphic Routing in Lossy Wireless Sensor Networks” in Proc of ACMSENSYS 2004 November 2004[7] A Woo T Tong and D E Culler “Taming the Underlying Challengesof Reliable Multihop Routing in Sensor Networks” in Proc of ACMSENSYS 2003 CA USA November 2003[8] I F Akyildiz W Su Y Sankarasubramaniam and E Cayirci “WirelessSensor Networks: A Survey” Computer Networks (Elsevier) vol 38no 4 pp 393–422 Mar 2002[9] Moteiv Corporation Tmote Sky datasheet [Online] Available:wwwmoteivcom/products/docs/tmote-sky-datasheetpdf[10] Crossbow Technology MicaZ datasheet [Online] Avail-able: wwwxbowcom/Products/Product pdf files/Wireless pdf/MICAzDatasheetpdf[11] “Wireless Medium Access Control (MAC) and Physical Layer (PHY)Specifications for Low-Rate Wireless Personal Area Networks (LR-WPANs)” IEEE 802154 Standard Oct 2003[12] CC2420 Radio [Online] Available: http://wwwchipconcom[13] J Polastre R Szewczyk and D Culler “Telos: Enabling Ultra-lowPower Wireless Research” in Proc of IEEE ISPN 2005 April 2005[14] K Srinivasan and P Levis “RSSI is Under Appreciated” in Proc ofEMNET 2006 May 2006[15] Experiment measurements at Siemens Sensor Network andRFID Lab [Online] Available: http://grumpyusuedu/∼zhensong/ExperimentMeasurements/[16] T Kevan “Case Study: When Renovation Includes Building Automa-tion” in Proc of Sensors Magazine May 2006[17] I Howitt and J Gutierrez “IEEE 802154 Low Rate-Wireless PersonalArea Network Coexistence Issues” in Proc of IEEE WCNC 2003March 2003[18] TinyOS MultiHopLQI routing algorithm [Online] Available: wwwtinyosnet/tinyos-1x/tos/lib/MultiHopLQI/This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the ICC 2007 proceedings 3369
draft-ietf-roll-rpl-04-pdf,76th IETF Meeting - ROLL WG11/10/2009RPL: IPv6 Routing Protocol for Low Power and Lossy NetworksJonathan HuiRPL Author TeamROLL WG Meeting76th IETF MeetingHiroshima Japan1(draft-ietf-roll-rpl-04)76th IETF Meeting - ROLL WG11/10/2009Outline• Basic Approach• Mechanism Details (draft-03 vs draft-04)• Open Issues• Next Steps276th IETF Meeting - ROLL WG11/10/2009Basic Approach376th IETF Meeting - ROLL WG11/10/2009Overview• Assumption: most traffic flows through few nodes• many-to-one• one-to-many• baseline required by all requirements drafts• Approach: build DAG(s) rooted at these nodes• Up towards the DAG root for many-to-one• Down away from the DAG root for one-to-many• Use the DAG to detect and avoid loops• Allow point-to-point via up* down*4Up Down76th IETF Meeting - ROLL WG11/10/2009Definitions• Instance• Defines the optimization objective when forming paths towards roots• Link properties: (Reliability Latency) Node properties: (Powered or not)• Objective: optimize paths based on one or more metrics• Scope: RPL network• Composed of one or more disjoint DODAGs5Instance76th IETF Meeting - ROLL WG11/10/2009Definitions• DODAG• Defines a DAG that forms paths to a single logical root• Scope: within an Instance6DODAG76th IETF Meeting - ROLL WG11/10/2009Sequence NSequence N+1Definitions• DODAG Iteration• A DODAG constructed using a particular sequence• Scope: within a DODAG776th IETF Meeting - ROLL WG11/10/2009Sequence NSequence N+1Definitions• Node Rank• Defines a node’s relative position within a DODAG• Scope: within a DODAG Iteration8Rank = 0Rank = 1Rank = 1Rank = 2Rank = 3 Rank = 376th IETF Meeting - ROLL WG11/10/2009Definitions• Instance: defines optimization objective for the network• DODAG: a disjoint DAG within an Instance• DAG Iteration: a DODAG built with a particular sequence number• Rank: position within a DODAG Iteration• Objective Function: identifies metrics constraints and objectives• Objective Code Point: identifies Objective Function976th IETF Meeting - ROLL WG11/10/2009DAG Construction• Distance-Vector• advertise path cost to root• choose parents that minimize path cost• but be careful about loops & count-to-infinity• Assign every node a Rank• Rank strictly decreasing towards root10Rank = 0Rank = 1Rank = 1Rank = 2Rank = 3 Rank = 376th IETF Meeting - ROLL WG11/10/2009Route Construction• Up routes towards nodes of decreasing rank• DAG parents• Down routes towards nodes of increasing rank• Nodes inform parents of their presence and reachability to descendants• Record route/source route for nodes that cannot maintain any down routes1176th IETF Meeting - ROLL WG11/10/2009Forwarding Rules• All routes: up*down* along DODAG• When going up• always forward to lower rank when possible• may forward to sibling if no lower rank exists• When going down• forward based on down routes12Rank = 0Rank = 1Rank = 1Rank = 2Rank = 3 Rank = 376th IETF Meeting - ROLL WG11/10/2009Metric vs Rank• Metric is used to achieve an optimization goal• Rank: path calculation according to objective metric• Scalar that represents relative position within a DAG• Strictly increasing from the root• Topological constraint to avoid and detect loops• Coarse granularity allows siblings (in addition to parents children)• Common language if we want to utilize different OCPs in a DAG1376th IETF Meeting - ROLL WG11/10/2009Protocol Mechanisms1476th IETF Meeting - ROLL WG11/10/2009Protocol Mechanisms• Control Messages• Conveyance• Loop Avoidance• Route Flapping Avoidance• Loop Detection & Repair• Present proposals from Draft 03 & Draft 04• WG Feedback on 03: SIMPLIFY1576th IETF Meeting - ROLL WG11/10/2009Draft 03 to 04 Summary• Remove binding between RPL and IPv6 ND• Remove detach/float/reattach local repair• Remove Hold-Up/Down Timer• Specify data-path loop detection/repair1676th IETF Meeting - ROLL WG11/10/2009Conveyance (draft-03)• Bind to IPv6 ND• Router Solicitation• Router Advertisement• DAG Information Option (form the DAG)• Neighbor Advertisement• Destination Adv Option (form down routes)1776th IETF Meeting - ROLL WG11/10/2009Conveyance (draft-04)• Create new ICMPv6 type for RPL• Use ICMPv6 Code to identify RPL message• DIS: DAG Information Solicitation• DIO: DAG Information Object• DAO: Destination Advertisement Object1876th IETF Meeting - ROLL WG11/10/2009Loop Avoidance (draft-03)• Loops may occur when node increases Rank• Global repair• Create new DAG Iteration (use sequence number to rebuild DAG)• Sequence number establishes event-horizon• Local repair• Detach/float/merge within a DAG instance• Use DAG Hop Timer to color sub-DAG and reduce advertisements1976th IETF Meeting - ROLL WG11/10/2009Loop Avoidance (draft-04)• Only global repair for simplicity• Must wait for new instance to increase rank• Maybe too simple?• If no parents exist with lower rank MUST poison route by advertising infinite cost2076th IETF Meeting - ROLL WG11/10/2009Loop Detection & Repair (draft-03)• Not addressed (listed as open issue)2176th IETF Meeting - ROLL WG11/10/2009Loop Detection & Repair (draft-04)• Up routes must strictly decrease in rank• Down routes must strictly increase in rank• Generalized to inconsistency detection & repair22ABDECRank = 4Rank = 7Rank = 6 Rank = 6Rank = 776th IETF Meeting - ROLL WG11/10/2009Inconsistency Detection/Repair (draft-04)• Pass back to parent if no down route exists• Cleanup stale down routes if dgram is passed back23ABDECRank = 4Rank = 5Rank = 6 Rank = 6Rank = 776th IETF Meeting - ROLL WG11/10/2009Loop Detection & Repair (draft-04)• Parent routes fail use siblings (same rank)• Allow at most one (?) sibling hop at a time24ABDECRank = 4Rank = 5Rank = 6 Rank = 6Rank = 776th IETF Meeting - ROLL WG11/10/2009Loop Detection & Repair (draft-04)• Include routing info in data path to validate DAG• Instance ID identifies instance to route along• Up/Down Bit to identify up vs down• Sender’s Rank to assert Rank invariant• Rank-Error Bit to tolerate single rank error• DAO-Error Bit to back-track and cleanup state• Sibling Bit to allow at most one sibling hop2576th IETF Meeting - ROLL WG11/10/2009Route Flapping Avoidance (draft-03)• Use a Hold-Down Timer to delay parent eviction2676th IETF Meeting - ROLL WG11/10/2009Route Flapping Avoidance (draft-04)• Removed: unclear if needed given other mechanisms2776th IETF Meeting - ROLL WG11/10/2009Draft 03 to 04 Summary• Remove binding between RPL and IPv6 ND• Remove detach/float/reattach local repair• Remove Hold-Up/Down Timer• Specify data-path loop detection/repair• 93 page ➜ 82 pages and counting2876th IETF Meeting - ROLL WG11/10/2009Open Issues2976th IETF Meeting - ROLL WG11/10/2009Open Issues• Behavior when OF is not supported • Local repair• Use of siblings• Minimum Viable Protocol3076th IETF Meeting - ROLL WG11/10/2009Open Issues: OF Not Supported• Node wants to join a network but does not understand OFx• Join and extend network using “default” OCP• requires all nodes to implement OF0• Join as leaf and log issue• allows connectivity but does not extend the network• Strong consensus on “join as leaf” will fix in draft-05 and close this issue3176th IETF Meeting - ROLL WG11/10/2009Open Issues: Local Repair• Global repair• requires nodes to wait for sequence number• delay to repair depends on sequence number refresh rate• Local repair• nodes can move down in the DAG within an instance• risks creating loops and count-to-infinity issues• general consensus that important cases exist• One proposed mechanism• Use DAG Hop Timer to wait for poisoning to occur• Another proposed mechanism• nodes can move down at most X ranks within a sequence• if things are really bad must wait for new sequence3276th IETF Meeting - ROLL WG11/10/2009Open Issues: Utilize Siblings?• Only parents• Only route to nodes with lower rank• Directional sibling links• Equal rank may only route one way• More receiver diversity• Bi-directional sibling links• Equal rank nodes may route through each other• Even more receiver diversity• Loop detection and/or error reporting when siblings have no parents3376th IETF Meeting - ROLL WG11/10/2009Open Issues: MVP• General consensus: draft 03 is far too complex• Draft 04 removes many mechanisms/knobs/hooks• hold-up/down timers detach/float/reattach local repair• Should we simplify more?• Nearly orthogonal Instance and DAG concepts• Backtracking on DAO errors• Utilization of sibling links• Objective Control Point generality• What is missing?• Local repair Address/Header Compression• Tradeoff between defining a feature-limited base architecture and working “well” out-of-the-box3476th IETF Meeting - ROLL WG11/10/2009Supporting Drafts• Metrics• Applicability Statements• Objective Function specifications• Source Routing?• Address/Header Compression?3576th IETF Meeting - ROLL WG11/10/2009Next Steps3676th IETF Meeting - ROLL WG11/10/2009Next Steps• State machine• Clarify relationship between neighbor set and candidate parents• Specify node operation when OF is not supported• Focus on security• Many editorial improvements to make the spec more clear concise and organized3776th IETF Meeting - ROLL WG11/10/2009End3876th IETF Meeting - ROLL WG11/10/2009Open Issues: Inconsistency Detection• IPv6 Flow Label?• Not compliant with RFC 3697• Require end-points to set Flow Label to zero/Instance ID• Edge Routers then reset Flow Label to zero/Instance ID• Define an IPv6 Hop-by-Hop Option?• Requires all routers to process a IPv6 HBH Option header• Define a new IPv6 Extension Header?• Only processed by RPL routers• Requires all end-points to understand new extension header• Currently soliciting 6man for feedback39
TinyECC-Library-pdf,TinyECC: A Configurable Library for Elliptic Curve Cryptographyin Wireless Sensor Networks∗An LiuDepartment of Computer ScienceNC State University Raleigh NC 27695email: aliu3@ncsueduPeng NingDepartment of Computer ScienceNC State University Raleigh NC 27695email: pning@ncsueduAbstractPublic Key Cryptography (PKC) has been the enablingtechnology underlying many security services and proto-cols in traditional networks such as the Internet In thecontext of wireless sensor networks elliptic curve cryptog-raphy (ECC) one of the most efficient types of PKC is be-ing investigated to provide PKC support in sensor networkapplications so that the existing PKC-based solutions canbe exploitedThis paper presents the design implementation andevaluation of TinyECC a configurable library for ECC op-erations in wireless sensor networks The primary objec-tive of TinyECC is to provide a ready-to-use publicly avail-able software package for ECC-based PKC operations thatcan be flexibly configured and integrated into sensor net-work applications TinyECC provides a number of opti-mization switches which can turn specific optimizationson or off based on developers’ needs Different combi-nations of the optimizations have different execution timeand resource consumptions giving developers great flexi-bility in integrating TinyECC into sensor network applica-tions This paper also reports the experimental evaluationof TinyECC on several common sensor platforms includ-ing MICAz Tmote Sky and Imote2 The evaluation resultsshow the impacts of individual optimizations on the exe-cution time and resource consumptions and give the mostcomputationally efficient and the most storage efficient con-figuration of TinyECC1 IntroductionRecent technological advances have made it possibleto develop wireless sensor networks consisting of a largenumber of low-cost low-power and multi-functional sen-sor nodes that communicate over short distances through∗This work is supported by the National Science Foundation undergrants CAREER-0447761 and CNS-0721424 and by the Army ResearchOffice under grant W911NF-05-1-0247 The contents of this paper do notnecessarily reflect the position or the policies of the US Governmentwireless links Such sensor networks are ideal candidatesfor a wide range of applications such as monitoring of crit-ical infrastructures data acquisition in hazardous environ-ments and military operations The desirable features ofwireless sensor networks have attracted many researchersto develop protocols and algorithms that can fulfill the re-quirements of these applicationsSecurity services such as authentication and key man-agement are critical to communication security in wire-less sensor networks as well as the security of sensor net-work applications In traditional networks such as the Inter-net Public Key Cryptography (PKC) has been the enablingtechnology underlying many security services and proto-cols (eg SSL [3] and IPsec [18]) For example PKC hasbeen used to bootstrap symmetric session keys and authen-ticate messages to multiple receivers However in wirelesssensor networks PKC has not been widely adopted due tothe resource constraints on sensor platforms particularlythe limited and depleteable battery powerThere has been intensive research aimed at developingtechniques that can bypass PKC operations in sensor net-work applications For example there has been a substan-tial amount of research on random key pre-distribution forpairwise key establishment (eg [13 23]) and broadcastauthentication (eg [24 25]) However these alternativeapproaches do not offer the same degree of security or func-tionality as PKC For instance none of the random keypre-distribution schemes can guarantee key establishmentbetween any two nodes and tolerate arbitrary node com-promises at the same time As another example the afore-mentioned broadcast authentication schemes which are allbased on TESLA [32] require loose time synchronizationwhich itself is a challenging task to achieve in wirelesssensor networks In contrast PKC can address all theseproblems easily Pairwise key establishment can always beachieved using for example the Diffie-Hellman (DH) keyexchange protocol [12] without suffering from the nodecompromise problem Similarly broadcast authenticationcan be provided with for example the ECDSA digital sig-2008 International Conference on Information Processing in Sensor Networks978-0-7695-3157-1/08 $2500 © 2008 IEEEDOI 101109/IPSN200847245nature scheme [7] without requiring time synchronizationThus it is desirable to explore the application of PKC onresource constrained sensor platformsThere have been a few recent attempts to use PKC inwireless sensor networks [15 26 33] which demonstratethat it is feasible to perform limited PKC operations on thecurrent sensor platforms such as MICAz motes [2] EllipticCurve Cryptography (ECC) has been the top choice amongvarious PKC options due to its fast computation smallkey size and compact signatures For example to provideequivalent security to 1024-bit RSA an ECC scheme onlyneeds 160 bits on various parameters such as 160-bit finitefield operations and 160-bit key size [8]Despite the recent progress on ECC implementationson sensor platforms all the previous attempts [15 26 33]have limitations In particular all these attempts were de-veloped as independent packages/applications without se-riously considering the resource demands of sensor net-work applications As a result developers may find it dif-ficult and sometimes impossible to integrate an ECC im-plementation with the sensor network applications thoughthe ECC implementation may be okay on its own For ex-ample an ECC implementation may require so much RAMthat it would be impossible to fit both the sensor networkapplication and the ECC implementation on the same nodeMoreover various optimization techniques are availableto speed up the ECC operations Such optimizations how-ever typically will increase the ROM and RAM consump-tions though they may reduce the execution time and en-ergy consumption It is not clear what optimizations shouldbe used and how they should be combined to achievethe best trade-off among security protection computationoverheads and storage requirements Additional researchis necessary to clarify these issues and facilitate the adop-tion of ECC-based PKC in wireless sensor networksIt is certainly possible to have dedicated PKC hardwareincluded on sensor platforms However given that thereis no PKC hardware that is currently available on currentsensor platforms it is a sensible choice to explore softwareapproaches for PKC support on sensor platformsIn this paper we present the design implementationand evaluation of TinyECC a configurable library for ECCoperations in wireless sensor networks1 The primary ob-jective of TinyECC is to provide a ready-to-use publiclyavailable software package for ECC-based PKC operationsthat can be flexibly configured and integrated into sensornetwork applicationsTargeted at TinyOS [5] TinyECC is written innesC [14] with occasional in-line assembly code to achievefurther speedup for popular sensor platforms including MI-CAz [2] TelosB [4] Tmote Sky [6] and Imote2 [1] A1TinyECC 10 and its previous versions are publicly available athttp://discoverycscncsuedu/software/TinyECC/unique feature of TinyECC is its configurability TinyECCincludes almost all known optimizations for ECC opera-tions Each optimization is controlled by a software switchwhich can turn the optimization on or off based on devel-opers’ needs Different combinations of optimizations havedifferent ROM/RAM consumption execution time and en-ergy consumption This gives the developers great flexibil-ity in integrating TinyECC in their applicationsTo provide guidance in using TinyECC we perform aseries of experiments with different combinations of ac-tivated optimizations To understand the impact of eachoptimization technique we compare the execution timeROM/RAM consumption and energy consumption withand without the given optimization enabled on MICAz [2]Tmote Sky [6] and Imote2 [1] In addition our experi-ments also present the performance results and the resourceusages for the most computationally efficient configuration(ie fastest execution and least energy consumption) andthe most storage-efficient configuration (ie least ROMand RAM usage) of TinyECC on these common sensorplatforms respectivelyThe contribution of this paper is two-fold: First we de-velop TinyECC to allow flexible integration of ECC-basedPKC in sensor network applications Second we per-form a substantial amount of experimental evaluation us-ing representative sensor platforms including MICAz [2]TelosB [4] Tmote Sky [6] and Imote2 [1] The experi-mental results provide useful experience and guidance fordevelopers to choose different TinyECC optimizations fortheir needsThe remainder of this paper is organized as followsSection 2 discusses the design principles of TinyECC Sec-tion 3 gives background information on ECC Section 4 de-scribes the optimization techniques adopted by TinyECCSection 5 discusses the implementation of TinyECC Sec-tion 6 presents the experimental evaluation of TinyECC onMICAz Tmote Sky and Imote2 Section 7 discusses therelated work and Section 8 concludes this paper2 Design PrinciplesAs mentioned earlier the primary objective of TinyECCis to provide a ready-to-use publicly available softwarepackage for ECC-based PKC operations that can be flexiblyconfigured and integrated into sensor network applicationsTo make sure we achieve this objective we follow severalprinciples in the design and development of TinyECCSecurity: TinyECC should provide PKC schemes thathave proven to be secure To follow this principleTinyECC only includes support for the well-studied ECCschemes such as ECDSA ECDH and ECIES which aredefined in the Standards for Efficient Cryptography [8]Moreover TinyECC also includes elliptic curve parame-ters recommended by SECG (Stands for Efficient Cryp-246tography Group) such as secp160k1 secp160r1 andsecp160r2 as defined in [9]Portability: TinyECC should run on as many sensorplatforms as possible Due to this reason we choose toimplement TinyECC on TinyOS [5] which is a popularopen-source OS for networked sensors All the TinyECCcomponents have nesC [14] implementations though somemodules also include inline assembly code which can beturned on for faster execution on some sensor platformsThis allows TinyECC to be compiled and used on any sen-sor platform that can run TinyOS TinyECC has been testedsuccessfully on MICAz TelosB Tmote Sky and Imote2Resource Awareness and Configurability: TinyECCshould accommodate the typical resource constraints onsensor nodes Moreover TinyECC should allow for flex-ible configuration so that it can take advantage of the avail-able resources on a wide spectrum of sensor platforms Tofollow this principle TinyECC is implemented carefullyto avoid unnecessary resource usage Moreover TinyECCuses a set of optimization switches which can be turnedon or off to achieve different combinations of performanceand resource consumptionsEfficiency: TinyECC should be computationally effi-cient to reduce the battery consumption as well as the de-lay introduced by PKC operations We make three designdecisions to improve the efficiency of TinyECC The firstis about the type of finite fields over which the ECC opera-tions are performed ECC can be implemented over eithera prime field Fp where p is a large prime number or a bi-nary extension field F2m  where m is an integer Since arith-metic operations over F2m are insufficiently supported bymicro-controllers we choose to support prime fields Fp inTinyECC Second we adopt almost all existing optimiza-tions for ECC operations in TinyECC As mentioned ear-lier these optimizations can be turned on or off to balancethe efficiency and the resource requirements Third we in-clude inline assembly code in critical parts of TinyECCfor popular sensor platforms including MICAz TelosBTmote Sky and Imote2Functionality: TinyECC should support the typicaldemands for PKC To follow this principle the currentversion of TinyECC includes a digital signature scheme(ECDSA) a key exchange protocol (ECDH) and a pub-lic key encryption scheme (ECIES) These cover all typicaluses of PKC3 Background on ECCIn this and next sections we give an overview of ECCand the optimizations adopted by TinyECC as a convenientreference The reader can find details in the referencesElliptic curve cryptography (ECC) is an approach topublic-key cryptography based on the algebraic structure ofelliptic curves over finite fields [16] Elliptic curves used incryptography are typically defined over two types of finitefields: prime fields Fp where p is a large prime numberand binary extension fields F2m  For space reasons we fo-cus on elliptic curves over Fp in this paperAn elliptic curve over Fp is defined by a cubic equationy2 = x3 + ax+ b where ab ∈ Fp are constants such that4a3 + 27b3 = 0 [16] An elliptic curve over Fp consists ofthe set of all pairs of affine coordinates (xy) for xy ∈ Fqthat satisfy an equation of the above form and an infinitypoint O  The points on an elliptic curve form an abeliangroup with O as the additive identity (The formulas defin-ing point addition and its special case point doubling canbe found in [16])For any point G on an elliptic curve the set{OG2G3G } is a cyclic group [16] The calcula-tion of kG where k is an integer is called a scalar mul-tiplication The problem of finding k given points kGand G is called the elliptic curve discrete logarithm prob-lem (ECDLP) It is computationally infeasible to solveECDLP for appropriate parameters [16] The hardness ofECDLP allows several cryptographic schemes based on el-liptic curvesTinyECC includes three well-known ECC schemes:(1) the Elliptic Curve Diffie-Hellman (ECDH) key agree-ment scheme (2) the Elliptic Curve Digital Signature Algo-rithm (ECDSA) and (3) the Elliptic Curve Integrated En-cryption Scheme (ECIES) ECDH is a variant of the Diffie-Hellman key agreement protocol [12] on elliptic curvegroups ECDSA is a variant of the Digital Signature Al-gorithm (DSA) [29] that operates on elliptic curve groupsECIES is a public-key encryption scheme which providessemantic security against an adversary who is allowed touse chosen-plaintext and chosen-ciphertext attacks [16]ECIES is also known as the Elliptic Curve Augmented En-cryption Scheme (ECAES) or simply the Elliptic Curve En-cryption Scheme These ECC schemes allow smaller keysizes for similar security level to the alternatives such as theoriginal DH and DSA schemes For each of the schemesa party that would like to use the scheme needs to agreeon some domain parameters such as the elliptic curve and apoint G on the curve and must have a key pair consisting ofa private key d and a public key Q = dG The specificationof ECDH ECDSA and ECIES can be found in [8 16]4 Optimizations Adopted by TinyECCIn this section we briefly discuss the optimization tech-niques adopted by TinyECC We will omit the details sincethe focus of this paper is not these individual optimizationtechniques More information about these techniques canbe found in the relevant references24741 Optimizations for Large Integer OperationsBarrett Reduction [28]: A straightforward way toperform large integer modular reductions is to use divi-sion [19] A nice side effect is that it reuses the code ofdivision thus resulting in more compact code sizeBarrett Reduction is an alternative method for modularreduction [28] It converts the reduction modulo an arbi-trary integer to two multiplications and a few reductionsmodulo integers of the form 2n When used to reduce asingle number Barrett reduction is slower than a normaldivision algorithm However when used to reduce vari-ous numbers modulo the same number many times by pre-computing some value Barrett reduction can achieve fasterspeed than modular reductions obtained by division De-tails of Barrett reduction can be found in [28]In TinyECC since almost all the modular operationsare modulo the same prime number p Barrett reductioncan potentially speed up the computation However thisrequires the implementation of a separate reduction algo-rithm which implies larger code size (ie greater ROMrequirement) on sensor nodes In addition Barrett reduc-tion also increases RAM use Assume the target micro-controller has a w-bit word size Given a finite field Fpwhere p is a k words long prime number Barrett reductionrequires the pre-computation of µ =  bkp  where b = 2w(eg b = 28 on a 8-bit processor) This number µ has tobe stored and used throughout all the modular reductionsThus to exchange for faster computation Barrett reductionrequires more ROM and RAM than the traditional division-based modular reductionHybrid Multiplication and Hybrid Squaring [15]:Standard large integer multiplication algorithms [19] storethe operands and the product in arrays When such an al-gorithm is implemented in a high-level language such asnesC the compiler cannot use the registers in the micro-controller efficiently and the binary code usually needsto load the operands from memory to registers multipletimes [15] Gura et al [15] proposed a hybrid multipli-cation algorithm which was intended for assembly codeThis algorithm can maximize the utilization of registersand reduce the number of memory operations TinyECCadopts this hybrid multiplication algorithm for MICAz [2]TelosB [4]/Tmote Sky [6] and Imote2 [1] Indeed the codecan be used on any sensor platforms that have processorsusing the same instruction setsIn addition to hybrid multiplication we also customizethe hybrid multiplication algorithm for squaring operationsby using the fact that the two multiplicative operands insquaring are the same This further reduces the executiontime for squaring at the cost of larger code size42 Optimizations for ECC OperationsProjective Coordinate Systems [16]: As discussed ear-lier an elliptic curve consists of the infinity pointO and theset of points in the affine coordinates (xy) for xy∈ Fp thatsatisfy the defining equation Alternatively a point on anelliptic curve can be represented in a projective coordinatesystem in the form of (xyz)Point addition and point doubling are critical operationsin ECC which are building blocks for scalar multiplica-tions required by all ECC schemes These operations inaffine coordinate system require modular inversion oper-ations which are much more expensive than other oper-ations such as modular multiplications Using a projectivecoordinate system [16] modular inversions can be removedwith the compensation of a few modular multiplicationsand squares As a result the execution times of point ad-dition and point doubling based on projective coordinatesystem are faster than those based on affine coordinate sys-tem respectively [16]TinyECC uses two additional optimizations along withprojective coordinate representation which can further re-duce both the execution time and the program size Thefirst is a mixed point addition algorithm [16] which adds apoint in projective coordinate and a second point in affinecoordinate This algorithm can be used in scalar multipli-cations to further reduce the number of modular multiplica-tions and squares leading to smaller and faster code Thesecond is repeated Doubling [16] for scalar multiplicationIf consecutive point doublings are to be performed the re-peated doubling algorithm may be used to achieve fasterperformance than repeated use of the doubling formula Inm consecutive doublings this algorithm trades m− 1 fieldadditions m− 1 divisions by two and a multiplication fortwo field squarings (in comparison with repeated applica-tions of the plain point doubling algorithm) [16]Though reducing the execution time the projective co-ordinate representation requires a larger code size (for morecomplex formula) and more RAM (for storing additionalvariables) than the affine coordinate systemSliding Window for Scalar Multiplications [16]:Scalar multiplication is a basic operation used by all ECCschemes It is in the form of kP where k is an integer andP is a point on an elliptic curve In the most straightfor-ward method to compute kP k is scanned from the mostsignificant bit to the least significant bit When each bit isscanned the algorithm needs to compute a point doublingWhen the scanned bit is “1” the algorithm also needs toperform a point addition The sliding window method canspeed up the scalar multiplication by scanning w bits at atime Each time when a w-bit window is scanned the algo-rithm needs to perform w point doublings By precomput-ing 2P 3P  and (2w− 1)P the sliding window method248only needs to perform 1 point addition every w bits andthus has less computational costIt is easy to see that the sliding window method willincrease both the ROM (for additional code size) and RAM(for storing the pre-computed points) consumptionsShamir’s Trick [16]: This optimization is only usedfor the verification of ECDSA signatures The verificationof ECDSA signature requires the computation of the formaP+ bQ where ab are integers and PQ are two pointson an elliptic curve A straightforward implementationrequires two scalar multiplications and a point additionHowever Shamir’s trick allows us to compute the abovevalue at a cost close to one scalar multiplication Specif-ically with pre-computed P+Q we may scan the (same)bits of a and b from the most significant one to the leastsignificant one For each bit we need double the interme-diate value which is initialized as the infinity point If thescanned bit positions are 〈ai = 0bi = 1〉 〈ai = 1bi = 0〉or 〈ai = 1bi = 1〉 we add P Q or P+Q to the interme-diate value This reduces two scalar multiplications to be abit more expensive than one such operationSimilar to the sliding window method Shamir’s trickwill increase both the ROM (for additional code size) andRAM (for storing the pre-computed P+Q) consumptionsCurve Specific Optimization [15]: A number of el-liptic curves specified by NIST [30] and SECG [9] usepseudo-Mersenne primes A pseudo-Mersenne prime is ofthe form p = 2n − c where c  2n Reduction modulo apseudo-Mersenne prime can be performed by a few mod-ular multiplications and additions without any division op-eration As a result the time for modular reduction canbe reduced significantly Thus using elliptic curves overa pseudo-Mersenne prime can achieve additional perfor-mance gain5 ImplementationWe implemented TinyECC on TinyOS [5] an opensource operating system designed for wireless embeddedsensor networks The current version of TinyECC providessupport for ECDSA (digital signatures) ECDH (pairwisekey establishment) and ECIES (PKC-based encryption)Most of the code was written in nesC [14] for portabilityreasons To best harness the capabilities of the processorson popular sensor platforms such as MICAz and TelosBwe also provided inline assembly implementation of somecritical operations such as large integer multiplicationsTo save implementation efforts we ported the C code oflarge integer operations in RSAREF 20 [20] to nesC codeon TinyOS These include modular addition subtractionmultiplication division inverse and exponentiation opera-tions We then implemented all the elliptic curve operationsand the optimization techniques discussed earlierTinyECC has been released publicly at http://discoverycscncsuedu/software/TinyECC/ Some preliminary versions have beenadopted by other researchers (eg [11 21 27]) Asdiscussed earlier starting from the current version weadded a set of optimization switches to provide for flexibleconfiguration of TinyECC so that it can be integratedinto sensor network applications with different resourceconsumptions and performance demandsTable 1 lists the optimization switches available in thecurrent version of TinyECC All optimization switches canbe turned on or off by a simple configuration at compiletime or slight modification in the source code Moreoverwhen the sliding window method is used an additional pa-rameter defining the size of the window (eg w = 4) needsto be specified6 EvaluationWe performed a series of experiments to evaluateTinyECC on four representative sensor platforms includ-ing MICAz [2] TelosB [4] Tmote Sky [6] and Imote2 [1]The objective of these experiments is three-fold: Firstwe want to measure the performance and resource con-sumption of TinyECC on a spectrum of sensor platformsranging from the low-end ones (such as MICAz TelosBand Tmote Sky) to high-end ones (such as Imote2) Sec-ond we would like to understand the impact of the op-timizations adopted by TinyECC on performance and re-source consumption Finally we would like to provide de-tailed performance results and resource demands for com-monly desirable configurations including the configurationthat provides the fastest execution time and the configura-tion that requires the least memory consumption The for-mer has the least energy consumption while the latter is theeasiest one to integrate into sensor network applications61 Methodology and Experimental SetupEvaluation Methodology: Given seven optimizationswitches four sensor platforms where Imote2 has mul-tiple CPU frequencies due to dynamic voltage scalingmany possible elliptic curves and three ECC-based PKCschemes there are a large number of experiments to per-form if we have to observe the performance and resourceconsumptions in all casesTo simplify the scenarios we adopted the followingmethodology in our experiments For each optimizationswitch we performed two sets of experiments referred toas case A and case B respectively In case A for each opti-mization we disabled all the other optimizations and thenobtained the performance and resource consumption met-rics when the given optimization was enabled and disabledrespectively In case B we enabled all the other optimiza-tions and obtained the evaluation metrics again when thegiven optimization was enabled and disabled respectively249Table 1 TinyECC Optimization SwitchesMethod Optimization Switch Category DescriptionBarrett Reduction BARRETT large number Allow Barrett reductionHybrid Multiplication HYBRID MULT large number Allow hybrid multiplication in inline assemblyHybrid Squaring HYBRID SQR large number Allow hybrid squaring in inline assemblyProjective Coordinate System PROJECTIVE EC Use projective coordinate system along with mixed point addition and repeated doublingSliding Window Method SLIDING WIN EC Use sliding window method for scalar multiplication A window size (eg w = 4) has to bedefined along with this switchShamir’s Trick SHAMIR TRICK EC Allow Shamir’s trick when verifying ECDSA signatures A window size (eg w = 2) has to bedefined along with this switchCurve-Specific Optimization CURVE OPT EC Allow curve specification optimization This has to be used for the curves defined over pseudo-Mersenne primes [9 30]The differences in these metrics reflect the impact of thegiven optimization techniqueMoreover as discussed earlier we also performed ad-ditional experiments to examine in detail two commonlydesirable configurations: the one that provides the fastestexecution time and the one that requires the least storageExperimental Setup: We evaluated TinyECC on thelatest CVS version of TinyOS 1x [5] As discussed ear-lier we chose four representative sensor platforms MI-CAz TelosB Tmote Sky and Imote2 for the experimentssince they are popular sensor platforms and cover the 8-bit16-bit and 32-bit processors Other sensor platforms (egMica2 Mica2Dot) are expected to perform similarly to oneof these platforms due to the use of the same processorTelosB and Tmote Sky have almost the same hardwareThe only difference is that TelosB can only run at 4 MHzwhile Tmote Sky can run at 8 MHz when an external resis-tor is enabled We configure Tmote Sky to run at 8 MHz inour experiments Due to the similarity between TelosB andTmote Sky we only report the results on Tmote Sky in thispaper The reader may refer to the technical report versionof this paper [22] for experimental results on TelosBAs a high-end sensor platform Imote2 uses an XScaleprocessor and supports dynamic voltage scaling To ob-tain a relatively complete view of Imote2 we used four dif-ferent frequencies on Imote2 in our experiments: 13MHz104MHz 208MHz and 416MHzBy default TinyECC includes all 128-bit 160-bit and192-bit ECC parameters recommended by SECG [9] Itis well-known that 160-bit ECC has the same securitylevel as 1024-bit RSA We selected a 160-bit elliptic curvesecp160r1 [9] to evaluate the impact of individual op-timization techniques Note that the actual selection ofcurves depends on the security needs in the sensor networkapplications and is outside of the scope of this paperWe used the following evaluation metrics in all ex-periments: ROM consumption (byte) RAM consumption(byte) execution time (ms) and energy consumption (mil-lijoule) We used the check sizepl script in theTinyOS distribution to obtain the ROM and RAM sizes re-quired by the TinyECC components The execution timewas measured directly on the sensor nodes To get the over-all performance result we randomly generated the parame-ters (eg random message random public and private keypairs) other than those defining the curves and obtainedthe execution time for each data point by taking the av-erage of 10 test instances The energy consumption wasthen calculated as U × I × t based on the execution time(t) the voltage (U) and current draw (I) on these sensorplatforms [1 2 4 6]62 Evaluation ResultsDue to the space limit we can only report a portion ofthe evaluation results Please refer to the full version of thispaper [22] for more details621 Impact of Individual OptimizationsIn the following we use the experimental results forECDSA to show the impact of individual optimizationtechniques More results on the impacts of these optimiza-tions on ECDH and ECIES can be found in [22]There are three aspects of the execution time forECDSA Figures 1(a) and 1(b) show the initialization timerequired to prepare for ECDSA in cases A and B respec-tively Figures 1(c) and 1(d) show the signature generationtime in cases A and B respectively Figures 1(e) and 1(f)show the signature verification time in cases A and B re-spectivelyIn the initialization of ECDSA TinyECC needs to pre-compute µ for Barrett reduction a few points for the slid-ing window method and a few points for Shamir’s trickIn case A as Figure 1(a) shows only these 3 optimiza-tion techniques have impact on the initialization time ForMICAz the initialization of the sliding window methodwith window size 4 requires 3587 ms which is longerthan Shamir’s trick (1672 ms for window size 2) andBarrett reduction (6 ms) The same situation applies toTelosB/Tmote Sky and Imote2 If we disable all thesethree techniques the initialization time of ECDSA is closeto 0 In case B as Figure 1(b) shows the disabling of se-lected optimization technique does not reduce the initial-ization time dramatically except that the disabling of thesliding window method reduces the initialization time byhalfIn Figure 1 we can see that PROJECTIVE is the most25000781005190028100041000230002363978407710786400988004980027100781004880027800040000230002300781004880028400040000250002300781005800027700043000230002300781004270028200042000230002035866933246543263197278399632199811100027167187881146420214887841861049305046558000010010010000100000010000000010000000000MICAz(8 MHz)Tmote Sky(8 MHz)Imote2(13 MHz)Imote2(104 MHz)Imote2(208 MHz)Imote2(416 MHz)Time (ms)Disable All BARRETT HYBRID_MULT HYBRID_SQRCURVE_OPT PROJECTIVE SLIDING_WIN(w=4) SHAMIR_TRICK(w=2)(a) Init time when all other optimizations are disabled (case A)34933625451834125426821341074254420340464257212910713772852594953601245012250113235720825669034692433621681091382672293496378474731236611853292862327403002237531876940168446123010164502056102851736261426411535318441422071111348692000010010010000100000010000000010000000000MICAz(8 MHz)Tmote Sky(8 MHz)Imote2(13 MHz)Imote2(104 MHz)Imote2(208 MHz)Imote2(416 MHz)Time (ms)Enable All BARRETT HYBRID_MULT HYBRID_SQRCURVE_OPT PROJECTIVE SLIDING_WIN(w=4) SHAMIR_TRICK(w=2)(b) Init time when all other optimizations are enabled (case B)30723002128439278511348111740687123176027217796129365836706183539181304237421220112766763458217291865630207652119615275048343791718929591552091837271026338761693884819086124177888911311139557028312527389173334122709028384141927107307255721323552785103481117406871286041101001000100001000001000000MICAz(8 MHz)Tmote Sky(8 MHz)Imote2(13 MHz)Imote2(104 MHz)Imote2(208 MHz)Imote2(416 MHz)Time (ms)Disable All BARRETT HYBRID_MULT HYBRID_SQRCURVE_OPT PROJECTIVE SLIDING_WIN(w=4) SHAMIR_TRICK(w=2)(c) Sig generation time when all other optimizations are disabled (case A)2001621580633639845632282118020079715856036497458622931195324944186571447395592279314342957781894934319753992700406637304578611527644382119252356596167772321797927245136206828245695204165459205740287014782001621583223657345722286118213911101001000100001000001000000MICAz(8 MHz)Tmote Sky(8 MHz)Imote2(13 MHz)Imote2(104 MHz)Imote2(208 MHz)Imote2(416 MHz)Time (ms)Enable All BARRETT HYBRID_MULT HYBRID_SQRCURVE_OPT PROJECTIVE SLIDING_WIN(w=4) SHAMIR_TRICK(w=2)(d) Sig generation time when all other optimizations are enabled (case B)61800344288627556035694993474917400638929043841095863277328536643183316119770427249455238769044345221728760761774267535549107686413431759517104211565541192676453382216955182949484256717837322295111465619508071234745254514045642128210141203048470207936927100333873169378477171751101001000100001000001000000MICAz(8 MHz)Tmote Sky(8 MHz)Imote2(13 MHz)Imote2(104 MHz)Imote2(208 MHz)Imote2(416 MHz)Time (ms)Disable All BARRETT HYBRID_MULT HYBRID_SQRCURVE_OPT PROJECTIVE SLIDING_WIN(w=4) SHAMIR_TRICK(w=2)(e) Sig verification time when all other optimizations are disabled (case A)2436462016024468556022801144924420920201044629559627981449410800241119557076963347817843556522347825258765733287504830380469754559431471523752850993201573126063632577162918165243649201840447575594279714484020433175117255290684534233816931101001000100001000001000000MICAz(8 MHz)Tmote Sky(8 MHz)Imote2(13 MHz)Imote2(104 MHz)Imote2(208 MHz)Imote2(416 MHz)Time (ms)Enable All BARRETT HYBRID_MULT HYBRID_SQRCURVE_OPT PROJECTIVE SLIDING_WIN(w=4) SHAMIR_TRICK(w=2)(f) Sig verification time when all other optimizations are enabled (case B)Figure 1 ECDSA timing result (Projective coordinate system is the most effective optimization while Barrettreduction does not have obvious impact)effective switch to improve the speed of signature genera-tion and verification In case A by enabling the PROJEC-TIVE switch the signature generation and verification of allplatforms can speed up by at least 3 times In case B if wedisable the PROJECTIVE switch the signature generationand verification has at least 6 times slowdown comparedwith enabling all optimization techniquesAlthough PROJECTIVE is the most efficient switch itincreases the ROM usage Figures 2(a) and 2(b) show thatwhen the PROJECTIVE switch is enabled in case A theROM size is increased by 1218 1326 and 1752 bytesfor MICAz TelosB/Tmote Sky and Imote2 respectivelywhile the RAM size does not change at all In case Bas Figures 2(c) and 2(d) show disabling the PROJECTIVEswitch can save 3816 3880 and 4660 bytes in ROM forMICAz TelosB/Tmote Sky and Imote2 respectively ThePROJECTIVE switch is the most effective switch to speedup ECDSA operations but it also incurs larger ROM con-sumption than any other optimization techniqueSHAMIR TRICK is also an efficient option to speed upECDSA signature verification From Figure 1(e) we cansee that the verification can speed up by 2 times on allplatforms when enabling SHAMIR TRICK in case A BothROM and RAM sizes are increased In case A the RAMsize is increased by 634 676 and 784 bytes for MICAzTelosB/Tmote Sky and Imote2 respectively Similarly the251ROM size of MICAz TelosB/Tmote Sky and Imote2 is in-creased by 638 632 and 620 bytes respectively In caseB disabling SHAMIR TRICK makes verification 16 timesslower but saves 2148 2068 and 2208 bytes in ROM forMICAz TelosB/Tmote Sky and Imote2 respectively TheRAM size does not decrease much because the sliding win-dow method is used for verification when SHAMIR TRICKis disabledNow let us take a look at the SLIDING WIN option Incase A as Figures 1(c) 1(e) 2(a) and 2(b) show enablingSLIDING WIN can make signature generation and verifica-tion 12 times faster at the cost of dramatic RAM increase(1262 1328 and 1472 bytes for MICAz TelosB/TmoteSky and Imote2 respectively) In case B as Figures1(d) 1(f) 2(c) and 2(d) show disabling SLIDING WINcan save 632 668 and 752 bytes of RAM for MICAzTelosB/Tmote Sky and Imote2 with 12 times slower sig-nature generation and verification Since MICAz andTelosB/Tmote Sky are low-end sensor platforms they havemuch smaller RAM (4kB 10kB) compared with Imote2(256kB) Before enabling SLIDING WIN we should bevery careful if the sensing application has large RAM con-sumption Since SLIDING WIN is the most RAM consum-ing switch in TinyECC application developers may disableit or reduce the window size to reserve more RAM for theapplicationsNow consider the HYBRID MULT HYBRID SQR andCURVE OPT options In case A HYBRID MULT HY-BRID SQR and CURVE OPT do not have big impact onthe timing result However in case B HYBRID MULTcan speed up signature generation by 16 times for MI-CAz 12 times for TelosB/Tmote Sky and 12 times forImote2 Similarly it can speed up signature verificationby 17 times for MICAz 12 times for TelosB/Tmote Skyand 12 times for Imote2 HYBRID SQR can speed up sig-nature generation by 15 times for MICAz 12 times forTelosB/Tmote Sky and 12 times for Imote2 and speed upsignature verification by 15 times for MICAz 12 times forTelosB/Tmote Sky and 12 times for Imote2 CURVE OPTcan speed up signature generation by 2 times for MICAz19 times for TelosB/Tmote Sky and 17 times for Imote2Similarly it can speed up signature verification by 21times for MICAz 19 times for TelosB/Tmote Sky and17 times for Imote2 The reason that HYBRID MULTHYBRID SQR and CURVE OPT cannot speed up ECDSAmuch in case A is that the PROJECTIVE option is disabledwhen each of these switches is enabled Thus inverse op-eration is the major computation of signature generationand verification In case B when PROJECTIVE is enabledmultiplication and squaring become the major computationin ECDSABased on the timing results obtained for ECDSA theeffectiveness of these optimization switches in terms of10180817286441146893581004811278820886961150083108824106908660923211398949810396103748364889610818880492640500010000150002000025000MICAz Tmote Sky Imote2ROM size (Byte)Disable All BARRETT HYBRID_MULT HYBRID_SQRCURVE_OPT PROJECTIVE SLIDING_WIN(w=4) SHAMIR_TRICK(w=2)(a) ROM size w/ all other optimizations disabled (case A)152160176244258292152160176152160176152160176152160176141414881648786836 96005001000150020002500MICAz Tmote Sky Imote2RAM size (Byte)Disable All BARRETT HYBRID_MULT HYBRID_SQRCURVE_OPT PROJECTIVE SLIDING_WIN(w=4) SHAMIR_TRICK(w=2)(b) RAM size w/ all other optimizations disabled (case A)1930814708163521797013520149401837814672163001808014570161721824613904154521549210828116921819613546149721716012640141440500010000150002000025000MICAz Tmote Sky Imote2ROM size (Byte)Enable All BARRETT HYBRID_MULT HYBRID_SQRCURVE_OPT PROJECTIVE SLIDING_WIN(w=4) SHAMIR_TRICK(w=2)(c) ROM size w/ all other optimizations enabled (case B)15101602 182814181504 171215101602 182815101602 182815101602 182815101602 1828878934 107615061586176405001000150020002500MICAz Tmote Sky Imote2RAM size (Byte)Disable All BARRETT HYBRID_MULT HYBRID_SQRCURVE_OPT PROJECTIVE SLIDING_WIN(w=4) SHAMIR_TRICK(w=2)(d) RAM size w/ all other optimizations enabled (case B)Figure 2 Code size of ECDSA (Sliding window hasthe most memory demand Shamir’s trick ranks thenext while all the other optimizations have similarmemory demands)252Available ROM (byte) How to Conf TinyECC’s Switches[1018010374) disable all[1037411398) enable SLIDING WIN[1139817160) enable PROJECTIVE[1716017970) enable all & disable SHAMIR TRICK[1797019308) enable all & disable BARRETT[19308+∞) enable allTable 2 Configuration based on Free ROM for MICAzAvailable RAM (byte) How to Conf TinyECC’s Switches[152786) disable all[786878) enable SHAMIR TRICK[8781418) enable all & disable SLIDING WIN[14181510) enable all & disable BARRETT[1510+∞) enable allTable 3 Configuration based on Free RAM for MICAzexecution time can be ordered as follows: PROJECTIVE> CURVE OPT > HYBRID MULT > HYBRID SQR >SLIDING WIN > SHAMIR TRICK > BARRETT In termsof RAM size the optimization switches can be ordered asfollows: SLIDING WIN > SHAMIR TRICK > BARRETT> HYBRID MULT = HYBRID SQR = CURVE OPT =PROJECTIVEIn terms of ROM size the optimization switches are or-dered differently for different platforms For MICAz PRO-JECTIVE > BARRETT ≈ HYBRID SQR > CURVE OPT≈ SHAMIR TRICK ≈ HYBRID MULT > SLIDING WINFor TelosB/Tmote Sky PROJECTIVE > BARRETT ≈SHAMIR TRICK > CURVE OPT ≈ SLIDING WIN >HYBRID SQR > HYBRID MULT For Imote2 PROJEC-TIVE > BARRETT > SHAMIR TRICK ≥ CURVE OPT >SLIDING WIN > HYBRID SQR > HYBRID MULTConfiguration Guideline: To summarize and assistusers of TinyECC in Tables 2 and 3 we show how tochoose optimization switches on MICAz motes when theamount of available ROM and RAM for TinyECC can beestimated TinyECC requires at least 10180 bytes ROMand 152 bytes RAM to be used on MICAz As more ROMand RAM are available we can gradually enable the opti-mization switches as indicated in these tables to get betterperformance For example having a ROM size between11398 bytes and 17160 bytes allows us to enable bothSLIDING WIN and PROJECTIVE switches (but not oth-ers) Note that an optimization can be enabled if both ROMand RAM sizes allow it Optimization switches can be de-termined for other platforms similarly622 Most Computationally Efficient ConfigurationNow consider the most computationally efficient con-figuration Apparently TinyECC provides the most com-putationally efficient configuration when all the optimiza-34933620016224364618387439074626326618387421174325451815806320160213193232710121277713195417559634125363984468517834736974661017916 392124268456356022229920658152239 49012134228228011115460629131120 2451107411801449564242615105651289110100100010000100000init(ECDSA)sign(ECDSA)verify(ECDSA)init(ECIES)encrypt(ECIES)decrypt(ECIES)init(ECDH)key establish(ECDH)Time (ms)MICAz (8 MHz) Tmote Sky (8 MHz) Imote2 (13 MHz) Imote2 (104 MHz) Imote2 (208 MHz) Imote2 (416 MHz)Figure 3 Execution time of ECDSA ECIES andECDH w/ all optimization switches enabledtion switches are enabled Figure 3 shows the executiontime required by ECDSA initialization signature genera-tion signature verification; ECIES initialization encryp-tion decryption; ECDH initialization key establishmentFrom figure 3 we can see that enabling all optimiza-tion switches requires long pre-computation For exam-ple it takes MICAz 3493 1839 and 1839 ms to do pre-computation for ECDSA ECIES and ECDH respectivelyMost of the pre-computation time is for the sliding win-dow method and Shamir’s trick (ECDSA only) Tmote Skyruns slightly faster than MICAz Running at 13 MHz thedefault CPU frequency for Imote2 Imote2 is faster thanTmote Sky in all operations If we set the frequency to416 MHz it only takes 12 and 14 ms to generate ECDSAsignature and verify it Moreover it can perform ECIESencryption in 24 ms and decrypt in 15 ms Finally ECDHkey establishment only takes 13 msEnabling all optimization switches requires the largestROM and RAM consumptions Figure 4 shows the ROMand RAM requirements by all schemes Imote2 has thelargest RAM size due to its word size MICAz has thesmallest RAM size due to its 8-bit word size but it has thelargest ROM size because it has additional assembly codefor minimizing memory operation when CURVE OPT op-tion is enabledNow consider the energy consumption of ECDSAECIES and ECDH on the testing platforms We estimateenergy consumption using W = U × I× t where U is thevoltage I is the current draw in active mode with radio offand t is the execution time We took the voltage and cur-rent draw (with radio off) from the data sheet of each sensorplatform [1 2 4 6] and used the execution time obtainedin our experiments Specifically we chose U as 3v for MI-CAz and TelosB/Tmote Sky The current draw for MICAzand TelosB/Tmote Sky was 8 mA and 18 mA respectivelyFor Imote2 U is 095v for 13 MHz and 104 MHz [1] TheImote2 data sheet [1] does not give the current draw whenthe node runs at 104 MHz with radio off To be conserva-tive we use the current draw with radio on in our compu-tation That is we chose 31 mA and 66 mA for Imote2 at253207681601813520 1565811396163521772812852193080500010000150002000025000ECDSA ECIES ECDHROM size (byte)MICAz Tmote Sky Imote2(a) ROM size177417741504 181618161828 20642064151005001000150020002500ECDSA ECIES ECDHRAM size (byte)MICAz Tmote Sky Imote2(b) RAM sizeFigure 4 Code size of ECDSA ECIES and ECDH w/all optimization switches enabled83844804 5848441393786318441350821374854 108971217661149713 94810051072131652521701373528 1155268286 351140 577365140 3070102030405060708090100init(ECDSA)sign(ECDSA)verify(ECDSA)init(ECIES)encrypt(ECIES)decrypt(ECIES)init(ECDH)key establish(ECDH)Energy consumption (mJ)MICAz (8 MHz) Tmote Sky (8 MHz) Imote2 (13 MHz) Imote2 (104 MHz)Figure 5 Energy consumption of ECDSA ECIESand ECDH w/ all optimization switches enabled13 MHz and 104 MHzFigure 5 shows the energy consumption required by allthese operations Imote2 is the most energy efficient plat-form when it runs at 104 MHz It needs 286 mJ and 351mJ to generate ECDSA signature and verify it; it needs577 mJ and 365 mJ to do ECIES encryption and decryp-tion; and it needs 307 mJ for the ECDH key agreementoperation MICAz is the most energy consuming platformTelosB/Tmote Sky is quite efficient at energy consumptiondue to its low current draw with radio off623 Most Storage-Efficient ConfigurationMany TinyOS applications may use TinyECC for au-thentication encryption/decryption or key establishment00830723006180034008614018331872280083120821005212843942886270054255809214150600421151530032785115560350045514292811870042718310003481169499001689233514500133977000174063474900034463175730001698900087121740000017242880200085050001001011101001000100001000001000000init(ECDSA)sign(ECDSA)verify(ECDSA)init(ECIES)encrypt(ECIES)decrypt(ECIES)init(ECDH)key establish(ECDH)Time (ms)MICAz (8 MHz) Tmote Sky (8 MHz) Imote2 (13 MHz) Imote2 (104 MHz) Imote2 (208 MHz) Imote2 (416 MHz)Figure 6 Execution time of ECDSA ECIES andECDH w/ all optimization switches disabledThus it is likely that TinyECC will be loaded on sen-sor nodes with other applications Due to the resourceconstraint of low-end sensor platforms (eg MICAzTelosB/Tmote Sky) we may have to reduce ROM andRAM consumption by disabling some optimizations to re-serve enough space for the sensing applicationsFor example when all optimizations are enabledECDSA needs 19308 bytes ROM and 1510 bytes RAMon MICAz as figure 4 shows Stack overflow may happenwhen TinyECC is integrated with other programs such asTOSBase; the available stack for local variables may notbe large enough due to the limited RAM (4K bytes) onMICAz As another example Tmote Sky only has 48Kbytes ROM If ECDSA with all optimizations enabled isintegrated with the SurgeTelos a popular TinyOS applica-tion [5] the total ROM size would be 40380 bytes leavinglittle space for other applicationsWe can disable all optimizations to show how compactTinyECC could be Figure 6 shows the execution time ofECDSA ECIES and ECDH when all optimization switchesare disabled In this case no pre-computation is neededand the initialization time is close to 0 Imote2 runningat 416 MHz is still the fastest one which MICAz is theslowest oneThe benefit of disabling all optimizations is the compactcode size Figure 7 shows the code size of all schemes inTinyECC when all optimization switches are disabled Dueto their word size Imote2 has the largest RAM size whileMICAz has the smallest RAM size The code size has beenreduced greatlySince the execution time of TinyECC is much longerthe energy consumption of TinyECC is also increased asfigure 8 shows In our experiments the energy cost is in-creased by 6 to 254 times Please refer to the technicalreport version of this paper [22] for detailed discussion7 Related WorkA comprehensive guide for elliptic curve cryptographyis given in [16] Additional documentation on ECC can be2541244286348172 1043469508644 109046876101800500010000150002000025000ECDSA ECIES ECDHROM size (byte)MICAz Tmote Sky Imote2(a) ROM size15015016015815817617217215205001000150020002500ECDSA ECIES ECDHRAM size (byte)MICAz Tmote Sky Imote2(b) RAM sizeFigure 7 Code size of ECDSA ECIES and ECDH w/all optimization switches disabled000737351483210001473647649300074900000 11494231590002298111564000 11422000 820216375000 162408281000 8005000 21834358000 43212204000 21300400800120016002000init(ECDSA)sign(ECDSA)verify(ECDSA)init(ECIES)encrypt(ECIES)decrypt(ECIES)init(ECDH)key establish(ECDH)Energy consumption (mJ)MICAz (8 MHz) Tmote Sky (8 MHz) Imote2 (13 MHz) Imote2 (104 MHz)Figure 8 Energy consumption of ECDSA ECIESand ECDH w/ all optimization switches disabledfound in [7–9] There have been numerous ECC implemen-tations in various contexts (eg Crypto++ [10]) Most ofthese implementations are aimed at traditional computingplatforms such as PCsSeveral recent efforts have focused on sensor platformssuch as the MICA series of motes Malan et al imple-mented ECC over binary extension fields F2m on TinyOSfor Mica2 [26] Unfortunately due to the constraints onthe typical micro-controllers used on sensor platforms itis difficult to obtain efficient ECC implementation overF2m  Gura et al implemented and compared ECC andRSA on Atmel ATmega128 in assembly [15] Howeverit is not clear how well their implementation can be inte-grated into sensor network applications Wang et al imple-mented ECC on specific 160-bit elliptic curves on MICAzand TelosB running TinyOS [33] They obtained fast ex-ecution time by hard-coding all the curve parameters intoassembly codeA common limitation of all these efforts is that allthese attempts were developed as independent pack-ages/applications without seriously considering the re-source demands of sensor network applications As a re-sult developers may find it difficult and sometimes im-possible to integrate an ECC implementation with thesensor network applications (eg not enough ROM orRAM) though the ECC implementation may be okay on itsown In contrast TinyECC provides a set of optimizationswitches that allow itself to be configured with different re-source consumptions This allows TinyECC to be flexiblyintegrated into sensor network applications8 ConclusionIn this paper we presented the design implementationand evaluation of TinyECC A unique feature of TinyECCis its configurability It provides a number of optimizationswitches which can turn specific optimizations on or offbased on developers’ needs Different combinations of theoptimizations have different execution time and resourceconsumptions and thus give the developers flexibility inintegrating TinyECC into sensor network applications Wealso performed a series of experiments to evaluate the per-formance and resource consumptions of TinyECC withdifferent combinations of enabled optimizations and pro-vided guidelines for configuring TinyECC for sensor net-work applicationsAs a final note we would like to point out that PKCcomponents could become the source of attacks if not prop-erly used In particular developers should pay special at-tention to Denial of Service (DoS) attacks against PKCFor example TinyECC has been used to bootstrap securecode dissemination in wireless sensor networks [11 17]However if there is no additional protection an attackermay repeatedly claim that a new code image is availableand convincing sensor nodes to perform many PKC opera-tions eventually exhausting their battery power Additionalmechanisms such as message specific puzzles [31] is thusnecessaryAcknowledgment We would like to thank Ben Greensteinfor shepherding our paper Panos Kampanakis ported anearlier version of TinyECC to Imote2 We are grateful tothe anonymous reviewers for their helpful commentsReferences[1] Imote2: High-performance wireless sensor networknode http://wwwxbowcom/Products/Product_pdf_files/Wireless_pdf/Imote2_Datasheetpdf[2] MICAz: Wireless measurement system http://wwwxbowcom/Products/Product_pdf_255files/Wireless_pdf/MICAz_Datasheetpdf[3] SSL 30 specification http://wpnetscapecom/eng/ssl3/[4] TelosB mote platform http://wwwxbowcom/Products/Product_pdf_files/Wireless_pdf/TelosB_Datasheetpdf[5] TinyOS: An open-source OS for the networked sensorregime http://wwwtinyosnet/[6] Tmote sky: Reliable low-power wireless sensor network-ing eases development and deployment http://wwwmoteivcom/products-tmoteskyphp[7] American Bankers Association ANSI X962-1998: PublicKey Cryptography for the Financial Services Industry: theElliptic Curve Digital Signature Algorithm (ECDSA) 1999[8] Certicom Research Standards for efficient cryp-tography – SEC 1: Elliptic curve cryptographyhttp://wwwsecgorg/download/aid-385/sec1_finalpdf September 2000[9] Certicom Research Standards for efficient cryptography– SEC 2: Recommended elliptic curve domain parame-ters http://wwwsecgorg/collateral/sec2_finalpdf September 2000[10] W Dai Crypto++ library 55 http://wwwcryptoppcom/ May 2007[11] J Deng R Han and S Mishra Secure code distributionin dynamically programmable wireless sensor networks InProceedings of the Fifth International Conference on Infor-mation Processing in Sensor Networks (IPSN ’06) April2006[12] W Diffie and ME Hellman New directions in cryptogra-phy IEEE Transactions on Information Theory IT-22:644–654 November 1976[13] L Eschenauer and V D Gligor A key-management schemefor distributed sensor networks In Proceedings of the 9thACM Conference on Computer and Communications Secu-rity pages 41–47 November 2002[14] D Gay P Levis R von Behren M Welsh E Brewer andD Culler The nesC language: A holistic approach to net-worked embedded systems In Proceedings of Program-ming Language Design and Implementation (PLDI ’03)June 2003[15] N Gura A Patel and A Wander Comparing elliptic curvecryptography and RSA on 8-bit CPUs In Proceedings of the2004 Workshop on Cryptographic Hardware and EmbeddedSystems (CHES 2004) pages 119–132 August 2004[16] D Hankerson A Menezes and S Vanstone Guide to El-liptic Curve Cryptography Springer 2004[17] S Hyun P Ning A Liu and W Du Seluge: Secureand dos-resistant code dissemination in wireless sensor net-works In Proceedings of the Seventh International Confer-ence on Information Processing in Sensor Networks (IPSN’08) April 2008[18] S Kent and R Atkinson IP authentication header IETFRFC 2402 November 1998[19] DE Knuth The Art of Computer Programming volume 2:Seminumerical Algorithms Addison-Wesley third edition1997 ISBN: 0-201-89684-2[20] RSA Laboratories RSAREF: A cryptographic toolkit (ver-sion 20) March 1994[21] PE Lanigan R Gandhi and P Narasimhan Sluice: Se-cure dissemination of code updates in sensor networks InProceedings of the 26th International Conference on Dis-tributed Computing Systems (ICDCS ’06) July 2006[22] A Liu and P Ning TinyECC: A configurable library for el-liptic curve cryptography in wireless sensor networks Tech-nical Report TR-2007-36 North Carolina State UniversityDepartment of Computer Science 2007[23] D Liu and P Ning Establishing pairwise keys in distributedsensor networks In Proceedings of 10th ACM Confer-ence on Computer and Communications Security (CCS’03)pages 52–61 October 2003[24] D Liu and P Ning Multi-level µTESLA: Broadcast au-thentication for distributed sensor networks ACM Transac-tions in Embedded Computing Systems (TECS) 3(4):800–836 2004[25] D Liu P Ning S Zhu and S Jajodia Practical broad-cast authentication in sensor networks In Proceedings ofthe 2nd Annual International Conference on Mobile andUbiquitous Systems: Networking and Services (MobiQui-tous 2005) July 2005[26] D Malan M Welsh and M Smith A public-key infras-tructure for key distribution in tinyos based on elliptic curvecryptography In Proceedings of IEEE Conference on Sen-sor and Ad Hoc Communications and Networks (SECON)pages 71–80 2004[27] K Malasri and L Wang Addressing security in medicalsensor networks In HealthNet ’07: Proceedings of the 1stACM SIGMOBILE international workshop on Systems andnetworking support for healthcare and assisted living envi-ronments pages 7–12 2007[28] AJ Menezes P C van Oorschot and SA Vanstone Hand-book of Applied Cryptography CRC Press 1996 ISBN:0-8493-8523-7[29] National Institute of Standards and Technology Federal in-formation processing standard 186: Digital signature stan-dard http://csrcnistgov/publications/1993[30] National Institute of Standards and Technology Recom-mended elliptic curves for federal government use August1999[31] P Ning A Liu and W Du Mitigating DoS attacks againstbroadcast authentication in wireless sensor networks ACMTransactions on Sensor Networks 4(1) February 2008[32] A Perrig R Canetti D Song and D Tygar Efficientauthentication and signing of multicast streams over lossychannels In Proceedings of the 2000 IEEE Symposium onSecurity and Privacy May 2000[33] H Wang and Q Li Efficient implementation of public keycryptosystems on mote sensors In Proceedings of Interna-tional Conference on Information and Communication Se-curity (ICICS) pages 519–528 Dec 2006256
wang-Surevey of security WSN-pdf,University of Nebraska - LincolnDigitalCommons@University of Nebraska - LincolnCSE Journal Articles Computer Science and Engineering Department of1-1-2006A Survey of Security Issues In Wireless SensorNetworksYong WangUniversity of Nebraska - LincolnGarhan AtteburyUniversity of Nebraska - Lincoln gattebury2@unleduByrav RamamurthyUniversity of Nebraska - Lincoln bramamurthy2@unleduFollow this and additional works at: http://digitalcommonsunledu/csearticlesPart of the Computer Sciences CommonsThis Article is brought to you for free and open access by the Computer Science and Engineering Department of at DigitalCommons@University ofNebraska - Lincoln It has been accepted for inclusion in CSE Journal Articles by an authorized administrator of DigitalCommons@University ofNebraska - LincolnWang Yong; Attebury Garhan; and Ramamurthy Byrav "A Survey of Security Issues In Wireless Sensor Networks" (2006) CSEJournal Articles Paper 84http://digitalcommonsunledu/csearticles/84IEEE Communications Surveys & Tutorials • 2nd Quarter 20062dvances in wireless communication and electronicshave enabled the development of low-cost low-power multifunctional sensor nodes These tiny sen-sor nodes consisting of sensing data processing andcommunication components make it possible to deploy Wire-less Sensor Networks (WSNs) which represent a significantimprovement over traditional wired sensor networks WSNscan greatly simplify system design and operation as the envi-ronment being monitored does not require the communica-tion or energy infrastructure associated with wired networks[1]WSNs are expected to be solutions to many applicationssuch as detecting and tracking the passage of troops and tankson a battlefield monitoring environmental pollutants measur-ing traffic flows on roads and tracking the location of person-nel in a building Many sensor networks have mission-criticaltasks and thus require that security be considered [2 3]Improper use of information or using forged information maycause unwanted information leakage and provide inaccurateresultsWhile some aspects of WSNs are similar to traditionalwireless ad hoc networks important distinctions exist whichgreatly affect how security is achieved The differencesbetween sensor networks and ad hoc networks are [4]:• The number of sensor nodes in a sensor network can beseveral orders of magnitude higher than the nodes in anad hoc network• Sensor nodes are densely deployed• Sensor nodes are prone to failures due to harsh environ-ments and energy constraints• The topology of a sensor network changes very frequentlydue to failures or mobility• Sensor nodes are limited in computation memory andpower resources• Sensor nodes may not have global identificationThese differences greatly affect how secure data-transferschemes are implemented in WSNs For example the use ofradio transmission along with the constraints of small sizelow cost and limited energy make WSNs more susceptible todenial-of-service attacks [5] Advanced anti-jamming tech-niques such as frequency-hopping spread spectrum and physi-cal tamper-proofing of nodes are generally impossible in asensor network due to the requirements of greater designcomplexity and higher energy consumption [5] Furthermorethe limited energy and processing power of nodes makes theuse of public key cryptography nearly impossible While theAYONG WANG GARHAN ATTEBURY AND BYRAV RAMAMURTHYUNIVERSITY OF NEBRASKA-LINCOLNABSTRACTWireless Sensor Networks (WSNs) are used in many applications in mil-itary ecological and health-related areas These applications often includethe monitoring of sensitive information such as enemy movement on thebattlefield or the location of personnel in a building Security is thereforeimportant in WSNs However WSNs suffer from many constraints includ-ing low computation capability small memory limited energy resourcessusceptibility to physical capture and the use of insecure wireless communi-cation channels These constraints make security in WSNs a challenge Inthis article we present a survey of security issues in WSNs First we outlinethe constraints security requirements and attacks with their correspondingcountermeasures in WSNs We then present a holistic view of securityissues These issues are classified into five categories: cryptography keymanagement secure routing secure data aggregation and intrusion detec-tion Along the way we highlight the advantages and disadvantages of vari-ous WSN security protocols and further compare and evaluate theseprotocols based on each of these five categories We also point out theopen research issues in each subarea and conclude with possible futureresearch directions on security in WSNsA SURVEY OF SECURITY ISSUES INWIRELESS SENSOR NETWORKS2ND QUARTER 2006 VOLUME 8 NO 2wwwcomsocorg/pubs/surveys1553-877X                IEEE Communications Surveys & Tutorials • 2nd Quarter 2006 3results from recent studies show that public keycryptography might be feasible in sensor net-works [6 7] it remains for the most part infeasi-ble in WSNs Instead most security schemesmake use of symmetric key cryptography Onething required in either case is the use of keys forsecure communication Managing key distributionis not unique to WSNs but again constraints suchas small memory capacity make centralized key-ing techniques impossible Straight pairwise keysharing between every two nodes in a networkdoes not scale to large networks with tens ofthousands of nodes as the storage requirementsare too high A security scheme in WSNs mustprovide efficient key distribution while maintain-ing the ability for communication between all rel-evant nodesIn addition to key distribution secure routingprotocols must be considered These protocolsare concerned with how a node sends messagesto other nodes or a base station A key challengeis that of authenticated broadcast Existingauthenticated broadcast methods often rely onpublic key cryptography and include high computational over-head making them infeasible in WSNs Secure routing proto-cols proposed for use in WSNs such as SPINS [8] mustconsider these factors Additionally the constraint on energyin WSNs leads to the desire for data aggregation This aggre-gation of sensor data needs to be secure in order to ensureinformation integrity and confidentiality [9 10] While this isachievable through cryptography an aggregation scheme musttake into account the constraints in WSNs and the uniquecharacteristics of the cryptography and routing schemes It isalso desirable for secure data aggregation protocols to be flex-ible allowing lower levels of security for less important datathus saving energy and allowing higher levels of security formore sensitive data thus consuming more energyAs with any network awareness of compromised nodesand attacks is desirable Many security schemes provide assur-ance that data remain intact and communication unaffected aslong as fewer than t nodes are compromised [11] The abilityof a node or base station to detect when other nodes are com-promised enables them to take action either ignoring thecompromised data or reconfiguring the network to eliminatethe threatThe remainder of this article discusses the above areas inmore detail and considers how they are all required to form acomplete WSN security scheme A few existing surveys onsecurity issues in ad hoc networks can be found in [12–14];however only small sections of these surveys focus on WSNsA recent survey article on security issues in mobile ad hocnetworks also included an overview of security issues in WSNs[15] However the article did not discuss cryptography andintrusion detection issues Further it included only a smallportion of the available literature on security in WSNsThe rest of this article is organized as follows Backgroundinformation on WSNs is presented followed by a discussionof attacks in the different network layers of sensor networksThen we focus on the selection of cryptography in WSNs keymanagement secure routing schemes secure data aggrega-tion and intrusion detection systems We discuss futureresearch directions on security in WSNs and then concludethe articleBACKGROUNDCOMMUNICATION ARCHITECTUREA WSN is usually composed of hundreds or thousands ofsensor nodes These sensor nodes are often densely deployedin a sensor field and have the capability to collect data androute data back to a base station (BS) A sensor consists offour basic parts: a sensing unit a processing unit a transceiverunit and a power unit [4] It may also have additional applica-tion-dependent components such as a location finding systempower generator and mobilizer (Fig 1) Sensing units areusually composed of two subunits: sensors and analog-to-digi-tal converters (ADCs) The ADCs convert the analog signalsproduced by the sensors to digital signals based on theobserved phenomenon The processing unit which is generallyassociated with a small storage unit manages the proceduresthat make the sensor node collaborate with the other nodesA transceiver unit connects the node to the network One ofthe most important units is the power unit A power unit maybe finite (eg a single battery) or may be supported by powerscavenging devices (eg solar cells) Most of the sensor net-work routing techniques and sensing tasks require knowledgeof location which is provided by a location finding systemFinally a mobilizer may sometimes be needed to move thesensor node depending on the applicationThe protocol stack used in sensor nodes contains physicaldata link network transport and application layers defined asfollows [4]:• Physical layer: responsible for frequency selection carrierfrequency generation signal deflection modulation anddata encryption• Data link layer: responsible for the multiplexing of datastreams data frame detection medium access and errorcontrol; as well as ensuring reliable point-to-point andpoint-to-multipoint connections• Network layer: responsible for specifying the assignmentof addresses and how packets are forwarded• Transport layer: responsible for specifying how the reli-able transport of packets will take place• Application layer: responsible for specifying how the dataare requested and provided for both individual sensornodes and interactions with the end usernFigure 1 The components of a sensor node (Source: [4])PowergeneratorSensing unitSensorProcessing unitProcessorStorageTransmissionunitTransceiverADCPower unitPosition finding system MobilizerInternetUserBSSensor node          IEEE Communications Surveys & Tutorials • 2nd Quarter 20064CONSTRAINTS IN WSNSIndividual sensor nodes in a WSN are inherently resourceconstrained They have limited processing capability storagecapacity and communication bandwidth Each of these limita-tions is due in part to the two greatest constraints — limitedenergy and physical size Table 1 shows several currently avail-able sensor node platforms The design of security services inWSNs must consider the hardware constraints of the sensornodes:• Energy: energy consumption in sensor nodes can be cate-gorized into three parts:–Energy for the sensor transducer–Energy for communication among sensor nodes–Energy for microprocessor computationThe study in [20 21] found that each bit transmitted inWSNs consumes about as much power as executing 800–1000instructions Thus communication is more costly than compu-tation in WSNs Any message expansion caused by securitymechanisms comes at a significant cost Further higher secu-rity levels in WSNs usually correspond to more energy con-sumption for cryptographic functions Thus WSNs can bedivided into different security levels depending on energy cost[22 23]• Computation: the embedded processors in sensor nodesare generally not as powerful as those in nodes of awired or ad hoc network As such complex cryptographicalgorithms cannot be used in WSNs• Memory: memory in a sensor node usually includes flashmemory and RAM Flash memory is used for storingdownloaded application code and RAM is used for stor-ing application programs sensor data and intermediatecomputations There is usually not enough space to runcomplicated algorithms after loading OS and applicationcode In the SmartDust project for example TinyOSconsumes about 3500 bytes of instruction memory leav-ing only 4500 bytes for security and applications [20 21]This makes it impractical to use the majority of currentsecurity algorithms [8] With an Intel Mote the situationis slightly improved but still far from meeting therequirements of many algorithms• Transmission range: the communication range of sensornodes is limited both technically and by the need to con-serve energy The actual range achieved from a giventransmission signal strength is dependent on variousenvironmental factors such as weather and terrainSECURITY REQUIREMENTSThe goal of security services in WSNs is to protect the infor-mation and resources from attacks and misbehavior Thesecurity requirements in WSNs include:• Availability which ensures that the desired network ser-vices are available even in the presence of denial-of-ser-vice attacks• Authorization which ensures that only authorized sensorscan be involved in providing information to network ser-vices• Authentication which ensures that the communicationfrom one node to another node is genuine that is amalicious node cannot masquerade as a trusted networknode• Confidentiality which ensures that a given message can-not be understood by anyone other than the desiredrecipients• Integrity which ensures that a message sent from onenode to another is not modified by malicious intermedi-ate nodes• Nonrepudiation which denotes that a node cannot denysending a message it has previously sent• Freshness which implies that the data is recent andensures that no adversary can replay old messagesMoreover as new sensors are deployed and old sensorsfail we suggest that forward and backward secrecy should alsobe considered:• Forward secrecy: a sensor should not be able to read anyfuture messages after it leaves the network• Backward secrecy: a joining sensor should not be able toread any previously transmitted messageThe security services in WSNs are usually centered aroundcryptography However due to the constraints in WSNs manyalready existing secure algorithms are not practical for useWe discuss this problem in the section “Cryptography inWSNs” belowTHREAT MODELIn WSNs it is usually assumed that an attacker may know thesecurity mechanisms that are deployed in a sensor network;they may be able to compromise a node or even physicallycapture a node Due to the high cost of deploying tamper-resistant sensor nodes most WSN nodes are viewed as non-tamper-resistant Further once a node is compromised theattacker is capable of stealing the key materials containedwithin that nodenTable 1 Variety of real-life sensor nodesBerkeley mote [16]EYES [17] Medusa MK-2 [18] Imote[19]WeC rene2 rene2 dot micaMonth/Year 09/99 10/00 06/01 08/01 02/02 03/02 09/02 01/03CPU AT90LS8535 ATmega163 ATmega1031 MSP 430F149 40MHz ARM THUMB ARM core 12MHzProg memory 8KB 16KB 128KB 60KB 1MB 512KBRAM 05KB 1KB 4KB 2KB 136KB 64KBRadio RFM TR1000 916MHz RFM TR1001 86835MHz RFM TR1000 916MHz BT 24 GHzRate 10 kb/s 10/40 kb/s 115 kb/s 115 kb/s 100kb/s1 Later versions are an ATmega128 running in 103 mode                     IEEE Communications Surveys & Tutorials • 2nd Quarter 2006 5Base stations in WSNs are usually regarded as trustworthyMost research studies focus on secure routing between sen-sors and the base station Deng et al considered strategiesagainst threats which can lead to the failure of the base sta-tion [24]Attacks in sensor networks can be classified into the fol-lowing categories:• Outsider versus insider attacks: outside attacks aredefined as attacks from nodes which do not belong to aWSN; insider attacks occur when legitimate nodes of aWSN behave in unintended or unauthorized ways• Passive versus active attacks: passive attacks includeeavesdropping on or monitoring packets exchanged with-in a WSN; active attacks involve some modifications ofthe data steam or the creation of a false stream• Mote-class versus laptop-class attacks: in mote-classattacks an adversary attacks a WSN by using a fewnodes with similar capabilities to the network nodes; inlaptop-class attacks an adversary can use more powerfuldevices (eg a laptop) to attack a WSN These deviceshave greater transmission range processing power andenergy reserves than the network nodesEVALUATIONWe suggest using the following metrics to evaluate whethera security scheme is appropriate in WSNs• Security: a security scheme has to meet the requirementsdiscussed above• Resiliency: in case a few nodes are compromised a secu-rity scheme should still protect against the attacks• Energy efficiency: a security scheme must be energy effi-cient so as to maximize node and network lifetime• Flexibility: key management needs to be flexible so as toallow for different network deployment methods such asrandom node scattering and predetermined node place-ment• Scalability: a security scheme should be able to scalewithout compromising the security requirements• Fault-tolerance: a security scheme should continue toprovide security services in the presence of faults such asfailed nodes• Self-healing: sensors may fail or run out of energy Theremaining sensors may need to be reorganized to main-tain a set level of security• Assurance: assurance is the ability to disseminate differ-ent information at different levels to end-users [25] Asecurity scheme should offer choices with regard todesired reliability latency and so onATTACKS IN SENSOR NETWORKSWSNs are vulnerable to various types of attacks According tothe security requirements in WSNs these attacks can be cate-gorized as [3]:• Attacks on secrecy and authentication: standard crypto-graphic techniques can protect the secrecy and authentic-ity of communication channels from outsider attackssuch as eavesdropping packet replay attacks and modifi-cation or spoofing of packets• Attacks on network availability: attacks on availability areoften referred to as denial-of-service (DoS) attacks DoSattacks may target any layer of a sensor network• Stealthy attacks against service integrity: in a stealthyattack the goal of the attacker is to make the networkaccept a false data value For example an attacker com-promises a sensor node and injects a false data valuethrough that sensor nodeIn these attacks keeping the sensor network available forits intended use is essential DoS attacks against WSNs maypermit real-world damage to the health and safety of people[5] In this section we focus only on DoS attacks and theircountermeasures in sensor networks We discuss attacks onsecrecy and authentication in the section “Secure RoutingProtocols” and discuss stealthy attacks and countermeasuresin the section “Intrusion Detection” belowThe DoS attack usually refers to an adversary’s attempt todisrupt subvert or destroy a network However a DoS attackcan be any event that diminishes or eliminates a network’scapacity to perform its expected function [5] Sensor networksare usually divided into layers and this layered architecturemakes WSNs vulnerable to DoS attacks as DoS attacks mayoccur in any layer of a sensor networkPrevious discussions on DoS attacks in WSNs can be foundin [3 5 26 27] The remainder of this section summarizes thepossible DoS attacks and countermeasures in each layer of asensor networkPHYSICAL LAYERThe physical layer is responsible for frequency selection carri-er frequency generation signal detection modulation anddata encryption [4] As with any radio-based medium thereexists the possibility of jamming in WSNs In addition nodesin WSNs may be deployed in hostile or insecure environmentswhere an attacker has easy physical access These two vulnera-bilities are explored in this subsectionJamming — Jamming is a type of attack which interferes withthe radio frequencies that a network’s nodes are using [3 5]A jamming source may either be powerful enough to disruptthe entire network or less powerful and only able to disrupt asmaller portion of the network Even with lesser-poweredjamming sources such as a small compromised subset of thenetwork’s sensor nodes an adversary has the potential to dis-rupt the entire network provided the jamming sources arerandomly distributed in the networkTypical defenses against jamming involve variations ofspread-spectrum communication such as frequency hoppingand code spreading [5] Frequency-hopping spread spectrum(FHSS) is a method of transmitting signals by rapidly switch-ing a carrier among many frequency channels using a pseudorandom sequence known to both transmitter and receiverWithout being able to follow the frequency selection sequencean attacker is unable to jam the frequency being used at agiven moment in time However as the range of possible fre-quencies is limited an attacker may instead jam a wide sec-tion of the frequency bandCode spreading is another technique used to defendagainst jamming attacks and is common in mobile networksHowever this technique requires greater design complexityand energy thus restricting its use in WSNs In general tomaintain low cost and low power requirements sensor devicesare limited to single-frequency use and are therefore highlysusceptible to jamming attacksTampering — Another physical layer attack is tampering [5]Given physical access to a node an attacker can extract sensi-tive information such as cryptographic keys or other data onthe node The node may also be altered or replaced to createa compromised node which the attacker controls One defenseto this attack involves tamper-proofing the node’s physicalpackage [5] However it is usually assumed that the sensor               IEEE Communications Surveys & Tutorials • 2nd Quarter 20066nodes are not tamper-proofed in WSNs due to the additionalcost This indicates that a security scheme must consider thesituation in which sensor nodes are compromisedLINK LAYERThe data link layer is responsible for the multiplexing of datastreams data frame detection medium access and error con-trol [4] It ensures reliable point-to-point and point-to-multi-point connections in a communication network Attacks at thelink layer include purposely introduced collisions resourceexhaustion and unfairness This subsection looks at each ofthese three link-layer attack categories [5]Collisions — A collision occurs when two nodes attempt totransmit on the same frequency simultaneously [5] Whenpackets collide a change will likely occur in the data portioncausing a checksum mismatch at the receiving end The pack-et will then be discarded as invalid An adversary may strategi-cally cause collisions in specific packets such as ACK controlmessages A possible result of such collisions is the costlyexponential back-off in certain media access control (MAC)protocolsA typical defense against collisions is the use of error-cor-recting codes [5] Most codes work best with low levels of col-lisions such as those caused by environmental or probabilisticerrors However these codes also add additional processingand communication overhead It is reasonable to assume thatan attacker will always be able to corrupt more than what canbe corrected While it is possible to detect these malicious col-lisions no complete defenses against them are known at thistimeExhaustion — Repeated collisions can also be used by anattacker to cause resource exhaustion [5] For example anaive link-layer implementation may continuously attempt toretransmit the corrupted packets Unless these hopelessretransmissions are discovered or prevented the energyreserves of the transmitting node and those surrounding it willbe quickly depletedA possible solution is to apply rate limits to the MACadmission control such that the network can ignore excessiverequests thus preventing the energy drain caused by repeatedtransmissions [5] A second technique is to use time-divisionmultiplexing where each node is allotted a time slot in whichit can transmit [5] This eliminates the need of arbitration foreach frame and can solve the indefinite postponement prob-lem in a back-off algorithm However it is still susceptible tocollisionsUnfairness — Unfairness can be considered a weak form ofa DoS attack [5] An attacker may cause unfairness in a net-work by intermittently using the above link-layer attacksInstead of preventing access to a service outright an attackercan degrade it in order to gain an advantage such as causingother nodes in a real-time MAC protocol to miss their trans-mission deadline The use of small frames lessens the effect ofsuch attacks by reducing the amount of time an attacker cancapture the communication channel However this techniqueoften reduces efficiency and is susceptible to further unfair-ness for example when an attacker is trying to retransmitquickly instead of randomly delayingNETWORK AND ROUTING LAYERThe network and routing layer of sensor networks is usual-ly designed according to the following principles [4]:• Power efficiency is an important consideration• Sensor networks are mostly data-centric• An ideal sensor network has attribute-based addressingand location awarenessThe attacks in the network and the routing layer includethe followingSpoofed Altered or Replayed Routing Information —The most direct attack against a routing protocol in any net-work is to target the routing information itself while it is beingexchanged between nodes An attacker may spoof alter orreplay routing information in order to disrupt traffic in thenetwork [26] These disruptions include the creation of rout-ing loops attracting or repelling network traffic from selectnodes extending and shortening source routes generatingfake error messages partitioning the network and increasingend-to-end latencyA countermeasure against spoofing and alteration is toappend a message authentication code (MAC) after the mes-sage By adding a MAC to the message the receivers can veri-fy whether the messages have been spoofed or altered Todefend against replayed information counters or timestampscan be included in the messages [8]Selective Forwarding — A significant assumption made inmultihop networks is that all nodes in the network will accu-rately forward received messages An attacker may createmalicious nodes which selectively forward only certain mes-sages and simply drop others [26] A specific form of thisattack is the black hole attack in which a node drops all mes-sages it receives One defense against selective forwardingattacks is using multiple paths to send data [26] A seconddefense is to detect the malicious node or assume it has failedand seek an alternative routeSinkhole — In a sinkhole attack an attacker makes a com-promised node look more attractive to surrounding nodes byforging routing information [5 26] The end result is that sur-rounding nodes will choose the compromised node as the nextnode to route their data through This type of attack makesselective forwarding very simple as all traffic from a largearea in the network will flow through the adversary’s nodeSybil — The Sybil attack is a case where one node presentsmore than one identity to the network [3 26 27] Protocolsand algorithms which are easily affected include fault-tolerantschemes distributed storage and network-topology mainte-nance For example a distributed storage scheme may rely onthere being three replicas of the same data to achieve a givenlevel of redundancy If a compromised node pretends to betwo of the three nodes the algorithms used may conclude thatredundancy has been achieved while in reality it has notWormholes — A wormhole is a low-latency link between twoportions of the network over which an attacker replays net-work messages [26] This link may be established either by asingle node forwarding messages between two adjacent butotherwise non-neighboring nodes or by a pair of nodes in dif-ferent parts of the network communicating with each otherThe latter case is closely related to the sinkhole attack as anattacking node near the base station can provide a one-hoplink to that base station via the other attacking node in a dis-tant part of the network Hu et al presented a novel and gen-eral mechanism called packet leashes for detecting anddefending against wormhole attacks [28] Two types of leasheswere introduced: geographic leashes and temporal leashesThe proposed mechanisms can also be used in WSNs                         IEEE Communications Surveys & Tutorials • 2nd Quarter 2006 7Hello Flood Attacks — Many protocols which use HELLOpackets make the naive assumption that receiving such apacket means the sender is within radio range and is thereforea neighbor An attacker may use a high-powered transmitterto trick a large area of nodes into believing they are neighborsof that transmitting node [26] If the attacker falsely broad-casts a superior route to the base station all of these nodeswill attempt transmission to the attacking node despite manybeing out of radio range in realityAcknowledgment Spoofing — Routing algorithms used insensor networks sometimes require Acknowledgments to beused An attacking node can spoof the Acknowledgments ofoverheard packets destined for neighboring nodes in order toprovide false information to those neighboring nodes [26] Anexample of such false information is claiming that a node isalive when in fact it is deadTRANSPORT LAYERThe transport layer is responsible for managing end-to-endconnections [4] Two possible attacks in this layer floodingand desynchronization are discussed in this subsectionFlooding — Whenever a protocol is required to maintainstate at either end of a connection it becomes vulnerable tomemory exhaustion through flooding [5] An attacker mayrepeatedly make new connection requests until the resourcesrequired by each connection are exhausted or reach a maxi-mum limit In either case further legitimate requests will beignored One proposed solution to this problem is to requirethat each connecting client demonstrate its commitment tothe connection by solving a puzzle [5] The idea is that a con-necting client will not needlessly waste its resources creatingunnecessary connections Given that an attacker does not like-ly have infinite resources it will be impossible for him/her tocreate new connections fast enough to cause resource starva-tion on the serving node While these puzzles do include pro-cessing overhead this technique is more desirable thanexcessive communicationDesynchronization — Desynchronization refers to the dis-ruption of an existing connection [5] An attacker may forexample repeatedly spoof messages to an end host causingthat host to requestthe retransmission ofmissed frames If timed correctly an attacker may degrade oreven prevent the ability of the end hosts to successfullyexchange data thus causing them to instead waste energy byattempting to recover from errors which never really existedA possible solution to this type of attack is to requireauthentication of all packets communicated between hosts [5]Provided that the authentication method is itself secure anattacker will be unable to send the spoofed messages to theend hostsTable 2 shows the possible DoS attacks and countermea-sures in WSNsIn the following sections we discuss cryptography key man-agement protocols secure routing protocols secure dataaggregation and intrusion detection for WSNs For theremainder of this article we use the following notation:• A B are principals such as communicating nodes• IDA denotes the sensor identifier of node A• NA is a nonce generated by A (a nonce is an unpre-dictable bit string usually used to achieve freshness)• KAB denotes the secret pairwise key shared between Aand B• MK is the encryption of message M with key K• MAC(KM) denotes the computation of the messageauthentication code of message M with key K• A → B denotes A unicasts a message to B• A → * denotes A broadcasts a message to its neighborsCRYPTOGRAPHY IN WSNSSelecting the most appropriate cryptographic method is vitalin WSNs because all security services are ensured by cryptog-raphy Cryptographic methods used in WSNs should meet theconstraints of sensor nodes and be evaluated by code sizedata size processing time and power consumption In thissection we focus on the selection of cryptography in WSNsPublic key cryptography discussed first is followed by sym-metric key cryptographyPUBLIC KEY CRYPTOGRAPHY IN WSNSMany researchers believe that the code size data size pro-cessing time and power consumption make it undesirable forpublic key algorithm techniques such as the Diffie–Hellmankey agreement protocol [29] or RSA signatures [30] to benTable 2 Sensor network layers and denial-of-service defensesNetwork Attacks DefensePhysical JammingTamperingSpread-spectrum priority messages lower duty cycle regionmapping mode changeTamper-proofing hidingLinkCollisionExhaustionUnfairnessError-correcting codeRate limitationSmall framesNetwork androutingSpoofed altered or replayed routing informationSelective forwardingSinkholeSybilWormholesHello flood attacksAcknowledgment spoofingEgress filtering authentication monitoringRedundancy probingAuthentication monitoring redundancyAuthentication probingAuthentication packet leashes by using geographic and temporal informationAuthentication verify the bidirectional linkAuthenticationTransport FloodingDesynchronizationClient puzzlesAuthentication                                                                    IEEE Communications Surveys & Tutorials • 2nd Quarter 20068employed in WSNsPublic key algorithms such as RSA are computationallyintensive and usually execute thousands or even millions ofmultiplication instructions to perform a single security opera-tion Further a microprocessor’s public key algorithm effi-ciency is primarily determined by the number of clock cyclesrequired to perform a multiply instruction [31] Brown et alfound that public key algorithms such as RSA usually requireon the order of tens of seconds and up to minutes to performencryption and decryption operations in constrained wirelessdevices which exposes a vulnerability to DoS attacks [32] Onthe other hand Carman et al found that it usually takes amicroprocessor thousands of nano-joules to do a simple multi-ply function with a 128 bit result [31] In contrast symmetrickey cryptography algorithms and hash functions consumemuch less computational energy than public key algorithmsFor example the encryption of a 1024-bit block consumesapproximately 42 mJ on the MC68328 DragonBall processorusing RSA while the estimated energy consumption for a 128bit AES block is a much lower at 0104 mJ [31]Recent studies have shown that it is feasible to apply pub-lic key cryptography to sensor networks by using the rightselection of algorithms and associated parameters optimiza-tion and low-power techniques [6 7 33] The investigatedpublic key algorithms include Rabin’s Scheme [34] NtruEn-crypt [35] RSA [30] and Elliptic Curve Cryptography (ECC)[36 37] Most studies in literature focus on RSA and ECCalgorithms The attraction of ECC is that it appears to offerequal security for a far smaller key size thereby reducing pro-cessing and communication overhead For example RSA with1024 bit keys (RSA-1024) provides a currentlyaccepted level of security for many applicationsand is equivalent in strength to ECC with 160 bitkeys (ECC-160) [38] To protect data beyond theyear 2010 RSA Security recommends RSA-2048as the new minimum key size which is equivalentto ECC with 224 bit keys (ECC-224) [39] Table3 summarizes the execution time of ECC andRSA implementations on an Atmel ATmega128processor (used by Mica2 mote) [6] The execu-tion time is measured on average for a point mul-tiplication in ECC and a modular exponentialoperation in RSA ECC secp160r1 and secp224r1are two standardized elliptic curves defined in[40] As shown in Table 3 by using the smallinteger e = 216 + 1 as the public key RSA publickey operation is slightly faster than ECC pointmultiplication However ECC point multiplication outper-forms RSA private key operation by an order of magnitudeThe RSA private key operation which is too slow limits itsuse in a sensor node ECC has no such issues since both thepublic key operation and private key operation use the samepoint multiplication operationsWander et al investigated the energy cost of authenticationand key exchange based on RSA and ECC cryptography onan Atmel ATmega128 processor [7] The result is shown inTable 4 The ECC-based signature is generated and verifiedusing the Elliptic Curve Digital Signature Algorithm (ECDSA)[41] The key exchange protocol is a simplified version of theSSL handshake which involves two parties: a client initiatingthe communication and a server responding to the initiation[42] The WSN is assumed to be administered by a centralpoint with each sensor having a certificate signed by the cen-tral point’s private key using a RSA or ECC signature In thehandshake process the two parties verify each other’s certifi-cate and negotiate the session key to be used in the communi-cation As Table 4 shows in comparison with RSAcryptography at the same security level ECDSA signaturesare significantly cheaper than RSA signatures and ECDSAverifications are within reasonable range of RSA verificationsFurther the ECC-based key exchange protocol outperformsthe RSA-based key exchange protocol at the server side andthere is almost no difference in the energy cost for these twokey exchange protocols at the client side In addition the rela-tive performance advantage of ECC over RSA increases asthe key size increases in terms of the execution time and ener-gy cost Tables 3 and 4 indicate that ECC is more appropriatethan RSA for use in sensor networksThe implementation of RSA and ECC cryptography onMica2 motes further proved that a public key based protocolis viable for WSNs Two modules TinyPK [43] based onRSA and TinyECC [44] based on ECC have been designedand implemented on Mica2 motes using the TinyOS develop-ment environment Similar work was also conducted by Malanet al on ECC cryptography using a Mica2 mote [45] In theirwork ECC was used to distribute a single symmetric key forthe link-layer encryption provided by the TinySec module[46]While public key cryptography may be possible in sensornodes the public key operations are still expensive Theassumptions in [33 45] may not be satisfied in some applica-tions For example the work in [33 45] concentrated on thepublic key operations only assuming the private key opera-tions will be performed by a base station or a third party Byselecting appropriate parameters for example using the smallinteger e = 216 + 1 as the public key the public key operationtime can be extremely fast while the private key operationtime does not change The limitation of private key operationnTable 3 Public key cryptography: average ECCand RSA execution times (Source: [6])Algorithm Operationtime (s)ECC secp160r1 081sECC secp224r1 219sRSA-1024 public-key e = 216 + 1 043sRSA-1024 private key w CRT1 1099RSA-2048 public-key e = 216 + 1 194sRSA-2048 private-key w CRT1 83261 Chinese Remainder TheorynTable 4 Public key cryptography: average energy costs of digital signature andkey exchange computations [mJ] (Source: [7])Algorithm Signature Key ExchangeSign Verify Client ServerRSA-1024 304 119 154 304ECDSA-160 2282 4509 223 223RSA-2048 23027 537 572 23027ECDSA-224 6154 12198 604 604                             IEEE Communications Surveys & Tutorials • 2nd Quarter 2006 9occurring only at a base station makes many security servicesusing public key algorithms not available under these schemesSuch services include peer-to-peer authentication and securedata aggregationIn contrast Tables 5 and 6 show the execution time andenergy cost of two symmetric cryptography protocols on anAtmel ATmega128 processor In Table 5 the execution timewas measured on a 64 bit block using a 80 bit key From thetable we can see that symmetric key cryptography is faster andconsumes less energy as compared to public key cryptographyIn the next section we focus on symmetric key cryptographySYMMETRIC KEY CRYPTOGRAPHY IN WSNSThe constraints on computation and power consumption insensor nodes limit the application of public key cryptographyin WSNs Thus most research studies focus on symmetric keycryptography in sensor networksFive popular encryption schemes RC4 [51] RC5 [48]IDEA [51] SHA-1 [49] and MD5 [51 52] were evaluated onsix different microprocessors ranging in word size from 8 bit(Atmel AVR) to 16 bit (Mitsubishi M16C) to 32 bit widths(StrongARM XScale) in [53] The execution time and codememory size were measured for each algorithm and platformThe experiments indicated uniform cryptographic cost foreach encryption class and each architecture class The impactof caches was negligible while Instruction Set Architecture(ISA) support was limited to specific effects on certain algo-rithms Moreover hashing algorithms (MD5 and SHA-11)incurred almost an order of a magnitude higher overheadthan encryption algorithms (RC4 RC5 and IDEA)In [54] Law et al evaluated two symmetric key algorithms:RC5 and TEA [55] They further evaluated six block ciphersincluding RC5 and RC6 [56] Rijndael [50] MISTY1 [57]KASUMI [58] and Camellia [59] on IAR Systems’MSP430F149 in [60] The benchmark parameters were codedata memory and CPU cycles The evaluation results showedthat Rijndael is suitable for high-security and energy-efficiencyrequirements while MISTY1 is suitable for good storage andenergy efficiency The evaluation results in [60] disagreed withthe work in [8] in which RC5 was selected as theencryption/decryption scheme and with the work in [22] inwhich RC6 was selected The work in [60] provides a goodresource for deciding which symmetric algorithm should beadopted in sensor networksThe performance of symmetric key cryptography is mainlydecided by the following factors:• Embedded data bus width: many encryption algorithmsprefer 32 bit word arithmetic but most embedded pro-cessors usually use 8 or 16 bit wide data bus• Instruction set: the Instruction Set Architecture (ISA)has specific effects on certain algorithms For examplemost embedded processors do not support the variable-bit rotation instruction like ROL (rotate bits left) of theIntel architecture which greatly improves the perfor-mance of RC5Due to the constraints in sensor nodes symmetric keycryptography is preferred in a WSNOPEN RESEARCH ISSUESSelecting the appropriate cryptography method for sensornodes is fundamental to providing security services in WSNsHowever the decision depends on the computation and com-munication capability of the sensor nodes Open researchissues range from cryptography algorithms to hardware designas described below:• Recent studies on public key cryptography have demon-strated that public key operations may be practical insensor networks However private key operations arestill too expensive in terms of computation and energycost to accomplish in a sensor node The application ofprivate key operations to sensor nodes needs to be stud-ied further• Symmetric key cryptography is superior to public keycryptography in terms of speed and low energy costHowever the key distribution schemes based on symmet-ric key cryptography are not perfect Efficient and flexi-ble key distribution schemes need to be designed• It is also likely that more powerful motes will need to bedesigned in order to support the increasing requirementsfor computation and communication in sensor nodesKEY MANAGEMENT PROTOCOLSKey management is a core mechanism to ensure the securityof network services and applications in WSNs The goal of keymanagement is to establish required keys between sensornodes which must exchange data Further a key managementscheme should also support node addition and revocationwhile working in undefined deployment environments Due tothe constraints on sensor nodes key management schemes inWSNs have many differences with the schemes in ad hoc net-worksAs shown above public key cryptography suffers from limi-tations in WSNs Thus most proposed key managementschemes are based on symmetric key cryptography Further astraight pairwise private key sharing scheme between everypair of nodes is also impractical in WSNs A pairwise privatekey sharing scheme requires predistribution and storage of n –1 keys in each node where n is the number of nodes in a sen-sor network Due to the large amount of memory requiredpairwise schemes are not viable when the network size islarge Moreover most key pairs would be unusable sincedirect communication is possible only among neighboringnodes This scheme is also not flexible for node addition andrevocation In this section we discuss key management proto-cols in WSNs Another investigation of key managementmechanisms for WSNs can be found in [61]Figure 2 shows a taxonomy of key management protocolsin WSNs According to the network structure the protocolsnTable 5 Symmetric key cryptography: averageRC5 and skipjack execution times (Source:[46])Algorithm Operation time (ms)Skipjack (C) [47] 038msRC5 (C assembly) [48] 026msnTable 6 Symmetric key cryptography: averageenergy numbers for AES and SHA-1 (Source:[7])Algorithm EnergySHA-1 (C) [49] 59 mJ/byteAES-128 Enc/Dec (assembly)[50] 162/249 mJ/byte                         IEEE Communications Surveys & Tutorials • 2nd Quarter 200610can be divided into centralized key schemes and distributedkey schemes According to the probability of key sharingbetween a pair of sensor nodes the protocols can be dividedinto probabilistic key schemes and deterministic key schemesIn this section we present a detailed overview of the main keymanagement protocols in WSNs We start with key manage-ment protocols based on network structureNETWORK STRUCTURE BASEDKEY MANAGEMENT PROTOCOLSThe underlying network structure plays a significant role inthe operation of key management protocols According to thestructure the protocols can be divided into two categories:centralized key schemes and distributed key schemesCentralized Key Management Schemes — In a centralizedkey scheme there is only one entity often called a key distri-bution center (KDC) that controls the generation regenera-tion and distribution of keys The only proposed centralizedkey management scheme for WSNs in the current literature isthe LKHW scheme which is based on the Logical Key Hier-archy (LKH) [62] In this scheme the base station is treatedas a KDC and all keys are logically distributed in a tree root-ed at the base stationThe central controller does not have to rely on any auxil-iary entity to perform access control and key distributionHowever with only one managing entity the central server isa single point of failure The entire network and its securitywill be affected if there is a problem with the controller Dur-ing the time when the controller is not working the networkbecomes vulnerable as keys are not generated regeneratedand distributed Furthermore the network may become toolarge to be managed by a single entity thus affecting scalabili-tyDistributed Key Management Schemes — In the distribut-ed key management approaches different controllers are usedto manage key generation regeneration and distribution thusminimizing the risk of failure and allowing for better scalabili-ty In this approach more entities are allowed to fail beforethe whole network is affectedMost proposed key management schemes are distributedschemes These schemes also fall into deterministic and prob-abilistic categories which are discussed in detail in the follow-ing subsectionKEY MANAGEMENT PROTOCOLS BASED ON THEPROBABILITY OF KEY SHARINGIn the remainder of this section we present thekey management protocols based on the proba-bility of key sharing between a pair of sensornodes We first discuss deterministic approachesand then discuss probabilistic approachesDeterministic Approaches — Zhu et al haveproposed a key management protocol LocalizedEncryption and Authentication Protocol(LEAP) for sensor networks in [63] LEAP sup-ports the establishment of four types of keys foreach sensor node:• An individual key shared with the basestation (predistributed)• A group key that is shared by all thenodes in the network (predistributed)• Pairwise keys shared with immediateneighboring nodes• A cluster key shared with multiple neighboring nodesThe pairwise keys shared with immediate neighboringnodes are used to protect peer-to-peer communication whilethe cluster key is used for local broadcast The pairwise keyscan be set up as follows: in the key predistribution stage eachsensor node is loaded with an initial key KI and each node Agenerates a master key KA = fKI (A) where f is a pseudoran-dom function Then in the neighbor discovery stage A broad-casts a HELLO message and expects an Acknowledgmentfrom neighboring nodes eg node B:A → *: AB → A: B MAC(KB A|B)Node A computes its pairwise key with B KAB = fKB(A) NodeB knows A KB and can also compute KAB in the same wayThen KAB serves as their pairwise keyCluster key establishment follows the pairwise key estab-lishment phase Suppose node A wants to establish a clusterkey with all its immediate neighbors B1 B2 … Bm Node Afirst generates a random key KcA then encrypts this key withthe pairwise key shared with each neighbor and finally trans-mits the encrypted key to each neighbor Bi where 1 ≤ m:A → Bi: (KcA)KABiLEAP uses unicast for key exchange Notice that most ofthe proposed security protocols were based on point-to-pointhandshaking procedures to negotiate session keys Lai et alhave proposed a BROadcast Session Key (BROSK) negotia-tion protocol [64] BROSK assumes a master key is shared byall nodes in the network To establish a session key K with itsneighbors such as node B a sensor node A broadcasts a keynegotiation message:A → *: IDA|NAMAC(K IDA|NA)B → * : IDB|NBMAC(K IDB|NB)A and B will receive the broadcast message They can verifythe message using the master key K and both A and B can cal-culate the shared session key:KAB = MAC(KNA|NB)BROSK therefore establishes pairwise session keys betweenevery two neighboring nodes It is both scalable and energyefficientnFigure 2 Key management protocols in WSNs: a taxonomyDeterministickey schemeProbabilistickey schemeDistributedkey schemeLKHW [62] LEAP [63] BROSK [64]CDTKeying [65]IOS/DMBS [66]random key schemes [6768 69 70 71 72 73 74]Random key schemes[67 68 69 70 71 7273 74]LKHW [62]LEAP [63]BROSK [64]CDTKeying [65]IOS/DMBS [66]Centralizedkey schemeNetwork structure Probability of key sharingKey management protocols in WSNs                                                                                                                                                          IEEE Communications Surveys & Tutorials • 2nd Quarter 2006 11Camtepe and Yener have proposed a deterministic key dis-tribution schemes for WSNs using Combinatorial Design The-ory [65] The combinatorial design theory based pairwise keypredistribution (CDTKeying) scheme is based on block designtechniques in combinatorial design theory It employs sym-metric and generalized quadrangle design techniques Thescheme uses a finite projective plane of order n (for primepower n) to generate a symmetric design with parameters n2+ n + 1 n + 1 1 The design supports n2 + n + 1 nodesand uses a key-pool of size n2 + n + 1 It generates n2 + n +1 key chains of size n + 1 where every pair of key chains hasexactly one key in common and every key appears in exactly n+ 1 key chains After the deployment every pair of nodesfinds exactly one common key Thus the probability of keysharing among a pair of sensor nodes is 1 The disadvantageof this solution is that the parameter n has to be a primepower thus indicating that not all network sizes can be sup-ported for a fixed key-chain sizeLee and Stinson have proposed two combinatorial designtheory based deterministic schemes: the ID-based one-wayfunction scheme (IOS) and the deterministic multiple spaceBlom’s scheme (DMBS) [66] They further discussed the useof combinatorial set systems in the design of deterministic keypredistribution schemes for WSNs in [67]Probabilistic Approaches — Most proposed key manage-ment schemes in WSNs are probabilistic and distributedschemesEschenauer and Gligor introduced a key predistributionscheme for sensor networks which relies on probabilistic keysharing among the nodes of a random graph in [68] Thisscheme consists of three phases: key predistribution shared-key discovery and path key establishment In the key predis-tribution phase each sensor is equipped with a key ring heldin the memory The key ring consists of k keys which are ran-domly drawn from a large pool of P keys The associationinformation of the key identifiers in the key ring and sensoridentifier is also stored at the base station Further theauthors assumed that each sensor shares a pairwise key withthe base station In the shared key discovery phase each sen-sor discovers its neighbors within the wireless communicationrange with which it shares keys Two methods to accomplishthis are suggested in [68] The simplest method is for eachnode to broadcast a list of identifiers of the keys in their keyring in plain text thus allowing neighboring nodes to checkwhether they share a key However an adversary may observethe key-sharing patterns among sensors in this way The sec-ond method uses the challenge–response technique to hidekey-sharing patterns among nodes from an adversary Forevery Ki on a key ring each node could broadcast a list α EKi(α) i = 1 … k where α is a challenge The decryption ofEKi(α) with the proper key by a recipient would reveal thechallenge and establish a shared key with the broadcastingnode This method requires that the challenge α be wellknown in the sensor network thus allowing the recipient withthe proper key to discover the challengeFinally in the path-key establishment phase a path-key isassigned for those sensor nodes within wireless communica-tion range and not sharing a key but connected by two ormore links at the end of the second phase If a node is com-promised the base station can send a message to all othersensors to revoke the compromised node’s key ring Rekeyingfollows the same procedure as revocation The messages fromthe base station are signed by the pairwise key shared by thebase station and sensor nodes and thus it is ensured that noadversary can forge a base station If a node is compromisedthe attacker has a probability of approximately k/P to be ableto successfully attack any link Because k << P it only affectsa small number of sensor nodesInspired by the work in [68] which we call the basic ran-dom key scheme in the following section additional randomkey predistribution schemes have been proposed in [69–74]In the basic random key scheme any two neighboringnodes need to find a single common key from their key ringsin order to establish a secure link in the key setup phaseHowever Chan et al observed that increasing the amount ofkey overlap in the key ring can increase the resilience of thenetwork against node capture [69] Thus they proposed a q-composite keying scheme in which it is required that at leastq common keys be shared in the key setup phase in order tobuild a secure link between any two neighboring nodes Fur-ther a key update phase was introduced to enhance the basicrandom key scheme Suppose A has a secure link to B afterthe key setup phase and the secure key k is from the key poolP Because k may be residing in the key-ring memory of someother nodes in the network the security of the link between Aand B is jeopardized if any of those nodes are captured Thusit is better to update the communication key between A and Binstead of using a key in the key pool To address this prob-lem they presented a multipath key reinforcement for the keyupdate Assume there are j disjoint paths between A and B Agenerates j random values v1 v2 … vj and then routes eachrandom value along a different path to B When B hasreceived all j keys the new link key can be computed by bothA and B as follows:k′ = k ⊕ v1 ⊕ v2 ⊕ … ⊕ vjThe adversary has to eavesdrop on all j paths if he/shewants to reconstruct the communication key This securityenhancement comes at the cost of more communication over-head needed to find multiple disjoint paths Further Chan etal also developed a random-pairwise keys scheme for node-to-node authenticationBlundo et al presented a polynomial-based key predistri-bution protocol for group key predistribution [75] which canalso be adapted to sensor networks The key setup server ran-domly generates a bivariate t-degree polynomial f(x y) =Σitj=0 aijxiyj over a finite field Fq where q is a prime numberthat is large enough to accommodate a cryptographic key suchthat it has the property of f(x y) = f(y x) For each sensor ithe setup server computes a polynomial share of f(x y) thatis f(i y) For any two sensor nodes i and j node i can com-pute the common key f(i j) by evaluating f(i y) at point j andnode j can compute the same key f(j i) = f(i j) by evaluatingf(j y) at point i In this approach each sensor node i needs tostore a t-degree polynomial f(i x) which occupies (t + 1) logq storage space This scheme is unconditionally secure and t-collusion resistant However the storage cost for a polynomialshare is exponential in terms of the group size making it pro-hibitive in sensor networksInspired by the work of [68 69 75] Liu and Ning pro-posed a polynomial pool-based key predistribution scheme in[70] which also includes three phases: setup direct key estab-lishment and path key establishment In the setup phase thesetup server randomly generates a set F of bivariate t-degreepolynomials over the finite field Fq For each sensor node thesetup server picks a subset of polynomials Fi ⊆ F and assignsthe polynomial shares of these polynomials to node i In thedirect key establishment stage the sensor nodes find a sharedpolynomial with other sensor nodes and then establish a pair-wise key using the polynomial-based key predistributionscheme discussed in [75] The path key establishment phase issimilar to that in the basic random key scheme Further the                                                                                                                                                                                                                                                           IEEE Communications Surveys & Tutorials • 2nd Quarter 200612proposed framework allows for the study of multiple instantia-tions of possible pairwise key establishment schemes Two ofthe possible instantiations the key predistribution schemebased on random subset assignment and the grid-based keypredistribution scheme are also presented and analyzed in thearticleSimilar to [70] Du et al presented another pairwise keypredistribution scheme in [72] which uses Blom’s method [76]The key difference between [70] and [72] is that the scheme in[70] is based on a set of bivariate t-degree polynomials whileDu’s scheme is based on Blom’s method The proposedscheme allows any pair of nodes in a network to be able tofind a pairwise secret key As long as no more than λ nodesare compromised the network is perfectly secure (which iscalled the λ-secure property) To use Blom’s method duringthe predeployment phase the base station first constructs a (λ+ 1) × N matrix G over a finite field GF(q) where N is thesize of the network and G is considered to be public informa-tion Then the base station creates a random (λ + 1) × (λ +1) symmetric matrix D over GF(q) and computes a N × (λ +1) matrix A = (D ⋅ G)T where (D ⋅ G)T is the transpose of D ⋅G Matrix D needs to be kept secret and should not be dis-closed to adversaries It is easy to verify that A ⋅ G is a sym-metric matrixA ⋅ G = (D ⋅ G)T ⋅ G = GT ⋅ DT ⋅ G = GT ⋅ D ⋅ G = (A ⋅ G)TThus we know that Kij = Kji The idea is to use Kij (or Kji) asthe pairwise key between nodes i and j To carry out theabove computation in the predistribution phase for any sen-sor k = 1 … N:• Store the kth row of matrix A at node k• Store the kth column of matrix G at node kTherefore when nodes i and j need to find the pairwise keybetween them they first exchange their columns of G andthen respectively compute Kij and Kji using their private rowsof AIn the proposed scheme in [72] each sensor node is loadedwith G and τ distinct D matrices drawn from a large pool of ωsymmetric matrices D1 … Dω of size (λ + 1) × (λ + 1) Foreach Di calculate the matrix Ai = (Di ⋅ G)T and store the jthrow of Ai at this node After deployment each node needs todiscover whether it shares any space with neighbors If theyfind out that they have a common space the nodes can followBlom’s method to build a pairwise key The scheme in [72] isscalable and flexible Moreover it is substantially moreresilient against node capture as compared to [70]Hwang et al extended the basic random key scheme andproposed a cluster key grouping scheme [74] They furtheranalyzed the tradeoffs involved between energy memory andsecurity robustnessNotice that location information helps to avoid unneces-sary key assignments and thus improve the performance ofsensor networks for example connectivity memory usageand network resilience against node capture Taking this intoaccount two random key predistribution schemes were pro-posed in [73 77] Although the presented schemes showimproved performance the deployment information (eglocation) is required when sensors are deployedThe abovementioned schemes are classified and comparedin Table 7nTable 7 Classification and comparison of key management protocols in WSNsProtocol Ref Theory MasterkeyPairwisekeyPathkeyClusterkeyScala-bilityResiliencyProcessloadCommloadStorageloadIAll pairwise — n/a n/a Yes No No Low Low Low Low HighLEAP [63] n/a Yes Yes Yes Yes Good Low Low Low LowBROSK [64] n/a Yes Yes No No Good Low Low Low LowLKHW [62] LKH Yes Yes No Yes Limited Low Low Low LowCDTKeying [65] Combinatorial n/a Yes No No Good Good Medium Medium HighIOS &  DMBS [66] Combinatorial n/a Yes No No Good Good Medium Medium HighIIBasic random key [68] Random graph n/a Yes Yes No Good Good Medium Medium Highq-composite [69] Random graph n/a Yes Yes No Good Good Medium Medium HighPolynomial based [70]t-degreepolynomial &random graphn/a Yes Yes No Good Good Medium Medium HighBlom based [72]Blom's method& randomgraphn/a Yes Yes No Good Good Medium Medium HighDeploymentknowledge based [73] Random graph n/a Yes Yes No Good Good Medium Medium MediumCluster keygrouping [74] Random graph n/a Yes Yes No Good Good Medium Medium HighLocation based [77] Random graph n/a Yes Yes No Good Good Medium Medium MediumNote: Category I denotes deterministic approaches and category II denotes probabilistic approaches Master key is the key shared by all thenodes in the network Pairwise key is the key shared between two neighboring nodes Path key denotes the key shared between any twonodes which need exchange data but does not share a pairwise key Cluster key denotes the common key shared by all cluster members                                                                                                                                                                                IEEE Communications Surveys & Tutorials • 2nd Quarter 2006 13OPEN RESEARCH ISSUESAlthough some key management protocols have been pro-posed for sensor networks the design of key managementprotocols is still largely open to research Open researchissues include the following:• The proposed key management protocols discussed inthis section employ different strategies on the trade-offbetween memory processing and communication over-head These protocols could be improved and new keymanagement protocols need to be designed• All key management protocols discussed in literature sofar are based on symmetric key cryptography Recentprogress in public key cryptography has shown that pub-lic key cryptography may be suitable for sensor networksKey management schemes based on public key cryptog-raphy need to be designed• Current proposed key management schemes assume thatthe base station is trustworthy However there may besituations (eg in the battlefield) where the security of abase station needs to be considered New schemes needto be designed considering the security of base stationsSECURE ROUTING PROTOCOLSMany routing protocols have been specifically designed forWSNs These routing protocols can be divided into three cate-gories according to the network structure: flat-based routinghierarchical-based routing and location-based routing [78] Inflat-based routing all nodes are typically assigned equal rolesor functionality In hierarchical-based routing nodes play dif-ferent roles in the network In location-based routing sensornode positions are used to route data in the networkAlthough many sensor network routing protocols have beenproposed in literature few of them have been designed withsecurity as a goal Lacking security services in the routing pro-tocols WSNs are vulnerable to many kinds of attacksMost network layer attacks against sensor networks fallinto one of the categories described above namely:• Spoofed altered or replayed routing information• Selective forwarding• Sinkhole• Sybil• Wormholes• Hello flood attacks• Acknowledgment spoofingThese attacks may be applied to compromise the routingprotocols in a sensor network For example directed diffusionis a flat-based routing algorithm for drawing information froma sensor network [79] In directed diffusion sensors measureevents and create gradients of information in their respectiveneighboring nodes The base station requests data by broad-casting interest which describes a task to be conducted by thenetwork The interest is diffused through the network hop byhop and broadcasted by each node to its neighbors As theinterest is propagated throughout the network gradients aresetup to draw data satisfying the query towards the requestingnode Each sensor that receives the interest sets up a gradienttoward the sensor nodes from which it received the interestThis process continues until gradients are setup from thesources back to the base station Interests initially specify alow rate of data flow but once a base station starts receivingevents it will reinforce one or more neighboring nodes inorder to request higher data rate events This process pro-ceeds recursively until it reaches the nodes generating eventscausing them to generate events at a higher data rate Pathsmay also be negatively reinforced Directed diffusion is vul-nerable to many kinds of attacks if authentication is notincluded in the protocol [26] For example it is easy for anadversary to add himself/herself onto the path taken by a flowof events as described in the following:• The adversary can influence the path by spoofing positivereinforcements After receiving and rebroadcasting aninterest an adversary could strongly reinforce the nodesto which the interest was sent while spoofing high-ratelow-latency events to the nodes from which the interestwas received• The adversary can replay the interests intercepted from alegitimate base station and list himself/herself as a basestation All events satisfying the interest will then be sentto both the adversary and the legitimate base stationBy using the attacks above the adversary can add himself/herself onto the path and thus gain full control of the flowThe adversary can eavesdrop modify and selectively forwardpackets of his/her choosing He/she can drop all forwardedpackets and act as a sinkhole Further a laptop-class adver-sary can exert great influence on the topology by using awormhole attack The adversary creates a tunnel between anode located near a base station and a node located close towhere events are likely to be generated By spoofing positiveor negative reinforcements the adversary can push data flowsaway from the base station and towards the nodes selected bythe adversaryHierarchical and location based routing protocols notincorporating security services are also vulnerable to manyattacks [26] For example location-based routing protocolssuch as Geographic and Energy Aware Routing (GEAR) [80]require location information to be exchanged between neigh-bors However location information can be misrepresentedRegardless of the adversary’s actual location he/she mayadvertise false position data to place himself/herself on thepath of a known flow Once on that path the adversary canmount selective forwarding and Sybil attacks in the data flowsSimulations in [81] found that such attacks have great influ-ence on the overall ratio of successfully delivered messages inthe networkSecure routing in ad hoc networks is similar to that in sen-sor networks and has been well studied in the literature [14]However the defense mechanisms developed for ad hoc net-works cannot be directly applied to sensor networks becauseof the differences between sensor and ad hoc networks dis-cussed earlierIdeally a secure routing protocol should guarantee theintegrity authentication and availability of messages in thepresence of adversaries of arbitrary power In the presence ofonly outsider adversaries it is conceivable to achieve theseidealized goals However in the presence of compromisednodes or insider adversaries especially those with laptop classcapabilities it is most likely that some if not all of these goalsare not fully attainable In this situation the best we can hopefor is graceful degradation instead of a complete compromiseof the network To achieve the above goal requires that arouting protocol degrades no faster than a rate approximatelyproportional to the ratio of compromised nodes to total nodesin the network [26]A secure routing protocol depends on an appropriate keymanagement scheme in a WSN which has been discussed ear-lier Before a routing protocol starts sensor nodes shouldhave been loaded with proper keys (eg the key for confiden-tiality authentication etc) One of the fundamental securityservices in sensor networks is broadcast authentication whichenables the base station to broadcast authenticated data tothe entire sensor network In this section we first discuss thebroadcast authentication problem and then review several      IEEE Communications Surveys & Tutorials • 2nd Quarter 200614secure routing schemesBROADCAST AUTHENTICATIONPrevious proposals for authenticated broadcast are impracticalin WSNs for the following reasons:• Most proposals rely on public key cryptography for theauthentication However public key cryptography isimpractical for WSNs;• Even one-time signature schemes that are based on sym-metric key cryptography have too much overheadµTESLA [10] and its extensions [82 83] have been pro-posed to provide broadcast authentication for sensor net-worksµTESLA is an authenticated broadcast protocol which wasproposed by Perrig et al for the SPINS protocol [8] µTESLAintroduces asymmetry through a delayed disclosure of sym-metric keys resulting in an efficient broadcast authenticationscheme µTESLA requires that the base station and nodes beloosely time synchronized and that each node knows anupper bound on the maximum synchronization errorTo send an authenticated packet the base station simplycomputes a MAC on the packet with a key that is secret atthat point in time When a node gets a packet it can verifythat the corresponding MAC key was not yet disclosed by thebase station Since a receiving node is assured that the MACkey is known only by the base station the receiving node isassured that no adversary could have altered the packet intransit The node stores the packet in a buffer At the time ofkey disclosure the base station broadcasts the verification keyto all receivers When a node receives the disclosed key it caneasily verify the correctness of the key If the key is correctthe node can now use it to authenticate the packet stored inits bufferEach MAC key is a key from the key chain generated by apublic one-way function F To generate the one-way keychain the sender chooses the last key Kn from the chain andrepeatedly applies F to compute all other keys: Ki = F(Ki+1)Figure 3 shows an example of µTESLA The receiver nodeis loosely time-synchronized and knows K0 in an authenticatedway Packets P1 and P2 sent in interval 1 contain a MAC withkey K1 Packet P3 has a MAC using key K2 If P4 P5 and P6are all lost as well as the packet that disclosed key K1 thereceiver cannot authenticate P1 P2 and P3 In interval 4 thebase station broadcasts key K2 which the nodes authenticateby verifying K0 = F(F(K2)) and hence also know K1 = F(K2)so that they can authenticate packets P1 P2 with K1 and P3with K2SPINS limits the broadcasting capability to only the basestation If a node wants to broadcast authenticated data thenode has to broadcast the data through the base station Thedata is first sent to the base station in an authenticated way Itis then broadcasted by the base stationTo bootstrap a new receiver µTESLA depends on a point-to-point authentication mechanism in which a receiver sends arequest message to the base station and the base stationreplies with a message containing all the necessary parame-ters Notice that µTESLA requires that the base station uni-cast initial parameters to individual sensor nodes thus incur-ring a long delay to boot up a large-scale sensor network Liuand Ning proposed a multilevel key chain scheme for broad-cast authentication to overcome this deficiency in [82 83]The basic idea in [82 83] is to predetermine and broadcastthe initial parameters required by µTESLA instead of usingunicast-based message transmission The simplest way is topredistribute the µTESLA parameters with a master key dur-ing the initialization of the sensor nodes As a result all sen-sor nodes have the key chain commitments and othernecessary parameters once they are initialized and are readyto use µTESLA as long as the starting time has passed Fur-thermore Liu and Ning introduced a multilevel key chainscheme in which the higher-level key chains are used toauthenticate the commitments of lower-level ones Howeverthe multilevel key chain scheme suffers from possible DoSattacks during the commitment distribution stage Furthernone of the µTESLA or multilevel key chain schemes is scal-able in terms of the number of senders In [84] a practicalbroadcast authentication protocol was proposed to support apotentially large number of broadcast senders using µTESLAas a building blockµTESLA provides broadcast authentication for base sta-tions but is not suitable for local broadcast authenticationThis is because µTESLA does not provide immediate authen-tication For every received packet a node has to wait for oneµTESLA interval to receive the MAC key used in computingthe MAC for the packet As a result if µTESLA is used forlocal broadcast authentication a message traversing l hopswill take at least l µTESLA intervals to arrive at the destina-tion In addition a sensor node has to buffer all the unverifiedpackets Both the latency and the storage requirements limitthe scheme for authenticating infrequent messages broadcastby the base station Zhu et al proposed a one-way key chainscheme for one-hop broadcast authentication in LEAP [63]In this scheme every node generates a one-way key chain ofcertain length and then transmits the commitment (ie thefirst key) of the key chain to each neighbor encrypted withtheir pairwise shared key Whenever a node has a message tosend it attaches to the message the next authenticated key inthe key chain The authenticated keys are disclosed in anorder that is reverse to their generation A receiving neighborcan verify the message based on the commitment or anauthenticated key it received from the sending node morerecentlySECURE ROUTINGThe goal of a secure routing protocol is to ensure the integri-ty authentication and availability of messages The proposedsecure routing protocols for WSNs in the literature are basedon symmetric key cryptography except the work in [85] whichis based on public key cryptographySPINS is a suite of security protocols optimized for sensornetworks [8] SPINS includes two building blocks: SNEP andµTESLA SNEP provides data confidentiality two-party dataauthentication and data freshness for peer-to-peer communi-cation (node to base station) µTESLA provides authenticatedbroadcast as discussed before We discuss SNEP in this sub-sectionSPINS assumes that each node is predistributed with amaster key K which is shared with the base station at creationtime All other keys including a key Kencr for encryption akey Kmac for MAC generation and a key Krand for randomnumber generation are derived from the master key using astrong one-way function SPINS uses RC5 for confidentialitynFigure 3 Using a time-released key chain for source authenti-cation (Source: [8])F F F FK0 K1 K2 K3 K4 TimeP1 P2 P3 P4 P5 P6 P7                                                                                                                                                  IEEE Communications Surveys & Tutorials • 2nd Quarter 2006 15If A wants to send a message to base station B the completemessage that A sends to B isA → B : D〈KencrC〉MAC(KmacC|D)〈KencrC〉while D is the transmitted data and C is a shared counterbetween the sender and the receiver for the block cipher incounter mode The counter C is incremented after each mes-sage is sent and received in both the sender and receiversides SNEP also provides a counter exchange protocol to syn-chronize the counter value in both sidesSNEP offers the following properties: semantic securitydata authentication replay protection weak freshness andlow communication overhead SPINS identifies two types offreshness: weak freshness and strong freshness Weak fresh-ness provides partial message ordering and carries no delayinformation while strong freshness provides a total order on arequest–response pair and allows for delay estimation• Semantic security: The counter value is incremented aftereach message and thus the same message is encrypteddifferently each time• Data authentication: A receiver can be assured that themessage originated from the claimed sender if the MACverifies correctly• Replay protection: The counter value in the MAC pre-vents replaying old message• Weak freshness: The counter also maintains a messageordering in the receiver side and yields weak freshnessSNEP provides weak data freshness only because there isno absolute assurance to node A that a message was cre-ated by node B in response to an event in node A• Low communication overhead: The counter state is keptat each end point and does not need to be sent in eachmessageThe directed diffusion routing protocol was proposed byIntanagonwiwat et al without considering security issues [79]Pietro et al proposed an extension of the directed diffusionprotocol which provides secure multicasting in [62] Theextended scheme Logical Key Hierarchy for WSNs (LKHW)provides robustness in routing and security and supports bothbackward and forward secrecy for sensor join and leave oper-ations However it does not provide data authenticationInspired by the work on public key cryptography [6 7 3343] Du et al investigated the public key authentication prob-lem [85] The use of public key cryptography eases manyproblems in secure routing for example authentication andintegrity However before a node A uses the public key fromanother node B A must verify that the public key is actuallyB’s (ie A must authenticate B’s public key); otherwise man-in-the-middle attacks are possible In general networks publickey authentication involves a signature verification on a cer-tificate signed by a trusted third party Certificate Authority(CA) [86] However the signature verification operations arestill too expensive for sensor nodes as depicted in Table 3and 4 Du et al proposed an efficient alternative that usesonly a one-way hash function for the public key authentica-tion The proposed scheme can be divided into two stages Inthe predistribution stage a Merkle tree R is constructed witheach leaf Li corresponding to a sensor node (more informa-tion on Merkle trees is given below) Let pki represent nodei’s public key V be an internal tree node and Vleft and Vrightbe V’s two children The value of an internal tree node isdenoted by φ The Merkle tree can then be constructed as fol-lows:φ(Li) = h(idi pki) for i = 1 … Nφ(V) = h(φ(Vleft) || φ(Vright))where “||” represents the concatenation of two strings and his a one-way hash function such as MD5 or SHA-1 Let R bethe root of the tree Each sensor node v needs to store theroot value φ(R) and the sibling node values λ1 … λH alongthe path from v to R If node A wants to authenticate B’s pub-lic key B sends its public key pk along with the value of λ1… λH to node A Then A can use the same procedure toreconstruct the Merkle tree R′ and calculate the root valueφ(R′) A will trust B to be authentic if φ(R′) = φ(R) A sensornode only needs H + 1 storage units for the extra hash valuesBased on this scheme Du et al further extended the idea toreduce the height of the Merkle tree in order to improve thecommunication overhead of the scheme The proposedscheme is more efficient than signature verification on certifi-cates However the scheme requires that some hash values bedistributed in a predistribution stage This results in somescalability issues when new sensors are added to an existingWSNThe above discussion is summarized in Table 8OPEN RESEARCH ISSUESThe development of secure routing protocols is challengingbecause sensor nodes are prone to failures and the topologyof a sensor network changes frequently due to node failuresand possible mobility Key open research issues include thefollowing:• The proposed secure routing protocols for WSNs focuson static sensor networks only ignoring mobility Securerouting protocols for mobile sensor networks need to beinvestigated• Current broadcast authentication schemes such as µTES-LA and its extensions require the sensor network to beloosely time-synchronized This requirement is oftenhard to meet and new techniques that do not requirenTable 8 Comparison of secure routing protocolsReference Routing Confidentiality P2PAuthenticationBroadcastauthentication Integrity ScalabilitySNEP [8] Flat Yes Yes No Yes GoodLKHW [62] Flat Yes No No No LimitedµTESLA [8] Flat/Hierarchy No No Yes Yes MediumMulti level key chains [82] Flat/Hierarchy No No Yes Yes GoodLEAP [63] Hierarchy Yes Yes Yes Yes Medium                                                                                                                                                                                           IEEE Communications Surveys & Tutorials • 2nd Quarter 200616time synchronization are desirable• New schemes with higher scalability and efficiency needto be developed for the authenticated broadcast proto-cols The recent progress on public key cryptography mayfacilitate the design of authenticated broadcast protocols• Quality of Service (QoS) in WSNs needs to be evaluatedwith the addition of secure routing servicesSECURE DATA AGGREGATIONData communication constitutes an important share of thetotal energy consumption of the sensor network The simula-tion in [8] shows that data transmission accounts for 71 per-cent of the energy cost of computation and communicationfor the SNEP protocol Thus data aggregation can greatlyhelp conserve the scarce energy resources by eliminatingredundant dataData aggregation (fusion) protocols aim at eliminatingredundant data transmitted across the network and are essen-tial for energy-constrained WSNs Traditional data aggrega-tion techniques include simple types of queries such as SUMCOUNT AVERAGE and MIN/MAX Some researchers alsoextend data aggregation to median the most frequent (con-sensus) data values a histogram of the data distribution andrange queries [87] Data aggregation can be divided into twostages: detection and data fusionIn a WSN there are usually certain nodes called aggrega-tors helping to aggregate information requested by queriesWhen an aggregator node is compromised it is easy for theadversary to inject false data into sensor networks Thus theaggregators are vulnerable to attack Another possible attackis to compromise a sensor node and inject forged data througha sensor node Without authentication the attackers can foolthe aggregators into reporting false data to the base stationSecure data aggregation requires authentication confidentiali-ty and integrity Moreover secure data aggregation alsorequires the cooperation of sensor nodes to identify the com-promised sensorsHowever requirements for confidentiality and data aggre-gation are at odds with each other Confidentiality requiresthe data to be transmitted in encrypted text while data aggre-gation is usually based on plain text A straightforwardmethod is to invoke end-to-end encryption and decryptionbefore evoking data aggregation However the tradeoff is thatthe end-to-end encryption and decryption operations consumemore energy which is of great concern in WSNs An alterna-tive way is to provide data aggregation on concealed datawhich requires a particular class of encryption transformationHowever this method usually lowers the security levelFigure 4 shows a taxonomy of secure data aggregation pro-tocols in WSNs According to the protocol operation securedata aggregation can be classified into two categories: plain-text based and cipher based This section reviews the tech-niques for secure data aggregationPLAIN-TEXT BASED SECURE DATA AGGREGATIONHu and Evans proposed a secure aggregation (SA) protocolfor WSNs that is resilient to both intruder devices and singledevice key compromises [9] However the protocol may bevulnerable if a parent and a child node in the hierarchy arecompromisedPrzydatek et al proposed a secure information aggregation(SIA) framework for sensor networks [10] The frameworkconsists of three node categories: a home server base sta-tion(s) and sensor nodes A base station is a resources-enhanced node which is used as intermediary between thehome server and the sensor nodes and is also the candidateto perform the aggregation task SIA assumes that each sen-sor has a unique identifier and shares a separate secret cryp-tographic key with both the home server and the aggregatorThe keys enable message authentication and encryption ifdata confidentiality is required Moreover it further assumesthat the home server and base station can use a mechanismsuch as µTESLA to broadcast authentic messages The pro-posed solution consists of three parts: computation of theresult committing to the collected data and reporting theaggregation result while proving the correctness of the resultIn the first part the aggregator collects the data from sen-sors and locally computes the aggregation result The aggrega-tor can verify the authenticity of each sensor readingIn the second part the aggregator commits to the collecteddata The commitment to the input data ensures that theaggregator uses the data provided by the sensors and that thestatement to be verified by the home server about the correct-ness of computed results is meaningful One efficient way ofcommitting to the data is a Merkle hash-tree construction Inthis construction all the data collected from the sensors isplaced at the leaves of the tree The aggregator then com-putes a binary hash tree starting from the leaf nodes Eachinternal node in the hash tree is computed as the hash valueof the concatenation of its two child nodes The root of thetree is called the commitment of the collected data As thehash function in use is collision resistant once the aggregatorcommits to the collected values it cannot change any of themFigure 5 shows an example of a Merkle hash treeIn the third part the aggregator and the home serverengage in a protocol in which the aggregator communicatesthe aggregation result and the commitment to the server whileproving to the server that the reported results are correctusing interactive proof protocols Moreover the authors alsopresented efficient protocols for secure computation of themedian and average of the measurements for the estimationof the network size and for finding the minimum and maxi-mum sensor readingDeng et al proposed a collection of mechanisms for secur-ing in-network processing (SINP) for WSNs [88] Securitymechanisms were proposed to address the downstreamrequirement that sensor nodes authenticate commands dis-seminated from parent aggregators and the upstream require-ment that aggregators authenticate data produced by sensorsbefore aggregating that data In the downstream stage twotechniques are involved: one-way functions and µTESLA ThenFigure 4 Secure data aggregation in WSNs: a taxonomySA [9] SIA [10] SINP [88]ESPDA [89 90]SDDA [91] WDA [92]CDA [93] HSC [94]Plaintext-basedaggregationProtocol operationsCipher-basedaggregation                    IEEE Communications Surveys & Tutorials • 2nd Quarter 2006 17upstream stage requires that a pairwise key be shared betweenan aggregator and its sensor nodesÇam et al proposed an energy-efficient secure pattern-based data aggregation (ESPDA) protocol for wireless sensornetworks in [89 90] ESPDA is applicable for hierarchy-basedsensor networks In ESPDA a cluster head first requests sen-sor nodes to send the corresponding pattern code for thesensed data If multiple sensor nodes send the same patterncode to the cluster head only one of them is permitted tosend the data to the cluster head ESPDA is secure because itdoes not require encrypted data to be decrypted by cluster-heads in order to perform data aggregationFurther the authors introduced a secure differential dataaggregation (SDDA) scheme based on pattern codes [91]SDDA prevents redundant data transmission from sensornodes by implementing the following schemes: SDDA trans-mits differential data rather than raw data SDDA performsdata aggregation on pattern codes representing the main char-acteristics of sensed data and SDDA employs a sleep proto-col to coordinate the activation of sensing units in such a waythat only one of the sensor nodes capable of sensing the datais activated at a given time In the SDDA data transmissionscheme the raw data from sensor nodes is compared to refer-ence data with the difference data being transmitted The ref-erence data is obtained by taking the average of previouslytransmitted dataDu et al proposed a witness-based data aggregation(WDA) scheme for WSNs to assure the validation of the datasent from data fusion nodes to the base station [92] In orderto prove the validity of the fusion result thefusion node has to provide proofs from severalwitnesses A witness is one who also conductsdata fusion like a data fusion node but does notforward its result to the base station Insteadeach witness computes the message authentica-tion code (MAC) of the result and then providesit to the data fusion node who must forward theproofs to the base stationWagner studied secure data aggregation insensor networks and proposed a mathematicalframework for formally evaluating their security[93] In [11 94] the authors proposed two datafusion schemes for the filtering of injected falsedata in sensor networks which will be intro-duced belowCIPHER-BASED SECURE DATA AGGREGATIONTwo cipher-based secure data aggregationschemes were proposed in [95 96] works whichare based on a particular encryption transforma-tion called a privacy homomorphism (PH) Thisis an encryption transformation that allowsdirect computation on encrypted data Let Qand R denote two rings and let + denote addi-tion and × denote multiplication on both Let Kbe the key space We denote an encryption trans-formation E: K × Q → R and the correspondingdecryption transformation D : K × R → Q Givena b ∈ Q and k ∈ K we terma + b = Dk(Ek(a) + Ek(b))additively homomorphic anda × b = Dk(Ek(a) × Ek(b))multiplicative homomorphic [12]The proposed scheme in [95] Concealed Data Aggregation(CDA) is based on the PH proposed in [97] although thestudy in [98] has shown that the proposed PH in [97] is unse-cure against chosen plain text attacks for some parameter set-tings In [95] the authors claimed that for the WSN dataaggregation scenario the security level is still adequate andthe proposed PH method in [97] can be employed for encryp-tion CDA can be used to calculate SUM and AVERAGE ina hierarchical WSN To calculate AVERAGE an aggregatorneeds to know the number of sensor nodes nCastelluccia et al proposed a simple and provable secureadditively homomorphic stream cipher (HSC) that allows forthe efficient aggregation of encrypted data [96] The newcipher uses modular addition and is therefore very well suitedfor CPU-constrained devices such as those in WSNs Theaggregation based on this cipher can be used to efficientlycompute statistical values such as the mean variance andstandard deviation of sensed data while achieving significantbandwidth gainOPEN RESEARCH ISSUESData aggregation is essential for WSNs and security is abso-lutely necessary to defend against compromised sensor nodesOpen research issues include the following:• Several secure data aggregation protocols have been pro-posed; however no comparisons have been conducted onthese protocols Further evaluation and comparison arenFigure 5 Merkle hash tree used to commit to a set of values The aggregatorconstructs the Merkle hash tree over the sensor measurement m0 … m7 Toconstruct the Merkle hash tree the aggregator first hashes the measurementswith a cryptographic hash function eg v30 = H(m0) assuming that the sizeof the hash is smaller than the size of the data Then each internal value of theMerkle hash tree is derived from its two child nodes: vij = H(vi+12j || vi+12j+1) The Merkle hash tree is a commitment to all the leaf nodes Once theaggregator commits to the collected values it cannot change any of the collect-ed data A verifier can authenticate any value by verifying that the leaf value isused to derive the root node given the authentic root node v00 For example toauthenticate the measurement m5 the aggregator sends m5 along with v3 4v23 v10 and m5 is authentic if the following equality holds: v00 = H(v10 ||H(H(v34 || H(m5)) || v23)) (Source:[10])v10v00=H(v10//v11)v11v20v30m0v31m1v32m2v33m3v34m4v35m5v36m6v37m7Hv21 v22 v23                                                                                                                                   IEEE Communications Surveys & Tutorials • 2nd Quarter 200618desirable to learn the performance of these protocolsThe performance matrices might include security pro-cessing overhead communication overhead energy con-sumption and data compression rate• New data aggregation protocols need to be developed toaddress higher scalability and higher reliability againstaggregator and sensor node cheatingINTRUSION DETECTIONThe security mechanisms implemented in secure routing pro-tocols and secure data aggregation protocols are configuredahead of time in order to inhibit an attacker from breakingthe security of the network These security mechanisms alonecannot ensure perfect security of a WSN Since sensor nodescan be compromised it is easy for an adversary to inject falsedata into a WSN through the compromised nodes Authenti-cation and data encryption are not enough for ensuring datasecurity Another approach to protect WSNs involves mecha-nisms for detecting and reacting to intrusionsAn Intrusion Detection System (IDS) monitors a host ornetwork for suspicious activity patterns outside normal andexpected behavior [5] It is based on the assumption that thereexists a noticeable difference in the behaviors of an intruderand a legitimate user in the network such that an IDS canmatch those preprogrammed or possibly learned rules Basedon the analysis model used for analyzing the audit data todetect intrusions IDSs in ad hoc networks are classified intorule-based and anomaly-based systems The rule-based intru-sion detection systems are used to detect known patterns ofintrusions (eg [99] and [100]) while anomaly-based systemsare used to detect new or unknown intrusions (eg [101] and[102]) A rule-based IDS has a low false-alarm rate whencompared to an anomaly-based system and an anomaly-basedIDS has a high intrusion-detection rate in comparison to arule-based systemHowever WSNs are generally application-specific and lackbasic information on topology normal usage expected com-munication patterns and so forth It is impractical to prein-stall some fixed patterns in sensors before they are deployedMoreover due to constraints in sensors to learn and detectthese parameters after deployment is both time and energyconsuming Thus existing IDSs in ad hoc networks may notbe adapted to WSNs The research on intrusion detection inWSNs is still preliminary Current research focuses on how todetect and eliminate injected false information Note thatcompromised nodes can always inject false information into asensor network Thus cooperation among sensors especiallyneighboring nodes is necessary to decide the validity of areport In this section we discuss the intrusion detection tech-niques in WSNsINTRUSION DETECTION IN WSNSZhu et al proposed an interleaved hop-by-hop authentication(IHOP) scheme in [11] IHOP guarantees that the base sta-tion will detect any injected false data packets when no morethan a certain number t of nodes are compromised The sen-sor network is organized in a cluster-based hierarchy Eachcluster head builds a route to the base station and each inter-mediate node has an upper associate node and a lower associ-ate node that is t + 1 hops away IHOP depends on the use ofsome sharing keys:• Every node shares a master secret key with the base sta-tion• Each node knows its one-hop neighbors and has estab-lished a pairwise key with each of them• A node can establish a pairwise key with another nodethat is multiple hops away if neededFurther IHOP also assumes that the base station has amechanism to authenticate broadcast messages (eg µTES-LA)A cluster head collects information from its members andsends a report to the base station only when at least t + 1 sen-sors observe the same result Meanwhile a cluster head alsocollects the message authentication codes (MACs) fromdetecting nodes Each detecting node sends two MACs to thecluster head: a MAC using the key shared with the base sta-tion referred to as the individual MAC and a MAC using thekey shared with its upper associate nodes referred to as thepairwise MAC The cluster head then compresses the t + 1individual MACs by XORing them to reduces the size of areport However the pairwise MACs are not compressed fortransmission If they were a node relaying the message wouldnot be able to extract the pairwise MACs of interest to itThus a legitimate report includes t + 1 pairwise MACs and acompressed MAC for the base station When an intermediatenode receives a report it verifies the MAC of its lower associ-ate node If it fails the report is eliminated Otherwise itremoves the MAC generates a new MAC using its upperassociate node pairwise key and appends it to the reportIHOP ensures that the base station can detect false datapackets when no more than t nodes are compromised Howev-er the article does not show how to select the parameter t fora sensor networkYe et al proposed a statistical en-route filtering (SEF)mechanism that can detect and drop false data [94] SEF usesa similar key assignment scheme as the basic random keyscheme presented in [68] There is a global key pool and eachsensor is pre-installed with a partition selected from the poolWhen a stimulus occurs in the fields the sensors detectingthis event elect one of the nodes as the center of stimulus(CoS) a node which collects and summarizes the detectionresults from all detecting nodes and produces a synthesizedreport on behalf of the group The CoS generates the reportand broadcasts the report to all detecting nodes If a detectingnode agrees with the report it generates a MAC using a keyin its partition and sends the MAC to the CoS The CoSreports the stimulus to the base station only if it receives ade-quate MACs A legitimate report carries multiple MACs anda single compromised node cannot fake all MACs When anen-route node receives the report it verifies the correctness ofthe MACs probabilistically and drops those with invalidMACs immediately Finally if a report reaches the base sta-tion the base station checks all the MACs and filters out anyremaining false reports that escaped the en-route filteringWhen a stimulus appears multiple nodes that detect it collab-orate to process the signal and elect the CoS based on thesensing signal strength The node with the strongest signalstands out as the CoS To reduce the communication over-head SEF further uses a Bloom filter [103] to reduce MACsizes SEF is designed to protect against injected false infor-mation and cannot defend against selective forwardingattacksDeng et al proposed an intrusion-tolerant routing in wire-less sensor networks (INSENS) in [104] and they further eval-uated its performance in [105] INSENS is a proactive routingprotocol The sensors collect local topology information andsend this information back to the base station The base sta-tion generates a forwarding table based on the collected infor-mation and sends the routing table to the correspondingsensors The base station is the central control point for calcu-lating the routing table which relieves the computation load                              IEEE Communications Surveys & Tutorials • 2nd Quarter 2006 19of individual sensors Protecting against intrusions focuses onthree attacks: DoS-type attacks routing attacks and selectforwarding attacks To protect against DoStype attacks onlythe base station is allowed to broadcast to the entire networkand individual sensors can only send unicast messagesINSENS requires some broadcast authentication scheme suchas µTESLA Although a compromised node may still alter avalid message and broadcast that message to its neighbors thedamage is restricted to only nearby nodes and the down-stream nodes To protect against routing attacks which propa-gate erroneous control packets a symmetric key is chosen forconfidentiality and authentication Further to protect againstselect forwarding attacks data are sent to base stations alongtwo separate paths which are calculated by the base stations inthe route discovery step However INSENS is built on a tablebased routing protocol and as such depends on the base sta-tions to collect all needed topology information to calculatethe forwarding table for each individual sensor Thus INSENSis not scalable in large sensor networksWang et al proposed a scheme to detect whether a node isfaulty or malicious with the collaboration of neighbor nodes[106] In the proposed scheme when a node suspects that oneof its neighbors is faulty it sends out messages to requestopinions on the behavior of this suspected node from otherneighbors of the suspect After collecting the results the nodeanalyzes the results to diagnose whether the suspect has afault The authors formalized the problem as how to constructa dominating tree to cover all the neighbors of the suspectand further proposed two tree-based propagation collectionprotocols to construct a dominating tree and collect informa-tion via the tree structureOPEN RESEARCH ISSUESIntrusion detection in WSNs is still largely open to researchKey research issues include the following:• Due to the constraints in WSNs intrusion detection hasmany aspects that are not of concern in other networktypes The problem of intrusion detection needs to bewell defined in WSNs• The proposed IDS protocols in literature focus on filter-ing injected false information only [11 94 104] Theseprotocols need to be improved so as to address scalabilityissuesSECURITY IN WSNS: FUTURE DIRECTIONSWSNs are promising solutions for many applications andsecurity is often a key concern Although research efforts havebeen made with regard to cryptography key managementsecure routing secure data aggregation and intrusion detec-tion in WSNs there are still some challenges to be addressedFirst the selection of the appropriate cryptographic methodsdepends on the processing capability of sensor nodes indicat-ing that there is no unified solution for all sensor networksInstead the security mechanisms are highly application-specif-ic Second sensors are characterized by the constraints onenergy computation capability memory and communicationbandwidth The design of security services in WSNs must sat-isfy these constraints Third most of the current protocolsassume that the sensor nodes and the base station are station-ary However there may be situations such as battlefieldenvironments where the base station and possibly the sensorsneed to be mobile The mobility of sensor nodes has a greatinfluence on sensor network topology and thus raises manyissues about secure routing protocols In particular we identi-fy some of the future directions in the study of security issuesin WSNs as follows• Exploit the availability of private key operations on sen-sor nodes: Recent studies on public key cryptographyshow that public key operations may be practical in sen-sor nodes However private key operations are still tooexpensive to accomplish in a sensor node As public keycryptography can greatly ease the design of security inWSNs improving the efficiency of private key operationson sensor nodes is highly desirable• Secure routing protocols for mobile sensor networks: Themobility of sensor nodes has a great influence on sensornetwork topology and thus on the routing protocolsMobility can be at the base station sensor nodes orboth Current protocols assume the sensor network isstationary New secure routing protocols for mobile sen-sor networks need to be developed• Continuous stream security in WSNs: Current work onsecurity in sensor networks focuses on discrete eventssuch as temperature and humidity Continuous streamevents such as video and images are not discussed Videoand image sensors for WSNs might not be widely avail-able now but will likely be in the future Substantial dif-ferences in authentication and encryption exist betweendiscrete events and continuous events indicating thatthere will be distinctions between continuous streamsecurity and the current protocols in WSNs• QoS and security: Performance is generally degradedwith the addition of security services in WSNs Currentstudies on security in WSNs focus on individual topicssuch as key management secure routing secure dataaggregation and intrusion detection QoS and securityservices need to be evaluated together in WSNsSUMMARYAs WSNs grow in capability and are used more frequentlythe need for security in them becomes more apparent How-ever the nature of nodes in WSNs gives rise to constraintssuch as limited energy processing capability and storagecapacity These constraints make WSNs very different fromtraditional ad hoc wireless networks As such special proto-cols and techniques have been developed for use in WSNsWhile existing surveys [12–15] discuss security in wirelessnetworks none focus specifically on security in WSNs and theconstraints unique to them In this article we have surveyedthe security issues in WSNs starting with the attacks andcountermeasures in each network layer followed by the issuesand solutions in cryptography key management secure rout-ing secure data aggregation and finally intrusion detectionWhile the discussed security services certainly add more com-putation communication and storage overhead in WSNs andthus consume more energy they are highly desirable andoften required in real-world applicationsACKNOWLEDGMENTSThis work is partially supported by NSF Grant no CCR-0311577 The authors thank the anonymous reviewers fortheir valuable comments on this manuscriptREFERENCES[1] D Estrin et al “Instrumenting the World with Wireless SensorNetworks” Proc Int’l Conf Acoustics Speech and Signal Pro-cessing Salt Lake City UT May 2001 [2] H Chan and A Perrig “Security and Privacy in Sensor Net-                      IEEE Communications Surveys & Tutorials • 2nd Quarter 200620works” IEEE Comp Mag Oct 2003 pp 103–05 [3] E Shi and A Perrig “Designing Secure Sensor Networks”Wireless Commun Mag vol 11 no 6 Dec 2004 pp 38–43 [4] I F Akyildiz et al “A Survey on Sensor Setworks” IEEE Com-mun Mag vol 40 no 8 Aug 2002 pp 102–114 [6] N Gura et al “Comparing Elliptic Curve Cryptography andRSA on 8-bit CPUs” CHES '04: Proc Wksp CryptographicHardware and Embedded Systems Aug 2004 [7] A S Wander et al “Energy Analysis of Public-Key Cryptogra-phy for Wireless Sensor Networks” PerCom ’05: Proc 3rd IEEEInt'l Conf Pervasive Computing and Commun Mar 2005 [8] A Perrig et al “SPINS: Security Protocols for Sensor Net-works” Wireless Networks vol 8 no 5 Sept 2002 pp521–34 [9] L Hu and D Evans “Secure Aggregation for Wireless Net-works” Wksp Security and Assurance in Ad Hoc Networks2003 [10] B Przydatek D Song and A Perrig “SIA: Secure Informa-tion Aggregation in Sensor Networks” SenSys '03: Proc 1stInt'l Conf Embedded Networked Sensor Systems New York:ACM Press 2003 pp 255–65[11] S Zhu et al “An Interleaved Hop-by-Hop AuthenticationScheme for Filtering of Injected False Data in Sensor Net-works” Proc IEEE Symp Security and Privacy Oakland CAMay 2004 pp 259–71 [12] R L Rivest L Adleman and M L Dertouzos “On DataBanks and Privacy Homomorphisms” in Foundations of SecureComputation New York: Academic 1978 pp 169–79 [13] F Stajano and R J Anderson “The Resurrecting Duckling:Security Issues for Ad-hoc Wireless Networks” Proc 7th Int'lWksp Security Protocols London: Springer-Verlag 2000 pp172–94 [14] Y-C Hu and A Perrig “A Survey of Secure Wireless Ad HocRouting” IEEE Security & Privacy Special Issue: Making Wire-less Work vol 2 no 3 May/June 2004 pp 28–39 [15] D Djenouri L Khelladi and N Badache “A Survey on Securi-ty Issues in Mobile Ad Hoc and Sensor Networks” IEEE Com-mun Surveys and Tutorials vol 7 no 4 2005 [16] P Levis and D Culler “Mate: A Tiny Virtual Machine for Sen-sor Networks” ASPLOS-X: Proc 10th Int'l Conf ArchitecturalSupport for Programming Languages and Operating SystemsNew York: ACM Press 2002 pp 85–95 [17] EYES project Mar 2002–Feb 2005 http://wwweyeseuorg[18] A Savvides and M B Srivastava “A Distributed ComputationPlatform for Wireless Embedded Sensing” ICCD '02: Proc2002 IEEE Int'l Conf Computer Design: VLSI in Computersand Processors Washington DC: IEEE Computer Society 2002p 220 [19] R Kling “Intel Research Mote” in Network Embedded Sys-tems Technology Winter 2003 Retreat Jan 15–17 2003 [20] J Hill et al “System Architecture Directions for NetworkedSensors” ASPLOSIX: Proc 9th Int'l Conf Architectural Supportfor Programming Languages and Operating Systems NewYork: ACM Press 2000 pp 93–104 [21] J Hill et al “System Architecture Directions for NetworkedSensors” SIGOPS Oper Syst Rev vol 34 no 5 2000 pp93–104[22] S Slijepcevic et al “On Communication Security in WirelessAd-Hoc Sensor Networks” Proc 11th IEEE Int'l Wksp EnablingTechnologies: Infrastructure for Collaborative Enterprises(WETICE’02) 2002 pp 139–44 [23] L Yuan and G Qu “Design Space Exploration for Energy-Efficient Secure Sensor Network” IEEE Int'l Conf Application-Specific Systems Architectures and Processors (ASAP '02) July2002 pp 88–100 [24] J Deng R Han and S Mishra “Enhancing Base StationSecurity in Wireless Sensor Networks” Department of Comput-er Science University of Colorado Tech Report CU-CS-951-032003 [25] B Deb S Bhatnagar and B Nath “Information Assurance inSensor Networks” Proc 2nd ACM Int'l Conf Wireless SensorNetworks and Applications (WSNA '03) New York: ACM Press2003 pp 160–68 [26] C Karlof and D Wagner “Secure Routing in Wireless SensorNetworks: Attacks and Countermeasures” Proc First IEEE Int'lWksp Sensor Network Protocols and Applications May 2003pp 113–27 [27] J Newsome et al “The Sybil Attack in Sensor Networks:Analysis and Defenses” IPSN '04: Proc IEEE Int'l Conf InfoProcessing in Sensor Networks Apr 2004 [28] Y-C Hu A Perrig and D B Johnson “Packet Leashes: ADefense Against Wormhole Attacks in Wireless Networks”Proc IEEE INFOCOM 2003 Apr 2003 [29] W Diffie and M E Hellman “New Directions in Cryptogra-phy” IEEE Trans Info Theory vol 22 no 6 Nov 1976 pp644–54 [30] R L Rivest A Shamir and L Adleman “A Method forObtaining Digital Signatures and Public-Key Cryptosystems”Commun ACM vol 26 no 1 1983 pp 96–99 [31] D W Carman P S Kruus and B J Matt “Constraints andApproaches for Distributed Sensor Network Security” NAILabs Tech Report 00-010 2000 [32] M Brown et al “PGP in Constrained Wireless Devices” Proc9th USENIX Security Symp Aug 2000 [33] G Gaubatz J-P Kaps and B Sunar “Public Key Cryptogra-phy in Sensor Networks-Revisited” ESAS ’04: 1st EuropeanWksp Security in Ad-Hoc and Sensor Networks 2004 [34] M O Rabin “Digitalized Signatures and Public-Key Functionsas Intractable as Factorization” Tech Rep Cambridge MA1979 [35] J Hoffstein J Pipher and J H Silverman “Ntru: A Ring-Based Public Key Cryptosystem” ANTS-III: Proc 3rd Int'lSymp Algorithmic Number Theory London: Springer-Verlag1998 pp 267–88 [36] V S Miller “Use of Elliptic Curves in Cryptography” Lecturenotes in computer sciences; 218 on Advances in Cryptology-CRYPTO 85 New York: Springer-Verlag 1986 pp 417–26 [37] N Koblitz “Elliptic Curve Cryptosystems” Mathematics ofComputation vol 48 1987 pp 203–09 [38] Elliptic Curve Cryptography SECG Std SEC1 2000 availableat wwwsecgorg/collateral/sec1pdf[39] B Kaliski “TWIRL and RSA Key Size” RSA Laboratories”Tech Note May 2003 [40] Recommended Elliptic Curve Domain Parameters SECG StdSEC2 2000 available at wwwsecgorg/collateral/sec2pdf[41] D Hankerson A Menezes and S Vanstone Guide to EllipticCurve Cryptography New York: Springer-Verlag 2004 [42] A Freier P Karlton and P Kocher “The SSL Protocol Ver-sion 30” http://homenetscapecom/eng/ssl3/[43] R Watro et al “TinyPK: Securing Sensor Networks with Pub-lic Key Technology” SASN '04: Proc 2nd ACM Wksp Securityof Ad Hoc and Sensor Networks New York: ACM Press 2004pp 59–64 [44] A Liu and P Ning “TinyECC: Elliptic Curve Cryptography forsensor networks (version 01)” Sept 2005 available athttp://discoverycscncsuedu/software/TinyECC/[45] D J Malan M Welsh and M D Smith “A Public-Key Infra-structure for Key Distribution in TinyOS based on Elliptic CurveCryptography” Proc 1st IEEE Int'l Conf Sensor and Ad HocCommunications and Networks Santa Clara CA Oct 2004 [46] C Karlof N Sastry and D Wagner “Tinysec: A Link-LayerSecurity Architecture for Wireless Sensor Networks” SenSys'04: Proc 2nd Int'l Conf Embedded Networked Sensor Sys-tems New York: ACM Press 2004 pp 162–75 [47] US National Institute of Standards and Technology (NIST)“SKIPJACK and KEA Algorithm Specifications” Federal Informa-tion Processing Standards Publication 185 (FIPS PUB 185) June1998 [48] R L Rivest “The RC5 Encryption Algorithm” Fast SoftwareEncryption B Preneel (Ed) Springer 1995 pp 86–96 [49] D Eastlake III and P Jones “US Secure Hash Algorithm 1(SHA1)” RFC 3174 (Informational) Sept 2001 [50] J Daemen and V Rijmen “AES Proposal: Rijndael” Proc 1stAES Conf Aug 1998 [51] A J Menezes S A Vanstone and P C V Oorschot Hand-book of Applied Cryptography Boca Raton FL: CRC Press1996 [52] R L Rivest “The MD5 Message-Digest Algorithm” RFC 1321Apr 1992 [53] P Ganesan et al “Analyzing and Modeling Encryption Over-                                                                                                       IEEE Communications Surveys & Tutorials • 2nd Quarter 2006 21head for Sensor Network Nodes” WSNA '03: Proc 2nd ACMInt'l Conf Wireless Sensor Networks and Applications NewYork: ACM Press 2003 pp 151–59 [54] Y W Law et al “Assessing Security- Critical Energy-EfficientSensor Networks” Proc 18th IFIP TC11 Int'l Conf Info Securi-ty Security and Privacy in the Age of Uncertainty (SEC)Athens Greece May 2003 pp 459–63 [55] D J Wheeler and R M Needham “TEA A Tiny EncryptionAlgorithm” Proc Fast Software Encryption: 2nd Int'l Wkspin Lecture Notes in Computer Science (series) B Preneel (Ed)vol 1008 1994 [56] R L Rivest et al “The RC6 Block Cipher” submitted to NISTas a candidate for the AES [57] M Matsui “New Block Encryption Algorithm Misty” Proc4th Int'l Wksp Fast Software Encryption in LNCS E Biham(Ed) vol 1267 London: Springer-Verlag 1997 pp 54–68[58] ETSI/SAGE “Specification of the 3GPP Confidentiality andIntegrity Algorithms Document 2: KASUMI Specification” Dec1999 [59] K Aoki et al “Specification of Camellia: A 128-Bit BlockCipher specification version 20” Nippon Telegraph and Tele-phone Corporation and Mitsubishi Electric Corporation 2001 [60] Y W Law J M Doumen and P H Hartel “BenchmarkingBlock Ciphers for Wireless Sensor Networks (ExtendedAbstract)” 1st IEEE Int'l Conf Mobile Ad-hoc and Sensor Sys-tems IEEE Computer Society Press Oct 2004 [61] S A Camtepe and B Yener “Key Distribution Mechanismsfor Wireless Sensor Networks: A Survey” Computer ScienceDepartment at RPI Tech Rep TR-05-07 2005 [62] R D Pietro et al “LKHW: A Directed Diffusion-Based SecureMulticast Scheme for Wireless Sensor Networks” ICPPW ’03:Proc 32nd Int’l Conf Parallel Processing Wksps IEEE Com-puter Society Press 2003 pp 397–406 [63] S Zhu S Setia and S Jajodia “LEAP: Efficient SecurityMechanisms for Large-Scale Distributed Sensor Networks” CCS’03: Proc 10th ACM Conf Comp and Commun Security NewYork: ACM Press 2003 pp 62–72 [64] B Lai S Kim and I Verbauwhede “Scalable Session KeyConstruction Protocols for Wireless Sensor Networks” IEEEWksp Large Scale Real Time and Embedded Systems 2002 [65] S A Cametepe and B Yener “Combinatorial Design of KeyDistribution Mechanisms for Wireless Sensor Networks” Proc9th European Symp Research Computer Security 2004 [66] J Lee and D R Stinson “Deterministic Key PredistributionSchemes for Distributed Sensor Networks” Proc SelectedAreas Cryptography 2004 pp 294–307 [67] J Lee and D R Stinson “A Combinatorial Approach to KeyPredistribution for Distributed Sensor Networks” Proc IEEEWireless Commun and Net Conf 2005 [68] L Eschenauer and V D Gligor “A Key-Management Schemefor Distributed Sensor Networks” CCS ’02: Proc 9th ACMConf Comp and Commun Security New York: ACM Press2002 pp 41–47 [69] H Chan A Perrig and D Song “Random Key PredistributionSchemes for Sensor Networks” Proc IEEE Symp Security andPrivacy May 2003 [70] D Liu and P Ning “Establishing Pairwise KeysDistributedSensor Networks” CCS ’03: Proc 10th ACM Conf Comp andCommun Security New York: ACM Press 2003 pp 52–61 [71] R D Pietro L V Mancini and A Mei “Random Key-Assign-ment for Secure Wireless Sensor Networks” SASN ’03: Proc1st ACM Wksp Security of Ad Hoc and Sensor Networks NewYork: ACM Press 2003 pp 62–71 [72] W Du et al “A Pairwise Key Predistribution Scheme forWireless Sensor Networks” CCS ’03: Proc 10th ACM ConfComp and Communications Security New York: ACM Press2003 pp 42–51 [73] W Du et al “A Key Management Scheme for Wireless Sen-sor Networks using Deployment Knowledge” Proc IEEE INFO-COM Hong Kong 2004 pp 586–97 [74] D D Hwang B Lai and I Verbauwhede “Energy-Memory-Security Trade-OffsDistributed Sensor Networks” Proc 3rdInt’l Conf Ad-Hoc Networks and Wireless July 2004 pp70–81 [75] C Blundo et al “Perfectly-Secure Key Distribution forDynamic Conferences” CRYPTO ’92: Proc 12th Annual Int’lCryptology Conf Advances in Cryptology London: Springer-Verlag 1993 pp 471–86 [76] R Blom “An Optimal Class of Symmetric Key Generation Sys-tems” Proc EUROCRYPT ‘84 Wksp Advances in CryptologyNew York: Springer-Verlag 1985 pp 335–38 [77] D Liu and P Ning “Location-Based Pairwise Key Establish-ments for Static Sensor Networks” Proc ACM Wksp SecurityAd Hoc and Sensor Networks Oct 2003 [78] J N Al-Karaki and A E Kamal “Routing Techniques in Wire-less Sensor Networks: A Survey” IEEE Wireless Commun vol11 no 6 Dec 2004 pp 6–28 [79] C Intanagonwiwat R Govindan and D Estrin “Directed Dif-fusion: A Scalable and Robust Communication Paradigm forSensor Networks” MobiCom ’00: Proc 6th Annual Int’l ConfMobile Computing and Networking New York: ACM Press2000 pp 56–67 [80] Y Yu R Govindan and D Estrin “Geographical and EnergyAware Routing: A Recursive Data Dissemination Protocol forWireless Sensor Networks” UCLA Computer Science Depart-ment Tech Rep UCLA/CSD-TR-01-0023 May 2001 [81] T Leinmüller et al “Influence of Falsified Position Data onGeographic Ad-Hoc Routing” 2nd European Wksp Securityand Privacy Ad Hoc and Sensor Networks (ESAS 2005) LNCSJuly 2005 [82] D Liu and P Ning “Efficient Distribution of Key Chain Com-mitments for Broadcast AuthenticationDistributed Sensor Net-works” Proc 10th Annual Network and Distributed SystemSecurity Symp San Diego CA Feb 2003 pp 263–76 [83] D Liu and P Ning “Multilevel mTESLA: Broadcast Authenti-cation for Distributed Sensor Networks” Trans EmbeddedComputing Sys vol 3 no 4 2004 pp 800–36 [84] D Liu et al “Practical Broadcast AuthenticationSensor net-works” MobiQuitous ’05: Proc 2nd Annual Int’l Conf Mobileand Ubiquitous Systems: Networking and Services July 2005pp 118–29 [85] W Du R Wang and P Ning “An Efficient Scheme forAuthenticating Public KeysSensor Networks” MobiHoc ’05:Proc 6th ACM Int’l Symp Mobile Ad Hoc Net and CompNew York: ACM Press 2005 pp 58–67 [86] Public-Key Infrastructure (X509) (pkix) available:http://wwwietforg/htmlcharters/pkix-charterhtml[87] N Shrivastava et al “Medians and Beyond: New Aggrega-tion Techniques For Sensor Networks” SenSys ’04: Proc 2ndInt’l Conf Embedded Networked Sensor Systems New York:ACM Press 2004 pp 239–49 [88] J Deng R Han and S Mishra “Security Support for in-Net-work Processing Wireless Sensor Networks” SASN ’03: Proc1st ACM Wksp Security of ad Hoc and Sensor Networks NewYork: ACM Press 2003 pp 83–93 [89] H Çam D Muthuavinashiappan and P Nair “ESPDA: EnergyEfficient and Secure Pattern-Based Data Aggregation for Wire-less Sensor Networks” Proc IEEE Sensors Toronto CanadaOct 2003 pp 732–36 [90] H Çam D Muthuavinashiappan and P Nair “Energy-Effi-cient Security Protocol for Wireless Sensor Networks” ProcIEEE VTC Conf Orlando FL Oct 2003 pp 2981–84 [91] H Çam et al Sensor Network Operations Wiley 2004 ch“Secure Differential Data Aggregation for Wireless Sensor Net-works”[92] W Du et al “A Witness-Based Approach for Data FusionAssurance wireless Sensor Networks” GLOBECOM ’03: ProcIEEE Global Telecommun Conf San Francisco CA Dec 2003pp 1435–39 [93] D Wagner “Resilient Aggregation Sensor Networks” SASN’04: Proc 2nd ACM Wksp Security of Ad Hoc and Sensor Net-works New York: ACM Press 2004 pp 78–87 [94] F Ye et al “Statistical En-Route Filtering of Injected FalseDatasensor Networks” Proc IEEE INFOCOM Hong Kong2004 [95] J Girao D Westhoff and M Schneider “CDA: ConcealedData Aggregation for Reverse Multicast Traffic wireless SensorNetworks” ICC ’05: Proc IEEE Int’l Conf Commun SeoulKorea May 2005 [96] C Castelluccia E Mykletun and G Tsudik “Efficient Aggre-                                                                                                         IEEE Communications Surveys & Tutorials • 2nd Quarter 200622gation of Encrypted Data Wireless Sensor Network” ProcACM/IEEE Mobiquitous San Diego CA July 2005 [97] J Domingo-Ferrer “A Provably Secure Additive and Multi-plicative Privacy Homomorphism” Lecture Notes Comp Scivol 2433 2002 pp 471–83 [98] D Wagner “Cryptanalysis of an Algebraic Privacy Homomor-phism” ISC ’03: Proc 6th Info Security Conf Bristol UKOct 2003 [99] S Marti et al “Mitigating Routing Misbehavior Mobile AdHoc Networks” MobiCom ’00: Proc 6th Annual Int’l ConfMobile Comp and Net New York: ACM Press 2000 pp255–65[100] Y Zhang W Lee and Y Huang “Intrusion Detection Tech-niques for Mobile Wireless Networks” Wireless Networks vol9 no 5 2003 pp 545–56 [101] Y Huang et al “Cross-Feature Analysis For detecting Ad-Hoc Routing Anomalies” ICDCS ’03: Proc 23rd Int’l ConfDistributed Computing Systems Providence RI May 2003 [102] Y Huang and W Lee “Attack Analysis and Detection for AdHoc Routing Protocols” RAIS ’04: Proc 7th Int’l Symp RecentAdvances Intrusion Detection Sophia Antipolis France Sept2004 [103] B H Bloom “Space/Time Trade-Offshash Coding withAllowable Errors” Commun ACM vol 13 no 7 1970 pp422–26 [104] J Deng R Han and S Mishra “INSENS: Intrusion-TolerantRouting Wireless Sensor Networks” Department of ComputerScience University of Colorado Tech Report CU CS-939-02Nov 2002 [105] J Deng R Han and S Mishra “A Performance Evaluationof Intrusion-Tolerant Routing Wireless Sensor Networks” IPSN’03: Proc IEEE 2nd Int’l Wksp Information Processing SensorNetworks Palo Alto CA 2003 pp 349–64 [106] G Wang et al “On supporting Distributed CollaborationSensor Networks” Proc MILCOM 2003BIOGRAPHIESYONG WANG (ywang@cseunledu) is a PhD candidate in theDepartment of Computer Science and Engineering (CSE) at theUniversity of Nebraska-Lincoln He received BS and MSEdegrees from Wuhan University China in 1995 and 1998 respec-tively Before joining the CSE department he has worked as asenior telecom engineer at ZTE Corp and UTStarcom Inc inChina His research focuses on secure group communication andsecurity for wireless ad hoc and sensor networksGARHAN ATTEBURY (attebury@cseunledu) is an MS degree candi-date in the Department of Computer Science and Engineering atthe University of Nebraska-Lincoln He received his BS degreefrom Eastern Oregon University in 2004 His research efforts arein the areas of computer network security and computationalchemistryBYRAV RAMAMURTHY (byrav@cseunledu) received his BTechdegree in computer science and engineering from the Indian Insti-tute of Technology Madras India in 1993 He received MS andPhD degrees in computer science from University of California(UC) Davis in 1995 and 1998 respectively Since August 1998 hehas been a faculty member in the Department of Computer Sci-ence and Engineering at the University of Nebraska-Lincoln (UNL)where he is currently an associate professor He is the co-directorof the UNL Academic Program Priority Initiative in the areas ofSimulation & Computing Engineering (SCE) and Information Tech-nology & Telecommunications (ITT) He is the founding co-directorof the Advanced Networking and Distributed Experimental Sys-tems (ANDES) Laboratory at UNL He served as Feature Editor onTheses for Optical Network Magazine He served as a guest co-editor for a special issue of IEEE Network on Optical Communica-tion Networks He served as a member of the technical programcommittees for the IEEE INFOCOM IEEE GLOBECOMOpticomm/Broadnets ICC and ICCCN conferences He is author ofthe book Design of Optical WDM Networks — LAN MAN andWAN Architectures and a co-author of Secure Group Communica-tions over Data Networks published by Kluwer Academic Publish-ers/Springer in 2000 and 2004 respectively From 2001–2003 heserved as the founding secretary of the IEEE ComSoc Optical Net-working Technical Committee (ONTC) for which he currentlyserves as the Secretary and Online Content Chair He serves as theTPC Co-Chair for the IEEE ICC 2006 Optical Systems and NetworksSymposium and the Broadnets 2006 Optical Symposium He wasa recipient of the Indian National Talent Search scholarship andwas a fellow of the Professors for the Future program at UCDavis He is a recipient of the UNL Research Council Grant-in-Aidaward (1999) the College of Engineering and Technology FacultyResearch Award (2000) and the UNL CSE Dept Students ChoiceAward for the Best Graduate Professor (2002–2003) His researchareas include optical networks wireless/sensor networks networksecurity distributed computing and telecommunications Hisresearch is supported by the US National Science FoundationAgilent Tech and OPNET Inc                                       IEEE Communications Surveys & Tutorials • 2nd Quarter 2006 23  
Dynamic Key managment-pdf,IEEE Communications Magazine • April 2006122 0163-6804/06/$2000 © 2006 IEEETOPICS IN AD HOC AND SENSOR NETWORKSINTRODUCTIONThe envisioned growth in utilizing sensor net-works in a wide variety of sensitive applicationsranging from healthcare to warfare is stimulatingnumerous efforts to secure these networks Sen-sor networks comprise a large number of tinysensor nodes that collect and (partially) processdata from the surrounding environment Thedata is then communicated using wireless linksto aggregation and forwarding nodes (or gate-ways) that may further process the data andcommunicate it to the outside world throughone or more base stations (or command nodes)Base stations are the entry points to the networkwhere user requests begin and network respons-es are received Typically gateways and base sta-tions are higher-end nodes It is to be notedhowever that various sensor gateway and basestation functions can be performed by the sameor different nodes The sensitivity of collecteddata makes encryption keys essential to securesensor networks The term key may refer to asimple key (eg 128-bit string) or a more com-plex key construct (eg a symmetric bivariatekey polynomial)A large number of keys needsto be managed in order to encrypt and authenti-cate sensitive data exchangedThe objective of key management is todynamically establish and maintain secure chan-nels among communicating parties Typicallykey management schemes use administrativekeys (aka key encryption keys) for the secureand efficient (re-)distribution and at times gen-eration of the secure channel communicationkeys (aka data encryption or session keys) tothe communicating parties Communication keysmay be pair-wise keys used to secure a commu-nication channel between two nodes that are indirect or indirect communications [1–4] or theymay be group keys shared by multiple nodes [56] Network keys (both administrative and com-munication keys) may need to be changed(rekeyed) to maintain secrecy and resilience toattacks failures or network topology changesKey management entails the basic functions ofanalysis generation assignment and distributionof network keys Rekeying is essentially compris-es these basic functionsThe characteristics of sensors and sensor net-works including limited resources lack of physi-cal protection unattended operation and closeinteraction with the physical environment ren-der most existing key management solutionsdeveloped for other networks infeasible for sen-sor networks Desirable features of key manage-ment schemes for sensor networks includeenergy awareness localized impact of attacksand scaling to a large number of nodes The pri-mary challenge lies in managing the trade-offbetween providing acceptable levels of securityand conserving the scarce resources in particu-lar energy needed for network operationsRecently numerous key managementschemes have been proposed for sensor net-works Most existing schemes build on the semi-nal random key predistribution schemeintroduced by Eschenauer and Gligor [1] Subse-Mohamed Eltoweissy Virginia TechMohammed Moharrum and Ravi Mukkamala Old Dominion University ABSTRACTNumerous key management schemes havebeen proposed for sensor networks The objec-tive of key management is to dynamically estab-lish and maintain secure channels amongcommunicating nodes Desired features of keymanagement in sensor networks include energyawareness localized impact of attacks and scal-ing to a large number of nodes A primary chal-lenge is managing the trade-off betweenproviding acceptable levels of security and con-serving scarce resources in particular energyneeded for network operations Many schemesreferred to as static schemes have adopted theprinciple of key predistribution with the underly-ing assumption of a relatively static short-livednetwork (node replenishments are rare and keysoutlive the network) An emerging class ofschemes dynamic key management schemesassumes long-lived networks with more frequentaddition of new nodes thus requiring networkrekeying for sustained security and survivabilityIn this article we present a classification of keymanagement schemes in sensor networks delin-eating their similarities and differences We alsodescribe a novel dynamic key managementscheme localized combinatorial keying (LOCK)and compare its security and performance with arepresentative static key management schemeFinally we outline future research directionsDynamic Key Management in Sensor Networks IEEE Communications Magazine • April 2006 123quent extensions to that scheme include usingkey polynomials [4] and deployment knowledge[3] to enhance scalability and resilience toattacks We refer to this set of schemes as statickey management schemes since they do notupdate the administrative keys post networkdeployment Another emerging category ofschemes employ a combinatorial formulation ofthe group key management problem to affectefficient rekeying [5 6] These are examples ofdynamic key management schemes While staticschemes primarily assume that administrativekeys will outlive the network and emphasizepairwise communication keys dynamic schemesadvocate rekeying to achieve resilience to attackin long-lived networks and primarily emphasizegroup communication keysThe objective of this article is to highlight thefeatures and performance/security attributes ofdifferent key management schemes designed forsensor networks We describe a general keymanagement process and present a classificationof key management schemes to enable identifi-cation of common architectural elements andfeatures and to expose common vulnerabilitiesof each class of schemes Another benefit is tofacilitate the analysis and comparison of solutionsets rather than individual schemes to help net-work designers make informed decisions suitableto their network conditions (eg long-lived vsshort-lived networks) and better identify emerg-ing trends and open research issues Since weemphasize the more recent class of dynamic keymanagement schemes as a viable alternative tothe de facto static schemes we also introduce anovel dynamic key management scheme local-ized combinatorial keying (LOCK) and compareits security and performance with a representa-tive static key management scheme described in[4] Finally we outline some future researchdirectionsTHE KEY MANAGEMENT PROCESSKey management entails four basic functionsnamely analysis assignment generation and dis-tribution of network keys Traditionally thesefunctions have been tightly coupled where all ofthem were performed by a centralized server orcollaboratively by the nodes in a network witheach node performing the same functions Morerecent proposals such as [1 4 5 6] moved todecouple these functions to various degreesSuch decoupling can immensely benefit sensornetworks due to their large scale high vulnera-bility to attacks and limited resourcesKeying functions are triggered by keyingevents These events include network deploy-ment node addition node eviction or periodic(or on-demand) key refresh Entities with keymanagement responsibilities may include a keyserver (prior to deployment in [1]) base sta-tion(s) (once during network bootstrapping [6]or multiple times throughout the network life-time [5]) gateway nodes [6] or even sensornodes (as proposed in this article) The basicfunctions in a general key management process(shown in Fig 1) are described belowKey analysis: Keying requirements are ana-lyzed to determine the required number of keysfor the network as well as the number of keysneeded by each node Also analysis may takeplace (using input from a detection system) todetermine keys that need updating Next keyassignment is performed Actual keys are thengenerated (and encrypted) and distributed totheir designated nodesKey assignment: This step refers to the map-ping of keys to different parties Administrativekey assignment is considered here since commu-nication keys are simply assigned by agreementof parties wanting to establish a secure commu-nication channel Key assignment may be static(say each node being assigned the same set ofkeys throughout the network’s lifetime) ordynamic depending on the key managementsolution employedMapping decisions significantly impact thelevel of security offered by the key managementscheme since a captured node may reveal all itskeys to an attacker If that node or a small num-ber of nodes collectively possess all networkadministrative keys capturing these nodes willjeopardize the security of the entire networkTherefore when a node is captured the fewerthe number of keys known (or the greater num-ber of keys unknown) to that node the smallerthe security risk However since some schemesdepend on the existence of overlapping keysamong nodes to establish communication amongthese nodes decreasing the number of keysknown to a node in these schemes may hampernetwork connectivityRandom key assignment is the simplest andleast expensive solution [1] However it limitscontrol over the network security risk in case ofmultiple node captures Deployment information(eg location or attack probability) has beenused to reduce the attacker’s probability touncover more keys by capturing related nodes(eg collocated nodes) [3 4]Key generation: The generation of adminis-trative keys may take place once or multipletimes over the lifespan of the network The gen-eration of communication keys is the responsibil-ity of the communicating parties (ie sensornodes gateways or base stations) In all casesthe key generating node(s) must be trusted by allkey-receiving nodes Keys might be as simple asa bit string or as complex as a symmetric bivari-ate polynomial [4]In static key predistribution schemes admin-istrative keys are generated by a key server andloaded into nodes prior to deployment [1 2] InnFigure 1 The key management processKeyingeventKeyanalysisKeyassignmentKeygenerationKeydistribution                    IEEE Communications Magazine • April 2006124other schemes new keys are generated regularlythroughout the lifetime of the network [7] possi-bly with a different key generator at differenttimes (as proposed in this article)Key distribution (and redistribution): Thisrefers to the delivery of keys to their designatednodes after they have been generated andassigned to the nodes If administrative keys aredelivered to their destinations after networkdeployment (eg due to rekeying) other (previ-ously distributed) administrative keys may beused to encrypt the new keys The distribution ofcommunication keys usually takes place after thenetwork has been deployed Communicationkeys are used for a short period of time andshould be regularly updated (this may includeanalysis assignment generation and [re]distri-bution)CLASSIFICATION OFKEY MANAGEMENT SCHEMES INSENSOR NETWORKSThe success of a key management scheme isdetermined in part by its ability to efficientlysurvive attacks on highly vulnerable andresource challenged sensor networks Key man-agement schemes in sensor networks can beclassified broadly into dynamic or static solu-tions based on whether rekeying (update) ofadministrative keys is enabled post networkdeployment Schemes can also be classified intohomogeneous or heterogeneous schemes withregard to the role of network nodes in the keymanagement process All nodes in a homoge-neous scheme perform the same functionality;on the other hand nodes in a heterogeneousscheme are assigned different roles Homoge-neous schemes generally assume a flat networkmodel while heterogeneous schemes areintended for both flat and clustered networksOther classification criteria include whethernodes are anonymous or have predeploymentidentifiers and if so when (pre- post-deploy-ment or both) and what deployment knowl-edge (location degree of hostility  etc) isimparted to the nodes Table 1 shows a classifi-cation based on the two primary criteria: staticvs dynamic and homogeneous vs heteroge-neous schemes Starting with the broad classifi-cation of static vs dynamic key managementwe briefly discuss examples of each class/sub-class Comprehensive coverage of the differentschemes is beyond the scope and space limita-tions of this articleSTATIC KEY MANAGEMENT SCHEMESThese schemes assume that once administrativekeys are predeployed in the nodes they will notbe changed Administrative keys are generatedprior to deployment assigned to nodes eitherrandomly or based on some deployment infor-mation and then distributed to nodes For com-munication key management most staticschemes use the overlapping of administrativekeys to determine the eligibility of neighboringnodes to generate a direct pair-wise communica-tion key Communication keys are assigned tolinks rather than nodes In order to establish anddistribute a communication key between twononneighboring nodes and/or a group of nodesthat key is propagated one link at a time usingpreviously established direct communicationkeysThe basic key predistribution scheme wasfirst proposed by Eschenauer and Gligor [1] Itassumes homogeneous nodes that are loadedwith keying material and perform the same keymanagement functions In this scheme k keys arerandomly selected by each node out of a largepool of P keys A major advantage of suchscheme is the exclusion of the base station in keymanagement Another advantage is incurring nopost-deployment communication overhead onsensor nodes (with respect to administrativekeys) However successive node captures enablethe attacker to reveal keys stored in capturednodes and use them to attack other nodes Theauthors show that on average half of the keysare used to secure links between nodes; thussuccessive node capturing hampers network sur-vivabilityAn enhancement of the basic scheme wasproposed in [2] in which two nodes can estab-lish a link only if they share q keys Liu andNing [4 8] provided further enhancements byusing t-degree bivariate key polynomials Insteadof selecting k keys out of a pool of P simplekeys for each node as in the basic Eschenauerand Gligor scheme a key server first randomlygenerates a pool of P bivariate t-degree polyno-mials each of which is uniquely identified by apolynomial ID The server then chooses a ran-dom subset of polynomials and distributes thepolynomial shares and polynomial IDs to thesensor nodes Two nodes can directly communi-cate only if they can identify at least one poly-nomial in common by exchanging theirpolynomial IDs nd using the polynomial-basedscheme to compute the pair-wise communica-tion key Indirect key establishment can beachieved in the same way as in [1 2] where twosensor nodes try to find a number of intermedi-ate nodes to help them set up a temporary com-munication key Since an attacker needs tocapture at least t + 1 nodes to obtain any t-degree polynomial this scheme was shown tosignificantly enhance network resilience to nodecapture as long as the number of captured nodesis below a certain threshold (around 3 percentas shown in [4])All  of  the above schemes are static homogenous and not reliant on post deploy-ment information Several techniques havebeen proposed to make use of deploymentnTable 1 Classification of key management schemes in sensor networksStatic DynamicHeterogeneous Liu et al [8]Jolly et al [6]LOCKYounis et al [9]Homogeneous Eschenauer and Gligor [1]Liu and Ning [7] Wadaa et al [4]                                        IEEE Communications Magazine • April 2006 125knowledge in order to improve static key man-agement Deployment knowledge may includenode locations neighbor locations node clus-ter (or group) as well as the attack probabilityin certain portions of the network For exam-ple in [8] the authors assume that nodes aredeployed in groups; each group might repre-sent a deployment event to a certain locationin the deployment field Individual nodes areassumed to be aware of their group prior todeployment A probabilistic deployment modelis assumed with a certain distribution of theexpected node location (either 2D uniform or2D normal distribution) through which nodesestimate their location If collocated nodes donot belong to the same group such nodes actas cross-group gateways to facilitate the estab-lishment of path keys between nodes belong-ing to multiple groups [8] This is an exampleof a heterogeneous static key managementschemeDYNAMIC KEY MANAGEMENT SCHEMESDynamic key management schemes may changeadministrative keys periodically on demand oron detection of node capture The major advan-tage of dynamic keying is enhanced network sur-vivability since any captured key(s) is replacedin a timely manner in a process known as rekey-ing Another advantage of dynamic keying isproviding better support for network expansion;upon adding new nodes unlike static keyingwhich uses a fixed pool of keys the probabilityof network capture does not necessarily increaseBoth homogeneous and heterogeneous dynamickey management schemes have been proposedin the literatureThe major challenge in dynamic keying isto design a secure yet eff icient rekeyingmechanism A proposed solution to this prob-lem is using exclusion-based systems (EBSs); acombinatorial formulation of the group keymanagement problem developed in [9]  InEBS-based schemes each node is assigned kkeys out of a pool of size P = k + m keysRekeying takes place either periodically oronce one or more nodes are captured (or sus-pected of being captured) Replacement keysare generated then encrypted with all the mkeys unknown to the captured nodes  andfinally distributed to other nodes that collec-tively know the m keys For details on EBSplease refer to [9] A drawback of the basicEBS-based solution is that a small number ofnodes may collude and collectively reveal allthe network keys  This is  particularly truewhen the value of m is selected to be relativelysmall (to make rekeying feasible in terms ofnumber of messages)The application of EBS was first proposedfor key management in sensor networks in [5]In this scheme nodes were assumed anony-mous (with no preloaded node ID) The sen-sor network establishes a coordinate system(or virtual infrastructure) around the base sta-tion The virtual infrastructure provides nodeswith post-deployment location informationwhich is used to select the combination of keysassigned to nodes within each cell All ID-lessnodes located in the same coordinate cell areassigned the same EBS key combination andare considered collectively as an EBS groupmember  Rekeying takes place on the celllevel by sending m messages of k keys each toevict nodes in a specific cell Although veryefficient (no communication required for keysetup) this scheme does not address collusionand assumes coarse keying granularity due tothe assumption of ID-less nodes A base sta-tion is central to the key management schemewith all sensor nodes performing the samekeying functions; consequently this scheme isheterogeneousAn example of non-EBS dynamic keyingschemes is due to Jolly et al [7] who proposeda key management scheme based on identity-based symmetric keying The network modelinvolves a base station and several clusters ofsensor nodes each led by a (better equipped)cluster gateway In Jolly et al’s approach keygeneration and assignment are the responsibili-ty of the base station while key distribution isperformed by the cluster gateways The pro-posed scheme requires very few keys (typicallytwo) to be stored at each sensor node andshared with the base station as well as the clus-ter gateways Rekeying involves reestablish-ment of clusters and redistribution of keysAlthough the storage requirement is  veryaffordable the rekeying procedure is ineffi-cient due to the large number of messagesexchanged for key renewals In addition theyrequire a centralized key server to play a majorrole in key management Since the networkmodel involves three types of nodes — sensornodes cluster gateways and base station —with different keying functionalities  thisscheme is classified as heterogeneous No nodelocation or other deployment information isused in key assignmentIn order to address the collusion problemin EBS Younis et al proposed SHELL [6]; anEBS-based scheme that performs location-based key assignment to minimize the numberof  keys revealed by capturing col locatednodes The network model is similar to Jollyet  al  ’s  with clusters and gateways  UnlikeJolly et al SHELL uses the EBS frameworkto perform rekeying within each cluster Clus-ter gateways keep track of the key assignmentbut not the actual keys These keys (k keysassigned to each node) are stored by gatewaysof other clusters (called key generation gate-ways) Keys are distributed to nodes by thekey generation gateways through their owncluster gateway using an extra cycle of encryp-tion/decryption SHELL is collusion-resistantSHELL uses post-deployment location infor-mation in key assignment; collocated nodesshare more keys than nodes that are not col-located While this is more energy-efficientthan Jolly et al’s scheme [6] both schemesrely considerably on a centralized key serverto perform rekeyingIn the next section we outline our new LOCKscheme as a representative of the emergingdynamic key management schemes LOCK per-forms localized rekeying to minimize overheadDetails and comprehensive performance analysisof LOCK will appear in a sequel paperDynamic key managementschemes may changeadministrative keysperiodically ondemand or upondetection of nodecapture The majoradvantage ofdynamic keying isenhanced networksurvivability sinceany captured key(s)is replaced in a timely manner in aprocess known as re-keying                                        IEEE Communications Magazine • April 2006126OVERVIEW OF LOCK: AN EXAMPLE OF DYNAMICKEY MANAGEMENT SCHEMESLOCK is an EBS-based dynamic key manage-ment scheme for clustered sensor network Thephysical network model as shown in Fig 2a is athree-tier wireless sensor network with the basestation (BS)at the top followed by cluster leadernodes (CLs)  then regular sensor nodes InLOCK no pre-deployment information isassumed about the expected locations of thenodes LOCK uses two layers of EBS adminis-trative keys The upper layer (level 1) is EBSbthat enables the base station to manage the clus-ter leaders as a group The lower layer (level 0)involves an EBSCi for each cluster Ci A clusterleader Ci is a member in both the upper EBSbas well as the lower EBSCi We assume that thecapture of a CL is as likely as any other sensornodeThe EBSb administrative keys are used toconstruct (and refresh) group session keys usedby the BS to communicate with the CLs Admin-istrative keys of each EBSCi in turn are used toconstruct (and refresh) cluster session keys usedby the cluster leader to communicate with thesensor nodes within the cluster The CL is con-sidered a regular member in its EBSC that knowsas many cluster administrative keys as any othernode in the same cluster (k keys out of k + mkeys) Accordingly the capture of a CL does notprovide the attacker with any more cluster keysthan the capture of a regular sensor node (com-pare with SHELL [6] where CLs store sensornode keys and hence their capture may causemore harm) Figure 2b shows the functionalcomponents of LOCKDuring the initialization phase sensor nodesof each cluster establish a set of backup keys(one chain of keys for each cluster) shared withthe base station and unknown to their (or anyother) cluster leader Key generation of EBSCkeys is performed by a group of sensor nodeswithin the cluster called key generation nodes(KGNs) which are usually selected by the CLKey distribution is performed by the CLThe capture of a sensor node (or a KGN) ishandled solely by a local rekeying mechanismwithin the cluster to exclude the captured nodefrom EBSC LOCK does not involve the basestation or any intercluster leader communicationto generate new cluster keys as in SHELL Thecapture of a cluster leader is first handled by thebase station through EBS rekeying at the clusterleader level through EBS eviction Sensor nodeswithin the cluster whose leader is captured alsouse EBS re-keying to exclude such node formthe cluster The base station might later deploy areplacement cluster leader or redistribute nodesDeploying a new cluster leader for a clusterwhose leader has been captured requires thecluster’s sensor nodes to authenticate the newleader using the backup keys shared with thebase station It is worth mentioning that unlikeother dynamic schemes the capture of any nodein LOCK (including cluster leaders) does notaffect the normal operation of other clustersSince location information is not necessarilyavailable in most sensor networks given the massdeployment in many applications we proposethe use of key polynomials in LOCK to improvenetwork resilience to collusion instead of loca-tion-based key assignment as in SHELL Asshown in the next section using such a tech-nique can significantly enhance networkresilience to node capture while using lowerdegree polynomials compared to static keying Inthe next section we discuss general performanceand security of static and dynamic key manage-ment schemesSTATIC VS DYNAMICKEY MANAGEMENT INSENSOR NETWORKSAs described earlier static key managementschemes depend on the pre-distribution of a ran-domly selected set of k keys [1] (or bivariate keypolynomials [4]) to each node out of a pool of P= k + m keys Two nodes can communicatedirectly if they are within the transmission rangeof each other and they share at least one key/keypolynomial Since the key polynomial model ismore general it is used in the analysis belowFor simplicity we only consider key manage-ment within a clusterThe probability of sharing a key polynomialbetween any two randomly selected nodes Ps isdefined as follows:(1)where k is the number of polynomials known toa node and m is the number of polynomialsunknown to that nodeIf two nodes are neighbors they can directlycommunicate only if they can establish a com-munication key; otherwise they use an interme-diary node that shares at least one keypolynomial with each of them to establish anindirect communication key The network topol-ogy as well as the transmission range determinesthe physical network connectivity whereas theprobability Ps is an indicator for logical connec-tivityStatic keying schemes select a large value ofk (eg 250 or more [1]) to guarantee reason-able connectivity (eg Ps > 099) Howeversince the value of k is directly related to thenode storage capacity C   it  might not be adesign option to use such large value of k especially in case of polynomials where forpolynomial degree t C = (t + 1)k On the otherhand in order to enhance the networkresilience to node capture m is selected to bequite large so that more nodes would be need-ed to reveal all keys However the larger valueof m leads to less network connectivity sincethe probability of sharing a key is lowered Therelationship between resilience connectivityand m in a 20000-node network is shown inFig 3a Since LOCK (and other EBS-basedschemes) essentially use a similar idea forselecting k polynomials for each node as in [4]P k mPm ik mk mssik= >= −−+ − ≤=−∏11101if if Since location information is notnecessarily availablein most sensor networks given themass deployment inmany applicationswe propose the useof key polynomials inLOCK to improvenetwork resilience tocollusion instead oflocation-based keyassignment as inSHELL                                                                          IEEE Communications Magazine • April 2006 127formula 1 holds for these schemes too Howev-er dynamic schemes operate at lower values ofm (shown in Fig 3a) thus guaranteeing higherconnectivity in generalThe probability PFi of compromising a specif-ic key polynomial Fi given the capture of Ncnodes that communicate directly is given by Eq2:nFigure 2 LOCK architecture: a) LOCK physical components; b) LOCK functional componentsPre-distribution ofinitialization dateCL captureDeployment CLs register with BSInitialization phase ICL generate kb+mbkeysBS assigns kb keys toeach CLBS generates newadministrative andbackup keysEBSb rekeyingBS distributes newadministrative keysto CLsSensor nodesauthenticate new CLBS deploys new CLor givesauthenticationbackup keys toreplacement CLSN or KGN captureKGNs generate newadministrative keysCluster rekeyingCL distributes newkeys to the clusterBS generates achain of backup keysfor each clusterInitialization phase IIBS distributebackup keys to CLsBS generates/updates CL sessionkeyRegular operationsCLs generate/updateand distributesession keys to theirclusterSensor nodesregister with their CLInitialization phase IIISensor nodesgenerate kc+mc keysCL assigns kc keys toeach SNCL assigns andannounces KGNsBS uses unknownmb keys to deliverbackup keysSensor nodeKGNCluster leaderCLBase stationBSCL0EBSb(Nbkbmb)EBSc0(Nc0kc0mco)(a)(b)CL1BSEBSc1(Nc1kc1mC1)CLNbEBScn(NcnkcnmCn)Two nodes can communicate directlyif they are within thetransmission rangeof each other andthey share at leastone key/key polynomial Since the key polynomialmodel is more general it is used inthe analysis belowFor simplicity weonly consider keymanagement withina cluster               IEEE Communications Magazine • April 2006128(2)The probability Pc of any direct or indirect keyto be compromised isPc = Ps * PFi+ (1 – Ps) (1 – PFi)2) ((1 – Nc/N)(3)In [4] these probabilities were studied againstthe polynomial degree t It was shown that thenetwork resilience is maintained up to a certainthreshold Nc* of captured nodes with probabili-ty very close to zero When Nc exceeds Nc* theprobability rises rapidly very close to one WhenPc is close to one then capturing a small numberof nodes may reveal all keys ie the network isfully captured and controlled by the attackerFigure 3b shows the network capture probabilityagainst Nc The network capture point Nc* isdefined as the number of captured nodes atwhich the capture probability is close to oneNc*is considered a measure for networkresilienceDifferent parameters affect the value of Nc*including k m and t First increasing the poly-nomial degree t enhances the network resilienceat the expense of storage per node Simple keyscan be considered as polynomials of degree zeroUsing simple keys capturing a very few nodes isusually enough to capture the network as long asthe attacker is assumed to foster collusion amongthese nodes without being restricted to the nodelocations Secondly assigning more polynomialsto each node (ie using a larger value of k)enhances the connectivity (ie the probability ofsharing a polynomial) However since morepolynomials are known by each node this alsoincreases the number of polynomials revealed toan attacker once a node is captured which cer-tainly decreases the network resilience (Nc*) asshown in Fig 3c Finally increasing the size ofthe polynomial pool while using the same num-ber of polynomials per node (ie increasing m)tends to enhances resilience since more polyno-mials will be needed to capture the networkHowever this solution reduces connectivity sincethe probability of sharing a polynomial fallsLOCK attempts to perform rekeying earlyenough before the number of captured nodesreaches Nc* Since the node capture probabilityrises rapidly close to Nc* rekeying can be per-formed at the rising edge of the node captureprobability; the point termed R-point in Fig 3bThe rekeying overhead for doing that is sendingm messages each containing k polynomials Oneobvious way to minimize the number of timesrekeying is needed is to enhance the networkresilience (increasing Nc*) by using a lower valueof m and a much larger value of k Since rekeyingis performed early enough before reaching Nc*we can afford to use a smaller value of t to savestorage without jeopardizing network securityIn conclusion from the above analysis bothstatic and (EBS-based) dynamic schemes sharethe idea of selecting a random subset of keys foreach node out of a pool of keys Static schemestend to rely on using a larger key pool toenhance network resilience to attacks whereasdynamic schemes use a limited pool of keys aswell as a limited number of keys per node toachieve better network connectivity In the latterschemes resilience to attacks is primarilyachieved by rekeying Table 2 summarizes pri-pNikk mmk mFcit i Nic= − +  + =∑10−>=icFN tpifor otherwise0nFigure 3 Comparison of static and dynamic schemes: a) network connectivi-ty and resilience at different key pool sizes; b) fraction of administrative keysm1000402060811232 54 76 98 120142164186208230252274296318340362384406428450472494Number of key polynomials known to each node (k)0200400600800100012002515 35 45Number of captured nodes55 65 75 85 95 105115125135145155165175185195Number of captured nodes01080604R point02123012261511 76 3764515266016767518269019761051112612011276135114261501ConnectivityResiliance (scaled)Nc*t = 0t = 100t = 200Nc*Nc*(a)(b)(c)                                                                    IEEE Communications Magazine • April 2006 129mary features of static and dynamic key manage-ment schemes and provides a qualitative com-parison of both classes of schemesCONCLUSION ANDRESEARCH DIRECTIONSKey management in sensor networks raises inter-esting research issues Design requirements forkey management solutions include energy aware-ness survivability and localization of attackimpact given a highly vulnerable network thatmainly operates unattended and scalability to alarge dynamic network Administrative key pre-distribution has been the de facto solution withthe underlying assumption that a key will outlivethe network Recently dynamic schemes (withrekeying) have been proposed particularly foremerging long-lived sensor networks Efficientrekeying is essential for these schemes to beadopted This article shows that both static anddynamic keying share some basic concepts Astudy of network resilience to attacks as well asstorage and communication overhead for bothclasses of schemes has been presentedOne major challenge to dynamic keyingschemes is the need for the participation (to vary-ing degrees) of a key management authority (usu-ally the base station) post network deploymentThis participation is not needed in static schemes(as there is no rekeying) Research is ongoing todecrease the reliance on a key managementauthority in dynamic key management schemessuch as LOCK Other notable leading and promis-ing research efforts on key management in sensornetworks include Ning et al at North CarolinaState University [4 8] Perrig et al at CarnegieMellon University [3 10] Zhu et al at The Penn-sylvania State University [11] and Hartel et al atthe University of Twente (EYES project) [12]Next-generation sensor networks will be long-lived and highly dynamic with roaming nodesand multiple network replenishments to satisfyevolving quality of service requirements Theattack profile on these networks will be morevaried and complex Research is needed onadaptive key management to address these newchallenges Also it is to be noted that currentlythe presence of an intrusion detection system isassumed by both static and dynamic key man-agement schemes Intrusion detection in sensornetworks remains an open research area at thetime of this writingREFERENCES[1] L Eschenauer and V Gligor “A Key Management Schemefor Distributed Sensor Networks” Proc 9th ACM ConfComp and Commun Sec Nov 2002 pp 41-47[2] H Chan A Perrig and D Song “Random Key Predistri-bution Schemes for Sensor Networks” Proc IEEE Secand Privacy Symp 2003 pp 197–213[3] W Du et al “A Key Management Scheme for WirelessSensor Networks Using Deployment Knowledge” ProcIEEE INFOCOM ’04 Mar 2004nTable 2 Summary comparison of static and dynamic key managementStatic keying Dynamic keyingNetwork life Assumed short-lived Assumed long-livedKey pool Very large pool; static administrative key values Small size pool; dynamic administrative key valuesKey assignment Once predeployment Multiple times post deploymentKey generation Once predeployment Multiple times post deploymentKey distribution All keys are predistributed to nodes prior to deploy-mentSubsets of keys are re-distributed to some nodes asneededHandling node capture Revealed keys are lost Revealed keys are altered (k → k′)Re-keying cost May be practically infeasible with respect tonumber of messages (m is very large eg 20000) Requires few messages (m is small eg 20)Communication cost Not applicable for administrative keys (key predistri-bution) Re-keying overheadStorage cost More keys per node Fewer keys per nodeHandling node addition New node preloaded with keys from static pool —may decrease network resilience to node captureNew node receives new set of keys; other nodes maybe rekeyed — less impact on network resilience tonode captureNetwork resilienceHigh as long as number of nodes captured is small(assuming key polynomials) Once a threshold isexceeded resilience falls sharplyHigh largely independent of number of nodes cap-tured as long as rekeying is performed in a timelymannerNetwork connectivity Less connected due to large key pool Connectivityimproves with increasing number of keys per node More connected due to small-size key pool                                    IEEE Communications Magazine • April 2006130[4] D Liu and P Ning “Improving Key Pre-Distribution withDeployment Knowledge in Static Sensor Networks” ACMTrans Sensor Networks 2005 pp 204–39[5] M Eltoweissy et al “Group Key Management Schemefor Large-Scale Wireless Sensor Network” J Ad HocNetworks Sept 2005 pp 796–802[6] M Younis K Ghumman and M Eltoweissy “Location-aware Combinatorial Key Management Scheme forClustered Sensor Networks” to appear IEEE Trans Par-allel and Distrib Sys 2006[7] G Jolly et al “A Low-Energy Key Management Protocolfor Wireless Sensor Networks” Proc IEEE Symp Compand Commun June 2003 p 335[8] D Liu P Ning and W Du “Group-Based Key Pre-Distri-bution in Wireless Sensor Networks” Proc 2005 ACMWksp Wireless Security (WiSe 2005) Sept 2005 pp11–20[9] M Eltoweissy et al “Combinatorial Optimization ofKey Management in Group Communications” J Net-work and Sys Mgmt Special Issue on Network Securi-ty Mar 2004 p 332b[10] R Anderson H Chan and A Perrig “Key Infection:Smart Trust for Smart Dust” 12th IEEE Int’l Conf Net-work Protocols 2004 pp 206–12[11] P Traynor et al “Establishing Pairwise Keys for Het-erogeneous Sensor Networks” Tech rep The PA StateUniv 2004[12] Y W Law “Key Management and Link-layer Securityof Wireless Sensor Networks: Energy-Efficient Attackand Defense” PhD thesis CTIT PhD thesis Series 05-75 Univ of Twente Dec 2005BIOGRAPHIESMOHAMED ELTOWEISSY [SM’05 M’98] (toweissy@vtedu) is anassociate professor in the Bradley Department of Electricaland Computer Engineering at Virginia Tech He also holdsa courtesy appointment in the Department of ComputerScience He is founder and director of the Center for CyberAssurance and Trust (CyCare) His research interests andpublication and funding record are primarily in the areas ofinformation assurance and trust networking in large-scaleunstructured and resource-constrained environments ser-vice-oriented architectures and group communicationsMOHAMMED MOHARRUM is a PhD candidate and an instruc-tor in the Department of Computer Science at Old Domin-ion University His research focuses on ad hoc and sensornetworks with respect to location and key managementHis work has been published in several journals bookchapters and conference proceedingsRAVI MUKKAMALA is a professor in the Department of Com-puter Science at Old Dominion University He received aPhD degree from the University of Iowa in 1987 and anMBA degree from Old Dominion University in 1993 Hisresearch interests include distributed systems data securi-ty performance analysis and PKI His research has beensponsored by NRL DARPA NASA and CISC                         
Efficient pairwise key establishment and managment in WSN-pdf,Efficient Pairwise Key Establishment andManagement in Static Wireless Sensor NetworksYi Cheng and Dharma P AgrawalOBR Center for Distributed and Mobile Computing LabUniversity of Cincinnati Cincinnati OH 45221{chengyg dpa}@ececsuceduAbstract-- Key establishment and management is the core ofsecurity protocols for wireless sensor networks deployed in thehostile environment Due to the strict resource constraintstraditional asymmetric key cryptosystems such as public/privatekey based schemes are infeasible for large-scale wireless sensornetworks Research shows that pre-distributing pairwise keysinto wireless sensor nodes before deployment is a practical way todeal with the key establishment problem Existing random keybased key pre-distribution schemes only provide probabilisticconnectivity of the network and some level of network resilienceIn this paper we propose an efficient pairwise key establishmentand management scheme to achieve both network connectivityand resilience for static wireless sensor networks Compared withcurrent key pre-distribution schemes our scheme supports largenetwork size and has lower communication and computationaloverhead1 INTRODUCTIONWireless sensor networks (WSNs) composed of a largenumber of tiny low power and cost wireless sensors can beeasily deployed at any interested area to monitor thesurrounding environment [1] This attractive property makesthey are widely used in a variety of applications both inmilitary operations and civilian fieldsSecurity is extremely important when wireless sensornetworks deployed in a hostile environment The sensitivedata must be protected properly to ensure the informationauthenticity confidentiality and integrity [2][3][4][5][6][7][8]In some military applications the highest level securityrequirement must be satisfied; otherwise the result could beextremely dangerousResource constraints are the main limitation of wirelesssensor networks Each sensor node only has limited batterypower small memory storage size and low power computingcapacity The lack of infrastructure support is another problemfor wireless sensor network Therefore security protocols usedfor wireless sensor networks must be not only secure but alsoefficient Traditional asymmetric key cryptosystem such aspublic/private key based security protocols  need highcomputing power and large memory storage hence can not beapplied in wireless sensor networks Furthermore due to theunpredictable network topology short radio transmissionrange and intermittence operations of sensor nodes traditionalkey distribution protocols suitable for infrastructure supportedwireless networks also can not be used in wireless sensornetworksResearch shows that key pre-distribution protocol may be apractical selection to deal with the key distribution problemunder the wireless sensor environment [9] The basic idea ofkey pre-distribution scheme includes two phases key pre-distribution phase and pair-wise key setup phase In key pre-distribution phase each sensor node is pre-loaded some keysin its memory before it is deployed After deployment eachnode exchanges key information with its neighbors and tries toestablish a secure link between them which is the pair-wisekey setup phase Once these two phases are finished a securelink network can be established among the wireless sensornetwork and data can be propagated through the secure linksto the base station Many key pre-distribution schemes havebeen proposed recently We will review two naïve solutionsfirst and then discuss some improved schemesThe first naïve solution is master key approach In thisapproach a key distribution center (KDC) assigns a singlemaster key to all sensor nodes before they are deployed Afterdeployment any two sensor nodes can communicate securelywith the master key This approach looks very simple andefficient but has a severe drawback when the sensor nodes arephysically captured by the adversary since even one node’scompromise could crash the entire network’s secrecyAnother naïve solution is to assign a distinct pairwise keyfor each pair of sensor nodes before they are deployed Thissolution guarantees any two nodes can communicate securelyafter deployment and any node’s compromising or capturecould not affect the rest of the network Although thisapproach can provide a perfect security for wireless sensornetwork it can not be applied for large scale networks inpractice As we mentioned before each sensor node haslimited memory storage which only can store a limited numberof keys inside In pairwise key approach each sensor node hasto store (n-1) keys in its memory (where n is the network size)Imaging how could a tiny sensor store 9999 distinct keys inits limited memory just for a network with 10000 nodesinside? (In practice most wireless sensor networks areexpected to composed of more than 10000 nodes)To achieve the security and scalability simultaneouslymany key pre-distribution schemes have been proposed inliteratures recently [9][1][11][12][13][14] Some of them arebased on the probability and random graph theories otherschemes are either based on symmetric matrices operations orpolynomial computations Each scheme has its advantage andweakness but none of them can satisfy all the security and0-7803-9466-6/05/$2000 ©2005 IEEE                                                                            MASS 2005efficiency requirements of wireless sensor networks listedbelow:• secrecy and authentication• resilience against node capture• node replication• nodes revocation• nodes addition• network connectivity• maximum supported network size• minimum memory storage requirement• low commu nication overhead• low computational overheadIn this paper we propose a new efficient pairwise keyestablishment and management scheme for static wirelesssensor networks Compared with existing key pre -distributionschemes our approach can provide the complete networkconnectivity and better resilience against node capture attackLow communication overhead low computational overheadand large network size supporting are other benefits of ourproposed schemeThe re mainder of this paper is organized as follows: InSection 2 we briefly describe and discuss some currentexisting key pre -distribution schemes A detailed introductionof our proposed efficient pairwise key establishment andmanagement scheme is presented in Section 3 Section 4 givesanalysis and evaluation of our proposed scheme We concludeour work in section 52 RELATED WORKRecently various key pre-distribution schemes have beenproposed to establish secure links between sensor nodes inwireless sensor networks [9][1][11][12][13][14] Due to theresource constraints  large scale and lack of infrastructuresupport traditional public/private key based asymmetrical keydistribution protocols are not suitable in wireless sensornetworks Researchers claimed that pre-distributingcommunication keys into sensor nodes before they aredeployed is a practical selection for key distribution andmanagement in wireless sensor network environments [9]Eschenauer and Gligor proposed a random key pre-distribution scheme in [9] The basic idea of their scheme israndomly selecting and storing a subset of communicationkeys from a very large size key pool into each wireless sensornode’s memory before it is deployed Each node uses a keydiscovery process to exchange key information with itsneighbors after deployment If two neighbor nodes share oneor more common keys in their memories they can establish asecure communication link between them Otherwise twocommunicating nodes need to setup a path key with otherintermediate nodes’ participation Random graph theory isused to show that if the probability of two nodes sharing atleast one common key satisfies a critical condition theconnectivity of the entire network can be obtained with a highprobabilityBased on the work on [9] Chan et al [1] proposed a “q-composite” scheme to improve the resilience of the networkResilience is defined as how much fraction of thecommunication between non-compromised nodes will becompromised after some nodes are captured or compromisedby the adversary which is the main metric to evaluate thesecurity property of a key pre-distribution schemeThe main difference between above two schemes is that thelatter requires two neighbor nodes share at least q )2( qcommon keys to establish a secure communication link Chanet al showed that as the value of q is increased the networkresilience against node capture is improved when the numberof nodes captured is small [1] In other words an attackerneeds to capture more nodes in [1] to compromise the samefraction of additional communication links in [9] BothEschenauer’s and Chan’s schemes can not guarantee theconnectivity of the entire network and need large memorystorage to store keys for a large-scale network Keys reuse isanother weakness of these schemes which means some nodes’capture may compromise the communication between othernon-captured nodesBlom [11] proposed a key pre-distribution method toguarantee any two members in a group compute a commonkey between them In Blom’s scheme first a n)1( matrixG and a )1()1( symmetric matrix D are constructedwhere n is the group size and is the expected threshold tocompromise the secret collusively Each member in the grouprandomly stores a row vector from matrix A and thecorresponding column vector form the matrix G whereTGDA )(=  Suppose member a get the ithrow from A and ithcolumn from G member b get the jthrow from A and jthcolumn from G When a and b want to communicate witheach other they exchange their column vector first and thenuse their row vector to multiply their partner’s column vectorAfter the calculation a gets an entry located in ithrow and jthcolumn of a symmetric matrix and b gets an entry located injthrow and ithcolumn of the same symmetric matrix Due tothe property of symmetric matrix the two entries have thesame value therefore a and b obtain a shared common keybetween themIn Blom’s scheme as long as no more than members arecompromised the entire group is perfectly secure Du et al[12] modified Blom’s scheme slightly and make it suitable forwireless sensor networks In [12] Blom’s scheme is used tocalculate pairwise keys between sensor nodes  To improve theperformance and network resilience Du et al separate a singekey space in [11] into multiple key spaces just using therandom key pre-distribution mechanism in [9]The main advantage of Blom’s scheme is it can provide afull connectivity of the network but it also has the “ -secure” problem The network keeps secure only when nomore than members are compromised; once the number ofcompromised node exceeds the threshold  the entirenetwork could be crashed Although Du et al’s scheme in [12]can increase the threshold value; but it only provides aprobabilistic connectivity of the networkA polynomial-based key pre-distribution scheme isproposed by Blundo et al in [13] Based on bivariatepolynomials operations their scheme allows any group of tnodes to compute a common key and being secure againstcollusion among some of them The problem is this schemealso only tolerates no more than t compromised nodes  Liuand Ning further improved this scheme in [14] by takingadvantage of sensors’ expected locations information Theyproposed a location-based pairwise keys establishment schemeusing bi-variable polynomials  In their work Liu and Ningshowed there is a trade-off between the security against nodecapture attack and the performance of the pairwise keyestablishment schemeAll proposed schemes in [9][1][11][12][13][14] can notprovide an enough network resilience against node captureattack As we have discussed previously once the number ofcaptured node reaches a critical value the entire network willbe crashed or a large fraction of the communication betweenthe non-captured nodes will be compromised    In this paper we try to solve the limitations and weaknessesof the current key pre-distribution schemes A new efficientpairwise key establishment and management scheme isproposed in the next section which can provide good networkresilience against node capture attack as well as the fullnetwork connectivity3 EFFICIENT PAIRWISE KEY ESTABLISHMENT ANDMANAGEMENT SCHEMEIn this section we introduce our proposed EfficientPairwise Key Establishment and Management scheme(EPKEM) in detail31 AssumptionsIn this work we assume the wireless sensor network is astatic large-scale and homogeneous network Each sensornode has the same battery power memory storage size CPUprocessing capacity and radio transmission range Sensornodes are uniformly distributed in an area by the airplane orother vehicles and can not change their position afterdeployment Sensor node’s location can not be predictedbefore deployment so that no prior location knowledge isavailable The sink node has unlimited computation andcommunication power unlimited memory storage capacityand very large radio transmission range which can reach anysensor node in the network Sink node can be located in eitherthe center or a corner of the sensor network32 Basic IdeaUnlike existing key pre -distribution schemes the pairwisecommunication keys are different from the pre -loaded networksetup keys in EPKEM Pre-loaded setup keys are only used toestablish a connected network and calculate the intendedpairwise communication keys which will be used to secure theexchanging data/information between sensor nodes33 Four Phases of EPKEM    In EPKEM pairwise communication key is establishedthrough four phases: setup key pre-assignment phase commonkeys discovery phase pairwise key computation phase andkey ring establishment phase These four phases are describedas follows331 Setup Key Pre-Assignment PhaseIn setup key pre-assignment phase the Key DistributionServer (KDS) generates a very large size key pool P withmore than202 distinct keys inside For each sensor nodeiN(iN denotes this node’s ID) KDS randomly selects a secretkey from P and stores it intoiN ’s memory This keydenoted asKDSNik   is only shared by the KDS and theintended nodeiN  and will be used to identify nodeiN andsecure the communication betweeniN and KDS in the futureThen for each sensor node KDS randomly selects a subsetkeys from the rest of P and pre-loads them into the node’smemory these keys will be worked as the network setup keysafter deployment The KDS assigns setup keys to each nodeunder certain rules to ensure any two nodes have at least twokeys in common To achieve this requirement a simplemethod is described as followsSuppose the intended network size is n  KDS randomlyselects n keys from the rest keys in P and uses them toconstruct a )( mm key matrix K  where nm = Figure 1 illustrates an example of constructed key matrixwhere each key has a unique two-dimensional id denoted asjik  )21( mji =  KDS constructs some key chains byrandomly selecting a row and a column from key matrix K We usejikc  )21( mji = to represent the key chain whichis composed bythi row and thj column of key matrix K  Thetotal number of constructed key chains is n  which is thesame as the network size For each sensor node KDSrandomly pickup a key chain and stores it into that node’smemory For convenience we assume nodeaN has jikc stored in memory and nodebN has mlkc  stored in memory inthis paperID 1 2 3 4 5 … m1 11k 21k 31k 41k 51k … mk 12 12k 22k 32k 42k 52k … mk 23 13k 23k 33k 43k 53k … mk 34 14k 24k 34k 44k 54k … mk 45 15k 25k 35k 45k 55k … mk 5: : : : : : … :m 1mk 2mk 3mk 4mk 5mk … mmk Figure 1: An example of constructed setup key matrix KID Keys in key chain11kc { 11k … mk 1  12k … 1mk  KDSNk 11}: :jikc  { 1ik … mik   jk 1 … jmk   KDSN jik }: :mmkc  { 1mk … mmk   mk 1 … mmk 1  KDSN mmk }Table 1: Keys in key chainTable 1 lists the constructed key chains it easy to see thatany two key chainsjikc  and mlkc  will share exactly twocommon keys when li and mj  Or they may share mkeys in common when li = or mj =  For instance keychains32kc and 54kc will have two common keys 52k and34k  In our scheme after the setup keys pre-assignment phaseany two sensor nodes share either two or m common keysand a secure link between them can be established by thesecommon keys after deployment332 Common Keys Discovery PhaseAfter deployment any two neighboring sensor nodes needto figure out their shared common keys To achieve this eachnode broadcasts its node ID and key chain ID to its neighborsOnce a node received its neighbor’s key chain ID it canidentify which keys they shared in common For examplenodesaN andbN are two neighbors within each other’sradio transmission range OnceaN knows bN ’s key chain ID)( ml aN checks its memory and looking for key mik  andjlk  which should be the common keys shared with node bN On the other side NodebN also can find the shared keysmik and jlk  through the same procedure333 Pairwise Key Computation PhaseAfter the common key discovery phase each sensor nodeknows its neighbor node’s ID and their shared common keysSince all the pre-loaded setup keys are picked from the samekey matrix K  the same key may be stored in different nodesThat means when some nodes are captured keys stored innon-captured nodes may be compromised too To address thisproblem we establish a new pairwise communication key foreach pair of neighbor nodes instead of using the sharedcommon keys directly The new pairwise communication keycan be calculated based on the shared setup keys SupposenodeaN and bN are a pair of neighbor nodes and theirshared setup keys are mik  and jlk   To establish a privatepairwise key which is unaware to other nodes nodeaN andnodebN compute their pairwise key using Equation 1bjlamiNN NkNkk ba =  (1)In Equation (1) “ ” is the exclusive-or operator In ourproposed scheme all setup keys in the key matrix K aredistinct to each other any pair of nodes will not share thesame two keys as other pairs Furthermore each node is thesensor network has a unique identity; hence the calculatedpairwise communication key for each pair of sensor nodes isdistinct to others and only shared between them This uniquepairwise communication key can not be computed or guessedby any other nodes  and will be used for data exchange andnode authentication between intended neighboring nodes inthe network334 Key Ring Establishment phaseOnce a sensor node computed all corresponding pairwisecommunication keys with its neighbors it erases all the pre-assigned setup keys from its memory immediately to preventthe possible key compromising and node capture attack Onlythe computed pairwise communication keys with its neighborsand the secret key KDSNk shared with KDS are kept in thememory of each node which compose the permanent key ringof a sensor nodeA connected secure link network can be established whenthe above four phases are finished Each sensor node now canuseKDSNk to communicate with KDS and the calculatedpairwise keys to authenticate and communicate with its properneighbor nodes securely4 ANALYSIS AND EVALUATIONIn this section we analysis the security property andevaluate the performance of our proposed scheme bycomparing with current existing random key based key pre-distribution schemes in [9] [1] which are the closest work toours41 Security Analysis of EPKEM411 Compromised Keys RevocationIn wireless sensor networks compromised keys must bedynamically removed from the network instantly In ourproposed scheme each node knows its neighbor’s ID andshares a unique pairwise communication key only with anintended 1-hop neighbor Once a misbehaving node which inmost case was captured or compromised by the adversary isdetected (malicious node detection is not discussed in thispaper interested readers may reference related literatures) allits 1-hop neighbor nodes immediately remove thecorresponding pairwise keys shared with it In addition themisbehaving node’s ID will be sent to the sink nodeimmediately Once sink node gets the information it informsthe KDS to remove the compromised node and itscorresponding setup and secret keys from the key pool Ppermanently and prevent any communication with thatcompromised node in the futureIn [9] [1] since the compromised keys may be shared byany nodes at any where the information of the compromisedkeys must be propagated to every node in the entire networkEach node gets that information need to check its key ringlocate the compromised keys and remove them from itsmemory The compromised key revocation procedure in [9][1] involves all the sensor nodes in the network which willconsume more time energy and bandwidth resources andproduce much more communication overhead than ourscheme412 Sensor Nodes AdditionIn some applications new sensor nodes need to be addedinto an existed network to replace the power exhausted orcompromised nodes EPKEM achieves nodes addition throughthe similar procedure as in [9] [1]First key distribution server (KDS) constructs a new keymatrix and the corresponding key chains then KDS assigns asecret key and a key chain to each of the new nodes just likethe key pre-assignment phase described in Section 3 Inaddition KDS also needs to assign the new key chains tonodeseN which are currently existing in the network andlocated close to the new nodes’ deployment area These keychains are encrypted by keyKDSN ek(the secret key sharedbetweeneN and KDS) and sent to nodes eN at the same timewhen the new sensors are deployed Once nodeseN receivethe message and decrypt it they can obtain the new setup keysand establish secure links with the new deployed nodesthrough the same procedure described in Section 3 After thefour setup phases finished new sensor nodes can join into thenetwork and communicate with existing nodes securely413 Resistance Against Node ReplicationWireless sensor networks are commonly deployed in ahostile environment; therefore some nodes may be capturedby the adversary It is a serious attack if the adversaryduplicates the captured nodes and populates them into thenetwork to obtain the critical information especially in [9] [1]where the same keys may be shared bysome different nodes atsomewhere of the network Also there is no nodeauthentication procedure existed in these two schemes    In our proposed scheme node replication attack can becompletely avoided since after initialization phase each nodeonly keeps the pairwise communication key and IDinformation of its 1-hop neighbors in memory and onlycommunicates with these neighbors  Without the properpairwise key’s authentication and neighborhood knowledgeverification any stranger’s communication request will be justignored Therefore the node replication attack is preventedtotally in EPKEM scheme414 Resiliency to Node CaptureIn wireless sensor networks adversaries not only can get thecritical data by eavesdropping or intercepting the radiomediums but also can physically capture sensor nodes toobtain the secret information such as communication keyscritical data and other valuable information Node captureattack is the most serious threat in wireless sensor networks001020304050607080910 100 200 300 400 500 600 700 800 900 1000Number of captured sensor nodesFractionofcompromisedkeysamongnon-capturednodesrandom key pre-distributionq-composite (q=2)q-composite (q=3)EPKEMFigure 2: Fraction of compromised keys amongnon-captured nodes vs number of captured nodesIn Eschenauer and Gligor’s scheme [9] sensor nodes usethe same setup keys as the communication keys in thenetwork; any node’s capture could compromise other non-captured nodes’ communication keys This kind of problem isdefined as the resiliency of a network In [9] given the keyring size of 200 and the probability that any two nodesshare atleast one common key as 033 10% of the communicationamong the non-captured nodes could be compromised whenonly 50 nodes are captured “q-composite” scheme in [1]improves the network resilience by requiring two nodes shareat least q )2(q common keys to establish a secure linkThis scheme only works well in case of a small number ofnodes are captured As shown in Figure 2 when the number ofcaptured nodes increases the fraction of compromisedcommunication between non-captured nodes increases fasterthan Eschenauer and Gligor’s schemeIn EPKEM after pairwise key setup phase each pair ofneighboring nodes have a unique pairwise communication keywhich is distinct to others Any node’s capture does not revealany key information about other links between non-capturednodes This approach can achieve good network resilienceagainst the node capture attack which is one of the maincontributions of our work Comparing our scheme with theprevious two schemes we can see that when 200 nodes arecaptured above 30% of the communication between non-captured nodes are compromised in [9][1]; when the numberof captured nodes increases to 500 more than 60% of thecommunication of the rest network will be compromised Butin our proposed EPKEM scheme no communication betweennon-captured nodes will be compromised no matter how manynodes are captured by the adversary42 Performance Evaluation of EPKEM421 Network ConnectivityNetwork connectivity is an important metric to evaluate akey pre-distribution scheme A good key pre-distributionshould guarantee the network connectivity no matter how thenetwork deploys Based on the probability theory [9][1] onlyprovide probabilistic connectivity of a network in otherwords it can not guarantee the entire network’s connectivityin practice Some nodes or some portions of a network couldbe isolated from the rest of the network when there is nocommon key existingEPKEM can guarantee a full secure connectivity of theentire network which is the second contribution of our workDifferent to any probability theory based key pre-distributionschemes our scheme guarantee any two nodes share at leasttwo network setup keys in the key pre-assignment phase Afterdeployment any pair of sensor nodes within each other’s radiotransmission range can establish a pairwise communicationkey by using their shared network setup keys which meansour proposed scheme can provide a complete connected securenetwork in the deployment area422 Maximum Supported Network SizeCompared with Eschenauer and Gligor’s scheme [9] andChan et al’s “q-composite” scheme [1] EPKEM can providethe largest maximum supported network size As described inSection 3 given the key ring size m  the maximum supportednetwork size of our scheme is2m  which is much larger thanthe network size supported by the previous two schemesFigure 3 indicates the difference of maximum supportednetwork size among these three schemes For convenienceswe use the same evaluation metrics as in [1] where theprobability of any two nodes can establish a secure link is033 and the maximum compromise threshold is 01Figure 4 shows that for previous two schemes the networksize is linearly increasing as the key ring size increasesHowever our proposed scheme provides an exponentialincreasing network size when the key ring size increases(where we used the number of pre -assigned setup keys as thekey ring size of our scheme which is much larger than ourfinal key ring size) It is easy to see that our proposed schemehas the better scalability than other two schemes423 Communication and Computational OverheadIn [9][1] to establish a secure link with its neighborssensor node needs to broadcast all the keys or key identities inits key ring to other nodes For a large-scale network eachnode has a large number of keys in its key ring This kind ofkey information exchanging not only consumes the sensornodes’ limited energy and radio bandwidth but also producestraffic overload and collisions In EPKEM only the node IDand the key chain ID needs to be broadcast which extremelyreduces the energy consumption and communication overheadin the network Additionally in [9][1] once two nodes have noshared common keys a direct pairwise key can not beestablished These two nodes have to setup a path-key withother nodes’ participation This path-key establishmentapproach needs to exchange additional key information withintermediate nodes More CPU power and time consumptionare required for this procedure also additional memorystorage is occupied Our proposed scheme guarantees any twonodes establish a pairwise communication key directly whichproduces much lower communication and computationaloverhead than previous schemes01000200030004000500060007000800090001000050 75 100 125 150 175 200Number of keys in each sensor's memoryMaximumnetworksizerandom key pre-distributionq-composite (q=2)q-composite (q=3)EPKEMFigure 3: Maximum supported network size vsnumber of keys in sensor’s memory5 CONCLUSIONIn this paper we present a new efficient pairwis e keyestablishment and management scheme (EPKEM) for largescale wireless sensor networks Compared to the random keybased pre-distribution scheme and the enhanced q-compositescheme our scheme can provide the full network connectivityand the best resiliency as well as the maximum supportednetwork size for fixed key ring size Lower computational andcommunication overhead are also achieved in our proposedschemeACKNOWLEDGEMENTThis work has been supported by the Ohio Board ofRegents Doctoral Enhancement FundsREFERENCES[1] D P Agrawal and Q-A Zeng “Introduction to Wireless and MobileSystems” Brooks/Cole Publishing Aug 2003[2] Neha Jain and Dharma P Agrawal “Current trends in wireless sensornetwork design” International Journal of Distributed Sensor NetworksVol1 issue 1 pp101-122 2005[3] David W Carman Peter S Kruus and Brian J Matt Constraints andapproaches for distributed sensor network security NAI Labs TechnicalReport #00-010 September 2000[4] Adrian Perrig Robert Szewczyk Victor Wen David Culler and J DTygar SPINS: Security protocols for sensor networks In SeventhAnnual ACM International Conference on Mobile Computing andNetworks (MobiCom 2001) July 2001[5] Sencun Zhu Sanjeev Setia and Sushil Jajodia LEAP: Efficient securitymechanisms for large-scale distributed sensor networks In ACM CCS2003 pages 62–72 October 2003[6] J M Kahn R H Katz and K S J Pister Next century challenges:Mobile networking for smart dust In Proceedings of the 5th AnnualACM/IEEE Internation Conference on Mobile Computing andNetworking (MobiCom) pages 483–492 1999[7] C Karlof and D Wagner Secure routing in wireless sensor networks:Attacks and countermeasures In First IEEE Int’l Workshop on SensorNetwork Proto cols and Applications May 2003[8] Akyildiz W Su Y Sankarasubramaniam and E Cayirci “A survey onsensor networks” IEEE Communication Magazine vol 40 no 8 pp102–116 Aug 2002[9] L Eschenauer and V D Gligor “A key-management scheme fordistributed sensor networks” In Proceedings of the 9th ACM conferenceon Computer and communications security November 2002[10] H Chan A Perrig and D Song “Random key pre-distribution schemesfor sensor networks” In IEEE Symposium on Security and Privacypages 197–213 Berkeley California May 11-14 2003[11] R Blom “An optimal class of symmetric key generation systems”Advances in Cryptology: Proceedings of EUROCRYPT 84 (ThomasBeth Norbert Cot and Ingemar Ingemarsson eds) Lecture Notes inComput er Science Springer-Verlag 209:335–338 1985[12] W Du J Deng Y S Han and P K Varshney “A pairwise key pre-distribution scheme for wireless sensor networks” in Proceedings of the10th ACM Conference on Computer and Communications Security(CCS) Washington DC USA October 27-31 2003 pp 42–51[13] C Blundo A D Santis A Herzberg S Kutten U Vaccaro and MYung “Perfectly -secure key distribution for dynamic conferences”Lecture Notes in Computer Science 740:471–486 1993[14] Dong gang Liu and Peng Ning “Location-Based Pairwise KeyEstablishments for Relatively Static Sensor Networks” 2003 ACMWorkshop on Security of Ad Hoc and Sensor Networks (SASN’03) October 31 2003 George W Johnson Center at George MasonUniversity Fairfax VA USA
Hash Based Sequential Aggregate and Forward Secure signature-pdf,Hash-Based Sequential Aggregate and ForwardSecure Signature for Unattended Wireless SensorNetworksAttila Altay Yavuz and Peng NingDepartment of Computer ScienceNorth Carolina State UniversityRaleigh NC 27695 USAEmail: {aayavuzc pning} @ncsueduAbstract-Unattended Wireless Sensor Networks (UWSNs)operating in hostile environments face great security and per-formance challenges due to the lack of continuous real-timecommunication between senders (sensors) and receivers (egmobile data collectors static sinks) The lack of real-timecommunication forces sensors to accumulate the sensed datapossibly for long time periods along with the correspondingsignatures for authentication purposes Moreover non-real-timecharacteristic of UWSNs makes sensors vulnerable especially toactive adversaries which compromise sensors and extract all datastored in them Hence it is critical to have forward securityproperty such that even if the adversary can compromise the cur-rent keying materials she cannot modify or forge authenticateddata generated before the node compromise Forward secure andaggregate signatures are cryptographic primitives developed toaddress these issues Unfortunately existing forward secure andaggregate signature schemes either impose substantial computa-tion and storage overhead or do not allow public verifiabilitythereby impractical for resource-constrained UWSNsIn order to address these problems we propose a new class ofsignature schemes which we refer to as Hash-Based 5equential&gregate and Eorward Secure 5ignature (HaSAFSS) Such ascheme allows a signer to sequentially generate a compact fixed-size and publicly verifiable signature at a nearly optimal com-putational cost We propose two HaSAFSS schemes SymmetricHaSAFSS (Sym-HaSAFSS) and Elliptic Curve Cryptography(ECC) based HaSAFSS (ECC-HaSAFSS) Both schemes integratethe efficiency of MAC-based aggregate signatures and the publicverifiability of bilinear map based signatures by preservingforward security via Timed-Release Encryption (TRE) Wedemonstrate that our schemes are secure under appropriatecomputational assumptions We also show that our schemes aresignificantly more efficient in terms of both computational andstorage overheads than previous schemes and therefore quitepractical for even highly resource-constrained UWSN applica-tionsIndex Terms-Unattended Wireless Sensor Networks(UWSNs) security and privacy digital signatures forwardsecurity signature aggregationI INTRODUCTIONAn Unattended Wireless Sensor Network (UWSN) [1]-[5]is a Wireless Sensor Network (WSN) in which continuous end-to-end real-time communication is not possible for sensors(senders) and their receivers (eg mobile collectors staticsinks) In other words receivers might not be available forsensors from time to time sometimes for long time periodsDigital Object Identifier: 10410B/ICSTMOBIQUITOUS20096B24http://dxdoiorg/10410B/ICSTMOBIQUITOUS20096B24In these time periods sensors accumulate the sensed dataand then transmit it to the receivers whenever they becomeavailable to sensors Receivers can collect the sensed datafrom sensors via for example mobile collectors visiting thenetwork periodically [2] [5]Examples of UWSNs can be found in military WSN appli-cations (eg [1] [6]) where sensors are deployed to an adver-sarial and unattended environment to gather information aboutenemy activities (eg underground underwater and airborneUWSNs to detect enemy vehicles as well as nuclear/chemicalactivities) One illustrative example is LANdroids [7] a recentUS Defense Advanced Research Projects Agency (DARPA)research project which designs smart robotic radio relay nodesfor the battlefield deployment These nodes are deployed inhostile environments gather military information and thenuploads it to ally vehicles (eg UAV tank or soldier) upontheir arrivalThe lack of real-time communication and the resource con-straints of the UWSNs bring several security and performancechallenges especially when an UWSN is deployed in a hostileenvironment as described above In particular inability to off-load the sensed data forces sensors to accumulate a largeamount of data along with their authentication informationMore importantly unattended settings make the UWSN highlyvulnerable to active [5] and/or mobile adversaries [1] [2]Such an adversary can physically compromise sensors andgain access to the accumulated data as well as the existingcryptographic keys When a sensor is compromised the ad-versary can always use the cryptographic keys learned from thesender to generate forged messages after the attack Howeverit is critical to prevent the adversary from modifying thedata accumulated before the adversary takes control of thesender [5] Such a security property is referred to as forwardsecurity [8]Forward secure signatures have been proposed to provideforward security for pre-accumulated data [8] In a forwardsecure signature a sender digitally signs each data item assoon as it is accumulated The sender then evolves its secretkey (which implies the deletion of the previous keys) anduses the new key to sign the next data item Consecutivelysigning accumulated data items also brings significant storageand communication overheads because of the accumulation ofthe signatures of individual data items Aggregate signatureschemes [9] were developed to address this issue by aggregat-ing the signatures of different data items into a single small-size signatureAll the above properties of forward secure and aggregatesignatures make them ideal cryptographic tools for achievingdata integrity and authentication for UWSN applications inthe presence of active adversaries [5] However almost allexisting forward secure and/or aggregate signature schemes(eg [5] [8] [9]) impose extreme computational storageand communication overheads on the network entities whichare intolerable for resource-constrained UWSN applicationsThe only exception is FssAgg-MAC [5] which achievescomputational efficiency through hash chains and symmetrickey distribution Unfortunately despite its computational ef-ficiency FssAgg-MAC has high storage overhead and doesnot allow the signatures to be publicly verifiable limiting itsapplicability Thus it is necessary to seek more flexible andefficient forward secure and aggregate signatures for UWSNapplicationsIn this paper we propose a new class of digital signa-ture schemes for UWSN applications which we call Hash-Based §equential dggregate and Eorward §ecure §ignatures(HaSAFSS pronounced "Hasafass") We develop two specificHaSAFSS schemes a symmetric HaSAFSS scheme (calledSym-HaSAFSS) and an ECC-based HaSAFSS scheme (calledECC-HaSAFSS) A nice property of these schemes is thatthey achieve three seemingly conflicting goals computationalefficiency public verifiability and forward security at the sametime To achieve this HaSAFSS schemes introduce asymmetrybetween the senders and receivers using the time factor viaTimed-Release Encryption (TRE) [10] Using this asymmetryour schemes achieve high efficiency by avoiding costly PublicKey Cryptographic (PKC) operations while still remainingpublicly verifiable and forward secureWe summarize the properties of our schemes as follows:• Our schemes achieve near-optimal computational effi-ciency and public verifiability at the same time Theyachieve the computational efficiency by adopting crypto-graphic hash functions to compute aggregate and forwardsecure signatures and thus are much more efficient than allthe existing schemes (eg [9] FssAgg-BLS in [5]) withthe exception of FssAgg-MAC in [5] When compared withFssAgg-MAC [5] our schemes achieve public verifiabilityby eliminating symmetric key distribution and therefore aremuch more applicable for ubiquitous systems Note that ourschemes preserve the computational efficiency of FssAgg-MAC [5] while achieving these goals• In our schemes both senders and receivers get equalbenefits of computational efficiency while most existingschemes incur extremely heavy computational overhead onthe receiver side This property is especially useful for theUWSN applications in which the receivers need to verifylarge amounts of data efficiently• Besides the computational efficiency our schemes arealso storage and bandwidth efficient: (i) Since HaSAFSSschemes achieve the signature aggregation a sender alwaysstores and transmits only a single compact signature regard-Digital Object Identifier: 1041OB/ICST MOBIQUITOUS2009 6B24http://dxdoiorg/10410B/ICSTMOBIQUITOUS20096B242less of the number of time periods or data items to be signedThis property provides an advantage for the bandwidthlimited systems (ii) ECC-HaSAFSS is a sender friendlyscheme that requires storing only one key per sender Incontrast Sym-HaSAFSS requires storing one key for eachreceiver by offering an alternative receiver friendly scheme(the storage overhead on the sender side is still plausible)Hence ECC-HaSAFSS and Sym-HaSAFSS complementeach other in terms of storage overheadHaSAFSS schemes utilize already existing verification de-lays in the envisioned UWSN applications as an opportunityto achieve the aforementioned properties Thus they are idealsolutions for UWSN applications in which high computa-tional/storage/bandwidth efficiency are more important thanimmediate verificationThe remainder of this paper is organized as follows SectionII briefly presents related work Section III discusses notationsecurity and data models Section IV describes the proposedschemes in detail Section V provides the security analysis ofthe proposed schemes Section VI gives performance analysisand compares the proposed schemes with previous approachesSection VII concludes this paperII RELATED WORKIn this section we first give an overview of the existingforward secure and aggregate signature schemes and thenreview the notion of Timed-Release Encryption (TRE) usedin our schemes We then briefly compare our schemes withTESLA [11] which also uses the time factor to achieveefficient source authentication Last we give a short reviewof self-healing schemes proposed for the UWSNsForward Secure and Aggregate Signatures: A forwardsecure signature aims to minimize the effect of key compro-mises The first forward secure signature scheme was proposedin [12] In this scheme each signature is associated with a timeperiod in addition to the signed data item After each timeperiod the secret key of the signer is changed and cannot beused for previous time periods Several new schemes were laterproposed to improve storage requirement signature size andcomputational cost (eg [8] [13] [14]) However all existingforward secure signatures are either computationally expensiveor introduce high storage overheadAnother important digital signature primitive is aggregatesignature which aggregates n individual signatures associ-ated with n different data items into a single compact sig-nature The first aggregate signature scheme was proposedin [9] which utilizes the BLS (Boneh-Lynn-Shacham) signa-tures [15] Various new aggregate signature schemes have beendeveloped to offer different properties such as sequentiality(order preserving) [16] low storage overhead [17] and for-ward security [5] Despite their attractive properties all theseschemes are also computationally expensive due to the heavyuse of BLS operationsRecently Ma et al [5] proposed the first signature schemesthat achieve signature aggregation and forward security simul-taneously motivating them for the efficient data integrity andauthentication in UWSNs: FssAgg-BLS and FssAgg-MACFssAgg-BLS uses hash chains and BLS based signatures [9]to compute and verify aggregate signatures thereby extremelycostly and impractical for the envisioned UWSN applicationsIn contrast FssAgg-MAC archives high computational effi-ciency by utilizing hash chains and MAC functions to com-pute and verify signatures via symmetric key pre-distributionDespite its effectiveness FssAgg-MAC does not allow thesignatures to be publicly verifiable and incurs significantstorage overhead Inspired by FssAgg-MAC scheme [5] ourapproach achieves low storage overhead public verifiability aswell as computational efficiencyTimed-Release Encryption (TRE): The purpose of TREis to encrypt a message in such a way that no entity in-cluding the intended receivers can decrypt it until a pre-defined future time The majority of modem TRE schemes arebased on Trusted Agent (TA) in which a time server providesuniversally accepted time reference and trapdoor informationto users [10] Hence users can decrypt the ciphertext whenits related trapdoor information is released by the TA Mostof the recent TRE schemes are based on Identity-BasedEncryption (IBE) [18] and bilinear map (eg [19]) In orderto achieve efficient solutions we avoid using expensive IBE-TRE schemes Instead we only use the basic TRE concept tofulfill our requirementsTESLA: TESLA [11] is an efficient broadcast authentica-tion protocol that also uses delayed disclosure of the keyingmaterial assuming that senders and receivers are loosely syn-chronized However our schemes provide important propertiesthat are not available in TESLA For example TESLA cannotachieve forward security and signature aggregation therebycannot address requirements of the aforementioned UWSNapplications Also TESLA cannot be used for UWSN appli-cations when loose time synchronization cannot be guaranteedfor the network entitiesSelf-Healing Techniques: Recently a series of studies [1]-[3] based on self-healing techniques have been proposed toachieve data survival in UWSNs They first propose mobileadversary models in which the adversary compromises thesensors and deletes the data accumulated in them To confrontsuch an adversary they propose collaborative techniquesin which non-compromised sensors collectively attempt torecover a compromised sensor [2] [3] by introducing localrandomness (with a PRNG) to their neighborhood DISH [2]assumes a read-only adversary and targets the data secrecyPOSH [3] allows constrained write-only adversaries and tar-gets the data survival Pietro et al [1] elaborates the adversarymodels given in [2] [3] and provides experimental/analyticalresults for themNote that the adversary models and security goals in [1]-[3]are different from ours In our schemes (similar to FssAgg [5])the goal of the adversary is to forge data and/or destroy theauthentication However the goal of the adversary in [1]-[3]is to prevent the data from reaching the sink (not modifyingor forging it)III NOTATION SECURITY AND DATA MODELSNotation: G is a generator on an Elliptic Curve (EC) overa prime field Fp  where p is a large prime number and q is theDigital Object Identifier: 1041OB/ICSTMOBIQUITOUS2009 6B24http://dxdoiorg/10410B/ICSTMOBIQUITOUS20096B243order of G kG where k is an integer denotes a scalar multi-plication HI and H 2 are two distinct cryptographic hash func-tions which are both defined as H I / H 2 : {a I}" ---+ {a 1}IHIwhere n denotes the bit length of randomly generated inputkey and IHI denotes the output bit length of the selected hashfunction H 3 is used to compute aggregate signatures and is de-fined as H 3 : {a 1}* ---+ {a l}IHI H4 is used to map an inputkey to a point on the EC Le H4 : {a I}" ---+ aGoWe also usea secure MAC to compute individual signatures of data itemsdefined as MACsk : {a l}n x {a 1}* ---+ {a l}IHI Last weuse E D II and [z] to denote symmetric encryption functionsymmetric decryption function concatenation operation andthe bit length of variable x respectivelySecurity Model: The security model of our schemes basedon the following assumptions and definitions:Definition 1: Adversary A is a resourceful but ProbabilisticPolynomial Time (PPT) bounded adversary having the fol-lowing abilities: (i) passive attacks against output of crypto-graphic operations (ii) active attacks including packet inter-ception/drop/modification and (iii) physically compromisingsenders/receivers (called as "break-in") and extracting thecryptographic keys from the compromised nodes A aims toforge the extracted data using cryptographic keys obtainedfrom all senders and receiversAssumption 1: HI  H4 are secure strong collision-freehash functions producing indistinguishable outputs from therandom uniform distribution MAC cannot be forged by Awithout knowing sk Symmetric encryption function E is anideal cipher which cannot be decrypted by A without knowingthe secret key We also assume that the Elliptic Curve DiscreteLogarithm Problem (ECDLP) [20] [21] is intractable withappropriate parametersAssumption 2: We assume a Trusted Third Party (TTP)which is trusted by all network entities (i) A cannot com-promise the TTP; (ii) A may jam the TTP but if an entitycontinuously tries its messages can eventually reach the TTP;(iii) the TTP releases time trapdoor keys (secret cryptographickeys) with which the receivers verify the forward secure andaggregate signatures generated by the senders We assume thattime trapdoor keys released by the TTP reach the receiverseventually Details of the time trapdoor key delivery are givenin data modelsDefinition 2: The forward security objective of our schemesis to achieve the per-data item forward security That is in agiven time interval tw  senders sign each collected data itemas soon as it is received and updates the signing key Thisstrategy provides forward security of each individual data itemcollected in a given time interval tw (not across intervals)which is different from the per-time period forward securityobjective of FssAgg schemes [5] 1 Detailed security analysisof this approach is given in Section VRemark 1: The per-data item forward security objectiverequires that senders should transmit the aggregate signaturecomputed in tw to the receivers before the TTP releases the1In FssAgg [5] schemes the signing key is updated once for each timeperiod not for the each collected data item Thus if A breaks-in in tw  thenshe can forge all data items accumulated-so-far from the beginning of t-»However A cannot forge data items accumulated in t < t-»time trapdoor key associated with tw • Such a requirement iscompatible with the periodic data collection characteristic ofthe envisioned UWSN applications [5]-[7] Details of howour schemes handle data/time trapdoor information are givenin data models and Section IV-BData Models: We consider two data delivery models forour envisioned UWSN applications:(a) Synchronous Data Delivery Model: This model ad-dresses applications in which senders/receivers and the TTPcan agree on a prospective data delivery schedule so thatdata/trapdoor delivery can be performed based on this pre-determined schedule In this model the TTP passively broad-casts time trapdoor keys periodically and it is assumed thatthe receivers (eg mobile collectors) are able to visit sensorsbased on this pre-determined schedule(b) Asynchronous Data Delivery Model: This model ad-dresses applications where the nature of application does notallow a prospective delivery schedule In this case the TTPprovides the time trapdoor information to the receivers ondemand A representative scenario would be a military UWSNapplication in which soldiers gather information from sensorsfrom time to time and then request time trapdoor keys from theTTP (eg UAV/satellite) Note that in the worst case receiverscan obtain time trapdoor keys from a high-end and mobileTTP directly (eg MTC (Mobile Tactical Center) [22]) ThusAssumption 2-(iii) is realisticRemark 2: Senders do not need to communicate with theTTP Receivers communicate with the TTP only in asyn-chronous data delivery model only once for each time period(the TTP is offline majority of the operation time)IV PROPOSED SCHEMESIn this section we present the proposed schemes Sym-HaSAFSS and ECC-HaSAFSS Before giving the detaileddescription we first give an overview of these schemesA OverviewThe main goal of the HaSAFSS schemes is to create aforward secure and aggregate signature scheme which is asefficient as a MAC-based signature scheme and is publiclyverifiable at the same time Our schemes achieve this goalbased on the following observations: (i) Delays are already in-trinsic to the envisioned UWNS applications; such delays canbe used to introduce asymmetry naturally between the sender(signer) and the receivers (verifiers) in order to bring bothpublic verifiability and efficiency to the envisioned UWSNapplications (ii) HaSAFSS introduces this asymmetry with theaid of TRE concept instead of offloading this task simply tothe senders Hence even when the senders are compromisedsuch asymmetry can still guarantee the forward security andsignature aggregation in a publicly verifiable wayThe HaSAFSS schemes consist of four phases: Initializa-tion signature generation time trapdoor release and signatureverificationInitialization Phase: In this phase the TTP prepares anddistributes necessary cryptographic keys to the senders andthe receivers In HaSAFSS the TTP divides the time-line intoDigital Object Identifier: 104108/ICSTMOBIQUITOUS20096824http://dxdoiorg/104108/ICSTMOBIQUITOUS200968244multiple time periods each of which is associated with fourtypes of cryptographic keys: time trapdoor keys per-intervalkeys per-data item keys and session keys(i) Time trapdoor keys: Time trapdoor keys are the essentialinstrument to introduce the desired asymmetry utilizing thebasic TRE concept Each time trapdoor key tkw is associatedwith the time period tw and is released according to the ap-plication requirements Time trapdoor keys introduce desiredasymmetry via per-data item per-interval and session keys(ii) Per-interval keys: Each sender uses a per-interval keyfor each time period The first per-interval key is given tothe sender by the TTP The sender then "evolves" (with ahash operation) the per-interval key as the time goes from oneperiod into the next The objective of the per-interval key isto provide a fresh initialization key for each time period fromwhich the other required keys are derived for that time interval(iii) Per-data item keys: Each sender uses a per-data itemkey for each data item The first per-data item key in eachtime interval called the chain root of the per-data item keysin that time interval is either derived from the per-intervalkey (Sym-HaSAFSS) or randomly generated (ECC-HaSAFSS)at the beginning of the time interval The per-data item keyalso "evolves" through hash operations on a per-data itembasis Each sender computes individual signatures of theaccumulated data items with a MAC operation using the per-data item keys which provide forward security of these dataitems for the given time periodSym-HaSAFSS and ECC-HaSAFSS complement each otherin terms of storage overhead by computing these keys indifferent ways In Sym-HaSAFSS the TTP directly providesthe per-data item keys to the senders in the encrypted formIn ECC-HaSAFSS the senders can compute their own sessionand per-data item keys themselves Figure 1 illustrates thecomputation of these keys in HaSAFSS schemesTime Trapdoor Release: Receivers need the time trapdoorkeys to verify aggregate signatures The TTP releases timetrapdoor keys in two modes following the two data deliverymodels whose details are given in Section III: (i) In thesynchronous mode the TTP can release the time trapdoor keysbased on a pre-determined data delivery schedule periodicallywithout requiring an interaction with the receivers (ii) In theasynchronous mode the TTP releases the time trapdoor keyif and only if it is requested by a sufficient number of validreceivers signature Generation Phase: HaSAFSS schemes achievecomputational efficiency since the aggregate signature gen-eration/verification steps rely on symmetric primitives only(signature generation step 2) Figure 2 summarizes signaturegeneration/verification phasesAt the beginning of each time period tw  the sender updatesher per-interval key and either derives the first per-data itemkey (Le the chain root) from the per-interval key (Sym-HaSAFSS) or generates it randomly (ECC-HaSAFSS) Usingthis per-data item key the sender computes aggregate signa-tures of individual data items as follows: The sender signseach accumulated data item individually by computing itsMAC using the corresponding per-data item key and updatesher per-data item key with a hash operation (and deletes the5ECC-HaSAFSS Initialization(-- ---~)Sym-HaSAFSS Initialization(-- ---~)H I II ITime Trapdoor Key tko""-- tk l~ tk 210 II I' 1_2 ' 1_1I I )tko~ tk l !!-L tk 2 H I Ik L_1~10 I ' 1_2 tl_1I I I ITTP - - >Senderi : ( lDi  zbcb c[  eLI) TTP - - > Receivers : HI (tk O)Session Key tkb = H 3(tkO II lDi )    tkLl = H 3(tk L_ I II lDi )Encrypted i E (k iO) i E (ki L- I)Chain Root Co = tk ; 0 CL-I = Ik ;_l 0per-Interva ;-~aL_IG =H 4(tkL- I )Vi-I =tkL-I (ri-1 - a L_I )G Public Keya oG = H 4 (tkO)V6 = tko(r6 - aO)GTTP - - > Sender i : r6Session and per-data item keys: Senders compute th emselves TTP - - > Receivers :1D0 : (vg ·v2_) ;  ; IDs : (vg ·vL) ; H I (tk o )qH I i~ ZL - l1H zkOiL- Ii H IZ2 -----01HzkOi2i H IZI -----01HzkOi1Per-Data KeyPer-Inlerval KeyFig I Initialization phase of Sym-HaSAFSS and ECC-HaSAFSSIt- - - - - - -------- - - - - - - - - --- --- --- --- - - - - - - - - lII Timing/request cond itions and time trapdoor key verification! when the signa ture-data packet (Pkt) is rece ived in t) II) Synchronous Mode : Check the timing condition as (t+o) < tw' IIf the timing condition holds then buffer Pkt else discard it I2) Asynchronous Mode: The TTP releases «; when the number of Ivalid requests coming from the receivers exceed 't o If Pkt is received IIbefore the release of tk  then buffer Pkt else discard it I(3) When tkis rece ived:'~eri fy it as tk"= ? H/ tk"_I )' I---------------------~---------------------~I'II  Verify the signature and authenticate IDj (after v: is released)2) Compute the individual signatures: of '" = MACk;" (D j ) for j = 0 ·1 I3) Verify the aggregate signature similar to the signature generation The IIcorrect verification provides the authentication of ID j '---------------'IU) Ik:l' = H3(tk\]' II lDi ) ~) TK\]' = 11 4 (tk\]' ) K:l' = III (tk\]' V~ +TK\]' ) 'Ib) k;;\]' = D'k: (c:l') [b) k~ \]' = DK (c:l')I Sym-HaSAFSS ECC-HaSAFSSII)Recover the per-data item key of sender i as follows :--{ HaSAFSS Signature Verification (Receivers)HaSAFSS Signature Generation (Sender i)c'--- ---'I I Update per-interval key and compute kb'w(beg inning of t) II Sym-HaSAFSS ECC-HaSAFSS I11) i H  k i1V 1) ' H  K ' - I f (" ') d I '1Z w~ 0 r~~ r~~ + l ' 1\ - I r l1 u  e iete r;2) i 1/ i d I I ) " ' k""  '"~ '"" " '''w2 'T m""'" 0 '" ( " " ' 'd K"II Compute the aggregate signa ture using kb'"in twtwqo D1 £(2 • • • l{ tW+Ik!?=- I H I  Ii'W! 1/1 ) k¥ j   ~I ;~ k{" t IO'n = MACk" (Dn) 0'1= MACk" (DI ) 1';:-2~ MACk" (D;~ · ·fO-7-:MAC';:"(D)l~ I ' L'\ -'-___ L__~~-'J0'01= H 3(0'0 II0'1)-0'02 = H 3(0'011I0'2 ) '" f--'i>o O'O1 = H 3(0'01-1 1I 0'1)I --- ----------~f   i ~Before lite relense 0 Ik "  sender  - - > receivers : (DnDI" ' Dt  CW ' lD i• 110" ailt )1-Fig 2 Overview of the signature generation/verification phases of HaSAFSS schemesprevious one) The sender folds individual signature of thenewly collected data item into the existing aggregate signatureby concatenating and hashing them together This procedureis shown in Figure 2 signature generation step 2Signature Verification Phase: In the signature verificationphase  the receivers obtain and verify the time trapdo or keyfrom the TTP Using the identity of the sender and the timetrapdoor key each receiver computes the session key anddecrypts the encrypted chain root of the sender for the giventime interval At this stage the receivers possess per-data itemkeys of the sender for the time interval  which were used tocompute the aggregate signature Thus they can verify theaggregate signature by following the same procedure as inthe signature generation phase  This allows both senders andreceivers to equally benefit from the computational efficiencyRemark 3: After the release of the time trapdoor key thereceivers never accept any signature associated with this timetrapdoor key from any sender This condition (the timingcondition in the synchronous mode and the request conditionin the asynchronous mode) prevents A from forging data itemsaccumulated in the previous time intervals At the same timeregularly updating per-data item keys prevent her from forgingdata items accumulated in the given time interval Detailedsecurity analysis of this approach is given in Theorem 1B Sym-HaSAFSSThe motivation behind Sym-HaSAFSS is to achieve threeseemingly conflicting goals at the same time without usingany PKC operations: Public verifiability high efficiency andforward security To achieve this Sym-HaSAFSS protects per-data item keys via encrypted chain roots  which are decryptedand publicly verified by the receivers with the release of timetrapdoor keysThe TIP generates the initial per-interval key zb for senderi The per-interval key is updated when the time goes into anew time interval In each time interval tw  the per-intervalkey is used to derive the chain root k~'w (ie the first per-dataDigital Object Identifier: 104108/1CSTMOBIQUITOUS20096824http://dxdoiorg/104108/1CSTMOBIQUITOUS2009 6824item key in tw )  which is then used to compute the aggregatesignatures in tw • The per-data item key is refreshed for eachnew data item In order to protect k~'w the TTP encrypts eachk~'w with tk~ to obtain the encrypted chain root c~As a result only using the cryptographic hash and symmet-ric encryption functions Sym-HaSAFSS generates publiclyverifiable forward secure and aggregate signatures Signa-ture generation/verification cost of a single data item inSym-HaSAFSS is only three hash operations which areextremely efficient when compared with all PKC-based al-ternatives Near-optimal computational efficiency of Sym-HaSAFSS makes it an ideal choice for resource-constrainedUWSN applicationsBesides its computational efficiency Sym-HaSAFSS is alsoa storage efficient scheme Different from the PKC-basedapproaches in which receivers are required to store a largenumber of public key sets the storage requirement of Sym-HaSAFSS for each receiver is only one key The storage re-quirement of Sym-HaSAFSS for each sender is also plausiblefor the envisioned UWSN applications ((L - w) keys in timeperiod tw ) We present the detailed description below:Initialization Phase:1) The TTP chooses the maximum clock synchronizationerror as 8t and the trapdoor release times as °< To < T 1 < < TL - 1 according to the application requirements Everytwo consecutive time points Ti - 1 and T; form the i-th timeinterval ti2) The TTP randomly generates a hash chain Vw =H1(vw-l) for w = 1 L - 1 whose elements will beused as the secret time trapdoor keys in the reversed order astkw = VL-l-w for w = 0   L - 1 Each tk is associatedwith time interval tw for w = 0   L -1 The TTP computesthe encrypted chain roots for each sender i as follows:a) Generate the n-bit initial per-interval key zb for eachsender i The chain root for each time interval tw is derivedas k~'w = H2(Z~) and Z~+l = Hl(Z~) for w = 0   L - 1b) Compute the session key as tk~ = H3(tkwI11Di) andthe encrypted chain root of sender i for time period twasc~ = Etk~ (k~'W) where w = 0   L - 13) The TTP gives the commitment and maximum clocksynchronization error (HI (tko) 8t ) to all receivers and theper-interval key encrypted chain roots and maximum clocksynchronization error (1Di zb cb ci Ci-l' 8t ) to eachsender iTime Trapdoor Release Phase: This phase can be executedin two different modes:(1) Synchronous Mode: According to the pre-determineddelivery time schedule at the end of each tw  the TTP releasesthe secret time trapdoor key tkw •(2) Asynchronous Mode: Each receiver sends a request tothe TTP for the release of the secret time trapdoor key whenshe is ready to transmit the data (or a mobile TTP visits andrequests the data from the receivers) When the TTP receivesmore than a threshold number of (authenticated) requests (egT = 90%) the TTP releases the secret time trapdoor keySignature Generation Phase:Digital Object Identifier: 1041OBIICST MOBIQUITOUS20096B24http://dxdoiorg/10410B/ICSTMOBIQUITOUS20096B2461) At the beginning of time interval tw  sender i derives theper-data item key as k~'w = H2(Z~) updates the per-intervalkey as Z~+l = Hl(Z~) and deletes z~ from memory2) Assume that sender i has accumulated data itemsDo D1  •••  DZ- 1 and computed the aggregate signaturea~'r-l in two When sender i collects Di she first computesthe individual signature of Di as at'w = M ACkiw(Dz)  lwhere k;'w = Hl(k;~~) and then folds a;'w into a~'r-las a~'r = H3(a~'r_lllat'W) In the synchronous mode allkeys and signatures associated with tw expire at the end oftwo Thus sender i must transmit (Do D1   Di a~'r c~ tw  1Di ) before tw ends In the asynchronous mode s~nderscan transmit it any time before the TTP releases tkw (Howeverthe sender transmits it too late she may miss the opportunity tohave receivers accept it if the transmission is after the trapdoorrelease)Signature Verification Phase:1) Assume that a receiver has received (Do D1  •••  Di tw a~'r c~ 1D i ) at time t In the synchronous mode the receiverchecks whether the timing condition (t + 8t ) ~ tw holds fora~'r If yes the receiver buffers the aggregate signature anddata set and waits for the end of tw to obtain tk; from theTTP In the asynchronous mode the receiver sends a requestto the TTP to obtain tkw • Note that due to the nature ofUWSN applications there may be a delay before this requestis delivered to the TTP (or the TTP might not be able tovisit the receivers for a long time) In this mode the receivercan buffer the received data and signature as long as they arereceived before the release of tkw •2) When the TTP releases tkw  each receiver verifies tk; by?checking whether tkw ~ HI (tkw- 1) If tkw is verified thenthe receiver verifies a~'r as follows: The receiver decrypts c~by computing tk~ = 'H3(tkwIIIDi ) and k~w = Dtk:"(C~)Using the per-data item key the receiver computes individualsignatures of Dj as a;iW = MACk~w(Dj) and updates•• Jk;~l = H1(kj'W) for 1 = 0:   l Finally the receivercomputes agjW = H3(agj~11Ia;tW) for j = 1  l whereriu: liw liw? iw h0'00 = 0'0 and checks aoz = aoz  If they match t ereceiver accepts a~'r; otherwise rejectC ECC-HaSAFSSECC-HaSAFSS addresses the applications where thesenders are highly storage constrained while the receiverscan afford certain storage [5] In this context ECC-HaSAFSSoffers a sender friendly scheme in which each sender storesonly one key while preserving the computational efficiency ofSym-HaSAFSS To achieve this ECC-HaSAFSS uses a simpleECC-based approach which requires only a single ECC scalarmultiplication for each time interval two The key idea behindthis approach is to give the ability to compute her own sessionand per-data item keys to each sender after the deploymentThus instead of storing a pre-computed encrypted chain rootfor each time interval like Sym-HaSAFSS each sender cancompute her own encrypted chain roots using her per-intervalkey (single key storage)In ECC-HaSAFSS the TTP generates the initial per-intervalkey rb for each sender i before the deployment Each senderi updates the per-interval key at the beginning of each timeinterval tw and computes the session key K~ using the per-interval key r~ with an ECC scalar multiplication Sender ithen randomly generates a per-data item key kh'w (ie thefirst per-data item key in tw) In order to protect kh'w in twsender i encrypts it with K~ to obtain the encrypted chain rootc~ After this stage sender i computes the aggregate signatureusing the per-data item kh'w following the signature generationstep 2 in Sym-HaSAFSS In order to verify the aggregatesignature a receiver first recovers K~ from the public keyof sender i using tk with an ECC scalar multiplication Thereceiver then decrypts the per-data item key of sender i andverifies the aggregate signature following the same steps ofthe signature generationNote that ECC-HaSAFSS preserves the computational effi-ciency of Sym-HaSAFSS since the signature generation andverification costs of a single data item in ECC-HaSAFSS aresimilar to that of Sym-HaSAFSS (only three hash operations)We present the detailed description of ECC-HaSAFSS below:Initialization and Time Trapdoor Release Phases:1) The TTP generates the time trapdoor keys tk; associatedwith the time period tw for w = 0   L - 1 following theSym-HaSAFSS initialization steps The TTP then generatesthe public key of each sender i in each time interval twasfollows: The TTP randomly generates the n-bit per-intervalkey rb and computes the public key for each tw as V~ =tkw(r~-cxw)G where cxwG = H4(tkw) ~or w = 0  : L-1The per-interval key is then updated as r~+l = Hl(r~) aftereach interval two The TTP provides rb to each sender i andgives the public keys V~ associated with each sender i forw = 0   L - 1 to all receivers2) Time trapdoor release in ECC-HaSAFSS is the same asin Sym-HaSAFSSSignature Generation Phase:1) At the beginning of tw  sender i randomly generatesthe n-bit per-data item key k~'w and computes the sessionkey as K~ = Hl(r~G) and the encrypted chain r?ot asc~ = EKi (k~'W) She updates the per-interval key as r~+l =HI (r~) a~d deletes (K~ r~) from memory 2) Sender i computes the aggregate signature ah'r for(Do D1  •••  Dz) using the per-data item key k~'w and trans-mits it to the receivers following step 2 in Sym-HaSAFSSsignature generationSignature Verification Phase: When a receiver receives(DoDl  Dza~'rc~ twIDi )  she first checks tim-ing/request conditions for the received packet and verifies tk;upon its receipt as in Sym-HaSAFSS signature verific~tion(step 2) The receiver recovers the session key as K:n =HI (tk:;; 1v~ + H4 (tk w)) and decrypts the per-data item keyas k~'w = DKi (c~) The receiver verifies a~'r using kh'wfollowing step '2 in Sym-HaSAFSS signature verificationv SECURITY ANALYSISHaSAFSS schemes achieve secure signature aggregationand forward security simultaneously We follow the exampleDigital Object Identifier: 1041OB/ICSTMOBIQUITOUS2009 6B24http://dxdoiorg/10410B/ICSTMOBIQUITOUS20096B247of [5] to analyze our schemes (ie authentication integrityunforgeability [9] [16] and forward security properties [14])First we prove that HaSAFSS schemes guarantee theconfidentiality of per-data item keys and authenticity of theaggregate signature in a given time interval tw • They achievethis goal by reducing the above security properties to thesecrecy and authenticity of tkw • That is HaSAFSS schemescompute the encrypted chain root c~ using tkw in such away that no entity including sender i can decrypt it beforethe release of tkw • Furthermore the successful verificationof the aggregate signature a~'r with (k~'W tkw I Di ) directlyguarantees the authenticity o'f a~'r Hence the receiver cantrust a~'r which was generated by sender i using kh'w beforethe rele~se of tkw • Sym-HaSAFSS and ECC-HaSAFSS followdifferent strategies to achieve this goal which have differentstorage demands on senders and receiversSecond we show that HaSAFSS schemes achieve forwardsecurity integrity and unforgeability of the accumulated dataitems in a given time interval tw • HaSAFSS schemes achievethese goals by regularly updating per-data item and per-intervalkeys and obeying the timing/request conditions of the timetrapdoor key release modesLemma 1: HaSAFSS schemes guarantee the confidentialityof k~'w and authenticity of a~'r in the time duration betweenthe releases of tkw- 1 and tk~ as long as Assumption 1 andAssumption 2 holdProof: First in both HaSAFSS schemes each tkw can besecurely verified by all receivers since they are elements of ahash chain and are released in the reverse orderSym-HaSAFSS: Sym-HaSA~SS reduces the confidentialityof k~'w and authenticity of a~'r to the secrecy and authen-ticity of tkw  without consulting a PKC primitive Before thedeployment the TTP derives the session key from the sec~ettime trapdoor key as tk~ = H3(tkwJIIDi ) and encrypts kh'wwith the session key as c~ = Etki (kh'W) for w = 0  L-1Assume that the receiver re;ived (Dou;  Dl a~'r c~ tw) before the release of tkw At this stage all tkj forj = w   L - 1 are only known by the TTP Thus noentity can decrypt or generate a valid c~ without knowingtkw  including the sender (even compromised by A) Afterthe release of tkw  the successful verification of a~'r with(k~'w tkw) guarantees that only sender i who knows k~'wbefore the release of tkw could have computed this signatureHence public verification and authentication of a~'r areachievedECC-HaSAFSS: We analyze ECC-HaSAFSS in two stagesFirst we show that ECC-HaSAFSS guarantees the confiden-tiality of k~'w and authenticity of a~'r based on the secrecyand authenticity of tkw • Second we show that ECC-HaSAFSSis key compromise resistant That is A compromising a senderand a receiver cannot use the compromised keys to extract thetime trapdoor keys of the TTP or the secret key of a non-compromised sender This property guarantees the secrecy oftkw before its release (1) Confidentiality of k~'wand authenticity of a ~'r: In ECC-HaSAFSS each sender i computes her own session key usingher per-interval key as K~ = Hl(r~G) with which theencrypted chain root is computed for each tw • In order to makeK~ recoverable for the receiver after the release of tkw  theTTP computes a set of public key for each sender i The TTPembeds session keys into the public keys V~ by blinding themwith tkw as V~ = tkw(r~ -aw)G where awG = H4 (tkw) forw = 0  L - 1 The algebraic structure of the public keysguarantees that the session key K~ cannot be recovered fromV~ without knowing tkw • That is r~G cannot be isolatedfrom V~ as K~ = tk~ 1V~ + H4 (tk w) without knowing tkwNote that sender i immediately deleted (K~ r~) from thememory after computing c~ = EK:V (k~'W) at the beginningof two Hence before the release of tkw no entity can decryptor generate a valid c~ without knowing tkw • Similarly onlysender i could compute a valid c~ which can be correctlydecrypted by using tkw and V~ Thus correct verification ofthe aggregate signature guarantees its authenticity(2) Key compromise resistance: Assume that A compro-mises a sender (sender i) and a receiver in time interval tw •A extracts r~+l from sender i and Vji for j = 0  L - 1from the receiver A has also accumulated pre-released tkjfor j = 0   W - 1 up to now The objective of A is torecover the future secret time trapdoor keys of the TTP or thesecret per-interval key of a non-compromised sender using thecompromised keys as follows:(a) A attempts to use the per-interval key r~+l of sender iand the public keys Vji for j = w +1   L -1 to extract anyfuture time trapdoor key tkj for j = w+1   L-1 Howeverrecovering such a tkj is as difficult as solving the ECDLPproblem since it requires to compute Xj = tkj(rj - aj) modq from Vji Note that even if such a Xj would be found both(tk j aj) are unknown to A Thus she cannot isolate tkj fromXj for j = w + 1  L - 1(b) A attempts to use the pre-released tkj and the publickeys Vjm j = 0   w - 1 to recover the secret per-intervalkey rj of a non-compromised sender m for any °:S j :Sw -1 (A can then easily compute the future per-interval keysof sender m using the recovered rj since they are elementsof a hash chain) However recovering such a rj as rj modq from rjG is as difficult as solving the ECDLP problem8where rjG = tkjlVjm + H4(tkj) for j = 0  w -1 •Theorem 1: HaSAFSS schemes achieve forward securityintegrity and unforgeability of (Do D1  •••  Di a~'r) in thetime duration between the releases of tkw- 1 and tkw as longas Lemma 1 holdsProof: At the beginning of each tw  signature generationstep 1 in both Sym-HaSAFSS and ECC-HaSAFSS guaranteesthat per-interval keys are evolved (by deleting the previousone) and per-data item keys are derived After the initialupdates both HaSAFSS schemes regularly update their per-data item keys for each accumulated data item (Sym-HaSAFSSsignature generation step 2) Hence if A breaks-in in theduration of tw  she always faces the updated per-interval andper-data item keys which guarantee the forward security ofthe data accumulated in the time duration between the releasesof tkw- 1 and tkwBoth HaSAFSS schemes prevent A from forging the dataaccumulated in the previous time periods by obeying the tim-ing/request rules of the time trapdoor release mode The maincondition for the receiver to accept (Do D1  •••  Di a~'r) isthat it should be received before the release of tkw • Aft~r therelease of tkw  the timing condition of the synchronous modeand the request condition of the asynchronous mode preventreceivers from accepting any signature associated with tkw •Thus if A breaks-in after the release of tkw  she cannot useany key associated with t :S tw  thereby cannot forge any dataitem accumulated in these time periodsHaSAFSS schemes achieve unforgeability and integrity in agiven tw by using per-data item keys to individually computeMAC of each accumulated data item and fold them into theprevious aggregate signature by hashing (H3 ) them as shownin Sym-HaSAFSS signature generation step 2 Lemma 1guarantees confidentiality of k~'w and authenticity of a~'rwhile the forward security is achieved in the time durationbetween the releases of tkw- 1 and tkw as shown aboveHence a~'r computed with k~'w is unforgeable and guaranteesthe integrity of (Do D 1  •••  Dl) in a given time interval •VI PERFORMANCE ANALYSISIn this section we present the performance analysis ofHaSAFSS schemes We analyze and compare HaSAFSSTABLE INOTATION USED IN THE PERFORMANCE COMPARISON OF HASAFSS AND FssAGG SCHEMESExp: Modular exponentiation with modulus p where Ipl = 512 bit L: # of time periodsECCMul: ECC scalar multiplication over t; S: # of senders w: Current time periodM ul: Scalar multiplication with modulus p f: #of data items P R: ECC pairing operationMtP: Map-to-point operation H: Hash operation R: # of receiversTABLE IICOMPARISON OF HASAFSS SCHEMES TO FssAGG SCHEMESCriteria vs Scheme II Sym-HaSAFSS I ECC-HaSAFSS I FssAgg MAC [5] FssAgg BLS [5] & [9]Computational Sender (3H)f ECCMul + (3H)f (3H)f (MtP + Exp+ Mul + nvOverhead Receiver (3H)f ECCMul + (3H)f (3H)f (Mul + PR)fStorage Sender IHI(L - w) IHI IHIR IHIOverhead Receiver IHI Iql(L - w)S IHIS Iql(L  S)Signature Size IHI IHI IHI IplKey Size n n n IqlPublic Verifiability y y N yImmediate Verification N N y yDigital Object Identifier: 1041OB/ICST MOBIQUITOUS20096B24http://dxdoiorg/1041OB/ICSTMOBIQUITOUS2009 6B24schemes to previous schemes in terms of six essential criteriafor forward secure and aggregate signatures : computationaland storage overhead of senders and receivers  respectivelythe size of aggregate signature and the size of signing keyWe present our analysis for these criteria under two mainsubsections: computational overhead and storage overheadWe first give notation in Table I and then provide TableII In Table II we compare HaSAFSS schemes with FssAggschemes (the best known alternatives) Note that HaSAFSSschemes are always computationally more efficient than theexisting aggregate signature schemes that utilize pairing op-erations (eg [9] [16]) Thus by specifically comparingHaSAFSS schemes with FssAgg-BLS we can see their dif-ference from this general class of schemes A Computational OverheadWe first analyze the signature generation cost of HaSAFSSschemes using the notation introduced in Table I In bothHaSAFSS schemes  at the beginning of each tw ' each sendercomputes the per-data item and per-interval keys with 2Hcomputational cost (ie two hash operations) This introducesnegligible cost since this operation is performed once for eachtwoIn ECC-HaSAFSS in addition to 2H a single ECCMulis also performed for each two After initialization the signaturegeneration cost of the sender for a single data item is 3H inboth Sym-HaSAFSS and ECC-HaSAFSS Thus the cost ofthe signature generation for £ data items in tw is (3H)£ inSym-HaSAFSS and ECCMul + (3H)£ in ECC-HaSAFSSThe analysis of the signature verification cost is similar tothe signature generation Note that the cost of a single H(verification of tk) and E / D operation (encrypt/decrypt k~'W)is negligible since they are executed only once for each twoThus  signature verification costs of Sym-HaSAFSS and ECC-HaSAFSS are (3H)£ and ECCMul + (3H)£ respectivelyTABLE IIIEXECUTION TIME OF THE BASIC OPERATION S IN COMPARED SCHEMES (IN MSjSignlVerify cost of a data item (Executed etimes)FssAgg-MAC [5] Sign/Verify 006HaSAFSS schemesFssAgg-BLS [5] Sign 769Verity 5352Initialization cost for each tw (Executed only once)Sym-HaSAFSS Sign/Verify 008ECC-HaSAFSS Sign/Verify 158Comparison: We first compare HaSAFSS schemes toFssAgg-MAC [5] FssAgg-MAC and Sym-HaSAFSS havesimilar computational cost as (3H)£ ECC-HaSAFSS requiresone extra ECCMul for each twas ECCMul + (3H)£which is slightly more costly than FssAgg-MAC Note that theessential superiority of HaSAFSS schemes over FssAgg-MACis their "public verifiability" whose benefits can be observedin the storage overhead analysisSecond we compare HaSAFSS schemes with their bestknown PKC-based counterpart scheme FssAgg-BLS [5]Based on PKC primitives  FssAgg-BLS has all advantages ofthe public verifiability However it incurs very high compu-tational overhead due to the heavy use of PKC operationsDigital Object Identifier: 104108/1CSTMOBIQUITOUS20096824http://dxdoiorg/104108/1CSTMOBIQUITOUS200968249FssAgg-BLS signature generation is costly due to Exp whileits signature verification is extremely costly due to PR TableIII shows the execution time difference between signaturegeneration and verification costs of HaSAFSS and FssAgg-BLS Signature generation and verification costs of a singledata item in FssAgg-BLS are 769 ms and 5352 ms [5]while they are both 006 ms in HaSAFSS schemes Thisprohibitive computational cost of FssAgg-BLS makes it im-practical for the envisioned UWSN applications Note thatthese expensive operations are executed for each data itemto be signed/verified" which increases the execution timedifference between HaSAFSS and FssAgg-BLS schemes asshown in Figure 3Execution time comparison of HaSAFSS and FssAgg schemes105 --------------------------------------<J)~ 104Q)§ 103J::U<J)Q) 102£'0Q) 10'E- FssAgg-MAC SignNerify- FssAgg-BLS Sign- FssAgg-BLS Verify- Sym-HaSAFSS SignNerify- ECDH-H aSAFSS SignlVerify200 400 600 800 1000Numb er of data item to be signed/ve rifiedFig 3 Execution time comparison of HaSAFSS and FssAgg [5]We see that both HaSAFSS schemes are much more efficientthan FssAgg-BLS Furthermore in HaSAFSS schemes bothsenders and receivers equally get benefits of this computationalefficiency while the classical aggregate signature schemesincur more computational cost to the receivers B Storage OverheadBesides their computational efficiency HaSAFSS schemesare also storage efficient and complement each other in termsof storage overheadIn Sym-HaSAFSS each sender initially stores L encryptedchain roots  As the time goes from one period into the nextthe sender deletes the encrypted chain root associated withthe previous time period from her memory Thus  each senderstores (L - w) keys in two However each receiver only storesa single key (negligible IHI overhead eg 160 bit) In ECC-HaSAFSS each sender stores only one key since she cancompute her own session keys after the deployment In orderto recover session keys each receiver stores L public keys foreach sender initially and as the time goes from one periodinto the next she deletes the public keys associated with theprevious time period from her memory Thus storage overheadof each receiver is Iql(L - w)S in tw (eg Iql = 160 bits)Comparison: Sym-HaSAFSS is the most storage efficientscheme among all the compared schemes from the receiver's2In our computational cost analysis we analyze FssAgg-BLS parallel toHaSAFSS schemes by updating the signing key for each data itemperspective Since Sym-HaSAFSS requires storing only singlekey it incurs small IHI bit overhead for each receiver How-ever FssAgg-BLS and FssAgg-MAC incur Iql(L·S) and IHISbit overheads respectively This advantage of Sym-HaSAFSSis also valid with respect to other aggregate signature schemesthat incur higher storage overhead on the receiver side Sym-HaSAFSS is also efficient in the sender perspective by requir-ing only linear storage overhead to each sender Thus Sym-HaSAFSS is especially useful for the applications in whichreceivers are also storage constrained while FssAgg schemescannot address this type of applicationsIn contrast to Sym-HaSAFSS ECC-HaSAFSS obeys thetraditional resourceful receiver assumption to address suchUWSN applications (eg high-end mobile receivers [5])Since the storage overhead of ECC-HaSAFSS reduces as thetime advances (Le Iql (L - w)S bit overhead in tw )  it ismore efficient than FssAgg-BLS whose overhead is alwaysconstant as Iql(L· S) bit When compared to FssAgg-MACECC-HaSAFSS is more efficient for the sender side (Le IHIvs IHIR bits) and FssAgg-MAC is more efficient for thereceiver side (Le IHI(L - w)S vs IHIS bits)Remark 4: Despite all the advantages introducing asym-metry between the senders and receivers using the time factorbrings a natural complication: HaSAFSS schemes cannotprovide immediate verification on the receiver side In orderto verify a received signature the receiver needs to wait forthe release of tk; corresponding to this signature Howeversuch a property is compatible with the non-real-time nature ofthe envisioned UWSN applications Thus HaSAFSS schemesare ideal solutions for the envisioned UWSN applicationsVII CONCLUSIONIn this paper we proposed a new class of digital signa-ture schemes Hash-Based ~equential Aggregate and forward~ecure ~ignature (HaSAFSS) which is especially suitablefor the UWSN applications HaSAFSS schemes achieve near-optimal computational efficiency low storage overhead publicverifiability signature aggregation and forward security simul-taneously HaSAFSS schemes achieve these goals by using thealready existing verification delays in the envisioned UWSNapplications via two realistic data/time trapdoor delivery mod-elsWe proposed two specific HaSAFSS schemes Sym-HaSAFSS and ECC-HaSAFSS in this paper Sym-HaSAFSScompletely relies on symmetric encryption and cryptographichash functions Thus Sym-HaSAFSS is extremely efficientin terms of computational cost when compared with the ex-isting PKC-based aggregate signature schemes FurthermoreSym-HaSAFSS is also a storage efficient scheme whichrequires only one key stored by each receiver while storagerequirement of each sender is linear with the total number oftime periods Our second scheme ECC-HaSAFSS preservesthe computational efficiency of Sym-HaSAFSS for signaturegeneration and verification but offers a different storage al-ternative In ECC-HaSAFSS each sender stores only one keywhile each receiver stores a set of public keys for each senderThus Sym-HaSAFSS and ECC-HaSAFSS complement eachother in terms of storage overheadDigital Object Identifier: 104108/ICSTMOBIQUITOUS20096824http://dxdoiorg/104108/ICSTMOBIQUITOUS2009682410In our future work we will consider different cryptographicmechanisms that allow us to further reduce the storage require-ment in HaSAFSS schemesREFERENCES[1] D Pietro R L Mancini C Soriente  A Spognardi and G Tsudik"Catch me (if you can): Data survival in unattended sensor networks"Pervasive Computing and Communications 2008 PerCom 2008 SixthAnnual IEEE International Conference on pp 185-194 March 2008[2] D Ma and G Tsudik "Dish: Distributed self-healing" in SSS '08: Pro-ceedings of the 10th International Symposium on Stabilization Safetyand Security of Distributed Systems Berlin Heidelberg: Springer-Verlag 2008 pp 47-62[3] R Di Pietro D Ma C Soriente  and G Tsudik "Posh: Proactive co-operative self-healing in unattended wireless sensor networks" ReliableDistributed Systems 2008 SRDS '08 IEEE Symposium on pp 185-194 Oct 2008[4] J C McEachen and J Casias "Performance of a wireless unattendedsensor network in a freshwater environment" in HICSS '08: Proceedingsof the 41st Annual Hawaii International Conference on System SciencesWashington DC USA: IEEE 2008 p 496[5] D Ma and G Tsudik "Forward-secure sequential aggregate authenti-cation" in Security and Privacy SP '07 IEEE Symposium on Securityand Privacy 20-23 May 2007 pp 86-91[6] Trident Systems "Trident's family of unattended ground sensors" http://wwwtridsyscom/white-unattended-ground-sensorshtm[7] Information Processing Technology Office (IPTO) Defense Ad-vanced Research Projects Agency (DARPA) "Bba 07-46 landroidsbroad agency announcement 2007" http://wwwdarpamillipto/solicitJbaa/BAA-07-46_PIPpdf[8] M Bellare and S Miner "A forward-secure digital signature scheme"in Proceedings of the 19th Annual International Cryptology Conferenceon Advances in Cryptology CRYPTO '99[9] D Boneh C Gentry B Lynn and H Shacham "Aggregate andverifiably encrypted signatures from bilinear maps" in Proceedings ofAdvances in Cryptology (EUROCRPYT 2003) 2004 pp 416-432[10] R Rivest A Shamir and D Wagner "Time-lock puzzles and timed-release crypto" Cambridge MA USA Tech Rep 1996[11] A Perrig R Canetti D Song and D Tygar "Efficient authenticationand signing of multicast streams over lossy channels" in Proceedingsof the 2000 IEEE Symposium on Security and Privacy May 2000[12] R Anderson "Invited lecture" 4th ACM Computer and Communica-tions Security 1997[13] B Libert J Quisquater and M Yung "Forward-secure signatures inuntrusted update environments: efficient and generic constructions" inProceedings of the 14th ACM conference on Computer and communi-cations security CCS '07 NY USA: ACM pp 266-275[14] H Krawczyk "Simple forward-secure signatures from any signaturescheme" in Proceedings of the 7th ACM conference on Computer andCommunications Security CCS '00 NY USA: ACM pp 108-115[15] D Boneh B Lynn and H Shacham "Short signatures from the weiIpairing" Journal of Cryptology vol 14 no 4 pp 297-319 2004[16] S Lu R Ostrovsky A Sahai H Shacham and B Waters "Sequentialaggregate signatures and multisignatures without random oracles" inAdvances in Cryptology EUROCRYPT '06[17] A Boldyreva C Gentry A O'Neill and D Yum "Ordered multisig-natures and identity-based sequential aggregate signatures with appli-cations to secure routing" in Proceedings of the 14th ACM conferenceon Computer and communications security CCS '07 New York NYUSA: ACM 2007 pp 276-285[18] D Boneh and M Franklin "Identity-based encryption from the weilpairing" SIAM Journal on Computing vol 32 pp 586-615 2003[19] H Varsakelis K Chalkias and G Stephanides "Low-cost anonymoustimed-release encryption" Information Assurance and Security lAS2007 pp 77-8229-31 Aug 2007[20] D Boneh "The decision diffie-hellman problem" in Proceedings of theThird Algorithmic Number Theory Symposium LNCS 1998 pp 48-63[21] D Stinson Cryptography: Theory and PracticeSecond EditionCRC/C&H 2002[22] A A Yavuz F Alagoz and E Anarim "Himutsis: Hierarchical multi-tier adaptive ad-hoc network security protocol based on signcryptiontype key exchange schemes" in ISCIS 2006 pp 434-444
Key managment scheme WSN using deployment knowledge-pdf,A Key Management Scheme for Wireless Sensor Networks Using Deployment Knowledge Wenliang Du' Jing Deng' Yunghsidng S Hant Shigang ChenT and Prainod K Varshney" 'Department of Elecuical Engineering and Computer Science Syracuse University Syracuse NY 13244-1240 USA Email: {wedu jdeng01 varshney}@ecssyredu tDepartment of Computer Science and Information Engineering National Chi Nan University Taiwan ROC Email: yshanQcsiencnuedutw tDepartment of Computer and Information Science and Engineering University of Florida Gainesville FL 3261 1-6120 USA Email: sgchen@ciseufledu Abstract-To achieve security in wireless sensnr networks it is imporlnnt t o  he ahle to encrypt mesages sent among sensor nodes Keys for encryption purposes must he agreed upon hy communicating nudes Due to resource constraints achieving such key agreement in wireless sensor networks is non-trivial Many key agreement schemes used in general networks such as Uiflie-Hellman and public-key hwed schemes are not suitahle for wireless sensor networks Pre-distrihution of secret keys for all pairs of nudes is not viahle due to the large amount OS memory used when the network sue  is large Recently B random key pre- distrihutian scheme and its improvements hare heen proposed A common assumption made hy these random key pre- distrihution schemes is that no deployment knowledge is avail- uhle Noticing that in many practical scenarios certain deploy- ment knowledge may he availahle n priori we propose a novel random key pre-distribution scheme that exploits deploynient knowledge and avoids unnecessary key nssignnients We show that the performance (including connectivity memory usage and network resilience against nude capture) of sensor networks can he snhslnntiirlly improved with the use of our  proposed scheme The scheme and its detailed performance evaluation are presented in this paper I IXTRODUCTION Recent advances in elecuonic and computer technologies have paved the way for the proliferation o i  wireless sensor networks (WSN) Sensor networks usually consist of a large number of ultra-small autonomous devices Each device called a sensor node is battery powered and equipped with inte- grated sensors data processing capabilities and short-range radio communications In typical application scenarios sensor nodes are spread randomly Over the deployment region under scrutiny and collect sensor data Examples of sensor network projects include SmanDust [I] and WINS [?I Sensor networks are being deployed for a wide variety of applications [3] including military sensing and tracking en- vironment monitoring patient monitoring and tracking smart environments etc When sensor networks are deployed in il hostile environment security becomes extremely important as they are prone to different types of malicious attacks For example an adversary can easily listen to the traffic imper- sonate one of the network nodes' or intentionally provide misleading information to other nodes To provide security communication should be encrypted and authenticated An open research problem is how to bootstrap secure commu- nications among sensor nodes ie how to set up secret keys among communicating nodes'? This key agreement problem is a part of the k?y nianageriienr problem which has been widely studied in general network environments There are three types of general key agreement schemes: trusted-server scheme self-enforcing scheme and key pre-distribution scheme The Inisfed-semi- scheme de- pends on a trusted server lor key agreement between nodes e: Kerberos [4] This type of scheme is not suitable for sensor networks because there is usually no trusted infrastruc- ture in sensor networks The self-enforcing scheme depends on  asymmetric cryptography such as key agreement using  public^ key certificates However limited computation and energy resources of sensor nodes often make it undesirable to use public key algorithms such as D agreement [ 5 ]  or RSA [6] as pointed out in [71 The third type of key agreement scheme is key pre-ilisfi-ibrition where key informatiori is distributed among all sensor nodes prior to deployment If  we know which nodes are more likely to stay in the same neighborhood before deployment keys can he decided a priori However because of the randomness of the deployment knowing the set of neighbors deterministically might not be feasible There exist a number of key pre-distribution schemes A naive solution is to let all the nodes carry a iiioster secret key Any pair of nodes can use this global master secret key to achieve key agreement and obtain a new painvise key This scheme does not exhibit desirable network resilience: if  one node is compromised the security of the entire sensor network will be compromised Some existing studies suggest storing the master key in tamper-resistant hardware to reduce 'In this paper w use the t e r m  SSISUTS sensor n d i s   and nodes inter- chaageshly 07803-8355-9/04/S2000 Q2004 BEE 586 the risk but this increases the cost and energy consumption of each sensor Furthermore tamper-resistant hardware might not always he safe [8] Another key pre-distribution scheme is to let each sensor carry N - 1 secret pairwise keys each of which is known only to this sensnr and one of the other N-l  sensors (assuming N is the total number of sensors) The resilience of this scheme is perfect because compromising one node does not affect the security of communications among other nodes: however this scheme is impractical for sensors with an extremely limited amount of memory because N could be large Moreover adding new nodes to a pre-existing sensor network is difficult because the existing nodes do not have the new nodes' keys Eschenauer and Gligor recently proposed a random key preilistribution scheme: before deployment each sensor node receives a random subset of keys from a large key pool To agree on a key for communication two nodes find one common key within their subsets and use that key as their shared secret key [91 Our scheme is based on the Eschenauer- Gligor scheme and we refer to this scheme as the basic scheme throughout this paper An overview of it is given in Section 11 The Eschenauer-Gligor scheme is further improved by Chan Perrig and Song [lll] by Du Den& Han_ and Varshney [ I l l   and by Liu and Ning 1121 A Oarline of Oer Scheme Although the proposed schemes provided viable solutions to the key pre-distribution problem they have not exploited a piece of information that might significantly improve their performance 'This piece of information is node deployicnf knowledge which in practice can be derived from the way that nodes are deployed Let us look at a deployment method that uses an airplane to deploy sensor nodes The sensors are first pre-arranged in a sequence of smaller groups 'These groups are dropped out of the airplane sequentially as the plane flies forward This is analogous to parachuting troops or dropping cargo in a sequence The sensor groups that are dropped next to each other have a better chance to be close to each other on the ground This spatial relation between sensors derived prior to deployment can be useful for key preiiistribution The goal of this paper is to show that knowledge regarding the actual non-uniform sensor deployment can help us improve the performance of a key pre-distribution scheme Knowing which sensors are close to each other is important to key pre-distribution In sensor networks long distance peer-to-peer secure communication hetween sensor nodes is rare and unnecessary in many applications The primary goal of secure communication in wireless sensor networks is to provide such communications among neighboring nodes Iherefore the most important knowledge that can benefit a key-predistribution scheme is the knowledge about fhr notlej that are likelv Io br the neighbors ofrocli sensor node When we know deterministically the neighbors of each node in the network key pre-distribution becomes trivial: for each node 7 1 :  we just need to generate a pairwise key between 7) and each of its neiphhoring nodes and save these keys in 11's memory This guarantees that each node can establish a secure channel with each of its neighbors after deployment However because of the randomness of deployment- it is unrealistic to know the exact set of neighbors of each node but knowing the set of possible or likely neighhors for each node is much more realistic However the number of possible neighhors can he very large and it may not be feasible for a sensor to store the secret keys for each potential neighbor due to memory limitations This problem can be solved using the random key pre-distribution scheme 191 ie instead of guar- anteeing that any two neighboring nodes can find a common secret key with 100% certainty we only guarantee that any two neighboring nodes can find a common secret key with a certain probability p  In this paper we exploit deployment knowledge in the random key pre-distribution scheme [91 such that the probability p can be maximized while the other performance metrics (such as security and memory usage) are not degraded Deployment knowledge can be modeled using probability density functions (pdfs) When the pdf is uniform no infor- mation can be gained on where a node is more likely to reside All the existing key pre-distribution schemes assume such a uniform distribution In this paper we look at non-uniform pdf functions Since the distribution is different from uniform distribution i t  is equivalent to saying that we know that a sensor is more likely to be deployed in certain areas We will show how this knowledge can help improve the random key pre-distribution scheme proposed by Eschenauer and Gligor in [91 To demonstrate the effectiveness nf our method we studied a specific distribution the Normal (Gaussian) distribu- tion in great depth Our results show substantial improvement over existing schemes B Main Contribiirions of Oirr Sclreii~e following: The main contributions of this paper are summarized in the I )  We model node deployment knowledge in a wireless sensor network and develop a key pre-distribution scheme based on this model This is the first attempt at the use of deployment knowledge while developing a key pre-distribution scheme 2) We show that key pre-distribution with deployment knowledge can substantially improve a network's con- nectivity ( in  terms of secure links) and resilience against node capture and reduce the amount of memory re- quired C Rrlared Work The Eschenauer-Gligor scheme [9] have been described earlier in this section We will give a more detailed description of this scheme in Section 11 Based on the Eschenauer-Gligor scheme_ Chan Perrig and Song proposed a y-composite ran- dom key pre-distribution scheme [IO]  The difference between this scheme and the Eschenauer-Gligor scheme is that y common keys If/ 2 1) instead ofjust a single one are needed to establish secwe communications between a pair ofnodes It is shnwn that hy increasing the value of q network resilience ayainst node capture is improved ie an attacker hiis to compromise many more nodes to achieve a high probability of compromised communication Du Deng Han and Varshney proposed a new key pre- distribution scheme [I 11 which substantially improves the resilience of the network compared to the existing schemes This scheme exhibits a nice threshold property: when the number of compromised nodes is less than the threshold the probability that any nodes other tlian these compromised nodes are affected is close to zero This desirable property lowers the initial payoff of smaller scale network breaches to an adversary and makes i t  necessary for the adversary to attack a significant proportion of the network A similar method is also developed by Liu and Ning [l?] The ideas described in this paper can be applied to all of the above pre-distrihution schemes tn further improve their performance Blundo et al proposed several schemes which allow any group of t parties to compute a common key while being secure against collusion between some of them r131 These schemes focus on saving communication costs while memory constraints are not placed on group members Perrig et al proposed SPINS a security architecture specifi- cally designed for sensor networks 171 In SPINS each sensor node shares a secret key with the base station Two sensor nodes cannot directly establish a secret key However they can use the base station as a trusted third party to set up the secret key Several other key distribution schemes have k e n  proposed for mobile computing although they are not specifically targeted at sensor networks Tatebayashi Matsuzaki and New- man consider key distribution fix resource-starved dcviccs in a mobile environment [14] This work is further improved by Park et al [151 Other key agreement and authentication protocols include the one by Beller and Yacobi [16] A survey on key distribution and authentication for resource-starved devices in mobile environments is given in L171 The ma-iority of these approaches rely on asymmetric cryptography which is not a hasible solution for sensor networks [7] Several other methods based on asymmetric cryptography are also proposed: 7hou and Hass propose a secure ad hoc network using secret sharing and threshold cryptography [IS] Koug et al also propose localized public-key infrastructure mechanisms based on secret sharing schemes [l‘] Stajanor and Anderson studied the issues of bootstrapping security devices and they proposed a solution that requires physical contact of the new device wilh a master device to imprint the uusted and secret information [?O] Key pre- distribution is similar to the “imprinting” process but their focuses are different 11 THE ESCHEKALIEK-GLIGOR RANDOM KEY PRE-DISTRIBUTION SCHEME The Oasic schofie proposed in [91 consists of three phases: key pre-distribution shared-key discovery and path-key estab- lishment In the kr\ pr~- i l i ~ t i - i~r f t ; i~n  phase each sensor node ran- domly selects i i i  distinct cryptographic keys from a key pool S and stores them in its memory This set o i  m keys is called the node’s k e \  ring The number of keys in the key pool ISI is chosen such that two random subsets of size n i  in S share at least one key with some probability p   After the nodes are deployed a ke\-ser!ip phose is per- formed During this phase each pair of neighboring nodes attempt to find a common key that they share If such a key exists the key is used to secure the communication link between these two nodes After key-setup is complete a connected graph of secure links is formed Nodes can then set up path ke\s with their neighbors with whom they do not share keys If the graph is connected a path can always be found from a source node to any of its neighbors The source node can then generate a path key and send it securely via the path to the target node The size ofthe key pool S is critical to both the connectivity and the resilience of the scheme ConnectiviF is defined as the probability that any two neighboring nodes share one key Resilience is defined as the fraction of the secure links that are compromised after a certain number of nodes are captured by the adversaries At one extreme if the size of S is one ie IS1 = 1 the scheme is actually reduced to the naive master-key scheme This scheme yields a high connectivity but it is not resilient against node capture because the capture of one node can compromise the whole network At the other extreme if the key pool is very large eg IS1 = 100: 000_ resilience becomes much better but connectivity of the sensor network becomes low For example as indicated in [9] in this case even when each scnsor selects n? = ‘100 kcys from this large key pool S the probability that any two neighboring nodes share at least one key is only 033 How can we pick a large key pool while still maintaining high connectivity’? In this paper we use deployment h o w l -  edge to solve this problem 111 MODELIXG OF TfIB DEPLOYMENT KNOWLEDGE We assume that sensor nodes are static once they are deployed We define drplaynmr point as the point location where a sensor is to be deployed This is not the location where this sensor tinally resides The sensor node can reside at points around this point according tn a certain pdf and this point is the mean of the pdf As an example let us consider the case where sensors are deployed by dropping them from a helicopter The deployment point is the location of the helicopter We also define r-esident poinr as the point location where a sensor finally resides A A General I~eplowient Moilel Assume that the target deployment area is a two- dimensional rectangular region with size A‘ x Y and the origin point is the upper left corner The pdf for the location of node i for i = 1:   ~ N   over the two-dimensional region 0-7803-8355-9/04/$2000 02004 BEE 588 is given by f;(:i:g) where :c t [ O  S ]  and $1 E [O:Y] With this gcncral model the existing key pre-distribution schemes for sensor networks are special cases: they all assume that fi(z:y) = & for z t [ O : S ]   y E [O:Y] and 1 5 i 5 N   ie all sensor nodes are uniformly distributed over the whole deployment region B Group-based Drpluyienr Model The above prohlem defines a general deployment model in which nodes are deployed individually thus they may have different pdfs In practice i t  is quite common that nodes are deployed in groups ie a group of sensnrs are deployed at a single deployment point and the pdfs of the final resident points of all the sensors in each batch (or group) are the same In this work we assume such a group-based deployment and we model the deployment knowledge in the following (we call this model the groupbased depIo\~?neril rnodrl): 1) N sensor nodes to he deployed are divided into t x ‘11 equal size groups so that each group Gij for i = 1:   > t  and j = l ?      i i   is deployed from the deploy- ment point with index ( i > j )   Let ( : c i  y 2 )  represent the deployment point for group Gj 2 )  The deployment points are arranged in a grid Note that the scheme we developed for grid-based deployment can be easily extended to different deployment strategies We choose this specific strategy because i t  is quite common in realistic scenarios 3) During deployment the resident points of the node k: in group Gij follow the pdf f?(:q glk E GeJ) = f(:c - - y j )   An example of the pdf f(:cg) is a two- When f(z y )  is a uniform distribution over the deployment region we do not know which nodes are innre likely to be close to each other a pi-tori because the resident point of a node can be anywhere within the region with the same probability However when f( ) is a non-uniform distribution we can determine which nodes are more likely to he close to each other For example with Gaussian distribution we know that the distance between a resident point and the deployment point is less than 30 with probability f N 9 8 i  (where a is the standard deviation of the Gaussian distribution) If the deployment points of two groups are 60 away then the probability for two nodes from these two different groups to he located near each other is very low Therefore the probability that two nodes from two different groups become neighbors decreases with an increase of the distance between rhe two deployment points Recall that in the hasic random key pre-distribution scheme [91 when the size of the key pool 5’ becomes smaller connectivity increases Since the basic scheme assumes no deployment knowledge (ie the distribution f (2;: y)  is uni- form) every node should choose from the same key pool because they are equally likely to he neighbors However as we have discussed when the function f (3:: y) is non-uniform we know that nodes from a specific group are more likely to be neighbors of nodes from the same group and those from ensional Gaussian distribution nearby groups Therefore when two groups are Par away from each other their key pools could be different rather than the same global key pool S We use Sij to represent the key pool used by group G j  j ;  the union of 5jj (for i = 1:    I  and j = 1:    I ] )  equals S  We use iScl to represent the sire nf Sij (we select all & j ’ s  with the same sire in this paper) Based on a specific deployment distribution we can develop a scheme such that when the deployment points of two groups Gob and G c  d  are farther away from each other the amount of overlap between S a ; b  and Sc>([ becomes smaller or zero C Deployiienl Dirrriberion There are many different ways to deploy sensor networks for example sensors could be deployed using an airborne vehicle The actual model for deployment distribution depends on the deployment method In this paper we model the sensor deployment distribution as a Gaussian distribution (also called Normal distribution) Gaussian distribution is widely studied and used in practice Although we only employ the Gaussian distribution in this paper our methodology can also be applied to other distrihu- tions We assume that the deployment distribution for any node L in group G‘ij follows a two-dimensional Gaussian distribution When the deployment point of group Gj is at ( : c e > y j )   we have / I   = (zeyj) and the pdf for node k in group Gij is the following [?I]: = f( - :c;> $/ - ?Ij)> where f ( : ~  y) = & e - ( ~ z z + ~ 2 ) / 2 u 2   Lxn2 Without loss of general- ity we assume that the pdf for each group is identical so we use fh(z: 1~lL E Cjj) instead 01- f;’(:c g l k  E G; j )  throughout this paper Although the distribution iunction for each single group is not uniform we still want the sensor nodes to be evenly deployed throughout the entire region By choosing a proper distance between the neighboring deployment points with respect to the value of 0 in the pdf of each deployment group the probability of linding a node in cach small region can be made approximately equal Assuming that a sensor node is selected to be in a given group with an equal prohability A the average deployment distribution (pdf) of any sensor node over the entire region is: To see the overall distribution of sensor nodes over the entire deployment region we have plotted fooeTi[~ o Eq ( I )  for 6 x 6 = 36: groups over a 6OOni x f iOOm square region with the deployment points 2 0  = 100m apart (assuming a = 50) Fig ](a) shows all the deployment points and Fig lib) shows the overall pdf From Fig l(b) we can see that the pdf is 0-7803-8355-9/@42000 82004 BEE 589 almost Aat (ie nodes are fairly evenly disuibuted) in the whole region except near the boundaries IV KEY PRE-DISTRIBUTION LISING DEPLOYMENT KNOWLEDGE Based on the deployment model described in the previ- ous section we propose a new random key pre-distribution scheme which takes advantage of deployment knowledge We assume that the sensor nodes are evenly divided into t x II groups Gii inr i = 1:    : t _  and j = 1:   ~ 1 7    Assume that the global key pool is S with size /SI and also assume that the deployment points are arranged in a grid depicted in Fig l(a) Each node carries 111 keys A K n  Pre-distrihirtion Schenre The goal of this scheme is to allow sensor nodes to find a common secret key with each of their neighbors after deployment Our scheme consists of three phases: key pre- distribution shared-key discovery and path-key establishment The l a t  two phases are exactly the same as die basic scheme [91 but because of deployment knowledge the first phase is considerably different from the basic scheme Siep 1: K q  Pre-ilistribriiion phase This phase is conducted offline and before the sensors are deployed First we need to divide the key pool S into t x 11 key pools and j = 1    : 1 7 )   with Si;j  corresponding to thc deployment proup Gi We say that two key pools are neighbors (or near each other) if their corresponding deployment grnups are deployed in neighboring (or nearby) locations The goal of setting up the key pools Si3 is to allow the nearby key pools to share more keys while pools far away from each other share fewer keys or no keys at all The key-pool setup step will be discussed in detail later After the key pools are set up for each sensor node in the deployment group Gii we raiidomly select 111 keys from (ior i = 1 (13) Lkploymcnl distributioii on 1hc entire region using the dc- ploymm1 slralqy modelad by CA) Fis I Node Deployment 07803-8355-9/04/$2000 02004 EEE 590 its corresponding key pool 5’s3 and load those keys into the memory of the node Step 2: Slrarerl-kq discoiai? phase After deployment each node needs to discover whether i t  shares any keys with its neighbors To do this each node broadcasts a message containing the indices of the keys it carries Each neighboring node can use these broadcast messages to find out if there exists a common key it shares with the broadcasting node If such a key exists the neighboring node uses this key to secure its communication channel with the broadcasting node If we are concerned about disclnsing the indices of the keys each node carries we can use the challenge-response technique to avoid sending the indices [‘I namely for every key K i  on a key ring each node could broadcast a list (Y_ EK((Y) i = 1:   k where (Y is a challenge The decryption of E K < ( ~ )  with the proper key by a recipient would reveal the challenge (Y and establish a shared key with the broadcasting node After the above step the entire sensor network forms a Kq-  Sl7aring gruph G which i s  defined in the following: Definition I :  (Key-Sharing Graph) Let 1’ represent all the nodes in the sensor network A Key-Sharing rraph G(V! E )  is constructed in the following man- ner: For any two nodes i and j in V   there exists an edge between them if  and only if  ( I )  nodes i and j have at least one common key and ( 2 )  nodes i and j can reach each other within the wireless transmission range ie in a single hop Step 2: Putli-kq establisliriimt phase It is possible that two neighboring nodes cannot find any common keys between them In this case they need to tind a secure way to agree upon a common key We now show how two neighboring nodes i and j _  who do not share a common key could still come up with a secret key hetween them The idea is to use the secure l A I R I C l  channels that have already been estahlished in the key-sharing graph G: as long as the graph is connected two neighboring nodes i and j can always find a path in  G from i to j   Assume that the path is i ill>    U    j   To lind a common secret key between i and j   i first generates a random key K- Then i sends the key to u1 using the secure link bctween i and iq; u1 forwards the key to 02 using the secure link between oi and 112 and so on until j receives the key from U Nodes j and j use this secret key I< as their pairwise key Because the key is always forwarded over a secure l ink no  nodes beyond this path can find out the key To find such a secure path for nodes i and j   the easiest way is to use Hooding [221 a common technique used in multihop wireless networks As we will show later in our analysis in practice the probability that the secure path between i and j is within thrcc hops is very high (close tn one) l'herefore we can always limit the lifetime of the Hooding message to three hops to reduce flooding overhead B Serring Up K q  Pools Next we show how to assign keys to each key pool Sij for i = l ?     : I   and j = 1:   ~ 71 such that key pools corresponding to nearby deployment points have o certain numher of common keys In our scheme we have: I )  Two horizontally or vertically neighboring key pools share exactly alScl keys'? where 0 5 o 5 0?5 2) Two diagonally neighboring key pools share exactly blSl keys where 0 5 b 5 025 and 4rr + 46 = 1 3 )  Two non-neighboring key pools share no keys We call U and b the overlapping factors To achieve the above properties we divide the keys i n  each key pool into eight partitions (see Fig 2) Keys in e3ch partition are those keys that are shared between the corresponding neighboring key pools For example in Fig 2_ the partition in the upper left corner of E consists of b -  lScl keys shared between A and E; the partition in the left part of E consists of ( I    ISI keys shared between U and E  Given the global key pool S and the overlapping factor n and b we now describe how we can select keys for each key pool 8 for i = 1 t and j = 1 ~   : 1 1   The procedure 'If al%/ is nul an inleper LalScIJ should Lx used instead is also depicted in Fig 3 for a 4 x 4 case First keys for the first group SI are selected from S: then keys for the groups in the first row are selected from S and their left neighbors Then keys for the groups in the second row to the last row are selected from S and their left upper-left upper and upper- right neighbors For each row we conduct the process from left to right The following procedure describes how we choose keys for each key pool: 1) For group S11 select IS/ keys from the global key pool S: then reinove these ISl keys from S 2)  For group Slj for j = 2  n_ select aIScl keys from key pool S1~j-1: then select iu = (1 -0) IS[ keys from the global key pool S and remove the selected I U  keys from S 3 )  For group St? for i = 2>    ~I and j = 1    ~ I ?   select ( I    ISc/ keys from each of the key pools Si-lj and S_ i f  they exist; select 6   /Scl keys from each of the key pools S<+I~-I and S-l+l if they exist; then select tu (defined below) keys from the global key pool S and remove these iu keys from S It is easy to see from the selection procedure that keys selected from the other groups are all distinct ( 1  - ( a + b ) )   lScl (1 - ?(a + b ) )   lScl for j = 1 for 2 5 j 5 I!- 1 { ( l - ( 2 a  + b ) ) + ' c ~   f o r j = n  Note that after group GI selects s keys (s = a    ISI or s = b-IS/) from its neighbor Gz no other neighboring groups of G I  or G1 can select any one of these B keys ie these s keys are only shared by GI and G2 and no key is shared by more than two neighboring goups  in our scheme C Derrrrnining IS\ We calculate the size of the key pool ISJ for each group given the size of the global key pool /SI According to our key pool setup procedure each g o u p  first selects or blSl keys from each of its left upper upper- l e k  and uppwright neighboring groups (if they exist) then selects the rest of the keys from the global key pool S Fig 3 depicts the number of keys each group selects from S (each number in the figure should he multiplied by ISc/) Since keys selected from the other groups are all distinct the sum o f  all the numhers in the figure should he equal to /SI; therefore we have the following equation: 7 u  = IS1 1s I -  ~  ~   ~   ~  ~~~~~~~~ t r l  - (?t!i - t - n)cr - 2 ( t n  - f - '71 + I ) b  c -  For instance when IS/ = 100:OOO I = 17 = 10 D = O  l f i i   and b = 0083 we have I &  = 1770 Therefore the size of the key pool for each group is just 1770 D Urremiining rlie overlapping factors The values of the overlapping factors are important to the performance of our scheme Because we have not introduced the performance meuics yet we will leave the detailed dis- cussion of the overlapping factors to the next section 0-7803-8355-9/04/52000 82004 IEEE 591 "=-I I I I I Fie 3 K q  assignment lor all the key pols V PERFORMANCE EVALUATION An important goal of this study is to analyze the perfor- mance of our proposed scheme We present both our analytical and simulation results in this section - A Evalrrarion Metrics We present several criteria that represent desirable charac- Connecrivih We use global connrctivily to refer to the ratio of the number of nodes in the largest isolated component in the final key-sharing graph to the size of the whole network If the ratio equals 99% it means that 99% of the sensor nodes are connected and the rest 1% are unreachable from the largest isolated component So the global connectivity metric indicates the percentage I)f nodes that are wasted because of their unreachability We use local connecrisity to refer to the probability of any two neighboring nodes sharing at least one key We use procol  and p interchangeably to refer to the local connec- tivity Both global connectivity and local connectivity are affected by the key pre-distribution scheme  Cotnrnrmicci~fion orerliead Since the probability that two neighboring nodes share a key is less than one when the two neighboring nodes are not connected directly they need to find a route in the key-sharing graph to connect to each other We need to determine the number of hops required on this route Obviously when the two neighbors are connected directly the number of hops needed is 1 When more hops are needed to connecttwo neighboring nodes the communication overhead of setting up the security association between them is higher We use ph(C)  to denote the probability that the smallest number of hops needed to connect two neighboring nodes is C Obviously p h (  1) equals the local connectivity p ~ ~ ~ ~ i    Resilience againsl node cnyrirre We assume that an adversary can mount a physical attack on a sensor node after i t  is deployed and read secret information from its memory We need to find how a successful attack on :I: sensor nodes by an adversary affects the rest of the network In particular we want to find the fraction of additional communication (ie; communications among uncaptured nodes) that an adversary can compromise teristics in a key-setup scheme for sensor networks based on the inforination retrieved from the :I: captured nodes B Systrtii Conjigitration In our analysis and simulations we use the following setup: The size of the key pool IS/ = 100: 000 The number nf sensor nodes io the sensor network is The deployment area is 100Ont x 1000ni The area is divided into a grid of size 100 = t x I I  = I0  x 10 with each grid cell of size 100m x 100m The center of each grid cell is the deployment point (see Fig I(a)) The wireless communication range for each node is R = 40m 10: onn C Lucal Connrcrivip We calculate the local connectivity pi<>cal the probability of two neighboring nodes being able to find a common key Let R(ni: n 3 )  be the event that node ni and node t l j  share at least one common key and z4(7fi: i t j )  be the event that node I?;  and node nj are neighbors Hence f>locol = Pl'(B(l7i: t /  j ) I A ( l l i 1 7 f j ) )   Note that since plocai is the same for any pair of nodes i i i  and nj we ignore the node indices i i i  and nj  in p ~ ~ ~ ~ i   Let X be the ratio nf the shared key pool hetween two nodes to lScl For example X = (I for groups B and E shown in Fig I(a) When the size of the key pool is ISc/ the number of keys shared between two key pools is XjSl' where the possible values of X are I n b and 0 To calculate Pr(two nodes do not share any key) we use the following strategy: the first node selects I keys from the XISc/ shared keys it then selects the remaining nt - i keys from the non-shared keys To avoid sharing any key with the first node the second node cannot select any of the i keys from those XlSl shared keys that are already selected by the tirst node so it has to select r n  keys from h e  remaining (ISI - i )  keys from its key pool Therefore /(A) the prohahility that two nodes share at least one key when their key pools have XIScl keys in common can be calculated in the following:' i'(\) = 1 - Pr(two nodes do not share any key) We define I as the set of all deployment groups in our scheme We now consider an infinitesimal rectangular area jFor he sake of simplicity we assume that XISJ is an istcgcr: otherwise 'When X = 1 p(X)  can k simplified to L - &: when X = 0 we could us6 LXlSJJ lSc1--m I m )  )'(A) = 0  0-7803-8355-9/04/$2000 02004 LEEE 592 0 0 0 t 0 Fig 1 Probability of n d c s  residing within I circlz (z > R) dz dg around position Z = (z 11)   as shown in Fig 4 Rased on the two-dimensional Gaussian distribution the probability that a node i i j  from group j E q with deployment point (zi: yj) resides within this small rectangle area is where djz  is the distance between Z and the deployment point of group j   and f R ( d j Z 1 I l j  E group j )  is defined as When a sensor node ni resides at position Z = ( : E   y)  as shown in Fig 4; the probability that the sensor node n1 from group i resides within the circle centered at location Z with radius R is defined as y(r1iif t group i )   where z = diZ f ix  i E q is the distance between Z and the deployment point of group i   An example is shown in Fig 4 When z > R as shown in Fig 4 q(zlnf t group i )  where we have calculated the length of the arc of the ring centered at i and have iutegrated over all possible values of C When z i K as shown in Fig 5   g ( z / 7 l L  E group i )  C  O T f R ( C )  I C  Thus y(+" t group 1 )  where 1{-} is the set indicator function' and fR(tI7?<  E group i )  is given by Eq (2) Assume ni is a node from group i and 7 z 3  is a n d e  from group j _  the probability that nj resides within the rectangle area dzdy around point Z and ni is a neighbor of n j  is the following: f R ( d j Z / n j  E group j )   g ( d c z l n i  E group i)  d z   11y Since the event that node i i i  and node n j  share at least one common key is independent of the event that node and node n j  are neighbors we can calculate the probability that i i j  resides within the rectangle area dxrlq around point 2 and 11; is a neighbor of i i j   and 7 i i  and nj  share at least one common key as: Y ( x ( i  j ) )  ' f R ( d ~ Z l l ? j  E group j )   y ( d i z l ~ i i  E group i )   (In:  dy? ( 3 )  where A(&;) is the ratio of keys shared by the key pool of group i and the key pool of group j :  1> when i = j :  a: 11: when i and j are horizontal or vertical neighhors;  when i and j are diagonal neighbors; 1 0 otherwise A ( i > j )  = The local connectivity piocai is the average of the value in Eq ( 3 )  throughout the entire deployment region from (0: 0) to (S Y) and for all the combinations of i and j :  5Thc value of I(} is 1 when the evaluated condition IS true 0 otherwise 07803-8355-9/04/S2000 O22004 IEEE 593 - f n ( d j z l r t j  E group j)g(diz1ni E group i )d: i :&/  Since we assume that a sensor node is selected to he in each given group with an equal probability we have where and Fig 6 depicts the local connectivity versus the number of keys (memory usage r n )  each node carries We plot both the simulation results and the analytical results calculated from Eq (5) They match each other very well We also compare our results with the basic scheme [91 The figure indicates that our scheme substantially improves local connectivity For example with the same setup when each sensor can cany 100 keys the local connectivity of the basic scheme is only 0095: it is improved to 0687 with deployment knowledge D GloDa/ Conriectivip It is possible that the key-sharing graph G in our scheme has a high local connectivity hut G can still have isolated components Since those components are disconnected no secure links can be established among them Therefore it is important to understand whether G will have too many isolated components To this end we measure the global connectivity of the graph G namely we measure the ratio of the size of the largest isolatcd component in G and the size of the whole network We consider that all the nodes that are not connected to the largest isolated component are useless nodes hecause they are "unreachable" via secure links! 6somi of thz "unreachable" ncoht be rsachablc physically because they are within the communication range but they canti01 find a conmm key with any of the " d e s  in rhz largest isolalsd component Fig 6 two nzivhhoring nodss Local Connectivity: Probahility of sharins at least onz key hctwecii TABLE I LOCAL CONNECTIVITY VS GLOBAL CONNECTIVITY When node distribution and key sharing are uniform global connectivity can be estimated using the local connectivity and other network parameters using ErdGs random graph theo- rem 1231 just like what has been done in [9] [IO] However since neither our distribution nor our key sharing is unil'orm Frd6s random graph theorem will not he a good estimation method Recently Shakkottai and et al have determined the connectivity of a wireless sensor grid network with unreliable nodes [24] In the future work we will estimate the global connectivity by usins the results given in [241 In this work we only use simulation to estimate global connectivity We use the configuration described in Section V-B to conduct the simulation The relationships between the memory usage nr the local connectivity and the global connectivity are shown in Table I Note that ni  indicates how many keys each sensor node can store in its memory The simulation results indicate that when I I I  = 100 only 012% of the sensor nodes will be wasted due 10 the lack of secure links: when I I I  = 200 no nodes are wasted These results have excluded those nodes that are not within Ihe communication ranges of the largest isolated components because they are caused by the deployment not by our key pre-distribution scheme E Ejfecrs oJ the Oiwlapping Facrors The values of the overlapping factors itre important to the performance of our scheme For example when 11 = 025 &7803-83SS-9/04/SZOKI 02004 IEEE 594 200 and b = 0 each group shares keys with its horizontal/venical neighbors only; when n = 0 and b = 025 each group shares keys with its diagonal neighbors only The local connectivities f i x  the above two cases are different: when 111 = 100_ the local connectivity for the first case is 068 whereas for the second case it is 048 Therefore choosing the appropriate combination of a and b is imponant We define the best overlapping fuctors as the combination of 11 and b that maximizes the local connectivity They depend on the proportions of different types of neighbors as well as on the number of keys each sensor node can carry Fig 7 depicts the relationship of the local connectivity with the overlapping factors when in : 100 and n? = 150 Using Q (5) we found the best overlapping factors for different values of 1 1 1   The results are shown in Table 11 E Conmtnication Overhead in this subsection we study the communication overhead of our key pre-distribution scheme when two neighboring nodes cannot find a common key As we have discussed before when this situation occurs these two nodes have to find a path hetwcen them in the key-sharing graph G The shorter the length of the path the better We use ph(C)  to denote the probability that the smallest number of hops needed to connect two neighboring nodes is t (note ph(  1)  = ptoco) We use simulations to estimate how many of the  key setups have to go through C hops for E = 1: 2: _ An analytical approach for estimation similar to that proposed in [I 1) will he included in our future work Our results are depicted in Fig 8 As we cm observe from the figure when each node RI 8 Communicauon Overhead carries more than XI keys (ie in > 50) the sum of p h (  l) p / 1 ( 2 ) ~  and p h ( 3 )  is almost 1 which means that most of the key setups can be conducted within 3 hops G Resilience Against Node Capriire To evaluate the resilience of our scheme against node capture we need to find the fraction of additional communica- tions (ie communications among uncaptured nodes) that an adversary can compromise based on the information retrieved from the z captured nodes Because keys are not uniformly distributed among sensor nodes throughout the entire area the locations of these :U compromised nodes affect the results of our analysis In this paper we assume that these :L' nodes are randomly distributed within the deployment region We also realize that in reality these :I: nodes might not he randomly distributed in the entire region: instead they may have a concentration in a local area because adversaries have a higher probability of compromising nodes around their lnca1ions In that case the resilience of the network in that local area is lower than that of the entire network Due to page limits we leave the local resilience analysis to the extended version of this paper Let K be the communication kcy used for the link between two nodes that are not compromised When any node other than these two nodes is compromised the probability that I< will not be cornpromised (ie li- is not among those keys carried by this compromised node) is 1 - % where ni is the number of keys carried by each sensor node When 2 nodes are compromised the probability that I< will not be compromised is (1 - g)" Therefore the expected fraction of total keys being compromised can he estimated as: 117 1 - (1 - -)" I SI The results and comparison with existing key pre- distribution schemes are depicted in Fig 9 ("Basic" refers to the basic Eschenauer-Glipor scheme; "q = 1: 2: 3'' refers to the Chan-Perrip-Song scheme) l h e  figures show that our scheme substantially lowers the fraction of  compromised @7803-8355-9~620CUlQ2004 EEE 595 Rg 9 Nztwork Resilience: Conlparisons with cnistinp schemes communication after :E nodes are compromised The most important reason for such an improvement is that to achieve the same local connectivity while using the same key pool size /SI_ our scheme requires a much smaller P I   For example when IS1 = 100: 000 to achieve p = 033 the basic scheme needs ' I I ~  = 200 hut our scheme only needs ni = 46; to achieve p = 050 the basic scheme needs i n  = 263 but our scheme only needs 111 = 67 It is easy to see from Eq (6) the smaller the value of J I I  is the better the resilience Such an improvement is attributed tn the deployment knowledge which enables us to reduce the number of unnecessary keys carried by each sensor node VI CONCLUSIONS AND FUTURE W O R K  We have described a random key pre-distribution scheme that uses deployment knowledge With such knowledge each node only needs to carry a fraction of the keys required by the other key pre-disuibution schemes [91 1101 while achieving the same level ofconnectivity The reduction in memory usage not only relieves the memory requirement on the memory- consuained sensor node but more importantly it substantially improves networks resilience against node capture We have shown these improvements using our analytical and simulation results Having demonslrated the dramatic improvement in the performance of the Eschenauer-Glignr scheme in our future work we will investigate how much the deployment h o w l -  ~ edge can improve the q-composite random key pre-distribution hy Chan Perrig and Song [lo] In addition wc will study Pmcerdings o j  Iha Sucomd Usmir Workshop ON Elrclrorric Cummenr xowmher 1996 pp 1 - 1 1  scheme and the pairwise key pre-distribution scheme Proposed the elobal connectivitv communication overhead and the 9 L Eschenvucr and v D (ilieor "A keg-rnanagemen[ for drstrilwturcd sensur naworks:' in P m c r r d i q s  ofrlw Yrh 4CM mnfkrence Sowmber 18-22 2002 pp 4 1 4 7   [IO] H Chan A Perrip and D Song "Random k q  prcdistrihution srhzmes for szmm networks" in IEEE Swnpsiirm on SmJrih mid P r i w q   Bcrkslcy California May 11-14 2003 pp 197-213 local resilience as we mentioned in the last section Other deployment stratezies and associated distributions will also be considered VII ACKNOWLEDGMENT The authors acknowledge supports from the United States National Science Foundation IIS-0219560 IIS-0312366 DUEE-0231122_ the SUPRIA program of the CASE Ceuter at Syracuse University and the National Science Council of Taiwan ROC under grants NSC 90-22 13-E-260-007 and NSC 91-2213-E1260-021 'The authors would also like to thank all the anonvmnus reviewers for their valuable comments REFERENCES [I] I M Khhn R H Katr and K S 1 Pistar "Nixt  cenlury challenges: Mohilc networkin fur smnn dual" in Pmcrrdinss qf Ibu i r h   i nmid  ACM/IEEE hmnnrion CmtJewzcc on Mobile Compi"ling md ~Verwork ins (MobiCom) 1999 pp 483492  [Z ]  Wimliss lntegriltad Ndtwork Sensors University of California Avail- ahls: http:l/wwwjanctucla2duiWINS 131 1 E Akyildiz W Su Y Sanbrrsubrarnaoiam and E Cuyirci "A survey OD SCOSUT network" IEEE Commmicariom Mngeirre vol 40 no 8 pp 102-114 Au$uI 2002 I41 B C Nlcumao and T Tso "Kcrkros: An vulhcnticatiun service for computer nctworks" IEEE Cmnrrrii~~rio!s vol 3 2   no 9 pp 33-38 Szptcmhsr 19Y4 151 W Diffii and M E Hellman "Nzw d i r d u n s  in cryptography" IEEE Trmsncriom on lnfofornmriort Th'huoc vol 22   pp 644454 Wowmlxr 1976 [ 6 ]  U L Umsl A Shamir and L M Adleman "A method for ohtainine digital sipalurer and public-kq cryptosystems:' Corlmlolicrri~ns o j  rhr ACM vol 21 no 2 pp 12&1?6 1978 171 A Perrig R Szzwczyk V Wen D Cullar and J D Tgar "Spins: Szcurity protocols for sensor networks" in Proceedings o j  llw 718  - Im~oI  -ICM/IEEE l?tlemarion CottJermci on Mobile Comprrring orid Ntnwrkirrg (MoDiCornJ Romc Italy July 2001 pp 189-199 181 U Andsrson and M Kuhn "Tamer rcristancs - a cautionarr note" in 07803-8355-9/04/$20M) 02004 BEE 596 Ill1 W Du J Den: Y S   Han and P K Varshnry "A pairwisc key pr2~ distribution srhenie for wireless s z n m  wtworks" i n  Pmcrrdinp  of Ii7r lolll -4CW Conference on Cornpuler nrld C~mmrtaicnli0zs Secit- nY CCCS) Wmhmylon DC USA Oaokr 27-31 2W3 pp 42-51 I121 D Liii m d  P Ninp "Establishing pairwise keys in dislributcd sensor networks" i n  Procrrdinys of rhe 10th AC!d Cmfermc ON Cornpurer m!d Conimarricnlions Srzsrifi (CCS) Washington E€ USA Oclohcr 27-31 2003 pp 52-61 I131 C Blundo A U Santis A Hcrzhcrg S   Kuttzn U Vuccaro m d  M Yuoy '"Perfectly-secure key distribution for dynamic conferences:' Lmli~m Nulrr 0 8  Comprrrer Scimcr vol 740 pp 471A86 1993 1141 M Talebayashi N Mulsuzuki and U B Newman "Kay distribution prolocol for diyi14 mobile communication sptcm:' 4dvancrs in C r p  Idogy - CRYPTO'XY pp 314-234 1989 INCS Volume 435 Sprinecr- \;dag I151 C Park K   Kurosawa 1 Okarnoto and S Tsujii "On key distribution and suthcnlicalion in mobile radio networks" Advancus ;n Cqxoloyy - EwoC~pI'Y3  pp 461465 1993 INCS Volume 765 Springer-ucrlag I161 :M Biller and Y Yacohi "Fully-Hcdgzd lwo-way public b y  authenti- calion and key agrccmznt for l o w - ~ a ~ t  t e ~ n a l s : '  Elrcrmnics Lellerers vol 29 nu I I   pp 999-1001 1993 I171 C Boyd and A Mathuria "Key cstahlishmcnt protocols for secure mobile runuiiuiucafioie: A dective survzy" Irclure NOM it! Contptmr Pirrrce vd  1438 pp 34-1-35 1998 1181 L Lhou and Z 1 Haas "Securing ad h w  nztworh" lEEE Nmvork vol 13 no 6 pp 2-1-30 1999 1191 1 Kong I? %dos H Luo S  Lu and L Zhanp "Providing robust and ubiquitous security support for mohile ad-hoc ne~works:' in Inrer- mlional Confermcr on Nrrwork Pmrocols (ICNPI 2001 pp 25 1-260 1201 E Stajano and R Anderson "The rzsurrectinp duckling: Security issues for ad-hoc wireless networks" in 711 Inlenznlimal Worbbop OII Srcrrrih Pmlods   vol 1796 1999 pp 171-194 INCS Volums 1796 Springer- [ I l l  A Leon-Garcia Pmbnbilio and Rmrdom Processsfor Eleclriml Enyi- neivinp 2nd cd Reading MA: Addison-Wesley Puhlishinp Company 1°C lW4 1221 C   E Perkins Ed Ad Hoc Nmuorkiug Addison-Wdey 2001 1231 &d& and Rtnyi "On random graphs I:' PsbI Math Debmrn vol 6 pp 29k297 1959 12-11 S Shakkutlai R Srikant and N Shroff "Llnrcliuhlc ssnsm gids:  coverape connectivity and diameter" in Proreedings of lire IEEE INFOCOM 2003 pp 1073-1083 W h p   07803-8355-9/04/s2000 07004 EEE 597 
Key-Distribution protocol-4 protocols-pdf,This content has been downloaded from IOPscience Please scroll down to see the full textDownload details:IP Address: 1287355This content was downloaded on 28/01/2014 at 16:01Please note that terms and conditions applyKey handling in wireless sensor networksView the table of contents for this issue or go to the journal homepage for more2007 J Phys: Conf Ser 76 012060(http://iopscienceioporg/1742-6596/76/1/012060)Home Search Collections Journals About Contact us My IOPscience       Key Handling in Wireless Sensor Networks Yue Li and Thomas Newe1 Optical Fibre Sensors Research Centre Department of Electronic and Computer Engineering University of Limerick Limerick Ireland Thomasnewe@ulie Abstract With the rapid growth of Wireless Sensor Networks (WSNs) many advanced application areas have received significant attention However security will be an important factor for their full adoption Wireless sensor nodes pose unique challenges and as such traditional security protocols used in traditional networks cannot be applied directly Some new protocols have been published recently with the goal of providing both privacy of data and authentication of sensor nodes for WSNs Such protocols can employ private-key and/or public key cryptographic algorithms Public key algorithms hold the promise of simplifying the network infrastructure required to provide security services such as: privacy authentication and non-repudiation while symmetric algorithms require less processing power on the lower power wireless node  In this paper a selection of key establishment/agreement protocols are reviewed and they are broadly divided into two categories: group key agreement protocols and pair-wise key establishment protocols A summary of the capabilities and security related services provided by each protocol is provided  1 Introduction  Wireless sensor networks are more vulnerable to security attacks than wired ones due to their broadcast resource limitations and uncontrolled environments where they are often left unattended In addition to the security requirements for fixed networks such as: identity authentication data confidentiality and non-repudiation WSNs have a number of additional requirements due to the constraints on sensor devices [1] which includes: Scalability: ability to support a larger network Key distribution protocol must support large networks and must be flexible against substantial increase in the size of the network even after deployment Efficiency: storage processing and communication limitations on sensor nodes must be considered Key connectivity: probability that two (or more) sensor nodes store the same key Enough key connectivity must be provided for a WSN to perform its intended functionality Resilience: resistance against node capture Usually higher resilience means lower number of compromised links                                                  1    To whom any correspondence should be addressed Sensors and their Applications XIV (SENSORS07) IOP PublishingJournal of Physics: Conference Series 76 (2007) 012060 doi:101088/1742-6596/76/1/012060c© 2007 IOP Publishing Ltd 1A generic set of eight security requirements for protocols in WSNs against which the protocols in this paper are evaluated are given:  1 Confidentiality   5 Contributory key agreement 2 Implicit key authentication  6 Mutual Authentication of user 3 Forward secrecy   7 Resilience 4 Assurance of key freshness  8 Scalability A selection of protocols for both key agreement and pair-wise key distribution are discussed in the following sections A summary of the capabilities and services provided by each protocol is then provided  2  Group Key Agreement Protocols  A group key agreement protocol relies on shared long-term keys between participants and servers in order to allow participants to construct a group key This means that once a shared group session key is established among the group symmetric encryption algorithms can be used to encrypt/decrypt the mission-critical messages and control information [11] Symmetric key algorithms are generally used due to the computational limitations of current sensor nodes Recently Bresson et al and Tseng proposed two authenticated key agreement protocols [2][3] for resource-limited wireless nodes Because both protocols employ an online/offline signature scheme [4] and shift much of the total amount of computation to the high-performance server the computational cost of each node is reduced to only one exponential one hash function and several multiplication operations which minimize the computation burden on mobile nodes  Let U = {U1 U2…  Un} be the initial set of low-power sensor nodes that want to generate a group key with powerful node S Each client as well as the base station holds a pair of secret/public keys at the initialization phase before running the protocol The following system parameters and notations are used to describe the security protocols in this section q: a large prime p: a large prime such that p=2q+1 Gq: a subgroup of quadratic residues in Z *p  that is Gq = {i2|i∈Z *p } g: a generator for the subgroup Gq SKi: a low-power node Ui’s secret key in Z *q  PKi: a low-power node Ui’s public key such that PKi = gSKi mod p SKS: the powerful node S’s secret key in Z *q  PKs: the powerful node S’s public key such that PKs = gSKs mod p H(): a one-way hash function H with arbitrary length input and a fixed length output[5] ie {01}*→{01}k where k is the length of output SigUi(m): the signing algorithm based on ElGamal [6] or DSA[7] schemes under Ui’s secret key SKi and the signed message m ||:  denotes the concatenation  21  Bresson et al’s key agreement protocol  Bresson et al [2] adopted the offline signature technique [4] to propose an authenticated group key agreement protocol suitable for asymmetric wireless networks involving low-power mobile nodes The offline signature technique reduces the computational burden placed on the low-power sensor nodes; however the computational requirements of the base station remain high The protocol was designed to provide security service such as implicit key authentication and forward secrecy This protocol is a two-round protocol and computationally asymmetric  Sensors and their Applications XIV (SENSORS07) IOP PublishingJournal of Physics: Conference Series 76 (2007) 012060 doi:101088/1742-6596/76/1/0120602 Figure 1 Bresson et al’s key agreement protocol  In [8] Nam et al presented a potential attack on the Bresson el al’s protocol This attack made some strong assumptions but it indicated a flaw in the protocol design which left the protocol susceptible to an impersonating attack This indicates that the protocol does not satisfy some of the security services assessed here such as implicit key authentication and forward secrecy   22  Tseng’s protocol In [3] Tseng proposes a protocol which suggests some improvements on Bresson et al see Figure 2  Figure 2 Tseng’s key agreement protocol  Initially each client Ui selects a random xi ∈  RZ *q  and computes αi = PKs xi mod p as well as yi=gxi mod p which is sent to server S together with a signature on yi On receipt of the messages from participant nodes the server S can check the signature using the public key of Ui if the verification is successful S proceeds to Step 2  In Step 2 S chooses a random x∈  RZ *q  computes X zi  αi’ and a checking value C and then S broadcasts the message containing C  αi’  and zi for i=1…n to all clients  Upon receiving the broadcast message from S each client Ui authenticates the message from Server S by checking αi= αi’ if the check holds the client computes X and then verifies that C is correct Finally client Ui computes the group session key K if the verification holds The design goal of Tseng’s protocol is to achieve perfect forward secrecy implicit key authentication and contributory key agreement However work undertaken by the author in the formal verification of this protocol revels that this is not the case and an active adversary can fool mobile clients into accepting a session key generated by the adversary itself This work is soon to be published   23  Summary  Bresson et al and Tseng proposed group key agreement protocols tried to achieve perfect key implicit key authentication and forward secrecy while minimizing the computational burden on clients Due to the significant reduction of computational cost on clients those protocols are applicable to modern 1 yi SigUi {yi} x∈  RZ *q  X=gx mod p zi = yix mod p αi’ = yi SKs mod p C=H(X⊕ z1…⊕ zn)   K=X pz jnj mod1=∏   2 C(ai’ zi) Mobile Uixi ∈  RZ *q and x1-1; yi = gxi mod p; αi = PKs xi mod p;   pzX ixi mod1−=  K=X pz jnj mod1=∏  Server S 1 yi SigUi {yi}  αi = yi SKs X=H(C||α1||α2||||αn) Ki= X⊕H(C|| αi)    K= H(X||Ui||S)  2 C Ki Mobile Uixi ∈  RZ *q ; yi = gxi mod p; αi = PKs xi mod p;    X=Ki⊕H(C|| αi) K= H(X||Ui||S) Server S Sensors and their Applications XIV (SENSORS07) IOP PublishingJournal of Physics: Conference Series 76 (2007) 012060 doi:101088/1742-6596/76/1/0120603sensor nodes However both protocols fail to achieve their security goals as they are vulnerable to impersonation attacks Further improvement is required to modify the protocols to meet all their goals  3 Pair-wise key establishment protocols  A pair-wise key between two nodes can be established through a trusted server or utilizing key pre-distribution solutions where two nodes exchange their pre-distribution key chains and discover a shared key if it exists The SNEP [9] key agreement protocol (trusted server based) and a basic probabilistic key pre-distribution protocol are discussed in this section The following notations are used to describe the security protocols in this section: • KP: The Number of keys in the key pool  • NA NB: The nuances generated by node A and node B • KBA  KAB  :  Two encryption keys KBA and KBA between A and B • K’AB  K’BA :  The secret MAC keys shared between A and B  • {M} KAB : The encryption of message M with encryption key KAB • MAC (K’AB M): The computation of a MAC for a message using MAC key K’AB • M1 || M2: Denotes the concatenation of two messages M1 and M2  • α: challenge • {α}Ki i=1… n: a list of challenge encrypted with the keys in the node’s key ring • skAB: session key between node A and node B  31  SNEP key agreement protocol  To achieve two-party authentication and data integrity SNEP [9] uses a message authentication code (MAC) Another important security property of SNEP is semantic security This ensures that an eavesdropper has no information about the plaintext even if it sees multiple encryptions of the same plaintext SNEP achieve this security property by preceding each message with a counter value which increments after transmission SNEP proposes each node shares a master secret key χAS and a Pseudo Random Function (PRF) with the server where A and S represent node A and server S respectively  Node A and server S can then generate encryption keys KAS=PRF(χAS 1) and KSA=PRF( χAS 2) and MAC keys K’AS=PRF( χAS3) K’BS=PRF( χAS 4) SNEP uses a base station as a trusted agent for key setup Assume that node A wants to establish a shared secret session key skAB with node B Since A and B do not share any secrets they need to use a trusted third party which is the base station S in this case In the trust setup both A and B share a master secret key with the base station XAS and XBS respectively The protocol uses SNEP with NA and NB to ensure strong key freshness The key agreement protocol is specified in Figure 3 below  Figure 3: Node-to-node key agreements using SNEP  At the start of the protocol node A sends node B nonce NA together with the identity of node A As soon as node B receives this message node B generates nonce NB and creates MAC(k’BSNA|NB|A|B) this message is then forwarded to the trusted server S by B together with NA  A NB and B In Step 3 upon receipt of the message containing the MAC authentication from B S verifies the MAC using key Sensors and their Applications XIV (SENSORS07) IOP PublishingJournal of Physics: Conference Series 76 (2007) 012060 doi:101088/1742-6596/76/1/0120604k’BS If verification is successful S will generate a shared session key between A and B skAB S encrypts the session key with kSA and sends it to A together with the MAC(k’SANA|B|{skAB}kSA) The base station also sends the same session key skAB encrypted with kSB to B together with the authentication code MAC(k’SBNB|A|{skAB}kSB) Nodes A and B verify that the message is from the base station S using the MAC keys k’SA and k’SB respectively If the authentication is successful the session key is decrypted by node A and node B using kSA and kSB respectively Now node A and node B share a session key skAB In this memory-efficient protocol the nodes only needs to share a key with the base station and form keys with other nodes through the base station Those nodes closest to the base station must forward a high volume of traffic between the nodes and base station This reduces the lifetime of the network as these nodes expend greater energy resources Scalability is an issue with this protocol as all keys are formed through the base station It may be suitable for smaller sensor networks but its reduced scalability is unsuitable for large sensor networks  32  Basic Probabilistic Key Pre-distribution Protocol  Eschenauer and Gilgor [10] proposed a probabilistic Key Pre-Distribution (KPD) scheme for pair-wise key establishment The main idea was to let each sensor node randomly pick a set of keys from a key pool before deployment so any two sensor nodes have a high probability of sharing at least one common key  1 A→B: {α}Ki i=1… n 2 B→A: {α||B}skAB 3 A→B: {known messages}skAB Figure 4 Basic probabilistic key pre-distribution protocol  In key setup phase for each sensor n keys are randomly drawn from the key-pool without replacement These n keys and their identities form the key-chain for each sensor node To avoid exposing key ID and key sharing patterns to adversary private shared-key discovery as shown in Figure 4 is recommended in key discovery phase  In step 1 Node A broadcast a list of {α}Ki i=1… n where α is  a challenge encrypted by a list of keys in the key chain In step 2 after receiving the list of encrypted challenges node B tries to decrypt those messages using the keys from its key chain to solve the challenge If the challenge is solved node B sends A an encrypted message under shared key skAB which contain challenge α and ID of node B Upon receipt of the encrypted message from node B node A decrypts the message using skAB from its key chain Finally A sends B a pre-agreed set of messages encrypted under the session key skAB if the message is decrypted by B then skAB is confirmed to be a session key between node A and node B In [1] Comptepe et al state that scalability and resilience of the protocol are low and these properties can be improved by using a larger key pool but a larger key-pool means smaller probability of key share because key-chain size may not increase due to storage limitations Probability that a link is compromised when a sensor node is captured is k/KP which is very high for small key-pools and produces low resilience  4 Summary  In this paper an introduction to security issues in WSNs was given and both group key agreement protocols and pair-wise protocols were discussed Group key agreement protocols proposed by Bresson et al and Tseng utilize public algorithms for authentication of nodes but with less computational burden on the clients which are well suitable for modern sensor nodes But both protocols are vulnerable to impersonating attacks which result in failure in achieving initial goals of supplying implicit key authentication and forward secrecy  Sensors and their Applications XIV (SENSORS07) IOP PublishingJournal of Physics: Conference Series 76 (2007) 012060 doi:101088/1742-6596/76/1/0120605Two efficient pair-wise key establishment protocols: SNEP key agreement and basic probabilistic key pre-distribution are also discussed in this paper Both protocols have weakness on scalability which makes them not applicable to large wireless sensor networks   Requirement list Protocol 1 2 3 4 5 6 7 8 Bresson et al √ x *√ x *√ *√ Low Mod Tseng’s protocol √ x √ x √ *√ Low Mod SNEP √ √ √ *√ x √ Mod Low Basic probabilistic KPD √ √ x x x x Low Mod √ - Indicates that the protocol provides this service *√ - Indicates that the protocol can be modified to provide this service x - indicates that the protocol does not provide this service Table 1 Requirements achieved by key distribution protocols  Table 1 summarizes what security requirements are achieved by the aforementioned protocols The number in the table represents the security requirements referred to in section 1 Based on the study on these protocols further research must be carried out to design an efficient protocol for source constrained sensor nodes to supply the required security services listed    Acknowledgment The authors wish to thank the following for their financial support: • SFI Research Frontiers Programme grant number 05/RFP/CMS0071 • The Embark Initiative who fund this research through the Irish Research Council for Science Engineering and Technology (IRCSET) postgraduate Research Scholarship Scheme  Reference: [1] S A Camtepe and B Yener (2005) Key Distribution Mechanisms for Wireless Sensor Networks: a Survey Technical Report TR-05-07 March 23 2005 [2] Bresson E Chevassut O Essiari A and Pointcheval D (2004) Multual authentication and group key agreement for low-power mobile devices Comput Commun 27 1730–1737 [3] Y-M Tseng (2007) A secure authenticated group key agreement protocol for resource-limited mobile devices The Computer Journal vol 50 no 1 pp 41–52 [4] Shamir A and Tauman Y (2001) Improved on-line/off-line signature schemes In Proc Advances in Cryptology— Crypto’01 Santa Barbara CA August 19–23 LNCS 2139 pp 355–367 Springer-Verlag Berlin [5] NIST/NSA FIPS 180-2 (2005) Secure Hash Standard (SHS) NIST/NSA Gaithersburg MD USA [6] ELGamal T (1985) A public-key cryptosystem and a signature scheme based on discrete logarithms IEEE Trans Inform Theory 31 469–472  [7] NIST (1992) The Digital Signature Standard (DSA) Commun ACM 35 36–40 [8]Nam J Kim S and Won D(2005) A weakness in the Bresson-Chevassut-Essiari-Pointcheval’s group key agreement scheme for low-power mobile devices IEEE Communications Letter 9 429-431 [9] Perring A Szewczyk R Tygar JD and Culler D(2002) SPINS: Security Protocols for Sensor Networks Wireless Networks 8521-534 [10] Eschenauer L and Gligor V D (2002) A key-management scheme for distributed sensor networks In 9th ACM conference on Computer and Communications Security [11] Newe T Coffey T (2003) Security Protocols for 2G and 3G Wireless Communications ACM ISICT 03 Dublin Ireland September 24-26 2003 pp 348-353  Sensors and their Applications XIV (SENSORS07) IOP PublishingJournal of Physics: Conference Series 76 (2007) 012060 doi:101088/1742-6596/76/1/0120606
KeyManagement Issues WSN-pdf,IEEE Wireless Communications • October 200776 1536-1284/07/$2000 © 2007 IEEESE C U R I T Y I N WIRELESSMO B I L E AD HOC A N D SENSOR NETWORKSINTRODUCTIONA wireless sensor network (WSN) is a networkformed by a large number of sensor nodes eachequipped with sensor(s) to detect physical phe-nomena such as heat light motion or soundUsing different sensors WSNs can be imple-mented to support many applications includingsecurity entertainment automation industrialmonitoring public utilities and asset manage-ment However many WSN devices have severeresource constraints in terms of energy compu-tation and memory caused by a need to limitthe cost of the large number of devices requiredfor many applications and by deployment scenar-ios that prevent easy access to the devices Suchresource limitations lead to many open issues —including WSN security — which have beenstudied actively by researchers Many applica-tions require WSNs to exchange sensitive infor-mation or contain feedback processes that havehigh reliability requirements and they require ahigh level of security to succeed Yet strongsecurity is difficult to achieve with resource-lim-ited sensor nodes and many well-knownapproaches become infeasible In this article weexplore the security issues for key managementfor WSNs First we examine the needs andrequirements for key management Then weexplore several promising key management pro-tocols and conclude with a discussion of futuretrends that may affect their developmentKEY MANAGEMENTBefore a WSN can exchange data securelyencryption keys must be established among sen-sor nodes Key distribution refers to the distribu-tion of multiple keys among the sensor nodeswhich is typical in a non-trivial security schemeKey management is a broader term for key dis-tribution which also includes the processes ofkey setup the initial distribution of keys andkey revocation — the removal of a compromisedkeyJOHNSON C LEE AND VICTOR C M LEUNG UNIVERSITY OF BRITISH COLUMBIAKIRK H WONG JIANNONG CAO AND HENRY C B CHANHONG KONG POLYTECHNIC UNIVERSITYABSTRACTKey management has remained a challengingissue in wireless sensor networks (WSNs) due tothe constraints of sensor node resources Vari-ous key management schemes that trade offsecurity and operational requirements have beenproposed in recent years In this article we firstexamine the security and operational require-ments of WSNs and then review five key man-agement protocols: Eschenauer Du LEAPSHELL and Panja Eschenauer’s scheme is aclassical random key distribution scheme forWSNs Du’s scheme improves on Eschenauer’sscheme by using key matrices LEAP provides ahighly flexible key management scheme usingfour types of keys SHELL focuses on achievinghigh robustness and Panja is optimized for hier-archical WSNs LEAP SHELL and Panja sup-port cluster-based operations and are morealigned with current trends as shown by the newstandards IEEE 802154b and the ZigBee“enhanced” standard Future developments like-ly will incorporate the features of LEAP andadjustable robustness enhancements fromEschenauer or Du; extremely security-criticalapplications may benefit from restructuringSHELL to ease implementation and mainte-nance Developments for extremely large WSNsshould consider improving Panja’s scheme dueto its hierarchical scalability featureKEY MANAGEMENT ISSUES INWIRELESS SENSOR NETWORKS: CURRENT PROPOSALS AND FUTURE DEVELOPMENTSThis work was supported in part by the Canadian NaturalSciences and Engineering Research Council under grantSTPGP 322208-05 and by the Department of ComputingThe Hong Kong Polytechnic University under accountnumber Z09ZKey managementhas remained a challenging issue inwireless sensor networks due to theconstraints of sensornode resources Theyfirst examine thesecurity and operational requirements ofWSNs and thenreview five key management protocols:Eschenauer DuLEAP SHELL andPanjaLEE LAYOUT  10/3/07  2:32 PM  Page 76                                 IEEE Wireless Communications • October 2007 77THE NEED FOR KEY MANAGEMENTKey management like security is a cross-lay-ered issue The need for key management startsin the link layer An applicable link layer stan-dard in a WSN is IEEE 802154 Although thisstandard considers key usage for secure datatransmission it does not specify how toexchange keys securely This leaves open thekey management problem that is the focus ofmuch recent research Besides the link layerupper layers such as the network and applica-tion layers also must exchange keys securelyMany security-critical applications depend onkey management processes to operate but alsodemand a high level of fault tolerance when anode is compromised This is a challengingproblem because there are many stringentrequirements for key management and theresources available to implement such processesare highly constrainedSECURITY AND OPERATIONAL REQUIREMENTS FORKEY MANAGEMENTKey management requirements can be dividedinto security requirements that form a subset ofthe overall WSN security requirements andoperational requirements that act as constraintsin the design and realization of key manage-mentTable 1 [1] shows the comprehensive securityrequirements of a WSN For key managementthe most critical requirements are robustness andself-organization Although confidentiality andintegrity are important the ability to distributesecret shared keys satisfies both requirementsand all key management schemes are able toaccomplish this Likewise data freshness is typi-cally attained by including a nonce (a crypto-graphic time stamp) in each packet to verify thatthe data is new That approach hinges on theintegrity of each data packet to ensure the noncehas not been modified which easily can beaccomplished after a secret shared key is estab-lished On the other hand self-organization —the ability to independently self-organize andself-heal in the presence of dynamic changes in aWSN — is a requirement that is more difficultto satisfy Normally without the considerationsof security WSNs are designed to satisfy thisproperty such that nodes can freely form con-nections around a failed node or re-establish thenetwork automatically after it has been dis-turbed However when a key managementscheme distributes certain communication keysto a few nodes this requirement can be violatedas other nodes are unable to form connectionsdynamically with these specific nodes for lack ofproper keysWith robustness the problem lies with thecompromise of one or more nodes BecauseWSN nodes are frequently deployed in unsuper-vised and remote locations physical tampering isa real threat and the WSN must be able to with-stand the compromise of some nodes If the net-work uses only one key then the compromise ofone node compromises the entire network If thenetwork uses multiple keys it is interesting todetermine how many compromised nodes ittakes to compromise the security of the entirenetwork We look at the distribution schemesand discuss robustness in more detail laterOn the other hand several operationalrequirements exist for WSNs: accessibility flexi-bility and scalability These requirements act asconstraints for security design because one mustensure that they are not violated in the designand realization of a security scheme Accessibili-ty the need for data to be accessible by manynodes arises as WSNs must efficiently utilize thelimited energy computation and memoryn Table 1 Security requirements for wireless sensor networks [1]Requirement DescriptionConfidentiality Nodes should not reveal any data to unintended recipientsIntegrity Data should not be changed between transmissions due to the environment ormalicious activitiesData freshness Old data should not be used as new (ie prevent replay attacks)Authentication Data used in decision-making processes must originate from the correct sourceRobustnessWhen some nodes are compromised the entire network should not also becomecompromised The quantitative value with which this requirement should besatisfied depends on the applicationSelf-organization Nodes should be independent and flexible enough to be self-organizing(autonomous) and self-healing (failure tolerant)Availability The network should not fail frequentlyTime synchronization Collaborative node applications need time synchronization Time synchronizationprotocols should not be manipulated to produce inaccurate timeSecure localization Nodes should be able to accurately and securely acquire location informationThe need for keymanagement startsin the link layer Anapplicable link layerstandard in a WSN isIEEE 802154Although this standard considerskey usage for securedata transmission it does not specifyhow to exchangekeys securelyLEE LAYOUT  10/3/07  2:32 PM  Page 77                                                   IEEE Wireless Communications • October 200778resources A popular scheme to enhanceresource efficiency is data aggregation or datafusion which combines data from other nodeswith local data before routing the fused datatowards the sink node This process requires theintermediate nodes to interpret the data beingsent by the other nodes Likewise at event detec-tion points neighbor nodes must be able tooverhear transmissions from other nodes toensure that only one node reports the eventinstead of every possible node Later we discusshow different schemes impact accessibilityAnother crucial operational requirement is flexi-bility For example in a large WSN nodes canfrequently join or leave the network due to net-work expansion or battery depletion A key man-agement scheme must support this process witheasy addition or deletion of keys This is chal-lenging as the lack of a central key managemententity makes the addition and deletion of keys atedious inefficient and more importantly aninsecure task Lastly the scalability of the keymanagement scheme is an important perfor-mance factor IEEE 802154-compliant WSNscan theoretically support up to 65536 nodesTherefore a key management scheme must bescalable up to this maximum network sizeAlthough WSNs seldom exceed a few thousandnodes in practice even this number is very chal-lenging for some key management schemes thatare less scalable The previous discussion is sum-marized in Table 2KEY DISTRIBUTION SCHEMESThe three simplest keying models that are usedto compare the different relationships betweenthe WSN security and operational requirementsare network keying pairwise keying and groupkeying A detailed problem and benefit analysisis summarized in Table 3The network keying model has inherentadvantages over the other two schemes It issimple easy to manage and uses very littleresources It also allows easy collaboration ofnodes since neighboring nodes can read andinterpret each other’s data satisfying the self-organization and accessibility requirements verywell It is also excellent in terms of scalabilityand flexibility because there is only one key forthe entire network and it does not change withthe addition of nodes However an unaccept-able drawback in robustness exists Supposeone node is compromised and the network-wide key is exposed With this key an adversarycan eavesdrop on all messages in the networkand even inject forged messages into the net-work possibly disrupting the proper operationof the networkAt the other extreme the pairwise keyingmodel employs N – 1 keys in each node whereN is the size of the network Although thismodel provides the ultimate in robustnessagainst node capture because the compromiseof one node does not compromise any othernode it fails to satisfy the scalability require-ment because the storage cost grows rapidlywith network size In the case of several thou-sand nodes the number of keys each nodemust maintain becomes unmanageable Consid-er the storage of N – 1 keys per node Thetotal number of distinguishable keys in the net-work is N(N – 1)/2 which grows at a rate ofN2; this is not maintainable when N is a largevalue Another issue with the pairwise keyingmodel is that it is difficult to add new nodes tothe network affecting the flexibility require-ment When a new node is added every nodemust obtain a new key to communicate with itThis is a resource-intensive process that usesmuch more precious energy when comparedwith the simple preloading of a network-widekey as in the previous model Similarly keyrevocation and key refreshing suffer from thesame scalability problem Additionally theaccessibility requirement is in jeopardy asnodes cannot passively monitor event signalsLastly in the case of some pairwise key distri-bution schemes self-organization comes intoquestion because they tackle the scalabilityproblem by reducing the number of sharedkeys resulting in some nodes being unable tocommunicate with others and compromisingthe self-healing and self-organizing abilities ofthe networkThe group keying scheme combines the fea-tures of both network and pairwise keyingschemes Within a group of nodes that form acluster communications are performed using asingle shared key similar to network keyingHowever communications between groupsemploy a different key between each pair ofgroups in a manner identical to the pairwisekeying scheme Thus for a group of nodes theaccessibility requirement is satisfied becausedata aggregation can occur with no additionalcost while some degree of robustness is main-tained When one of the nodes is compromisedthe worst-case scenario is the compromise ofthe entire cluster that it belongs to which isconsiderably more isolated than the entire net-work In terms of scalability an acceptabletrade off is possible in this scheme because thenumber of keys increases with the number ofgroups not with the size of the network How-ever the problem with this scheme is that it isdifficult to set up and also the formation of thegroups is a very application dependent processTo efficiently distribute the keys a keyingscheme would require group formation infor-mation Furthermore the existing IEEE802154 MAC specification has no support forgroup keying with its current use of access con-trol lists [2]n Table 2 Operational requirements for wireless sensor networks [1]Requirement DescriptionAccessibilityIntermediate nodes should be able to perform data aggre-gation by combining data from different nodes Neighbor-ing nodes should also be able to passively monitor eventsignals to prevent large amounts of redundant event signal-ing informationFlexibility Nodes should be replaceable when compromised On-the-flyaddition of nodes should also be supportedScalability A WSN should concurrently support at least 3000 nodeseven with the key management scheme in placeLEE LAYOUT  10/3/07  2:32 PM  Page 78                                         IEEE Wireless Communications • October 2007 79PROMISING KEY MANAGEMENTPROTOCOLSTo realize a practical robust keying modelresearchers have proposed various key manage-ment protocols that address the problems ineach of the three basic schemes discussed previ-ously In this section five different key manage-ment protocols are presented and reviewed inchronological orderESCHENAUER AND GLIGOREschenauer and Gligor [3] presented one of thefirst key management schemes for WSNs that iselegant simple and provides an effective tradeoff between robustness and scalability Thisscheme works as follows:• Generate a large pool of keys (eg 10000keys)• Randomly take k keys out of the pool to estab-lish a key ring where k << N where N is thetotal number of nodes Each node receives itsown unique key ring consisting of a subset ofkeys• When two nodes must communicate theysearch for a common key within the key ringby broadcasting the identities (IDs) of thekeys they have If such a key does not existthey attempt to communicate through a com-mon third party who is able to establish com-munications with both nodes This phase iscalled path-key discoveryAs one can see as long as the total numberof keys stored in a node is less than N – 1 thescheme uses less storage than a pure pairwisescheme This scheme also is scalable because thenumber of keys in the pool and the size of thekey ring are both adjustable Therefore a moremission critical application can use a larger poolof keys and adjust the key ring size appropriatelyto be more secure However this scheme hassome drawbacks Compared to the newerschemes Eschenauer’s random key distributionis just a key distribution scheme It lacks theauthentication process and does not clearlydefine any process for revoking or refreshingkeys In addition the dynamic handshaking pro-cess for each connection prevents any form ofpassive data aggregation; thus one event detect-ed by two neighboring nodes will result in twoseparate signals There is no support for cluster-ing or collaborative operations If a home light-ing automation application uses Eschenauer’skeying scheme turning off all the lights on onefloor would entail sending a message to eachlight which is rather inefficient Lastly since notevery node is guaranteed to have a common keywith all of its neighbors there is a chance thatsome nodes will be unreachable [3] OverallEschenauer’s scheme failed to satisfy securityrequirement authentication and operationalrequirement accessibilityDU DENG HAN AND VARSHNEYIn 2003 Du et al proposed a key managementscheme [4] based on the pairwise keying modelThis model extends Eschenauer and Blom’swork [5] by using the same paradigm asEschenauer and Gligor [3] but instead of indi-vidual keys it uses the concept of Blom’s keymatrix which is an array of keys In Du’s schemethere are k key matrices in each node and thekey matrices are distributed randomlyBlom’s model is based on the idea of a sym-metric matrix multiplication where row i columnj is equivalent to row j column i Thus whennode i calculates key ij and node j calculates keyji the keys are identical leading to a commonlyshared secret Blom’s scheme distributes theinformation required for this calculation interms of a public matrix and a private matrixIn Du’s pairwise key management schemeinstead of using only one private matrix the sinknode generates i private matrices and each nodestores a subset of these matrices in the samemanner as Eschenauer’s key ring When twon Table 3 Common key distribution schemes for WSNsModel Description Benefits ProblemsNetwork The entire network usesone shared secret key• Simple• Allows data aggregation and fusion• Scalable• Able to self-organize• Flexible/accessible• Compromise of one node compromises the entirenetwork (lacks robustness)PairwiseEach specific pair ofnodes shares a differentkey• Best robustness• Authenticates each node• Nonscalable — storage energy computation• Unable to self-organize• Not flexible for addition/removal of nodesGroup Each group uses adifferent shared key• Allows multicast• Allows group collaboration• Better robustness than network-widekeying• Adjustable scalability• Addition/removal of nodes possible• Able to self-organize within thecluster• Lacks efficient storage method for group keying inIEEE 802154• Difficult to set up securely• Cluster formation information is application-dependentLEE LAYOUT  10/3/07  2:32 PM  Page 79                                          IEEE Wireless Communications • October 200780nodes must communicate they start by broad-casting the node IDs the indices of key matricesthey carry and the seed of the column of thepublic matrix If they share a common keymatrix then they can compute the pairwisesecret key using Blom’s scheme If they do notshare a common key matrix they will go into apath-key discovery phase to find a common thirdparty to route the dataThe benefit of Du’s scheme is that it offersan even stronger robustness against node com-promise at a reasonable scalability cost Theauthors claimed that an adversary must compro-mise five times as many nodes compared withEschenauer’s scheme to compromise the entirenetwork Their analysis of scalability shows thatthe energy cost remains reasonable and on parwith the energy cost of using the advancedencryption standard for a WSN consisting of 264nodes which is 48 times higher than the maxi-mum number of nodes defined in IEEE 802154The main disadvantage of this scheme is its com-plexity which makes it hard to implement andincreases overhead costs Also cluster opera-tions are not supported because it is a pairwisekeying scheme and neither key revocation norkey refreshing are considered The operationalrequirement accessibility is also difficult to sat-isfy because nodes will not be able to passivelymonitor communications Lastly compared toother simpler schemes Du’s scheme likely usesmore energy due to its computational complexityand on-demand key computation To summarizeDu’s scheme can satisfy most requirements butin the operational requirements area it fails tosatisfy accessibility and may not be competitivewith simpler schemes in terms of scalability dueto its higher overhead costsLEAP — ZHU SETIA AND JAJORDIAZhu Setia and Jajordia introduced the localizedencryption and authentication protocol (LEAP)[6] which employs a hybrid approach This is ajack-of-all-trades protocol offering network-widecluster/group and pairwise keying capabilitiesTo accomplish this LEAP uses four types ofkeys: individual group cluster and pairwiseshared keys The individual key is unique for eachsensor node to communicate with the sink nodeThe group key is a network-wide key for commu-nication from the sink node to all sensor nodesAn authentication mechanism known as µTimedEfficient Streaming Loss-tolerant AuthenticationProtocol (µTESLA) [7] is used for the broadcastauthentication of the sink node which ensuresthat packets sent with the group key are fromthe sink node only The cluster key is used forcollaborations within a cluster An authentica-tion mechanism known as a one-way hash-keychain that employs a non-reversible mathemati-cal operation is used to ensure that the source ofthe packet can be authenticated without preclud-ing passive data aggregation Lastly the pairwiseshared key is used for secure communicationsbetween neighboring nodesLEAP uses a pre-distribution key to helpestablish the four types of keys The individualkey is first established using a function of a seedand the ID of the node Then in the pairwiseshared key phase a neighbor discovery processis initiated and nodes broadcast their IDs Thereceiving node uses a function seeded with aninitial key to calculate the shared key between itand all of its neighbors Afterwards the initialkey and any intermediate keys that were gener-ated are erased Thirdly the cluster key is dis-tributed by the cluster head using pairwisecommunication secured with the pairwise sharedkey Lastly for distributing the network-widegroup key the sink node broadcasts it in a multi-hop cluster-by-cluster manner starting with theclosest clusterLEAP has many advantages that satisfy therequirements of WSNs First it has µTESLAand one-way key chain authentication as well askey revocation and key refreshing The accessi-bility requirement also can be easily satisfied byencrypting data that requires aggregation withthe cluster key The fine granularity it supportsenables data to be encrypted at the correct level(ie key level) to ensure reasonable security isachieved without prohibiting data fusion oraggregation The scalability of LEAP can beanalyzed in terms of computational cost andstorage cost The computational cost of LEAP isinversely proportional to the number of nodesand directly proportional to the number ofneighbors (ie node density) [6] because thehigher the density of the network the more con-nections are formed per cluster The storage costalso is quite reasonable as pairwise keying isused only for one-hop neighbors It is apparentthat LEAP satisfies both the security and opera-tional requirements very well The only draw-back with LEAP is that it assumes the sink nodeis never compromisedSHELL — YOUNIS GHUMMAN AND ELTOWEISSYThe Scalable Hierarchical Efficient Location-aware and Light-weight (SHELL) protocol [8] isa complicated cluster-based key managementscheme published recently It is influenced byLEAP with its use of multiple types of keys butintroduces a new distributed key managemententity Each cluster has its own distributed keymanagement entity residing in a non-cluster-head node Thus the operational responsibilityand key management responsibility are separat-ed leading to a better resiliency against nodecapture Because there are multiple differententities and over seven types of keys the key setup and communication processes are too com-plex to be described in detail in this articleInterested readers are referred to [8]The main benefit of SHELL is that it has ahigh robustness against node capture Althoughsome nodes have unique functions the captureof that particular node does not reveal enoughkeys to compromise the entire network nor todisrupt the operation of the network Forinstance the capture of a key-generating gate-way node a key management entity does notcompromise the network because it does notcontain the key between the cluster head andthe cluster nodes Likewise due to the distribut-ed feature there are at least two key-generatinggateway nodes and the disruption of one doesnot hinder the operation of the network Inaddition SHELL accounts for the processes fornode addition replacement and refreshment ofThe main benefit ofSHELL is that it hasa high robustnessagainst node capture Althoughsome nodes haveunique functions the capture of thatparticular node doesnot reveal enoughkeys to compromisethe entire networknor to disrupt theoperation of the networkLEE LAYOUT  10/3/07  2:32 PM  Page 80                                   IEEE Wireless Communications • October 2007 81keys It also supports cluster (group) communi-cations and does not preclude data fusion oraggregation within the clusters HoweverSHELL has some drawbacks Its structure andoperation are highly complex involving hetero-geneous node operations and multiple (at leastseven) types of keys The specific network enti-ties include the gateway node key-generatinggateway node inter-gateway node commandnode and sensor node The energy consumptionand cryptographic overheads although scalablehave not been compared with other schemesDue to its increased complexity the energyusage and cryptographic overhead are likelyhigher than other schemes Finally the imple-mentation of such a complex protocol also maybe difficult with the current programming limita-tions of a WSN To conclude SHELL focuseson satisfying the robustness and security require-ments while trading off the availability require-ment since higher complexity leads to higherenergy usage and lowers the mean time betweenfailures In this case failures would likely occurdue to the depletion of battery energy of individ-ual nodesPANJA MADRIA AND BHARGAVAPanja et al [9] recently introduced a hierarchicalgroup keying scheme using the Tree-basedGroup Diffie-Hellman (TGDH) protocol Themain feature of this scheme is that each key ismade up of many partial keys By breaking upthe keys into smaller components it makesrekeying an efficient and simple task by revok-ing changing or adding one or more partialkey(s)The TGDH keying scheme works on a hierar-chical WSN that has one level of general sensornodes and multiple levels of cluster heads; thatis there can be a head of clusters responsible formultiple cluster heads below it in a tree-likemanner The data collection process starts with agroup of sensor nodes collecting data from aregion of interest and sending it to the nearestcluster head The cluster head then aggregatesthe data to reduce the size and overhead andsends it to its parent The parent if it has multi-ple children repeats the process of data aggre-gation and forwards the data to its parent untilthe sink node is reachedTo establish the keys in this hierarchical tree-based WSN two separate schemes are used:intra-cluster and inter-cluster keying The intra-cluster keying process starts with the leaf nodessending each of their partial keys to the parentThen the parent calculates its own partial keyand combines the partial keys together to formthe cluster key The parent node then broadcaststhis cluster key to its leaf nodes All communica-tions are encrypted with a pre-distributed key toprovide confidentiality during this early stageAfterwards the inter-cluster keying is initiatedThis process is very similar to that of intra-clus-ter keying except that intermediate keys of theparents (children of the next higher level) areused instead of the partial keysThe advantage of this scheme is that com-pared to SHELL it is simple and elegant andhence easy to implement Panja et al also simu-lated the performance of their scheme in com-parison with Security Protocols for SensorNetworks (SPINS) [7] a keying protocol thatestablishes secure one-to-one communication ina WSN The results are promising with fast andscalable key delivery time and energy usageAlso by using small partial keys the storage andcomputational costs are reduced This is espe-cially significant for the leaf nodes that frequent-ly have the least amount of resources at theirdisposal The drawback of Panja’s scheme is thatalthough key revocation and key refreshing pro-cesses are addressed node addition and replace-ment are not considered explicitly In additionits security robustness against the compromise ofthe initial pre-distributed key has not been ana-lyzed Further the security strength of the lowcomplexity keys at the leaf nodes for exampleagainst brute-force attacks has not been provenTo conclude Panja’s scheme trades off robust-ness to better satisfy the self-organization acces-sibility flexibility and scalability requirementsThe use of a tree-based hierarchical structurealso ensures that this protocol is very scalableSUMMARYThe promising key management protocols sur-veyed in this article are summarized in Table 4Table 5 and Table 6 respectively compare theperformance advantages and disadvantages ofthese protocolsn Table 4 Summary of key management schemesScheme Date Structure Key generation DescriptionEschenauer 2002 Partial pairwise randomkey distribution StaticRandomly selects k keys out of a large pool to form a key ringCommon keys in a pair of node’s key ring allow communicationDu 2003 Pairwise matrix Dynamic Selects T key matrices and uses matrix multiplication to com-pute pairwise shared key dynamicallyLEAP 2003 Hybrid: network groupneighbor pairwise Mostly static Uses a predistributed key to establish four types of keysSHELL 2006 Group distributed keymanagement roles DynamicUses a distributed key management entity to generate andmanage keysPanja 2006 Group hierarchical network Dynamic Uses multiple partial keys to compute group keys dynamicallyLEE LAYOUT  10/3/07  2:32 PM  Page 81                         IEEE Wireless Communications • October 200782TRENDS IN KEY MANAGEMENTAlthough there are many papers published onvarious keying schemes whether or not theywill  be implemented or used in practicedepends on market demands A proposedscheme likely will be adopted in practice if ittargets open standards Recently both theIEEE 80215 task group and the ZigBeeAlliance have released newly revised standardsDespite the fact that the new IEEE 802154bstill does not specify a key management schemeit clarifies ambiguities and enhances many fea-tures compared with the original standard Inthis section we discuss the security relatedchanges in 802154b and the features relevantto key management in the newly enhanced Zig-Bee standard 2006The 80215 task group 4b was chartered toprovide specific enhancements and clarificationsto the original 802154-2003 standard Therevised standard was published in September2006 as 802154-2006 In terms of the securitychanges the standard introduces a new counterwith cipher block chaining mode* (CCM*)cipher suite mode which incorporates the confi-dentiality-only and authentication-only modesthat were provided non-securely by cipherblock chaining (CBC) and counTeR (CTR)cipher suite modes in the original standardAnother new feature of the 4b standard that isrelevant to key management is secure groupkeying Many applications can benefit fromsecure broadcasting or multicasting abilitiesUnfortunately the secure broadcasting mecha-nism in 802154-2003 is actually insecurebecause it does not provide data freshness andis vulnerable to replay attacks The replay attackvulnerability can be exploited against applica-tions that require secure broadcast such ashome automation Imagine the devastatingeffect of a replayed lights-off broadcast rightbefore a home invasion Hence replay resistantbroadcasting has been introduced in 4b usingframe counters on a per-device basis and thefeature is made more flexible with the introduc-tion of group keying Many other small clarifica-tions were proposed but only the most relevantones were presented hereThe ZigBee Enhanced standard was releasedin September 2006 and offers improvements andnew features The most relevant feature is thesupport of group devices and targeted broad-casts Like 802154b the ZigBee Alliance alsohas treated group device support with a high pri-ority In addition the new targeted broadcastfeature that can reach a specific subset of devices(routers end nodes sleeping nodes currentlyawake nodes) is important to key managementscheme selection because it adds a new function-al requirement It is worthwhile to take thesenew features into account when considering thevarious key management schemesBased on the new trends in 802154b and theZigBee Enhanced standard one can easilyassume that a purely random or pairwise keyingscheme like Eschenauer [3] and Du [4] wouldnot be commercially viable The keying schemesthat offer group or multicast abilities are muchmore compatible with industry trends Thus thedevelopment of a key management scheme thatincorporates the flexible network pair and clus-ter abilities found in LEAP along with theadjustable robustness of Eschenauer or Du maybe desirable The main issue with SHELL is itshigh complexity; further developments can targetstreamlining of its processes and reduction ofoverheads Panja’s scheme also has some advan-tages for extremely large networks and onemight want to enhance Panja’s scheme with themultiple-level keying of LEAP for added flexi-bility or with Eschenauer’s or Du’s scheme forincreased robustness In any case the trade offspresented earlier remain true and the two newindustry standards provide a good guideline tothe acceptable essential services that a viable keymanagement solution must provideCONCLUSIONIn this article we reviewed five key managementschemes starting with the classic Eschenauerscheme and moving to the more recent schemespublished in 2006 It is clear that numeroustrade offs exist between different key manage-ment schemes and the vast number of proposalsmake it difficult to compare them Recent trendsalso show that cluster or group operation is arequired feature that has been considered bymany recent key management proposals includ-ing LEAP SHELL and Panja’s scheme Eachone of these schemes has its own strengths suchas the LEAP adjustable security level the strongrobustness of SHELL and Panja’s hierarchicalscalability One must consider the trade offscarefully when selecting key managementschemes For instance although SHELL offers ahigh robustness it is also far more complex thanthe other two and thus may be difficult to imple-ment LEAP on the other hand has the flexibil-ity to switch between group network andpairwise keying on a per packet basis but theprotocol must be studied further for securityweaknesses Future developments could incorpo-rate the flexibility of LEAP with the adjustablerobustness offered by Eschenauer or Du’sscheme For security-critical applicationsSHELL seems to offer the highest robustnessbut it may be further improved to reduce imple-n Table 5 Relative performance of key management schemes [10]Scheme Simplicity Scalability Robustness Storage efficiency1Eschenauer H M L M/HDu L L H L/MLEAP M M M MSHELL L M H L/MPanja M H M M/HLegends: H = High M = Mid L = Low For each variable the higher thevalue the better performance it has1 Storage cost may change with different factors We can only estimate therelative cost based on available informationLEE LAYOUT  10/3/07  2:32 PM  Page 82                  IEEE Wireless Communications • October 2007 83mentation complexity For extremely largeWSNs improving Panja’s scheme to take advan-tage of its highly scalable hierarchical featuremay prove attractiveREFERENCES[1] D W Carman P S Kruus and B J Matt “Constraintsand Approaches for Distributed Sensor Security” NAILabs tech rep 00-010 2000[2] N Sastry and D Wagner “Security Considerations forIEEE 802154 Networks” Proc 2004 ACM Wksp Wire-less Sec 2004 pp 32–42[3] L Eschenauer and V D Gligor “A Key-ManagementScheme for Distributed Sensor Networks” Proc 9thACM Conf Comp and Commun Sec 2002 pp 41–47[4] W Du et al “A Pairwise Key Predistribution Scheme forWireless Sensor Networks” Proc 10th ACM ConfComp Commun Sec 2003 pp 42–51[5] R Blom “An Optimal Class of Symmetric Key Genera-tion Systems” Proc EUROCRYPT ’84 Wksp Advancesin Cryptology: Theory and App of Cryptographic Tech-niques 1985 pp 335–38[6] S Zhu S Setia and S Jajodia “LEAP: Efficient SecurityMechanisms for Large-Scale Distributed Sensor Net-works” Proc 10th ACM Conf Comp and CommunSec 2003 pp 62–72[7] A Perrig et al “SPINS: Security Protocols for SensorNetworks” Wireless Network vol 8 2002 pp 521–34[8] M F Younis K Ghumman and M Eltoweissy “Loca-tion-Aware Combinatorial Key Management Scheme forClustered Sensor Networks” IEEE Trans Parallel andDistrib Sys vol 17 2006 pp 865–82[9] B Panja S K Madria and B Bhargava “Energy andCommunication Efficient Group Key Management Pro-tocol for Hierarchical Sensor Networks” SUTC ’06:Proc IEEE Int’l Conf Sensor Networks Ubiquitous andTrustworthy Comp 2006 pp 384–93[10] S A Camtepe and B Yener “Key Distribution Mecha-nisms for Wireless Sensor Networks: A Survey” Techrep TR-05-07 Dept of Comp Sci Rensselaer Polytech-nic Inst 2005BIOGRAPHIESJOHNSON C LEE (johnsonl@eceubcca) received his BASc(with distinction) from the University of British ColumbiaCanada in 2005 and is currently pursuing his MEngdegree at the same university During his undergraduatestudies he received the NSERC USRA Scholarship to workon communication security for SSL with Dr KonstantinBeznosov His research interests are communication securi-ty sensor networks distributed computing and softwareproject managementKIRK H M WONG (cshmwong@comppolyueduhk) receivedhis BSc (Honors) from York University Canada in 1986and his MSc from Hong Kong University of Science andTechnology in 1999 Currently he is a PhD student in theDepartment of Computing at Hong Kong Polytechnic Uni-versity He also works at the Department of Informationand Communications Technology at the Hong Kong Insti-tute of Vocational Education as a lecturer His researchinterests include security and positioning in wireless sensornetworksHENRY C B CHAN [M] (cshchan@comppolyueduhk)received his BA and MA degrees from the University ofCambridge England and his PhD degree from the Uni-versity of British Columbia Canada Currently he is anassociate professor in the Department of Computing atHong Kong Polytechnic University His research interestsinclude networking/communications wireless networks e-commerce Internet technologies and mobile computingFrom October 1988 to October 1993 he worked withHong Kong Telecommunications Limited primarily on thedevelopment of networking services in Hong KongBetween October 1997 and August 1998 he worked withBC TEL Advanced Communications on the development ofhigh-speed networking technologies and ATM-based ser-vices He has authored/co-authored a textbook on e-com-merce published by Wiley a book chapter in the InternetEncyclopedia (Wiley) and more than 50 journal and con-ference papers He is currently serving as an executivecommittee member of the IEEE Hong Kong Section Com-puter Chaptern Table 6 Comparison of advantages and disadvantages of key management schemesScheme Advantage DisadvantageEschenauer• Uses less storage than a pure pairwise scheme• Adjustable robustness trade-off with storage cost• Simple and implementable• No authentication available• No support for cluster operations• Some nodes may not be reachable• Low accessibilityDu• Provides node authentication in an Eschenauer-likescheme• Energy cost remains reasonable• Excellent robustness• High complexity• No support for cluster operations• High relative energy cost• Low accessibilityLEAP• Supports cluster pairwise and network-wide operations(good for data fusion/aggregation)• Can detect and isolate compromised nodes quickly usingµTELSA and one-way key chain hashing authentication• Reasonable complexity and scalability• Security during the startup key establishment processmay be weak• Storage cost is high for a small number of nodes due tothe use of four types of keys• Assumes the sink node is never compromisedSHELL• Supports addition and replacement of nodes• Refreshes keys using only a few messages• Utilizes distributed key management entity• High robustness• High accessibility• Complex operations with highly heterogeneous nodeoperations• Storage cost is high for a low number of nodes due tothe use of seven or more types of keys• Higher cryptographic overhead• Overall energy cost is higher due to complex operationsPanja• Simple and elegant• Fast and easy key refreshing process• Highly scalable using TGDH scheme• Low storage cost for leaf nodes• Ideal for shorter-term sensor networks• Nonadjustable security strength• Does not clearly address key revocation or node addition• Long-term eavesdropping may present a threat if initialkey is compromised• Leaf node security using small partial keys may not bestrong enough against analysis by widely available highcomputational platformsLEE LAYOUT  10/3/07  2:32 PM  Page 83                                     IEEE Wireless Communications • October 200784VICTOR C M LEUNG [F] (vleung@eceubcca) received aBASc from the University of British Columbia Canada in1977 and was awarded the APEGBC Gold Medal as thehead of the graduating class in the Faculty of Applied Sci-ence He attended graduate school at the same universityon an NSERC Postgraduate Scholarship and completed aPhD in electrical engineering in 1981 Currently he holdsthe positions of professor and Telus Mobility ResearchChair in the Department of Electrical and Computer Engi-neering at the University of British Columbia His researchinterests are in mobile and wireless networks From 1981to 1987 he was a senior member of technical staff at MPRTeltech Ltd Canada He was a lecturer in electronics at theChinese University of Hong Kong in 1988 He is an editorof IEEE Transactions on Wireless Communications an asso-ciate editor of IEEE Transactions on Computers and anassociate editor of IEEE Transactions on Vehicular Technol-ogy He has served on the organizing and technical pro-gram committees of numerous conferences He is aregistered Professional Engineer in British Columbia Cana-daJIANNONG CAO [M’93-SM’05] received a BSc degree in com-puter science from Nanjing University China in 1982 andMSc and PhD degrees in computer science from Wash-ington State University in 1986 and 1990 respectively Heis currently a professor in the Department of Computing atHong Kong Polytechnic University Hung Hom He is alsodirector of the Internet and Mobile Computing Laboratoryin the department His research interests include paralleland distributed computing networking mobile and wire-less computing fault tolerance and distributed softwarearchitecture His recent research has focused on mobileand pervasive computing systems developing testbedsprotocols middleware and applications Before joiningHong Kong Polytechnic University he was on the faculty ofcomputer science at James Cook University the Universityof Adelaide in Australia and City University of Hong KongHe has published over 200 technical papers in the previ-ously mentioned areas He is a senior member of the ChinaComputer Federation and a member of ACM He is also amember of the IEEE Technical Committees on DistributedProcessing Parallel Processing and Fault Tolerant Comput-ing He has served as a member of editorial boards of sev-eral international journals a reviewer for internationaljournals and conference proceedings and an organizing/program committee member for many international con-ferencesLEE LAYOUT  10/3/07  2:32 PM  Page 84          
Lightweight key managment in WSN-Similar-Shell-pdf,Lightweight Key Management for Wireless Sensor Networks Mohamed Eltoweissy Department of Computer Science Virginia Tech Falls Church VA 22043 eltoweissy@vtedu Abstract Given the growing number of applications of wireless sensor networks some recent research has focused on managing secure wireless communications in such networks When a large group of sensors that typically are constrained in energy computation and communication resource are deployed efficient key management becomes critical In this paper we propose a new hierarchical key management scheme for wireless sensor networks based on a combinatorial optimization of the group key management problem Our solution uses symmetric encryption and re­keying to support current forward and backward secrecy An important contribution of our solution is that it yields optimal results for the number of administrative keys per network granule and the number of re-key messages We also present a mechanism for recovery from a node failure or compromise Keywords: Wireless Sensor Networks Security Protocols Key Management Group Communications 1 Introduction Recent advances in nano-technology make it technologically feasible and economically viable to develop low-power battery-operated sensor nodes that integrate general-purpose computing with multiple sensing and wireless communications capabilities For most applications we envision a massive random deployment of sensor nodes that selfarganize into sophisticated computation and communication infrastructures called wireless sensor networks (WSNs) The fundamental goal of a WSN is to produce over a period of time global information from local data obtained by individual sensor nodes [1-3] A WSN is only as good as the information it produces In this respect perhaps the most important concern is information security If an adversary can thwart the work of the network by perturbing the information produced stopping production or pilfering information then the perceived usefulness of WSNs will be drastically curtailed The energy-constrained nature of the WSN s makes the task of incorporating security a challenging problem Most of the well-known security mechanisms employed in wireline and wireless networks are too expensive for WSN in terms of their computation and communications overhead In this paper we focus on the design of a low energy key 0-7803-8396-6/041$2000 © 2004 IEEE Mohamed Youois and Kajaldeep Ghumman Department of Computer Science and Elect Eng University of Maryland Baltimore County Baltimore MD 21250 (younis kajall}@csumbcedu management scheme for WSNs to preserve current forward and backward secrecy Preserving current secrecy requires that each authorized member of a secure network have knowledge of one or more communication encryption key(s) shared by a group of nodes The message source uses the communication keys for encrypting data packets before sending them to the group Numerous conditions may introduce the need to evict a node or a set of nodes For example nodes may experience failure due to energy depletion" also nodes may be compromised and exhibit anomalous behavior When a member node is evicted from the group the communication keys known to that member must be changed in order to maintain forward secrecy All remaining group members receive the new communication keys by secure transmission which is typically accomplished by broadcasting an encrypted message containing the new key(s) to the group Such a message must be indecipherable to the evicted member Re-keying may be needed also when a new member joins in order to preserve backward secrecy Typically administrative keys are used for re-keying operations that take place when network membership changes The network should have a key service whose purpose is to manage all communication and administrative keys used by the network The key service may or may not be implemented within a message source In this paper we will use the word "key" to refer collectively to communication keys and administrative keys For a large number of nodes the number of keys may become quite large making efficient key management a non-trivial problem Sensor nodes are memory constrained so it is desirable to keep the number of keys stored by each node to a minimum The key service must store the keys for the entire network of sensors so the total number of keys must also be minimized Furthermore network membership may change so the number of re-key messages needed to re­establish security when a member is evicted must be minimized as well These concerns give rise to the need for efficient key management techniques that minimize both the number of keys and the number of re-key messages The main contribution of this work is a novel solution to the problem of key management in cluster-based WSNs Specifically we propose a lightweight scheme based on a combinatorial formulation of the group key management problem Our solution produces optimal results with respect 813 to the parameters n k and m where n is the size of the network (number of members) k is the number of keys stored by each group member and m is the number of re-key messages The solution allows for trade-offs between the number of keys per a group member Ie  and the number of re-key messages m It also separates administrative keys used for key management from communication keys used for secure data transmission resulting in efficient key management and multi-granularity secure communications In the balance of this section we describe the WSN model assumed in the paper and discuss related 'woi'k Section 2 describes the basis of our key management solution; specifically it describes the concept of Exclusion Basis Systems (EBS) that is then used to construct optimal systems for key management Section 3 presents our proposed EBS-based key management solution for WSNs Finally section 4 otTers concluding remarks and maps out directions for future work 11 System Model The system architecture for the WSN is depicted in Figure 1 Sensor nodes are grouped into clusters controlled by a single command node Sensors are only capable of radio-based short-haul communication and are responsible for probing the environment to detect a target/event Every cluster has a gateway node that manages sensors in the cluster Sensors of each cluster gather information and transmit it to the gateway of their cluster The gateway fuses the data from the different sensors processes the infonnation pertaining to the mission program and sends it to the command nodes via long-haul transmission Clusters can be formed based on many criteria such as communication range number and type of sensors and geographical location [10] In our model the gateways collaboratively locate the deployed sensors and group them into clusters [11] In this paper we assume that sensor and gateway nodes are stationary and the gateway node is located within the communication range of all the sensors of its cluster Each tier of the network possesses different architectural capabilities The command node can be assumed to pose no restrictions in terms of computation and storage However the communications channel between the command node and the network is an expensive resource to use because its bandwidth is valuable and should not be unnecessarily flooded and because substantial amount of energy is necessary to transmit over the "long-haul ch�el The gateways are asswned to have sufficient energy resources to carry out this transmission Conversely sensors are extremely constrained in energy MICA sensor architecture is a good candidate for our network [12] Given the limited environment providing secwity services for the WSN is not a trivial task Secure communications between" a gateway and its sensors is a necessary part of the overall security of the network In this paper we focus key management for this network model ee-_ • �Ndr Fig 1: Multi-gatewa:{ clustered WSN 12 Related Work In recent years there has been extensive research in WSNs Most of the research effort has concentrated on energy efficient communication protocols [1-3] The comparative effort in making these networks secure and managing the security of networks with dynamic membership has been scarce Quite recently a nwnber of solutions for securing WSNs have been proposed {5-9J Carman et aI have evaluated approaches for key agreement and distribution in WSNs in terms of energy consumption and memory requirements [4] Eschenauer et al have proposed a distributed key establishment mechanism that relies on probabilistic key sharing among the nodes of a random graph and uses a shared-key discovery protocol for key establishment [7] Perrig et aI presented several extensions to this mechanism and provided solutions for node authentication and key revocati·on [8] Jolly et aI proposed a hierarchical key management scheme for WSNs In this scheme nodes only communic:ate with their gateway and each node shares a key with its corresponding gateway [9] In general existing work in security management in WSNs did not address node re-keying or security at different levels of granularity 2 Group Key Management Using Exclusion Basis Systems The security solution in this paper uses Exclusion Basis Systems a combinatorial fonnulation of the group key management problem Exclusion Basis Systems produce optimal results with respect to the parameters n k and m where n is the size of the group k is the number of keys stored by each group member and m is the number ofre-key messages In this section we present an overview of EBS For more details the reader is rc:ferred to [4} Exclusion Basis Systems (EBS) An EBS is defined as a collection r of subsets of the set of members Each 'subset corresponds to a key and the elements of a subset A e r are the nodes that have that key An EBS r of dimension (n k m) represents a situation in a secure group where there are "n" members numbered 1 814 through n and where a key service holds a distinct key for each subset in r In this section we will use the tenns "key" and "subset" interchangeably If the subset A is in r then the key Ai is known by each of the members whose number appears in the subset AI' Furthermore for each t EO [1 n] there are "m" elements in r whose union is [I n]·{t} From this it follows that the key service can evict any member t re-key and let all remaining members know the replacement keys for the "k" keys they are entitled to know by multicasting "m" messages encrypted by the keys corresponding to the m elements in r whose" union is [1 nJ· {t} Each new key is encrypted by its predecessor to limit decipherability only to the appropriate members To construct EBS(nkm) for feasible n Ie and m we employ a canonical enumeration of all possible ways of forming subsets of k objects from a set of k+m objects There are several algorithms for producing such a sequential enumeration We choose an enumeration where each element of the sequence is a bit string of length k+m where a I in the l" position of a string means that object i is included in that sUbset for all i (1 :5 i :5 k+m) Note that every bit string in this enumeration will have exactly k ones We use a canonical type of enumeration for the binomial coefficient C(k+mk) subsets using induction on k+m  For any k and m let Canonical(km) be the canonical enumeration of all C(k+mk) ways to form a subset of k elements from a set of k+m objects For the sequence of bit strings in Canonical(km) we form a matrix A where k and m are understood and whose C(k+mk) columns are the successive bit strings of k+m length each with k ones A is called the canonical matrix for EBS(nkm) For example the canonical matrix A for EBS(lO 3 2) contains the enumeration of all C(53) ways to form a subset of3 keys from 5 keys A is shown in the non·shaded portion of Fig 2 Fig 2: The canonical matrix A for EBS(1O 32) with session keys T S and U assigned to sets of members (unshaded) We assume that in addition to the administrative keys corresponding to subsets in r a key service also has one or more session keys known to sets of group members All group members aware of a particular session key constitute a secure communications group Members in a secure communications group use the session key corresponding to the group for encrypting messages exchanged among group members A canonical matrix is constructed and used as the basis for key assignment and management The shaded area in Fig 2 illustrates three rows of session key assignments; keys T S and U From Fig 2 evicting MJ will result in two re·key messages using Kj and Kj to send new keys K' J K' 1 K'4' S' and U· Note that even though member Msknows K4 and Kj it will not be able to decipher new keys S· and U' because these are transmitted encrypted with the old keys S and U respectively which are not known to Ms In [4] we prove that the overhead of an optimum EBS is half that of a binary key tree An EBS however may suffer from collusion attacks We suggest solutions to collusion in [4] Solving the collusion problem is out of the scope of this paper We note however that typically in WSNs where a very large number of sensors are randomly deployed the probability of a collusion attack is minimal 3 Group Key Management for WSNs Key management is an essential constituent of network security Symmetric key systems require keys to be protected Insecure environments like those in which WSNs will operate make this even more important Moreover WSNs have energy and computational constraints; therefore it is necessary to maintain a balanced security level with respect to those constraints In this section we propose a key management scheme for WSNs with the objective of minimizing the computation communications and storage overhead by the key management" Our approach is based on the EBS discussed in the previous section We assume that the command node is secure while the gateways and sensors can be compromised by an adversary For example in militaIy reconnaissance scenarios sensors and gateways are expected to be deployed across the border in the enemy territory The sensors will monitor the movements of the enemy and report the gathered information to the gateway that in turn will process that data and forward it to the command node which will be deployed in a friendly environment The next subsection lists the assumed capabilities and clarifies the role of each node in the security framework Discussion of securing network initialization and operation follows in subsection 32 Analysis of potential compromises and description of the recovery process can be found in subsection 33 31 Node Roles and Capabilities Sensors: Each sensor will have two built· in keys and a unique ID set prior to its deployment The first built·in key we tenn Kos is used during network setup for the sensor to announce its location and ID to the gateway The second built·in key Ko is known only to the individual sensor and the command node and is used for achieving trusted sensor clustering and recovery from a gateway compromise The command node will be given a database of the IDs and built· in keys of all sensors deployed in the area of interest We have not made any trust assumptions on sensors They can be captured and compromised Namely the adversary can read all the infonnation from the sensor's memory including 815 the keys and even program the sensor to inject malicious messages The gateway is assumed to be capable of detecting a compromise of a sensor The command node is assumed to be secure and is trusted by all the nodes in the �SN  Moreover the command node is capable of detecting mtruslon and WIll thereby remove the compromised gateway from the network Gateways: Each gateway performs key management within its cluster The gateways initially do not know the built-in keys for sensors EBS is used for key generation and management within the cluster after network setup A gateway's compromise includes the uncovering of its communication keys through spoofing the physical damaging of its processing andlor communication capabilities and the manipulation of its operation after being captured by an adversary Each gateway can directly communIcate WIth every other gateway in the network Every gateway will have a built-in key Kge to communicate with the command node After registering with the command node group conuimnications among the gateways are secured using EBS with a different set of keys from those used by sensors in the cluster Command node: The command node is the only authority for key generation The command node will be the direct service for the administration keys for the gateways and communication keys for the inter-gateway interaction and for gateway/command node message traffic Although the  gateway of a cluster would be responsible for the key management for the sensors in the cluster the keys still have to be generated by the command node Such arrangement facilitates recovery from a gateway compromise as explained later Each duster wi ll be assigned a set of distinct communication keys for data encryption Sharing the same  key among sensors in a cluster will enable selective decryption of data messages for the purpose of aggregation if instrumented in the network operation  Different communication keys will provide for sub-grouping of nodes within a cluster based on application criteria for example separation of concentS if different subgroups are tasked with different (sets of) functions Having more than one communication key within a cluster will not impact the number of administrative keys or the number of messages needed for re-keying as explained in Section 23 In follows that sub-grouping based on communication key assignment enables multi-granularity communications without impacting the EBS-based key administration structure The command node will periodically renew keys of the inter-gateway communication and gateway to sensor communication to counter potential on-going spoofing The following basic terminology is used for describing the key management protocol in the next subsections: Notation Description Gateway j Sensor i Total number of sensors Total number of sensors in c1usterj Gall CN GID ID_S Kai Kgej Kgg Ksgi � Loc_Sj E (K [data]) II All gateways Command node Gateway ID Sensor identifier Administrative keys for node i Key between gateway j & command node Keys for inter-gateway communication Key shared between sensor i and gateway Data key for the cluster of gateway j Location of sensor i Enc'YPtion fllDction of data with key K Concatenation operator 32 System Initialization and Operation At the time of deployment each gateway establishes connection with the command node The gateway broadcasts ann��cements of its ID encrypted with its Ksc Upon recelvmg the announcements from all gateways the command node will construct 1m EBS as explained earlier and send a message including tbe administrative keys known to the gateway and the conununication key used for inter­gateway communications to every gateway encrypted with its Omt Ks For a system with a few gateways it may suffice to assign a distinct administrative key to every gateway and use unicast for re-keying the gateways After establishing the c?mmand node to gateways and inter-gateway links sensor dIscovery starts with the command node sending each gateway the K" keys for all sensors in the region  We use the term network bootstrapping to designate the phase when gateways and sensors discover each other We envision that such bootstrapping will take the form of repeated sensors announcement of their location and 10 Each sensor announcement will be encrypted using its �B' Upon reception of one of the sensor announcements the gateway will decrypt the message and tabulate the sensor's ID and location It should be noted that the command node can even decide to limit its revelation of the Ks keys to only those sensors that are in the range of the gateway in order to increase the level of privacy in the network and limits the impact of any potential compromise of a gateway right after its deployment Alternatively the command node may decide to give each gateway only a subset of the sensor keys picked at random In such scenario the gateway has to broadcast the sensor announcements that it could not decrypt to other gateways or the command for decryption Justification of the added communication overhead to achieve an increase of system's security dtrring network bootstrapping is it design trade-off At the end of the bootslrapping phase each gateway will use its own list of reachable sensors and negotiate with the other gateways to form clusters Clustering can be based on many criteria such as strength of the radio signal the geographical proximity load balancing etc The clustering process ensures that each sensor will be uniquely assigned to only one cluster Next the gateway perfonns an analysis for defining the number of administrative keys needed for the 816 cluster As discussed earlier EBS offers tradeoffs with respect to the storage requirements and number of re-keying messages Depending on the size of the cluster and available memory in the sensor the gateway decides on the parameters It and m of an EBS For a large cluster it might be better to increase m to limit the storage requirements Another factor is the expected lifetime of a sensor and how risky the deployment area is Such a factor affects the frequency of sensor eviction It is advisable to increase the number of keys if sensor eviction rate is expected to be high in order to minimize re-keying traffic Upon' conclusion of such analysis the gateway sends a list of the identifications of the sensors of its cluster and asks the command node to generate a specific number of administrative keys The command node generates the required number of administrative keys 'and uses them to construct an EBS for the cluster The command node further assigns a unique administrative key combination to each sensor node in the cluster A message for each sensor node is then formed containing its designated combination of administrative keys the lD of the gateway and its designated set of communication keys The message is further encrypted using the Ke key of the particular sensor A distinct message is prepared for each sensor The command node concatenates all sensor messages and the cluster-specific communication keys in a long message The long message is further encrypted using the Kg key and forwarded to the gateway Upon receiving the long message the gateway will decrypt it and extract the cluster communication key and re-broadcast the sensor-specific portion of the message to the sensors of its clusters Again the gateway will not be able to decrypt the contents of the sensor messages and thus will never know the K  keys of the sensors of its cluster Each sensor will be able to decrypt only its designated message and start further interaction with the gateway For large clusters the lOIig message can be broken down This will increase the number of transmission In the extreme case sensors' messages can be sent from the command node to the gateway and finally to the sensor via unicast In case a sensor node is added to the network the gateways will decide among themselves on the cluster that the sensor should join Again the command node should be involved as explained earlier in infonning the sensor' about the ID of the gateway that the sensor should work with and the current cluster communication keys of the subgroups of which the node is a member Once the sensor knows its cluster the gateway will find an unused key combination in the EBS to assign it to the added sensor The gateway will then inform the sensor about the assigned administrative keys in a message encrypted using the cluster communication key In the unlikely case that there is no key combination available the gateway has to increase the nmnber of keys of re-keying messages for the cluster The reader is referred to [4] for description of expanding an EBS Such scenario is unlikely and can even be avoided during the assignment of the sensor to a cluster If the cluster does not have unused combination it should not get selected to host the added sensor The following summarize the initialization process assuming a single data encryption key per cluster: SYSTEM INITIALIZATION AND OPERATION Vj Gj  eN : E (Kgj [GlOj]) # Each gateway broadcasts ID to CN CN COnstruCt8 EBS Vj CN  Gj : E (Ksci [Ki Kg) # eN sends administrative and inter-gateway keys SENSOR DISCOVERY Vj CN -+ Gj : E (Ksci [Kstli Kss211   II KgJ) # Keys for all sensors in the region to each gateway NETWORK BOOTSTRAPPING Vi Sj  Gall : E (Ksg [Loc_ Sj IlIO_SiD # Every sensor announces its location and lD Sensor clustering K & m decided by gateway Vj Gj -+ CN : E (KsoJ [List ofID's of detected sensors]) eN generates Ka'8 EBS for every cluster Vi Sj  CN forms Mess;;;; E (Ksci [Kaill GIDII KwjD '<tj eN -0 Gj : E (Kgcj [Mess II Mess21l  11 Messnj II �) # CN broadcasts admin and data keys to every gateway : Mess; V 1 �i 5fIj 33 Handling Faulty or Compromises Nodes Revocation procedures are involved after detecting compromised or faulty nodes The gateway is responsible for monitoring sensor behaviorlheath and detecting a sensor failure or compromise The command node is expected to do the same for the gateway In this paper we assume that there is an appropriate intrusion detection mechanism employed at the command and gateway nodes We do not distinguish the handling of a failure and a compromise Node failure and compromise can be benign or malicious in nature and it may be hard to remotely diagnose whether it is an accidental failure or intentional attack From the key management point of view supporting revocation operations is sufficient If a sensor node is compromised it will be evicted from the cluster by the gateway The gateway will invoke the node eviction procedure of an EBS explained earlier The gateway will identify the keys that the compromised/faulty node knows and ask the command node for replacement keys Then the gateway will simply broadcast the new keys using the current administrative keys that the evicted sensor does not know Designating the command node as the only trusted key generation authority fa cilitates the recovery from a faulty or compromised gateway 817 The command node is responsible for the confJrnlation and handling a gateway failure or compromise The gateways can participate in the detection process [11]  However ultimately the command node has to make the decision for evicting a gateway Recovery from a gateway failure or a compromise has to achieve two goals The first goal is simply evicting the gateway from the communicating group Such a goal can be achieved using the EBS node eviction process similar to the sensor case It should be noted that gateway eviction requires changing the administrative keys at the gateway level and does not force re-keying for clusters with healthy gateways The second goal of the recovery is to hook up the sensor in the cluster of the faulty/compromised gateway to other clusters in order to avoid isolating these sensors That goal can be achieved by deploying a spare gateway or performing re-clustering We recognize that deploying a spare gateway in many applications may not be feasible In addition the placement of the spare gateway in the cluster has to ensure same sensor to gateway reachability pattern which cannot be guaranteed unless the spare gateway is deployed at the same location of the faulty/compromised one Such precise deployment can be unrealistic In addition if an adversary is present or can penetrate this location it is advisable to avoid such location Our approach for recovery relies on the other healthy gateways for identifying some of the isolated sensors for joining their clusters The healthy gateways will revisit their experience with the deployed sensors lit the bootstrapping phase and decide among themselves on the splitting of the isolated sensors among their clusters [lII- The next challenge is to inform these isolated sensors about the new arrangements The healthy gateways will infonn the command node with the new affiliation of these sensors The command node again will generate a new set of administrative keys for these sensors encrypted with the individual Ke of each individual sensor similar to the initialization phase The command node will forward these messages to the respective gateway which will send them out to the sensors On successfully decrypting the message the sensor knows that the message originated from the command node and hence discards messages from the evicted gateway and tunes its receiver to listen to the newly assigned gateway It also discards its previous communication keys and uses the new keys for future communication Keeping the secrecy ofKc of the sensors is very important to counter a compromise that makes the sensor unreachable   1n other word if a gateway knOM the K of a sensor an adversary can manipulate the gateway to continually change the keys of the sensors and keep them isolated from the network 4 Conclnsion In this paper we presented a lightweight method for key management in WSNs Our approach enables effici�nt key management at the various levels of the network hierarchy and facilitates the eviction and addition of nodes We use a flexible exclusion basis system for key generation and distribution Using' EBS allows trading off the storage requirements for storing keys and the communications overhead for re-keying Such flexibility is invaluable for the very resource constrained sensor nodes In addition our approach separates key management from secure communications reSUlting in efficient operation We further presented a mechanism for mcovery from a node failure or compromise  We cWTeotly are eValuating the overhead of security in terms of energy consumption Also we are investigating delegating the role of the command node in key management to the gateways in a distributed fashion An open problem is to integrate a lightweight intrusion detection mechanism to detect compromised nodes Acknowledgement: Supported in part by grant #SE 200 I-01 from the Commonwealth Technology Research Fund The authors would also like 1:0 thank Dr Sushil Jajodia at George Mason University for his valuable feedback References [1] I F Akyildiz el al "Wireless sensor networks: a survey" Computer Networks yot 38 pp 393-4222002 [2] P Bahl et al "PAWNs: satisfYing the need for ubiquitous secure connectivity and location services" IEEE Wirekss CommunicQtions Vol 9 No I February 2002 [3J G J Pottie and W 1 Kaiser "Wireless integrated network sensors" Communications of the ACM Vol 43 No 5 pp 51 - 58 May 2000 [4J M Eltoweissy H Heydari L Morales and H Sudborough "Combinatorial Optimization for Key Management in Secure Multicast Environments" Journal of Network and System Management K1uwer Publishing 2004 [5J D ClIIlIIan P Kruus and B Matt "Constraints and Approaches for Distributed Sensor Networks Security" NAI Technical Report #00-0 I 0 Sep 2000 [6] TinySec bttp:/IwwwcsberkeleyeduJ-nksltinvsec{ [7J L Eschenauer and V Gligor "A Key Management Scheme for Distributed Sensor Networks" Proceedings of the 9th ACM Conference 00 Computing and Communication Security Nov 2002 [8J H Chan A Perrig and D Song "Random Key Pre­distribution Schemes for Sensor Networks" Proceedings of IEEE 2003 Symposium on Security and Privacy Berkeley CA May 2003 [9] G Jolly et aI "A Low-Energy Key Management Protocol for Wireless Sensor Networks" in the PrOf;eedings of the Ef' IEEE Symposium on Computers and Communications (lSCC'2003) Antalya Turkey June 2003 (to appear) [10) C Lin M Gerla "Adaptive clustering for mobile wireless networks" IEEE Journal On Selected Areas of Communications Vol IS No7 1997 [11)G Gupta and M Younis "Fault-Tolerant Clustering of Wireless Sensor Networks" in the Proceedings of the IEEE Wireless Communication cznd Networks Conference (WCNC 2003) New Orleans LouisillIla March 2003 (121M Horton et at "Mica: The commercialization of microsensor motes" Sensors Online Magazine April 2002 htto:flwwwsensorsmagcom/articlesf0402l4Qfmainshtml 818 
Location aware-Probability Distribution-pdf,Location-aware Key Management Scheme for WirelessSensor NetworksDijiang Huang Manish Mehta Deep Medhi Lein Harn{dh7eemmmef7dmedhiharnl}@umkceduUniversity of Missouri-Kansas CityABSTRACTSensor networks are composed of a large number of lowpower sensor devices For secure communication amongsensors secret keys must be established between them Re-cently several pairwise key schemes have been proposed forlarge distributed sensor networks These schemes randomlyselect a set of keys from a key pool and install the keys inthe memory of each sensor After deployment the sensorscan set up keys by using the preinstalled keys Due to lackof tamper-resistant hardware the sensor networks are vul-nerable to node capture attacks The information gainedfrom captured nodes can be used to compromise communi-cation among uncompromised sensors Du et al [1] Liu andNing [2] proposed to use the known deployment informationto reduce the memory requirements and mitigate the conse-quences of node capture attack Our analysis shows that theassumption of random capture of sensors is too weak An in-telligent attacker can selectively capture sensors to get moreinformation with less efforts In addition to selective nodecapture attack all recent proposals are vulnerable to nodefabrication attack in which an attacker can fabricate newsensors by manipulating the compromised secret keys andthen deploy the fabricated sensors into the sensor systemTo counter these attacks we propose a grid-group schemewhich uses known deployment information Unlike the pair-wise key scheme using deployment information proposed byDu et al we uniformly deploy sensors in a large area; in-stead of randomly distributing keys from a large key poolto each sensor we systematically distribute secret keys toeach sensor from a structured key pool Our performanceanalysis shows that our scheme requires less number of keyspreinstalled for each sensor and is resilient to selective nodecapture attack and node fabrication attackCategories and Subject DescriptorsC20 [Computer-communication networks]: General—Security and protectionPermission to make digital or hard copies of all or part of this work forpersonal or classroom use is granted without fee provided that copies arenot made or distributed for profit or commercial advantage and that copiesbear this notice and the full citation on the first page To copy otherwise torepublish to post on servers or to redistribute to lists requires prior specificpermission and/or a feeSASN’04 October 25 2004 Washington DC USACopyright 2004 ACM 1-58113-972-1/04/0010 $500General TermsDesign SecurityKeywordskey management sensor networks probabilistic key sharing1 INTRODUCTIONSensor networks are composed of a large number of low-power sensor devices Typically these networks are installedto collect sensed data from sensors deployed in a large areaSmartDust [3] and WINS [4] are examples of sensor networkprojects Within the networks sensors communicate amongthemselves to exchange data and routing information Sincethe sensor networks are usually deployed in unattended oreven hostile environments (such as battle fields) the sensornetworks are vulnerable to various kinds of active and pas-sive attacks on the communication protocols This demandssecure communication among sensorsWe define a secure channel or link as as a channel throughwhich two nodes can communicate with each other using asecret key The secure channel is said to be compromisedif an attacker can compromise the secret key Since thelow-power sensor devices have very limited computationalpower the symmetric-key systems are preferred to establishsecure channels As specified in [5] the number of sensornodes deployed in studying a phenomenon may be on theorder of hundreds of thousands Depending on the appli-cation the number may reach an extreme value of millionsDue to inherent storage constraints it is infeasible for a sen-sor device to store a unique shared key value for every othersensor in the system One na¨ıve solution to use a commonkey between every pair of sensors can overcome the storageconstraints but it offers weak security Since if one node iscompromised the entire system is compromised RecentlyRandom Key Predistribution (RKP) schemes have been pro-posed [6 7 8 9 10] for large-scale distributed sensor net-works These schemes randomly select a set of keys from alarge key pool and install the keys in the memory of eachsensor After deployment the sensors can set up keys byusing the preinstalled keys Since the RKP schemes requirelimited number of keys preinstalled in the sensors a sensormay not share a key with all of its neighbors In this casea Pairwise Key Establishment (PKE) scheme is required toset up a shared key with every neighborIn current RKP schemes the analyses of the securitystrength are done on the basis of number of communicationlinks that can be compromised due to compromised sen-29sors in the network In other words the schemes considerprobable use of the keys exposed due to captured sensorsin non-compromised parts of the network This attack iscalled node capture attack Also the current schemes con-sider random capture of nodes in the deployment regionTo mitigate the random node capture attack Du et al [1]and Liu and Ning [2] proposed using deployment informa-tion (sensor location information) to improve the resilienceto node capture attack However in practice the open orhostile deployment environment of sensor networks makes iteasier for attackers to locate and selectively capture sensorswhich can provide more information for attackers to attackthe sensor networks In addition due to lack of node au-thentication attackers can easily fabricate nodes by usingthe secrets preinstalled in the captured nodeIn this paper we propose a new scheme called Grid-groupdeployment scheme This scheme utilizes merits from both[1] and [2] Similar to [1 2] a sensor deployment area ispartitioned into multiple small square areas (zones) and thesensors deployed in each zone form a group In the keypredistribution phase using the unconditionally secure andλ-collusion resistant properties of the group keying schemeproposed in [11] we utilize the key predistribution schemeproposed in [8 9] to distribute keys for the sensors in eachzone; for each sensor we select a sensor in each of its adja-cent zones and assign a unique key to them (the selectionof the pair of sensors is based on the mapping between theunique node IDs assigned to the sensors; the technical de-tails are presented in Section 422) After the deploymentof sensors each sensor first sets up pairwise keys with allits neighbors within its zone; then it sets up pairwise keywith its neighbors located in adjacent zones Comparingwith previously proposed schemes our approach is resilientto selective node capture attack and node fabrication attackOur main contributions in this paper are as follows:• We point out the weak assumption of random captureof nodes in current RKP schemes and introduce selec-tive attack on RKP schemes In particular we showthe importance of selective attack in RKP schemesthat use deployment information• We point out the node fabrication attack on currentRKP schemes and countermeasures for the same• We propose a new RKP scheme called Grid-group de-ployment scheme which is based on current schemesand deployment information Further this scheme isresilient against the introduced selective attack andnode fabrication attack• Our proposed scheme reduces the number of keys pre-installed in each sensorThe rest of the paper is organized as follows: In section 2we provide the background of RKP schemes in sensor net-works We introduce attacks on current schemes in section 3Section 4 describes our proposed scheme The sensor areacoverage analysis for the proposed scheme is given in sec-tion 5 In section 6 we analyze the key graph connectivitybased on our proposed scheme The Pairwise Key Estab-lishment protocol is presented in section 7 A performanceanalysis addressing storage requirements security commu-nication overhead and computation overhead is given in sec-tion 8 Section 9 provides summary and future work2 BACKGROUND OF RANDOM KEY PRE-DISTRIBUTION SCHEMESIn this section we review Purely Random Key Predis-tribution (P-RKP) schemes [6 7] and Structured Key-poolRandom Key Predistribution (SK-RKP) schemes [8 9]21 The Phases in Random Key Predistribu-tion SchemesWe present the main phases for random key predistribu-tion schemes [6 7 8 9] as follows:1 Key predistribution phase: A centralized key servergenerates a large key pool offline The procedure foroffline key distribution is as follows: 1 Assign a uniquenode identifier or key ring identifer to each sensor 2Select m different keys for each sensor from the keypool to form a key ring 3 Load the key ring into thememory of the sensor2 Sensor deployment phase: The sensors are randomlypicked and uniformly distributed in a large area Typ-ically the number of neighbors of a sensor (n′) is muchsmaller than the total number of deployed sensors (N)3 Key discovery phase: During the key discovery phaseeach sensor broadcasts its key identifiers in clear-textor uses private share-key discovery scheme1 to discoverthe keys shared with its neighbors By comparing thepossessed keys a sensor can build the list of reachablenodes with which share keys and then broadcast itslist Using the lists received from neighbors a sensorcan build a key graph (see Definition 1) based on thekey-share relations among neighbors4 Pairwise key establishment phase: If a sensor shareskey(s) with a given neighbor the shared key(s) canbe used as their pairwise key(s) If a sensor does notshare key(s) with a given neighbor the sensor uses thekey graph built during key discovery phase to find akey path (see Definition 2) to set up the pairwise keyThe set of all neighbors of sensor i is represented by WiThe definition of key graph is given as follows:Definition 1 (key graph) A key graph maintained bynode i is defined as Gi = (Vi Ei) where the vertices set Vi ={j|j ∈Wi∨j = i} the edges set Ei = {ejk|j k ∈Wi∧jRk}R is a relation defined between any pair of nodes j and k ifthey share required number of key(s) after the key discoveryphaseThe definition of key path is given as follows:Definition 2 (key path) A key path between node Aand B is defined as a sequence of nodes A N1 N2  Ni B such that each pair of nodes (AN1) (N1 N2)   (Ni−1 Ni) (Ni B) has required number of shared key(s) af-ter the key discovery phase The length of the key path isthe number of pairs of nodes in it1Specified in [6] using private share-key discovery for everykey on a key ring each node could broadcast of list αEKi(α) i = 1     k where α is a challenge The decryp-tion of EKi(α) with the proper key by a recipient wouldreveal the challenge α and establish a shared key with thebroadcasting node3022 Purely Random Key Predistribution (P-RKP) SchemesFor current P-RKP schemes the phases presented in Sec-tion 21 can be applied without any change There are twocharacteristics of P-RKP schemes First the m keys pre-installed in a sensor can also be installed in other sensorsThat is a key can be shared by more than one pair of sen-sors Second in most of current schemes there is no rela-tion between the set of preloaded keys and the sensor idA recent solution proposed by Pietro et al [12] attempts todefine this relation However the scheme is not scalable inthat the size of the network is restricted by a function ofnumber of preinstalled keys23 Structured Key-pool Random Key Predis-tribution (SK-RKP) SchemeUnlike in P-RKP schemes in SK-RKP scheme each sen-sor is preloaded with a unique set of keys in its memoryThe key discovery is not simply finding a shared key withthe neighboring sensor but using a set of polynomial vari-ables (constructed by the keys possessed by the sensor) toderive the shared key In addition the key id can serveas the sensor id which is linked to the set of preinstalledkeys This link can prevent the attackers from misusing thesensors’ ids In the following paragraphs we give a briefdescription of structured key pool schemeThe SK-RKP scheme uses the key predistribution schemeproposed by Blom [13] This scheme allows any pair of nodesin a network to find a pairwise key in a secure way as longas no more than λ nodes are compromised The scheme isbuilt on two matrices: a publicly known matrix G of size(λ + 1) × N ; a secret matrix D of size (λ + 1) × (λ + 1)created by key distribution center The matrix A of sizeN × (λ + 1) is then created as A = (D · G)T  Each row ofA is the keys distributed to a group member and the rownumber can serve as a sensor’s id Since K = A · G is asymmetric matrix nodes i and j can generate a shared key(Kij or Kji) from their predistributed secrets where Kij isthe element in K located in the ith row and jth columnA key pool is constructed by many key spaces representedby A(t) where t = 1     ω Each sensor randomly selectsτ key spaces out of ω key spaces where τ < ω If sensor kselects key space A(t) the kth row of A(t) and kth columnof G are preinstalled in the sensor (note that the G matrixis unique) The SK-RKP scheme has following properties:• Once two nodes i and j have keys presinstalled fromthe same key space A(t) they can derive a shared keyK(t)ij = K(t)ji • If x rows of a key space A(t) are predistributed to xsensors and x ≤ λ any subset of the x sensors cannotcollude to derive the secrets in other sensors• The id of a sensor is represented by the row numberof the key matrix A No other sensor can impersonatethis sensor since the row of A is uniquely distributedto this sensorThe technical details refer to [8 9]3 ATTACKS ON RANDOM KEY PREDIS-TRIBUTION SCHEMESThe proposed P-RKP schemes and SK-RKP schemes haveseveral limitations which make them vulnerable to attacksSince sensors are low-cost devices and operate in unattendedenvironment for many applications they cannot be con-sidered tamper-resistant We make following assumptionsabout capabilities of the attacker• The attacker has unlimited energy and computing power• The attacker knows all the information stored in a sen-sor once the sensor is captured• The attacker can listen and record all the traffic in thenetwork• The attacker has ability to physically locate a givensensor by listening to the traffic• The attacker has ability to fabricate similar nodes anddeploy them31 Selective Node Capture AttackIn all current RKP proposals the sensors are assumed tobe captured randomly But in practice the random captureassumption is too weak The attacker can purposely attackcertain area or a group of sensors possibly located closerto each other Thus an attacker can purposely locate asensor and compromise the sensors which can give him moreinformation about the sensor network For example in P-RKP scheme each sensor broadcasts its key ring id (thekey list) An attacker can selectively compromise a sensorthat possesses the most number of keys that are not alreadycompromisedWe model the selective attack by using the heuristic tech-nique In the following presentations x is the number ofcompromised sensors Cx is the cardinality of the set of com-promised keys when x nodes are compromised P is the sizeof the key pool m is the number of keys preinstalled ineach sensor N is the total number of sensors deployed inthe network and k is a variable We use B to represent thethreshold that an attacker is to inspect and then to decidewhich sensors to capture next The mathematical model ofselective attack is presented as follows:B =P−Cxm−k Cxk Pm (N − x) (k = 0    m) (1)where P−Cxm−k(Cxk )( Pm )is the probability that there exist un-compromised nodes and each of them has m − k keys notalready compromised; N − x is the total number of uncom-promised nodes in the systemThe heuristic method is described as follows Initiallywhen k = 0 an attacker can arbitrarily capture a sensorand derive m keys preinstalled in the captured sensor andCx = m Then he inspects the B: if B ≥ 1 he contin-uously captures the nodes with m − k keys that are notalready compromised and for each capture Cx is increasedby m−k; if B < 1 he increases k by 1 until B ≥ 1 He thencaptures the sensors with m − k keys that are not alreadycompromised The attacker continues this process until the3150 100 150 200 250 30000102030405060708091Number of compromised nodesSA q−composite q=3SA q−composite q=2SA Basic schemeRA q−composite q=3RA q−composite q=2RA Basic schemeFraction of compromised links among uncompromised nodes(a) Selective attack on P-RKP schemes (m = 100 p1 = 0423N=10000; basic scheme P = 28140; q-composite schemewhen q = 2 P = 9120 when q = 3 P = 5220)1725 50 100 150 200 250 30000102030405060708091Number of compromised nodesFraction of compromised links among uncompromised nodesSA−ST ω=71τ=6SA−ST ω=32τ=4SA−ST ω=8τ=2RA−ST ω=71τ=6RA−ST ω=32τ=4RA−ST ω=8τ=2(b) Selective attack on SK-RKP schemes (m = 100 p1 =0423 N=10000)Figure 1: Selective attack on RKP schemescondition m = k is fulfilled or the entire key pool is compro-mised The condition B > 1 means there exists uncompro-mised sensor that has m− k keys that are not already com-promised Figure 1(a) shows the comparison between theselective-node-capture attack (SA) and random-node-captureattack (RA) on the P-RKP schemes It might be note thatin this figure the size of key pool P is computed basedon the key graph connectivity probability presented in [14]and p1 is the probability that two sensors share at least onekey during the key discovery phase Our studies show thatthe selective node capture attack can gain more informationthan random node capture attack with the same number ofcaptured sensorsIn SK-RKP scheme the attacker can selectively capturethe sensors that possess keys within the same key spaceOnce λ+1 sensors with preinstalled keys from the same keyspace are compromised all the keys allocated from the samekey space are compromised Thus an attacker can incre-mentally compromise the sensors that use same key spaceIn this way the attacker can compromise all the key spacesone-by-one Since sensors have keys from more than one keyspace preinstalled the number of sensors required to be cap-tured to compromise the subsequent key spaces is smallerFigure 1(b) shows the SK-RKP scheme [8 9] under SA andRA with m = 100 p1 = 0432 This figure shows that un-der selective attack the robustness (threshold) of SK-RKPscheme against node capture attack decreases dramaticallyIn the example the threshold values under SA are: 17 withω = 71 τ = 6; 25 with ω = 32 τ = 4; 50 with ω = 8 τ = 2The relation between the τ and the threshold is: the smallerthe τ  the higher the initial threshold That is with τ = 2we can maximize the initial threshold32 Active Attack: Node Fabrication AttackThe proposed P-RKP and SK-RKP schemes are all vul-nerable to node fabrication attack We describe the nodefabrication attack as follows: in this attack the attackercompromises only few sensors and uses the captured keys tofabricate sensors with identities of uncompromised sensorsor fabricate sensors with new identities Then the attackercan deploy the fabricated nodes in the parts of the networkwhere the original node is not present The uncompromisedsensors in the network cannot detect the fabricated nodesas anomalous nodes as long as they can have standard com-munication with them This attack is severer as comparedto passive listening attacks as the attacker may have enoughinformation to fabricate many sensors with many differentidentities and possibly outnumber the original set of sensorsThe attacker can launch the node fabrication attack onP-RKP schemes [6 7] by capturing only two sensors Sincethere is no id authentication by using P-RKP scheme bycapturing two nodes the attacker can fabricate and deploy 2mmnew nodes without being detected These fabricatednodes are apparently good nodes since they all have validkeys Thus the fabricated nodes can quickly outnumber theuncompromised nodesSK-RKP scheme is also vulnerable to node fabrication at-tack However there are few restrictions for the attackerFirst an attack requires to capture more than λ sensors inorder to compromise a key space Second an attacker can-not arbitrarily generate new ids for the fabricated sensorssince the ids indicate the rows of the secret matrix A pos-sessed by the sensors A wrong id will not guarantee thata fabricated sensor can set up a pairwise key with uncom-promised sensors Thus by restricting the distribution ofthe number of rows of a secret matrix A to λ we can pre-vent the node fabrication attack Our scheme described inthe next section uses this technique The previous propos-als [8 9] cannot fulfil this requirement with relatively smallλ to support a large sensor system with typically 1000 to10000 sensors Since in our scheme we restrict the size ofdeployment region by partitioning it into multiple zones therequired network size for each zone becomes smaller and wecan prevent node fabrication attacks by using the technique320 10 20 30 40 50 60 70 80 90 100050100150200250300350400450λ ω=9 τ=2 p1=04167ω=8 τ=2 p1=04643ω=7 τ=2 p1=05238ω=6 τ=2 p1=06Number of sensors in a zone (n z)Figure 2: Relation between λ and the number ofsensors deployed in a zone (nz) and m = 100discussed above Figure 2 shows the relation between thevalue of λ and supported size of network for each zone (nz)4 GRID-GROUP DEPLOYMENT SCHEMEIn this section we present our grid-group deploymentscheme and the key predistribution schemes used for thesameFor our scheme we assume that the target deploymentarea is a two-dimensional rectangular region with the size(i · a)× (j · a) square meters The rectangular region can befurther divided into (i·j) deployment areas each of size a×asquare meters In this paper we denote each small deploy-ment area as zone Z(i j) where Area(Z(i j)) = a2 Anexample of deployment region is shown in Figure 3 wherei = j = 6 We use G(i j) to denote the group of sensorsdeployed in zone Z(i j) We assume that the sensors areuniformly distributed over the deployment region and foreach group the number of sensors in the group is nz Wedenote the total number of sensors in the whole deploymentregion by N  Thus we have N = nz · i · j A sensor isidentified by [(i j) b] where (i j) is the group id and b isthe unique node id of a sensor (b = 1     N)41 Sensor Deployment MethodThe sensor deployment method is given as follows:• Partition N sensors into i · j groups with nz sensors ineach group• Assign the identifier [(i j) b] to each sensor in theG(i j) where b = 1    N • Assign m keys to each sensor in group G(i j)2• Uniformly distribute the sensors for the group G(i j)in zone Z(i j)2The key-assignment is presented in Section 4242 Key Predistribution SchemesThe value (i j) is used to identify a group or zone Weuse the superscripts + and − with i and j to denote theneighboring groups or zones For example G(i+ j) = G(i+1 j) is a neighboring group of G(i j) We propose two keypredistribution schemes according to the group relationsThe key predistribution scheme used within a group is calledI-Scheme and the key predistribution scheme used betweentwo neighboring groups is called E-Scheme421 I-Scheme: key predistribution within a givenzoneWe use the scheme specified in Section 23 for our I-Scheme To achieve the non-colluding3 property We setthe following restrictions:• τ = 2 this maximizes the initial node capture thresh-old (refer to Figure 1(b))• No more than λ sensors are allowed to choose a givenkey space• As a result of the first two restrictions we restrict thenumber of sensors in each group nz to |G(i j)| ≤λω/τ As shown in Figure 1(b) for a fixed value of m=100 thenumber of keys preinstalled in each sensor the smaller theτ  the higher the initial node capture threshold The initialthreshold is computed as m/τ  For example for τ = 2ω = 8 and m = 100 the initial threshold is 50 Since τ = 2gives the highest initial threshold In this paper we considerτ = 2 for our analysisFor each key space the secret matrix A = (D · G)T is aN × (λ + 1) matrix If an attacker has knowledge of morethan λ rows the entire matrix A can be derived Thus toimprove the survivability of the sensor system we restrictthe number of rows of matrix A distributed to sensors to λAs a consequence of the previous restrictions the numberof sensors deployed in each zone is restricted to |G(i j)| ≤λω/τ  Figure 2 shows the relation between |G(i j)| and λBased on above discussion we propose the following keypredistribution scheme (I-Scheme) for the sensors locatedwithin the same zone as follows:1 The key pool P is composed by P = L ×M sub-keypools (a sub-key pool is represented as P(i j) wherei = 1     L j = 1    M) Each sub-key pool isdivided into ω sub-key spaces A sub-key space is aN × (λ + 1) key matrix A Each element of A is aunique key2 Divide the N sensors in L×M groups (a group is rep-resented by G(i j) where i = 1     L j = 1    M)3 Assign unique identifiers to the sensors For each sen-sor assign the id = [(i j) b] where (i j) is the groupid and b = 1     N 3The non-colluding feature of the proposed pairwise keyscheme is described as follows: for all pairwise key Kij ∈ Pwhere Kij is the pairwise key that can be derived from thesecrets possessed by sensors si sj ∈ S all sensors in the setS \ {si sj} cannot derive the pairwise key Kij  S is the setof all sensors deployed in the system33ij(11)112233445566(12) (13) (14) (15) (16)(21) (22) (23) (24) (25) (26)(31) (32) (33) (34) (35) (36)(41) (42) (43) (44) (45) (46)(51) (52) (53) (54) (55) (56)(61) (62) (63) (64) (65) (66)aaaaaaa a aa a aFigure 3: Sensor deployment in a grid structure4 For sensor [(i j) b] randomly select τ sub-key spacesfrom ω sub-key spaces in P(i j) while making surethat the selected sub-key space is not already selectedλ times Load the sensor with the bth row of matrix Afor each sub-key space selected422 E-Scheme: keys predistribution for two adja-cent zonesAs shown in Figure 3 a zone can have the maximum of8 neighboring zones; eg the bidirectional arrows shownaround zone Z(3 3) Our key predistribution scheme (E-Scheme) for sensors in two adjacent zones is given as follows:1 For a sensor i in group G(i1 j1) randomly select onesensor say j from one of its neighboring groups sayG(i2 j2) Groups G(i1 j1) and G(i2 j2) are neighborsif |i1 − i2| ≤ 1 or |j1 − j2| ≤ 12 Install duple < kij  idj > in i and duple < kij  idi > inj where key kij is unique and idi idj are the identifiersof node i j respectively Once node i select a peer nodej in group G(i2 j2) it cannot select another node inthe same group3 If all sensors have selected a node in each of its neigh-boring groups stop; otherwise goto step 15 AREA COVERAGE ANALYSISIn this section we study the area coverage of a sensorwithin the same zone and in the neighboring zones Ouranalysis is based on the following assumptions:• All our analysis is based on a two-dimensional Carte-sian plane A zone is represented by an area x ∈[0 a] y ∈ [0 a] where (x y) is a point in the two-dimensional Cartesian plane• All sensors have equal communication radius R andhence cover the same size of area where R ≤ a/2In our analysis we assume R = 40 meters a = 100meters• The sensors are uniformly distributed in a deploymentregion and the average number of neighbors for each0 10 20 30 40 50 60 70 80 90 10001020304050607080901001515151520202020252525252525253030303030303030353535353535354040404040404545454545Z(i−1j) Z(i−1j−1) Z(ij−1) Z(i+1j−1) Z(i+1j) Z(i+1j+1) Z(ij+1) Z(i−1j+1) 50 50 50 50 Figure 4: Contour curves for average number ofneighbors within the same zone (n′ = 50 nz = 100)sensor is n′ The density of the deployed sensors isρ = n′πR2According to the assumption presented above the numberof deployed sensors within each zone is nz = a2ρ ≈ a2n′πR2£51 Sensor Coverage – within the Same ZoneWe present the coverage of sensor [(i j) b] in its zoneZ(i j) in this section Given a position (x y) for sensor[(i j) b] the sensor coverage is given as follows:Cb(i j)|(xy) =C1b (i j)|(xy)  0 ≤px2 + y2 ≤ RC2b (i j)|(xy)  R <px2 + y2 ≤ a/2The expressions for C1b (i j) and C2b (i j) along with theproofs are given in Appendix A From the above resultsthe number of neighbors of sensor [(i j) b] within the zoneZ(i j) is given as:Nb(i j) = ρ · Cb(i j) (2)Where Nb(i j) is the number of neighbors of sensor [(i j) b]within the zone Z(i j) In Figure 4 we show the contourcurves of the average number of neighbors of sensor [(i j) b]within the zone Z(i j)52 Sensor Coverage – in Different ZoneIn Figure 4 we show that there are 8 possible zones sur-rounding zone Z(i j) We use superscripts + and − to rep-resent the area coverage and sensor coverage between twoneighboring zones For example Cb(i+ j−) and Nb(i+ j−)represent the area coverage and sensor coverage of sensor[(i j) b] in zone Z(i + 1 j − 1) Similarly Cb(i j−) andNb(i j−) represent the area coverage and sensor coverage ofsensor [(i j) b] in zone Z(i j − 1)The representations and proofs of neighboring zone cov-erage Cb(i j−)|(xy) Cb(i+ j−)|(xy) and Cb(i+ j)|(xy) aregiven in Appendix B In summary the number of neighborsthat node [(i j) b] covers in a neighboring zone is given as:Nb(i∗ j∗) = ρ · Cb(i∗ j∗) (3)where * represents - + or none346 KEY GRAPH CONNECTIVITYIn this section we present the Key Graph connectivityanalysis for sensors located within the same zone and inadjacent zones61 Key Graph Connectivity within the SameZoneThe number of keys preinstalled in each sensor is repre-sented by m According to the deployment pattern shownin Figure 3 we select a unique key pool for each zone ieP(i j) for Z(i j)To determine the size of key pool |P(i j)| and the num-ber of keys selectedm from the key pool for sensor [(i j) b]we use the equations of P-RKP scheme proposed by Es-chenauer and Gligor [6] and further modified for SK-RKPscheme by Du et al [9]p1 = 1− ωτ ω−ττ ωτ2= 1− ((ω − τ)!)2(ω − 2τ)!ω! (4)Here p1 is the probability that given two sensors share atleast one key Eschenauer and Gligor [6] proposed an ap-proximate method to compute key graph connectivity Ourpreliminary studies show that this approach does not workwell when the neighborhood size of a sensor is small Wederive the key graph connectivity by using binomial prob-ability distribution and modified binomial probability dis-tribution in a heuristic hop-by-hop fashion The key graphconnectivity probability is presented in [14]Since we assume that the sensors are uniformly distributedwithin a zone the closer the sensor to the center of the zonethe more the neighbors within the same zone for the sensorThus the key graph connectivity will only be consideredas the key graph created by the sensors within the samezone For sensor [(i j) b] in zone Z(i j) the number ofneighbors within its zone is Cb(i j) As shown in Figure 4if the average number of neighbors of a sensor n′ is 50the zone has total of nz = (n′a2)/(πR2) sensors and thereare approximately 11 nodes in the zone with less than 25neighbors from the same zoneIf we assume the number of neighbors of a sensor is 25 us-ing the key graph4 connectivity presented in [14] we derivethe probability p1 = 05 When p1 ≥ 05 the key graph isconnected with probability greater than 0996 within threehops In the worst case the sensor is located at the cor-ner of the square area and has approximately 12 neighborswithin the same zone In this case the probability thatthe key graph is connected within five hops is 08736 andon average there are only 01483 neighbors that can not bereached within five hops If there exist unreachable nodesa sensor can just simply send requests to is neighbors whichhave more than 25 neighbors to set up the pairwise keysA neighbor with more than 25 neighbors can be identifiedfrom the neighbor-list broadcasted during the key discoveryphase Since we know that a sensor with 25 or more neigh-bors can set pairwise keys with all its neighbors it can helpto set up the pairwise key when they all within each other’scommunication range In Section 71 we will discuss howa sensor sends requests to its neighbors for pairwise key setup within the same zone4Here the key graph is composed by only the sensors withinthe same zone62 Key Graph Connectivity between Two Ad-jacent ZonesThe node [(i j) b] may be located close to the boundaryof two neighboring zones Z(i j) and Z(i∗ j∗) The numberof neighbors of node [(i j) b] located within these two zonescan be represented by Nb(i j) and Nb(i∗ j∗) Node [(i j) b]is considered to be connected to the neighboring zone as longas it can find at least one neighbor b′ located in Cb(i j)who shares a key with at least one of nodes b′′ located inCb(i∗ j∗) The pairwise key establishment protocol betweentwo adjacent zones is described in Section 72 Thus using(2) and (3) we can derive the probability p(i∗ j∗) that sen-sor [(i j) b] can connect to the neighboring zone with thehelp of all its neighborsp(i∗ j∗) = 1−nz −Nb(i j)Nb(i∗ j∗) nz −Nb(i∗ j∗)Nb(i j)nzNb(i∗ j∗) nzNb(i j) (5)Note that (2) and (3) are derived from Cb(i j) and Cb(i∗ j∗)which are the functions of two-dimensional Cartesian co-ordinates with the position (x y) Thus p(i∗ j∗) is thefunction of (x y) Using the (5) we draw the probabil-ity contour curves that a node in Z(i j) can connect to itsneighboring zones Z(i j−) and Z(i+ j−) with parametersa = 100mR = 40mn′ = 50 nz = 100 in Figure 5(a)7 PAIRWISE KEY ESTABLISHMENT PRO-TOCOLOur key establishment protocol5 consists of two phases:1 the key establishment within a given zone 2 the keyestablishment between adjacent zones71 Key Establishment within the Same ZoneThe key establishment within the same zone is the firstphase after deployment of the sensors In this phase eachsensor attempts to establish pairwise keys with all its neigh-bors within the same zoneIn our scheme each sensor say [(i j) b] initiates thisphase by broadcasting its identifier [(i j) b] and its key spaceidentifiers [τ1 τ2] Based on the received ids and correspond-ing key spaces a sensor builds a key graph with ids of allthe neighbors as vertices For each of the neighbors say[(i j) u] the sensor checks if they share the same key spaceIf they do share a key space they can derive the pairwisekey Kbu using the key agreement method presented in Sec-tion 23 The node [(i j) b] will then add a link betweenitself and node [(i j) u] in its key graphAfter receiving the identifiers from all neighbors and addinglinks in the key graph for the neighbors with shared keyspace the sensor broadcasts a list of neighbors who sharekey space with it After receiving the same type of list fromthe neighbors each sensor updates its key graph by addingedges between vertices according to the received neighbor-list Finally based on the derived key graph the sensor canuse source routing by explicitly specifying the key path (inhop-by-hop fashion) to send request and establish pairwisekeys with all its remaining neighbors5Due to page limits in this paper we only present an outlineof the key establishment protocol The detailed protocol willbe covered in our following papers350 5 10 15 20 25 30 35 400510152025303540RR01010203030404050607070808090101010102020203030304040405050506060607070708080909Z(i+j−) Z(ij−) (a) Probability contour curves to zone Z(i+ j−)and zone Z(i j−) with q=10 5 10 15 20 25 30 35 400510152025303540RR3332222211111Z(i+j) Z(i+j−) (b) Connectivity contour curves to the neighbor-ing zone Z(i+ j−) and zone Z(i j−) with q=12 3 pqˆ(i∗ j∗) = 08Figure 5: Connectivity between two adjacent zones (a = 100mR = 40mn′ = 50 nz = 100)There may be a few nodes that may not be able to set uppairwise keys to all its neighbors within a given zone (egthe node are located outside of 25 curve line in Figure 4)In Section 61 we present the analysis that this probabil-ity is small Even if there exist nodes that cannot set uppairwise keys with its neighbors they can refer to the nodeswho have already set up the pairwise keys with all its neigh-bors within the same zone These nodes are usually locatedaround the high numbered contour curves For example ifour selected thresholds ω and τ can fulfil the requirementthat a node with 25 or more neighbors can set pairwise keyswith all its neighbors the nodes locate around 25 curve linecan set up links to every node within its communicationrange which includes the nodes located outside the 25 curveline Now these node can serve as the intermediate nodes(or proxy) to set up the pairwise keys A node can send re-quests to its neighbors with more than 25 neighbors withinthe same zone If the node has a link to the requested des-tination it selects a pairwise key and encrypts it using thealready set up pairwise keys with the source and destina-tion The source (a requestor) can send multiple requeststo its neighbors and it may receive multiple responses Inthis case the source and destination node can exclusive-orall received keys and use the result as their pairwise keyThis arrangement improves security A neighbor with morethan 25 neighbors can be identified from the neighbor-listbroadcasting during the key discovery phase72 Key Establishment between AdjacentZonesAfter the first phase of key establishment a sensor sets uppairwise keys with all its neighbors within the same zoneThen the system goes into the second phase of key estab-lishment to set up pairwise keys with nodes located in theadjacent zonesWe described the key predistribution scheme for two ad-jacent zones (E-Scheme) in Section 422 When a sensorwants to set up keys with its neighbors in the adjacent zonesit broadcasts the desired node list A neighbor of the re-questor within the same zone who already shares a key withthe nodes in the requestor’s list acts as a proxy and does thefollowing: 1 selects a pairwise key for the pair 2 encryptsthe selected pairwise key using the pairwise key already setup between itself and the requestor and the pairwise keyalready shared between itself and the destination node 3sends the two encrypted messages to the requestor Uponreceiving the response the requestor will forward the en-crypted pairwise key to the destination Figure 5(a) showsthe contour curves of the probabilities that a node in Z(i j)can connect to its neighboring zones Z(i j−) and Z(i+ j−)Since during the first phase nodes have already set up pair-wise keys to all their neighbors within the same zone duringthe second phase as long as there exists one node with a linkto the neighboring zone it can be used as a bridge to set uppairwise keys to the neighboring zone for all its neighborsThe probability that a node can connect to neighboringzones with the help of exactly k neighbors is given as follows:pk(i∗ j∗)=nzknz −Nb(i j)Nb(i∗ j∗)− k nz −Nb(i∗ j∗)Nb(i j)− knzNb(i∗ j∗)nzNb(i j)The probability that a node can connect to neighboringzones with the help of at least q neighbors is denoted bypqˆ(i∗ j∗) and is given as follows:pqˆ(i∗ j∗) = 1− [p0(i∗ j∗) + · · ·+ pq−1(i∗ j∗)] (6)Figure 5(b) shows the range in which a sensor can connect toits neighboring zones with at least q links via its neighborswhere q = 1 2 3 and the connectivity probability is 08Thus a sensor can randomly select q neighbors who respondto the requests and send the responses to the destinationnodes The selected q destination nodes can help the sensor36set up q paths to any of the neighbors in the adjacent zoneIf there are q keys generated the pairwise key is given as:k = k1 ⊕ · · · ⊕ kq (7)where ⊕ is the exclusive-or operatorComparing Figure 4 and Figure 5(b) almost all sensorsthat have less than 20 neighbors and some of sensors thathave less than 25 neighbors can set up at three connectionsto the diagonal neighboring zones The sensors that haveless than 35 neighbors within the same zone may set up atthree connections to the horizontal and vertical neighboringzonesSimilar to the key establishment scheme within the samezone for a sensor who cannot set up a key path to a neigh-boring zone a sensor can send requests to its neighbors with15 ∼ 30 neighbors within the same zone If the nodes hasa link to the requested destination it selects a pairwise keyand encrypts it using the already established pairwise keyswith the source and destination The pair of nodes thatmay want to set up a pairwise key can utilize the functionpresented in (7) to exclusive-or all received keys and use theresult as their pairwise key8 PERFORMANCE ANALYSISIn this section we present the performance analysis basedon storage security communication overhead and compu-tation overhead due to the proposed scheme We also pro-vide comparison studies of our scheme with the sensor de-ployment scheme proposed in [1]81 Other Location-aware SchemesTwo schemes have been proposed in [2] by using knownsensor location information The first scheme is called clos-est pairwise keys scheme (CPKS) This scheme assumes thedeployment point of each sensor is known in advance whichis too strict for implementation The second scheme is calledlocation-based key predistribution (LBKP) This scheme par-titions a deployment area in multiple square areas (zones);using the same key predistribution schemes proposed in [11]each area is associated with two polynomials; a key serveris responsible for predistributing keys based on known net-work topology and sensors’ location points within a squarearea Once a sensor’s location point is determined the keyserver installs a set of polynomial variables associated withthe square area in the sensor Using this scheme withina square area if λ + 1 or more sensors are captured allcommunications between this area and its adjacent area arecompromised Our analysis in Section 31 shows this schemeis vulnerable to selective node capture attack To overcomethis problem instead of using two polynomial settings foreach zone we use a unique structured key pool (proposedin [8 9]) for each zone and restrict at most λ polynomialvariables that are distributed from each polynomial An-other vulnerability of the scheme in [2] is that if attackerscapture more than λ sensors they can fabricate nodes with-out being detected We overcome this problem by assign aunique number (from 1 to N) to N deployed sensors Thisnumber also identify the column number of G matrix Sincethis number is unique for a sensor and no attacker can com-promise more than λ rows of a key matrix A Thus theattacker cannot fabricate new sensors by installing new rowelements to a fabricated sensor The LBKP scheme also re-quires the location of each sensor is preknown which is toorestricted for implementation due to large number of sen-sors In our grid-group deployment scheme we assume agroup of sensors (100 sensors in our performance analysis)are uniformly deployed within a given square area which re-duces the deployment complexity Our scheme employs twostage pairwise key establishment scheme which uses two setof preinstalled keys This method also reduces the numberof keys preinstalled in each sensorIn [1] Du et al showed that using known deploymentinformation the performance of P-RKP schemes can be im-proved significantly Especially the proposed scheme re-duces the consequences of random node capture attack Themain contribution of this scheme is to restrict the sharedkey information locally (within a small range eg 100m×100m) The P-RKP and SK-RKP schemes proposed in [67 10 8 9] assume that each sensor has an equal probabilityto have a given key installed in its memory Instead of dis-tributing the keys uniformly within a given sensor systemDu et al [1] proposed to restrict the key distribution lo-cally by geographically dividing the deployment region intoN×M small areas A small key pool is constructed for eachsmall area acco‘rding to its neighboring-area relation Thesensors located within each small area (which form a group)use the P-RKP scheme to predistribute the keys They callthis deployment method as group-based deployment modelHowever the scheme proposed by Du et al has several de-ficiencies The sensor density of of an area is uneven in thatthe density around the center of group deployment point ismuch higher than that at the edge of the small area Thedeployment pattern can be modeled by normal distributionThus in order to make sure that a sensor deployed at theedge of an area has enough preinstalled keys to set up pair-wise keys with all its neighbors the group-based deploymentmodel requires more sensors deployed around the group de-ployment point In addition the uneven distribution of sen-sors within a given area may be undesirable from the appli-cation and the security point view For example the senseddata may be unevenly distributed within the deployed areawhich can introduce additional complexity for the applica-tions analyzing the sensed data; moreover an attacker cancapture more sensors around the group deployment point82 System ConfigurationIn order to compare with the P-RKP location scheme weuse the similar system configuration proposed in [1]• The number of sensor nodes in the sensor network is10000• The deployment area is 1000m× 1000m• The area is divided into a grid of size 100 with eachsquare (a zone) of size 100m× 100m• The number of sensors deployed within each zone isnz = 100• The communication radius R is 40m and the averagenumber of neighbors of a sensor is n′ = 50• The parameters used for key predistribution schemewithin a zone are τ = 2 and ω = 7 Therefore theprobability that two neighboring sensors share a keyis p1 = 052383783 Storage Overhead AnalysisA sensor is required to store m = (λ + 1)τ keys thatare used to set up pairwise key within its zone where λ isrestricted by nz = λω/τ  For example if τ = 2 ω = 7 andnz = 100 then λ = 29 In addition to the keys selected fromthe key matrix A each sensor is required to install at leastone key for each of its neighboring zones The maximumnumber of neighboring zones is 8 Thus the total numberof keys that are needed to be preinstalled in a sensor is giveas:m = nzτω£+ 1τ + γαwhere the γ is the number of neighboring zones and α isthe number of keys preinstalled for each pair of neighboringzones for a sensor For all our analysis we use the follow-ing parameter setting: γ = 8 α = 1 Thus the storagerequirement for a sensor is m = 68Unlike the P-RKP scheme proposed in [6] which requiresm = 272 to fulfil p1 = 05238 our scheme requires m = 68which is much lesser For the scheme specified in [1] toachieve the p1 = 05238 it requires 72 keys preinstalled foreach sensor which is a marginally higher than our scheme84 Security AnalysisOur security analysis presents a new way to analyze thesecurity of pairwise key establishment for large distributedsensor system Particularly selective attack and node fabri-cation attack have not been addressed thoroughly in currentliteratures All our analysis is based on the attacker’s ca-pabilities presented in Section 3 and the two phases of keyestablishment procedure presented in Section 7841 Security evaluation metricsSensor networks have many characteristics that make themmore vulnerable to attacks as compared to conventionalcomputing environment We present several criteria thatrepresent desirable characteristics in a pairwise key estab-lishment scheme for sensor networksResilience against node capture attack : to evaluate therandom node capture attack and selective node capture at-tack: we evaluate the fraction of compromised links amonguncompromised nodes due to captured nodesResilience against node fabrication : we evaluate a theresilience of scheme against node fabrication by evaluatingthe capability of the attacker to successfully deploy the fab-ricated sensors into the deployment area842 Random node capture attackRandom node capture attack assumes that an attackerrandomly captures the deployed sensors If the attacker cangain the information which is not already known to him theattack is considered successful To evaluate the resilience toagainst the random node capture attack we use the frac-tion of compromised communication links among uncom-promised nodes to evaluate the proposed schemesOur pairwise key establishment scheme includes two phasesThe first phase uses the SK-RKP scheme proposed in [8 9]In addition we restrict the number of rows of secret matrixA (A = (D ·G)T ) distributed to sensors to λ The side effectof this restriction is that the number of sensors deployed ineach zone is restricted by λω/τ  where τ is the number ofkey spaces selected for each sensor This restriction gainsthe maximum security to guard against node capture attack10 20 30 40 50 60 70 80 90 10000102030405060708091Number of compromised nodesFraction of compromised links among uncompromised nodesP−RKP location scheme with selective attackP−RKP location scheme with random attackOur schemeFigure 6: Random/Selective node capture attack:P-RKP location scheme vs Our Schemesince no attacker can derive the secrets preinstalled in theuncompromised sensors Thus our scheme is perfectly se-cure against the random node capture attack during the firstphase of key establishment procedure During the secondphase of key establishment procedure a unique key is as-signed to each node for each of its neighboring zones Thusthe attacker cannot derive more information from the cap-tured information Hence for the second phase of our keyestablishment procedure our proposed scheme is perfectlysecure against random node capture attack In summaryusing our scheme the attacker can not derive the secret in-formation used among uncompromised nodes from the cap-tured nodes Overall our scheme is resilient to random nodecapture attack Figure 6 compares our scheme with the P-RKP location scheme proposed in [1] against selective at-tack843 Selective node capture attackThe selective node capture attack is described in Sec-tion 31 In this attack the attacker can listen to the broad-cast communications and selectively capture sensors to max-imize the attack effects Using selective node capture attackthe attacker only needs to attack certain area or a group ofsensors By doing this with little efforts a particular zonecan be compromisedThe analysis of the fraction of compromised link amonguncompromised nodes under selective attack on our schemeis the same that presented in previous section – the attackercannot derive the keys used among uncompromised nodesfrom the captured nodes But for P-RKP location scheme[1] if the attacker just concentrates on a particular areahe can compromise the system by capturing less number ofnodes As specified in [1] if the number of keys preinstalledfor each sensor is m = 50 and the average number of neigh-bors for a node is n′ = 50 the key pool size used by aparticular zone is 1770 Note that the 1770 keys contain notonly the keys for its own zone but also keys in the neigh-boring zones (for details refer to [1]) Thus by utilizing the(1) and attack techniques described in Section 31 we drawthe Figure 6 to compare our scheme with P-RKP locationscheme38Figure 6 shows that under selective attack for P-RKPscheme capturing 20 nodes will cause roughly 60% (1062keys) of the total keys (1770) compromised On the con-trary for our scheme the fraction of compromised links be-tween uncompromised nodes remains zero844 Node fabrication attackUsing node fabrication attack the attacker can fabricatenew nodes by manipulating the information from the cap-tured nodes such as the secret keys preinstalled in the cap-tured sensors This attack can cause severe security prob-lems for P-RKP location scheme since there is no connec-tions between a sensor’s id and the keys it possesses Forexample if an attacker only captures two nodes he canfabricate 2mmnew nodes and deploy them back into thesensor network without being detected Thus the attackercan quickly outnumber the uncompromised sensorsWe use the secure group key schemes proposed by Blom [13]and further developed by Blundo et al [11] in which thekey id is used to identify the row of the secret matrix A(A = (D · G)T )) distributed to the sensor (the key id canalso serve as user id) Since we restrict the number of rowsof the key matrix A distributed to sensors to λ the attackercannot derive the rows of key matrix A other than the oneshe has already captured Consequently the attacker cannotfabricate new nodes using the information from the capturednodes845 Other security considerationsIn other security attacks such as node replication attackcloned nodes can be deployed in the system Our scheme’sbehavior is the same as that of existing proposals under thisattack Further we notice that the attacker can compromisethe pairwise keys by capturing sensors and then use the cap-tured sensors to help the uncompromised sensors to setupthe pairwise keys This attack can be mitigated by increas-ing the probability that two sensors share a key p1 and usemultiple key paths to set up pairwise keys The analysis ofthese countermeasures will be given in our following papers85 Communication Overhead AnalysisWe derive the mathematical expressions for the probabil-ity that a sensor can set up key paths with all its neighborswithin h hops in [14] Due to page limits we simply put themathematical expressions simulation results and compari-son studies in [14] This mathematical model is used for ourcommunication overhead analysis Since our key establish-ment procedure includes two phases: the key establishmentwithin a zone and the key establishment between two adja-cent zones we analyze the communication overhead for eachphase separatelyDuring the first phase of key establishment the closer thesensor to the center of a zone the smaller the communicationoverhead due to key establishment For example for τ = 2ω = 7 the following table shows the number of hops andthe corresponding key graph connectivity probabilities: Asshown in Figure 4 most pairwise keys can be set up within 3hops If a sensor cannot set up pairwise keys with its neigh-bors within 3 hops as presented in Section 71 the sensorsends requests (r requests) to its neighbors if q neighborsreply to the requests with the keys k1     kq where q ≤ rthe pairwise key is k = k1 ⊕    ⊕ kq We show that forω = 7 and τ = 2 and if a sensor has 15 neighbors then on# of neighbors # of hops key graph connectivity50 2 0995740 2 0980630 3 0999625 3 0998020 3 0989315 4 09583average only 0044 neighbors cannot set up pairwise keyswithin 4 hops This is almost negligibleDuring the second phase of key establishment betweentwo adjacent zones as Figure 5(b) shows a sensor can setup q paths to the neighboring zones with the probability of09 Each path is a 2-hop path The nodes who cannot finda path to the neighboring zone can use the method describedin Section 72 which is the same as that in used in the firstphase In this scenario a sensor sends requests (r requests)to its neighbors if q neighbors reply to the requests with thekeys k1     kq the pairwise key is k = k1⊕  ⊕kq Since thesensors within the curve lines (the area of the zone Z(i j) issplit by the curve that close to the neighboring zone) shownin Figure 5(b) has already set up the pairwise keys withall the neighbors in the neighboring zones we only considerthe nodes who can help the sensor to set up path with 2hops We note that the farther the sensor from the zoneboundary the smaller the probability that a sensor can finda path to the neighboring zone; at the same time the fartherthe sensor from the boundary the smaller the number ofneighbors within the neighboring zone86 Computation Overhead AnalysisThe computation overhead is mainly from the secure groupkey scheme introduced by SK-RKP scheme In our schemeswe reduced the computation overhead significantly as com-pared to the SK-RKP scheme proposed in [8 9] that doesnot use the location information For example by usingthe SK-RKP scheme without using location information form = 200 τ = 2 and λ = 100 to derive a pairwise key thetotal number of required modular multiplication operationsis 200 (for the detail description of pairwise key establish-ment scheme refer to [8 9]) Note that this requirement isto fulfil the connectivity of whole sensor network In ourscheme we only need to guarantee the local connectivitywithin a zone We reduce the number of keys preinstalledin a sensor (see the analysis presented in Section 83) Ifwe restrict the number of sensor within a zone to nz = 100for ω = 7 τ = 2 the λ = nzτ/ω = 29 Thus the num-ber of required modular multiplication operations to derivea pairwise key is only 589 CONCLUSIONWe described SK-RKP schemes [8 9] used in our pro-posed grid-group scheme Using this scheme we signifi-cantly decrease the requirement for number of keys to beinstalled in each sensor (approximately 3 times less thanthe schemes without using deployment information) More-over our scheme is resilient to selective node capture attackand node fabrication attack which have not been completelyaddressed and analyzed in the current literatures Our com-parison studies with the recent P-RKP location scheme [1]show that our scheme exhibits better performance from bothstorage and security perspectives39We notice that the attacker can compromise the pairwisekeys by capturing sensors and then use the captured sensorsto help (act as a proxy) the uncompromised sensors to setupthe pairwise keys In this way the attacker can capture thepairwise keys used between uncompromised sensors In ourfuture work we will study the security of various proposalsunder such attack and corresponding countermeasuresACKNOWLEDGEMENTThe authors would like to thank the anonymous reviewersfor their valuable comments10 REFERENCES[1] W Du J Deng Y S Han S Chen and P KVarshney “A key management scheme for wirelesssensor networks using deployment knowledge” inIEEE INFOCOM March 2004[2] D Liu and P Ning “Location-based pairwise keyestablishments for static sensor networks” inProceedings of the 1st ACM workshop on Security ofad hoc and sensor networks (CCS’03) 2003 pp 72 –82[3] J M Kahn R H Katz and K S J Pister “Nextcentury challenges: Mobile networking for ”smartdust”” in International Conference on MobileComputing and Networking (MOBICOM) 1999 pp271–278[4] “Wireless integrated network sensors” University ofCalifornia[5] I F Akyildiz W Su Y Sankarasubramaniam andE Cayirci “A survey on sensor networks” IEEECommunications Magazine vol 40 pp 102 – 114August 2002[6] L Eschenauer and V D Gligor “A key-managementscheme for distributed sensor networks” inProceedings of 9th ACM Conference on Computer andCommunication Security (CCS-02) November 2002pp 41–47[7] H Chan A Perrig and D Song “Random keypredistribution schemes for sensor networks” inProceedings of 2003 Symposium on Security andPrivacy Los Alamitos CA: IEEE Computer SocietyMay 11–14 2003 pp 197–215[8] D Liu and P Ning “Establishing pairwise keys indistributed sensor networks” in Proceedings of 10thACM Conference on Computer and CommunicationsSecurity (CCS’03) October 2003 pp 52–61[9] W Du J Deng Y S Han and P K Varshney “Apairwise key pre-distribution scheme for wirelesssensor networks” in Proceedings of 10th ACMConference on Computer and CommunicationsSecurity (CCS’03) October 2003 pp 42–51[10] S Zhu S Xu S Setia and S Jajodia “Establishingpair-wise keys for secure communication in ad hocnetworks: A probabilistic approach” in Proceedings of11th IEEE International Conference on NetworkProtocols (ICNP’03) November 2003[11] C Blundo A D Santis A Herzberg S KuttenU Vaccaro and M Yung “Perfectly-secure keydistribution for dynamic conferences” Informationand Computation vol 146 no 1 pp 1–23 1998[12] R D Pietro L V Mancini and A Mei “Efficientand resilient key discovery based on pseudo-randomkey pre-deployment” in 18th International Paralleland Distributed Processing Symposium (IPDPS’04)April 2004[13] R Blom “An optimal class of symmetric keygeneration systems” in EUROCRYPT’84 serLecture Notes in Computer Science vol 209 ParisFrance: Springer-Verlag 1985 pp 335–338[14] D Huang M Mehta D Medhi and L Harn“Modeling pairwise key establishment for random keypredistribution in large-scale sensor networks”University of Missouri – Kansas City Tech Rep July2004 [Online] Available:http://conrelsiceumkcedu/dhuang/modelingpdfAPPENDIXA SENSOR COVERAGE – WITHIN THESAME ZONEThe covering area of sensor [(i j) b] in its zone Z(i j) isshown in Figure 7 We can further divide the zone into 4areas The sensor coverage in these 4 areas are horizontallyand vertically mapping to each other Within a small areathere are two scenarios that shown in the Figure 7In the first scenario (shown the sensor is located at theposition (x1 y1)) the distance between the origin and thesensor ispx21 + y21 ≤ R The coverage is composed by a sec-tor with the angle θ1 plus two triangles (the shaded areas)The θ1 is given as follows:θ1 =32π − sin−1 B1 − x1R− sin−1 A1 − y1RwhereA1 − y1 =ÈR2 − x21 B1 − x1 =ÈR2 − y21The coverage (the shade area) of sensor [(i j) b] in zoneZ(i j) is represented as C1b (i j) and it is computed as fol-lows:C1b (i j)|(x1y1) = x1y1 +12[x1(A1 − y1)+y1(B1 − x1)] + θ12R2In the second scenario (shown the sensor is located at theposition (x2 y2)) the distance between the origin and thesensorpx22 + y22 > R The coverage is composed by twotriangles (A2A3oB2B3o) and two sectors with anglesθ2 and θ3 The θ3 is given as follows:θ3 =32π − sin−1 B2 − x2R− sin−1 A2 − y2RThe θ2 is given as follows:θ2 =π2− sin−1 x2 −B3R− sin−1 y2 −A3RThe θ4 is given as follows:θ4 = 2 sin−1 A2 − y2RThe θ5 is given as follows:θ5 = 2 sin−1 B2 − x2R40                xy0zone (ij)zone (ij-1)zone (i+1j)zone (i+1j-1)(x1y1)A1B1RRA2B2B32(x1y1)1(x2y2)aa345Figure 7: Occupied zoneWe note thaty2 −A3 = A2 − y2 =ÈR2 − x22x2 −B3 = B2 − x2 =ÈR2 − y22The coverage (the shade area) of sensor [(i j) b] in zone(i j) is represented as C2b (i j) and it is computed as follows:C2b (i j)|(x2y2) =8>>><>>>:12[x2(A2 −A3) + y2(B2 −B3)]+ θ2+θ32R2  x ≤ R y ≤ R12x2(A2 −A3) + 2π−θ42 R2  x ≤ R y > R12y2(B2 −B3) + 2π−θ52 R2  x > R y ≤ RπR2  x > R y > RTo summarize given a position (x y) for sensor [(i j) b]the area coverage is given as follows:Cb(i j)|(xy) =C1b (i j)|(xy)  0 ≤px2 + y2 ≤ RC2b (i j)|(xy)  R <px2 + y2 ≤ a/2In Figure 4 shows the average number of neighbors of asensor that is located in different position of a given zoneB SENSOR COVERAGE – IN DIFFERENTZONEB1 Zone Coverage C(i j−)Shown in Figure 8 (a) we first compute the area of thetriangle A3A1b as follows:|A1A2| =pR2 − x2|A3b| = xcos(∠A3bA2)=xRpR2 − y2|A2A3| = xypR2 − y2|A2b| =È|A3b|2 − |A2A3|2A3A1b = 12(|A1A2|+ |A2A3|)|A2b|The area of triangle A3oB1 is given as follows:|B1A3| = R− |A3b||A3o| = y − |A2A3||B1o| =È|B1A3|2 − |A3o|2B1A3o = 12|B1o||A3o|The area of sector úB1bA1 is given as follows:∠A2bA3 = sin−1 yR∠A2A1b = sin−1 xR∠A1bA2 =π2− ∠A2A1b∠A1bB1 = ∠A1bA2 + ∠A2bA3úB1bA1 =∠A1bB12ππR2 =∠A1bB12R2Thus the shade area C(i j−) is given as;Cb(i j−)|(xy)= úB1bA1 +B1A3o−A3A1b=R22π2+ sin−1 yR− sin−1 xR−x2pR2 − x2 + xypR2 − y2+12y − xypR2 − y2×ÊR− xRpR2 − y2−y − xypR2 − y2B2 Zone Coverage C(i+ j−)Shown in Figure 8 (b) we first compute the area of sectorúB4bA4:úB4bA4 =πR24The area of sector úB1bA4 is given as follows:∠B1bA4 = sin−1 yRúB1bA4 =∠B1bA42R241          Zone (ij)Zone (ij-1)Zone(i+1j-1)Zone(i+1j)(xy)A1B1RR           Zone (ij)Zone (ij-1)Zone(i+1j-1)Zone(i+1j)(xy)R        Zone (ij)Zone (ij-1)Zone(i+1j-1)Zone(i+1j)(xy)RRoA2 bA3A1A2A3B1 B2 B3A4B3 B2 B1A1A2bo ox x xy yy(a) (b) (c)bB4Figure 8: Zone Coverage ProofThe area of triangle bB1B3 is given as follows:|B1B3| =pR2 − y2bB1B3 = 12|B1B3|yThe area of sector úB4bA3 is given as follows:∠B4bA3 = sin−1 xRúB4bA3 =∠B4bA32R2The area of triangle bA1A3 is given as follows:|A1A3| =pR2 − x2bA1A3 = 12|A1A3|xThus the shade area C(i+ j−) is given as;Cb(i+ j−)|(xy)= úB4bA4 − úB1bA4 −bB1B3 − úB4bA3−bA1A3 + xy=πR24− R22sin−1 yR+ sin−1 xR−12xpR2 − x2 + ypR2 − y2+ xyB3 Zone Coverage C(i+ j)Shown in Figure 8 (c) we first compute the area of triangleA3A1b as follows:|B1B2| =pR2 − y2|B3b| = ycos(∠B3bB2)=yR√R2 − x2|B2B3| = xy√R2 − x2|B2b| =È|B3b|2 − |B2B3|2B3B1b = 12(|B1B2|+ |B2B3|)|B2b|The area of triangle B3oA1 is given as follows:|A1B3| = R− |B3b||B3o| = x− |B2B3||A1o| =È|A1B3|2 − |B3o|2A1B3o = 12|A1o||B3o|The area of sector úA1bB1 is given as follows:∠B2bB3 = sin−1 xR∠B2B1b = sin−1 yR∠B1bB2 =π2− ∠B2B1b∠B1bA1 = ∠B1bB2 + ∠B2bB3úA1bB1 =∠B1bA12ππR2 =∠B1bA12R2Thus the shade area C(i+ j) is given as follows;Cb(i+ j)|(xy)= úA1bB1 +A1B3o−B3B1b=R22π2+ sin−1 xR− sin−1 yR−y2pR2 − y2 + xy√R2 − x2+12x− xy√R2 − x2×rR− yR√R2 − x2−x− xy√R2 − x242
Location based compromiose-WSN-pdf,IEEE JOURNAL ON SELECTED AREAS IN COMMUNICATIONS VOL 24 NO 2 FEBRUARY 2006 247Location-Based Compromise-Tolerant SecurityMechanisms for Wireless Sensor NetworksYanchao Zhang Student Member IEEE Wei Liu Wenjing Lou Member IEEE andYuguang Fang Senior Member IEEEAbstract—Node compromise is a serious threat to wireless sensornetworks deployed in unattended and hostile environments Tomitigate the impact of compromised nodes we propose a suite oflocation-based compromise-tolerant security mechanisms Basedon a new cryptographic concept called pairing we propose thenotion of location-based keys (LBKs) by binding private keys ofindividual nodes to both their IDs and geographic locations Wethen develop an LBK-based neighborhood authentication schemeto localize the impact of compromised nodes to their vicinity Wealso present efficient approaches to establish a shared key betweenany two network nodes In contrast to previous key establishmentsolutions our approaches feature nearly perfect resilience to nodecompromise low communication and computation overhead lowmemory requirements and high network scalability Moreoverwe demonstrate the efficacy of LBKs in counteracting severalnotorious attacks against sensor networks such as the Sybil attackthe identity replication attack and wormhole and sinkhole at-tacks Finally we propose a location-based threshold-endorsementscheme called LTE to thwart the infamous bogus data injectionattack in which adversaries inject lots of bogus data into the net-work The utility of LTE in achieving remarkable energy savingsis validated by detailed performance evaluationIndex Terms—Compromise tolerance location pairing secu-rity wireless sensor networksI INTRODUCTIONWIRELESS SENSOR NETWORKs (WSNs) have at-tracted a lot of attention recently due to their broad appli-cations in both military and civilian operations Many WSNs aredeployed in unattended and often hostile environments such asmilitary and homeland security operations Therefore securitymechanisms providing confidentiality authentication dataintegrity and nonrepudiation among other security objectivesare vital to ensure proper network operationsA future WSN is expected to consist of hundreds or eventhousands of sensor nodes This renders it impractical to monitorand protect each individual node from either physical or log-ical attack It is also unrealistic and uneconomical to encloseManuscript received October 1 2004; revised August 10 2005 This workwas supported in part by the US Office of Naval Research under Young Inves-tigator Award N000140210464 and the US National Science Foundation underGrant ANI-0093241 (CAREER Award)Y Zhang and Y Fang are with the Department of Electrical and ComputerEngineering University of Florida Gainesville FL 32611 USA (e-mail:yczhang@ufledu; fang@eceufledu)W Liu is with Scalable Network Technologies Los Angeles CA 90045 USA(e-mail: liuw@ufledu)W Lou is with the Department of Electrical and Computer EngineeringWorcester Polytechnic Institute Worcester MA 01609 USA (e-mail:wjlou@ecewpiedu)Digital Object Identifier 101109/JSAC2005861382each node in tamper-resistant hardware Thus each node rep-resents a potential point of compromise Once compromisingcertain nodes and acquiring their keying material adversariescan launch various insider attacks For example they mightspoof alter or replay routing information to interrupt the net-work routing [1] They may also launch the Sybil attack [2] [3]where a single node presents multiple identities to other nodesor the identity replication attack in which clones of a compro-mised node are put into multiple network places [3] Moreoveradversaries may inject bogus data into the network to consumethe scarce network resources [4] [5] This situation poses thedemand for compromise-tolerant security design That is thenetwork should remain highly secure even when a number ofnodes are compromised Although a lot of solutions such as[6]–[14] have been proposed for securing WSNs most of themdo not provide adequate resilience to node compromise and theresulting attacksMany WSNs have an intrinsic property that sensor nodes arestationary ie fixed at where they were deployed This prop-erty has played an important role in many WSN applicationssuch as target tracking [15] and geographic routing [16] Bycontrast its great potential in securing WSNs has so far drawnlittle attention Based on this observation we propose a suiteof location-based compromise-tolerant security mechanisms forWSNs in this paper Our main contributions are summarized asfollowsFirst we propose the novel notion of location-based keys(LBKs) based on a new cryptographic concept called pairing(cf Section II-A) In our scheme each node holds a private keybound to both its ID and geographic location rather than merelyits ID as in conventional schemes To the best of our knowledgethis is the first such effort in the context of WSNsSecond we design a novel node-to-node neighborhood au-thentication protocol based on LBKs It helps achieve the desir-able goal of localizing the impact of compromise nodes (if any)to their vicinity which is a nice property absent in most previousproposalsThird we present efficient approaches to establish pairwiseshared keys between any two nodes that are either immediateneighbors or multihop away Such keys are fundamental inproviding security support for WSNs [7]–[14] In contrast toprevious proposals our approaches feature low communicationand computation overhead low memory requirements andgood network scalability More important our approachesshow perfect resistance to node compromise in that pairwiseshared keys between noncompromised nodes always remainsecure no matter how many nodes are compromised0733-8716/$2000 © 2006 IEEE248 IEEE JOURNAL ON SELECTED AREAS IN COMMUNICATIONS VOL 24 NO 2 FEBRUARY 2006Fourth we demonstrate how LBKs can act as efficientcountermeasures against some notorious attacks against WSNsThese include the Sybil attack [1] [3] the identity replicationattack [3] wormhole and sinkhole attacks [1] and so onFinally we develop a location-based threshold-endorsementscheme (LTE) to thwart the aforementioned bogus data injec-tion attack [4] [5] Detailed performance evaluation shows thatLTE can achieve remarkable energy savings by detecting anddropping bogus traffic at their early transmission stages More-over our LTE has a much higher level of compromise tolerancethan previous work [4] [5]The rest of this paper is structured as follows Section II in-troduces the cryptographic basis the adversary model and thesecurity objectives of this paper Next we detail a LBK man-agement scheme including key generation authentication andshared-key establishment This is followed by a detailed illus-tration of using LBKs in combating various attacks Section Vpresents the LTE scheme and evaluates its performance Wethen survey related work in Section VI discuss the use of sym-metric-key versus public-key cryptography in Section VII andend with conclusions and future work in Section VIIIII PRELIMINARIESA Pairing ConceptIdentity-based cryptography (IBC) is receiving extensive at-tention as a powerful alternative to traditional certificate-basedcryptography (CBC) Its main idea is to make an entity’s publickey directly derivable from its publicly known identity infor-mation such as the e-mail address Eliminating the need forpublic-key certificates and their distribution makes IBC muchmore appealing for securing WSNs where the need to transmitand check certificates has been identified as a significant limi-tation For example wireless transmission of a bit can requireover 1000 times more energy than a single 32-bit computationas shown in [17] For this reason we adopt IBC as the cryp-tographic foundation of this paper Although the idea of IBCdates back to 1984 [18] only recently has its rapid developmenttaken place due to the application of the pairing technique out-lined belowLet  be two large primes and indicate an ellipticcurve over the finite field  We denote bya -order subgroup of the additive group of points of and by a -order subgroup of the multiplicative group ofthe finite field  The Discrete Logarithm Problem (DLP) isrequired to be hard1 in both and  For us a pairing is amap with the following properties1) Bilinear: For   (1)Consequently for   we have2) Nondegenerate: If is a generator of  thenis a generator of 1It is computationally infeasible to extract the integer x 2 = faj1 a  q   1g given P  Q 2 (respectively P  Q 2 ) such that Q = xP(respectively Q = P )3) Computable: There is an efficient algorithm to computefor all  Note that is also symmetric ie  for all  which follows immediately from the bilinearityand the fact that is a cyclic group Modified Weil [19] andTate [20] pairings are examples of such bilinear maps for whichthe Bilinear Diffie–Hellman Problem (BDHP) is believed to behard2 We refer to [19] and [20] for a more comprehensive de-scription of how these pairing parameters should be selected inpractice for efficiency and securityB Adversary ModelAdversaries in WSNs can be classified as either external orinternal adversaries The former do not have authentic keyingmaterial whereby to participate in network operations as legiti-mate nodes They might just passively eavesdrop on radio trans-missions or actively inject bogus data or routing messages intothe network to consume the network resources Once in full con-trol of certain nodes external adversaries can become internalones to be able to launch more subtle attacks like those men-tioned in Section I Internal adversaries are generally more dif-ficult to defend against than external ones for their possessionof authentic keying material We further assume that adversarieshave much more powerful resources regarding energy commu-nication and communication capacities than ordinary sensornodes They might also communicate and collaborate over ahigh-bandwidth and low-latency channel invisible to legitimatesensor nodes However we do assume that adversaries cannotcompromise an unlimited number of sensor nodes Neither canthey break any cryptographic primitive on which we base ourdesign Otherwise there is unlikely to be any feasible securitysolutionC Security ObjectivesWe aim to provide confidentiality authentication data in-tegrity and nonrepudiation four essential security objectivesWe also intend to offer both link-layer and end-to-end securityguarantees both of which are indispensable for security-sensi-tive WSNs [1] By definition link-layer security indicates thesecurity of radio links between neighboring nodes It is a pre-requisite to prevent external adversaries from accessing or mod-ifying or faking radio transmissions In contrast end-to-end se-curity refers to the communication security between a pair ofsource and destination nodes eg a data aggregation point (AP)to a higher level AP or the sink [1] We achieve link-layer se-curity by immediate pairwise keys shared between neighboringnodes and end-to-end security by multihop pairwise keys sharedbetween end-to-end sources and destinationsIII LOCATION-BASED KEY (LBK) MANAGEMENT SCHEMEThis section presents an LBK management scheme forWSNs including the generation and distribution of LBKs asecure LBK-based neighborhood authentication scheme andmethods for establishing both immediate and multihop pairwiseshared keys2It is believed that given hP; xP; yP; zP i for random x y z 2 andP 2  there is no algorithm running in expected polynomial time which cancompute e^(P; P ) 2 with nonnegligible probabilityZHANG et al: LOCATION-BASED COMPROMISE-TOLERANT SECURITY MECHANISMS FOR WSNS 249A Predeployment PhaseWe examine a large-scale WSN consisting of hundreds oreven thousands of sensor nodes We assume that all the nodeshave the same transmission range and communicate via bidi-rectional wireless links Nodes perform a collaborative moni-toring of the designated sensor field and report the sensed eventsto the distant sink which is a data collection center with suffi-ciently powerful processing capabilities and resources We fur-ther assume that each node has a unique integer-valued andnonzero ID denoted by  In view of the cost constraintsnodes are assumed to be not tamper-resistant in the sense thatadversaries can extract all the keying material and data storedon a compromised node However we postulate that the sinkis trustworthy and unassailable as is commonly assumed in theliterature [7]–[14]Prior to network deployment we assume that a trusted au-thority (TA) does the following operations1) Generate the pairing parameters as described in Section II-A Select an arbitrary generatorof 2) Choose two cryptographic hash functions:  mappingstrings to nonzero elements in  and  mapping arbi-trary inputs to fixed-length outputs eg SHA-1 [21]3) Pick a random as the network master secret andset 4) Calculate for each node an ID-based key (IBK forshort) Each node is preloaded with the public system parametersand its private It is important to note that it is computationally infeasible todeduce from either (  ) or any (ID IBK) pair like(  ) due to the difficulty of solving the DLP in (cfSection II-A) Therefore even after compromising an arbitrarynumber of nodes and their IBKs adversaries are still unable tocalculate the IBKs of noncompromised nodesB Sensor Deployment and LocalizationAfter loaded with the keying material sensor nodes canbe deployed in various ways such as physical installation orrandom aerial scattering There are also many methods to lo-calize each node ie furnishing each node with its geographiclocation We consider the following two sensor localizationtechniques which accordingly differ in their ways of gener-ating LBKs for individual nodes The final outcome of eitherapproach is that each node possesses its location denotedby and an LBK  where denotesmessage concatenation1) Range-Based Localization: In this approach we assumethat a group of mobile robots are dispatched to sweep acrossthe whole sensor field along preplanned routes Mobile robotshave GPS capabilities as well as more powerful computationand communication capacities than ordinary nodes The leadingrobot is also equipped with the network master secret  To lo-calize a node say  mobile robots run the secure range-basedlocalization protocol given in [22] or [23] to first measure theirrespective absolute distance to node and then co-determine the location of  Subsequently the leading robot calculates It then generatesand sends to  Hence-forth means encrypting message with key  andrefers to the message integrity code (MIC) of messageunder key Upon receipt of the message node first uses its preloadedIBK to decrypt and and then regenerates the MICIf the result matches with what the robot sent saves andfor subsequent use Following this process all the nodes canbe furnished with their respective location and LBK After thatmobile robots leave the sensor field and the leading robot shouldsecurely erase from its memory During subsequent networkoperations node addition may be necessary to maintain goodnetwork connectivity The localization of new nodes can be donein the same mannerThe assumption underlying this approach is that adversariesdo not launch active and explicit pinpoint attacks on mobilerobots at this stage which usually does not last too long How-ever they may still perform relatively passive attacks such asmessage eavesdropping or strategic channel inference to disturbthe localization process [22] [23] This assumption is reason-able in that mobile robots are much fewer than ordinary sensornodes and hence we can spend more on them by enclosingthem in high-quality tamper-proof hardware and putting themunder super monitoring Adversaries may also want to tem-porarily avoid active and explicit attacks that may easily exposethemselves After the localization phase adversaries are free tolaunch all kinds of attacks2) Range-Free Localization: By contrast the range-freelocalization approach does not rely on exact distance or rangemeasurements Instead we assume that there are some specialnodes called anchors knowing their own locations All thenonanchor nodes autonomously derive their locations based oninformation from the anchors and neighboring nodes via securerange-free localization techniques such as [24]–[26]The LBKs are also generated on the nodes’ own To enablethis each node is preloaded with the network master secretwhereby to generate its LBK  AsLEAP [27] this approach takes advantage of the fact that sensornodes deployed in security-sensitive environments are usuallydesigned to withstand break-in attacks at least for a short in-terval when captured by adversaries Specifically we assumethat an adversary needs a time interval at least to success-fully compromise a node and each node takes some time lessthan to finish localization and generation of its LBK Inaddition each node should be programmed to securely erasefrom its memory after of its deployment In the case ofsubsequent node addition new nodes can get their locations andLBKs in the same wayC Location-Based Neighborhood AuthenticationBy definition neighborhood authentication means theprocess that any two neighboring nodes validate each other’snetwork membership This process is fundamental in sup-porting many security services in WSNs For example a nodeshould only accept messages from and forward messages toauthenticated neighbors Otherwise external adversaries caneasily inject bogus broadcast messages into the network orswindle network secret information from legitimate nodes250 IEEE JOURNAL ON SELECTED AREAS IN COMMUNICATIONS VOL 24 NO 2 FEBRUARY 2006During the post-deployment phase each node is required todiscover and perform mutual authentication with neighboringnodes which is a normal process in many existing security so-lutions for sensor networks In our scheme each node will thinkof another node as an authentic neighbor if and only that node iswithin its transmission range and also holds the correct cor-responding LBK We take the following concrete example toexplain the neighborhood authentication process1)2)3)Suppose node wishes to discover and authenticate neigh-boring nodes once having its location and LBK To do so lo-cally broadcasts an authentication request including its ID location and a random nonce  Upon receipt of such arequest node first needs to ascertain that the claimed loca-tion is in its transmission range by verifying if the Euclideandistance  This check is the baseline defenseagainst the attack that adversaries surreptitiously tunnel authen-tication messages between and a virtually nonneighboringnode Without the location check and that victim will falselybelieve that they are neighbors because both possess an au-thentic LBK whereby to successfully finish the following au-thentication processIf the inequality does not hold node simply discards theauthentication request Otherwise calculates a shared key as It then unicasts a reply tonode including its ID and location a random nonce  anda MIC computed as  Upon receiving thereply node also first checks if the inequalityholds If so it proceeds to derive a shared key aswhereby to recompute the MIC If theresult is equal to what sent node considers an authenticneighbor Subsequently returns to node a new MIC com-puted as  Upon receipt of it usesto regenerate the MIC and compares the result with what it justreceived If they are equal regards node as an authenticneighbor as wellThe above process is valid because if and only if bothand have a correct LBK is equal to due to thefollowing equations:(2)The second and third lines hold for the bilinearity of and thefourth line holds by the symmetry of (cf Section II-A)Using the above three-way handshake all the nodes canachieve mutual authentication with neighboring nodes Notethat if multiple nodes simultaneously respond to the same au-thentication request possible MAC-layer collision may happenWe resort to effective MAC-layer mechanisms to resolve thisissue For example it can be alleviated through MAC-layerretransmission or by using a random jitter delay for which eachnode has to wait before answering an authentication requestIn our scheme new nodes can be added freely to maintainnecessary network connectivity especially when some existingnodes die out because of power shortage or other reasons A newnode is also required to execute the authentication protocol oncelocalized properlySecurity Analysis: Our location-based authenticationscheme is secure against various malicious attacks For ex-ample in a location forgery attack an adversary might sendan authentication request with a forged location within node’s range Since the adversary does not hold the LBK corre-sponding to the forged location he or she cannot successfullyfinish the authentication procedure and thus deceive intobelieving that he or she is an authentic neighbor Adversariesmight as well launch the tunnelling of authentication messagesattack by tunnelling authentication messages received at onelocation of the network over an invisible out-of-band andlow-latency channel to another network location which istypically multihop away By doing so they attempt to maketwo victim nodes far away from each other believe that they areauthentic neighbors This attack is infeasible with our schemein that each node will simply deny authentication requests fromnodes that are not physically within its transmission range Inaddition an adversary might put into the vicinity of a legitimatenode say  a replica of one compromised node at other distantlocations Most purely ID-based authentication schemes arevulnerable to this attack because without dependence on anycentral authority [3] [8] the victim has great difficulty indifferentiating between legitimate authentication requests andmalicious ones from replicas of a compromised node Withour scheme in place node will simply ignore the replica’sauthentication request because the replica should not appear inits transmission rangeIt is worth pointing out that as any other security solu-tion our scheme itself cannot prevent a compromised nodeor its replicas from achieving mutual authentication with itslegitimate neighbors However it can guarantee that the com-promised node or its replicas receive nothing more than somerandom numbers public IDs and locations from legitimatenodes This ensures that the compromised node cannot imper-sonate its legitimate neighbors to other nodes Therefore ourlocation-based authentication scheme can reduce the impact ofa compromised node from the otherwise network-wide scale toits vicinity more specifically within a circle with radiuscentered at its current location This makes it far more easier todevise efficient localized intrusion detection mechanismsOne may worry that adversaries might mount the denial-of-service attack by continuously sending bogus authentication re-quests or replies to allure legitimate nodes into endless pro-cessing of such messages In our opinion this attack is in factless worrisome The reason is that the number of neighbors ofany node is limited in reality Therefore abnormally many au-thentication requests or replies are highly likely an indicator ofmalicious attacks Under such situations we assume that thereare efficient mechanisms available for legitimate nodes to reportsuch an abnormality to the sinkZHANG et al: LOCATION-BASED COMPROMISE-TOLERANT SECURITY MECHANISMS FOR WSNS 251D Immediate Pairwise Key (IPK) EstablishmentLink-layer security schemes demand an efficient methodto establish pairwise shared keys between neighboring nodesHenceforth we refer to such keys as immediate pairwise keys(or IPKs for short) With IPKs messages exchanged betweenneighboring nodes can be encrypted and authenticated viaefficient symmetric-key algorithmsNote that after a successful three-way handshake two neigh-boring nodes say and  have established a shared key Adversaries be they external or internal mayoverhear the authentication messages but cannot deduce theshared key for the lack of the LBKs of and  From and can derive various shared session keys for differentsecurity purposes by feeding into the hash function For example they can use for messageencryption and for message authenticationIn the similar way each node can establish IPKs with all itslegitimate neighbors after the neighbor discovery and authenti-cation phaseSince the IPKs are by-products of the neighborhood authen-tication process there is no extra key-establishment communi-cation and computation overhead In addition our IPK estab-lishment method has perfect resistance to node compromise be-cause the IPKs are built upon the private LBKs of individualnodes No matter how many nodes are compromised the LBKsof noncompromised nodes always remain secure and so do theIPKs established between themE Multihop Pairwise Key (MPK) EstablishmentIn addition to the IPKs a node may need to establish pairwiseshared keys with other nodes that are multihop away We callsuch keys as multihop pairwise keys (or MPKs for short) thatare required for securing end-to-end trafficAssume that nodes and are multihop apart and therouting path between them has been established using theunderlying routing protocol To establish an MPK andexecute the following protocol:1)2)Here  are random private numbers chosen bynodes and  respectively At the conclusion of the protocolnode calculatesLikewise node computesIf both nodes are legitimate and have followed the protocol cor-rectly by the bilinearity and symmetry of :Based on the MPK  nodes and can derive variousshared session keys for different security purposes as beforeDiscussion: If possible the two protocol messages can pig-gyback on the routing messages used to establish the routingpath between and  In doing so the related communicationoverhead can be much reduced In addition there is no need forand to further exchange messages to prove to the otherthe knowledge of the MPK Any future messages encrypted andauthenticated with the MPK or the derivative session keys canimplicitly achieve the same effectOur MPK establishment protocol is a simple adaptation ofthe provably secure ID-based key agreement protocol [28] Anythird party may overhear the plaintext messages exchangedbetween and  but cannot derive the MPK withoutknowing the LBKs of or  This protocol also has perfectresilience against node compromise because of the dependenceof the MPKs on the nodes’ private LBKsIV EFFICACY OF LBKS IN ATTACK MITIGATIONIn this section we show how the proposed LBKs can act as ef-fective and efficient countermeasures against several notoriousattacks against WSNsA Spoofing Altering or Replaying Routing InformationWithout precaution external adversaries are able to spoofalter or replay routing messages By doing so they attempt tocreate routing loops cause network partitions incur false errormessages and so on [1]As mentioned before neighboring nodes are required to per-form mutual authentication based on their private LBKs Sinceeach node only processes routing messages from authenticatedneighbors external adversaries can be prevented from enteringthe network and distributing phony routing messages The re-maining problem is how to defend against internal adversariesor compromised nodes in possession of authentic keying mate-rial It is believed that there is no cryptographic way that can pre-vent them from manipulating routing information However ourlocation-based neighborhood authentication scheme can con-strain the impact of compromised nodes to a small range cen-tered at their original locations In other words internal adver-saries cannot utilize the acquired keying material at one place tolaunch routing attacks at another distant place What they canonly possibly do is to continue misbehaving at “the scene ofthe crime” ie a small range around the location of the com-promised node If doing so they might run a high risk of beingdetected by legitimate nodes if effective localized misbehaviordetection mechanisms are availableB Sybil AttackThe Sybil attack happens when a malicious node behavesas if it were a large number of nodes eg by impersonatingother nodes or simply claiming multiple forged IDs and/or lo-cations As pointed out in [1] and [3] this attack is extremelydetrimental to many important WSN functions such as routingfair resource allocation misbehavior detection data aggrega-tion and distributed storage252 IEEE JOURNAL ON SELECTED AREAS IN COMMUNICATIONS VOL 24 NO 2 FEBRUARY 2006With our scheme in place when a malicious node intends toimpersonate a legitimate node it does not have the authenticLBK and thus cannot successfully finish mutual authenticationwith other legitimate nodes For the same reason a maliciousnode cannot claim forged IDs and/or locations without beingdetected Therefore the Sybil attack is effectively defeatedC Identity Replication AttackThe identity replication attack [3] takes place when adver-saries put multiple replicas of a compromised node in differentgeographic locations It may lead to the inconsistence of thenetwork routing information as well as jeopardizing other im-portant network functions Conventional defenses often involvea central authority eg the sink that either keeps a record ofeach node’s location [3] or centrally counts the number of con-nections a node has and revokes those with too many connec-tions [8] These solutions require node-to-node authenticationand pairwise key establishment to be performed through the cen-tral authority thereby causing significant communication over-head and the lack of scalabilityThis attack is no longer feasible when our location-basedneighborhood authentication scheme is applied The replicasof a compromised node will be prevented from entering thenetwork by legitimate nodes at locations other than the neigh-borhood of the compromised node Our countermeasure is to-tally self-organizing and does not involve any central authorityhence it is rather lightweight and highly scalable in contrast toprevious solutionsD Wormhole and Sinkhole AttacksWormhole [1] [29] and sinkhole [1] attacks are two notoriousattacks against WSN routing protocols that are difficult to with-stand especially when the two are used in combinationIn the wormhole attack instead of compromising any nodecollaborative adversaries first create a wormhole link essentiallyan out-of-band and low-latency channel between two distantnetwork locations They then tunnel routing messages recordedat one location via the wormhole link to the other leading tothe chaos of the routing operations Hu et al [29] presenteda technique called packet leashes to withstand the wormholeattack It requires extremely tight time synchronization and isthus infeasible for most WSNs as noted in [1] In contrasteach node in our scheme only accepts routing messages fromauthenticated neighbors and will discard those tunnelled fromdistant locations Therefore the wormhole attack is effectivelyand efficiently thwartedIn the sinkhole attack compromised nodes attempt to attractall the traffic from their surrounding nodes by announcing ahigh-quality route to the sink or some other destinations For ex-ample adversaries create an invisible and fast channel betweentwo compromised nodes and residing in distant network re-gions Node claims that it is one hop or a few hops away fromor other nodes close to  By doing so aims to be selectedby legitimate surrounding nodes as a packet relay to or othernodes in that region Fortunately our scheme can withstand suchsinkhole attacks against minimum-hop routing protocols Forinstance upon seeing ’s advertisement of a single-hop path tonode  a legitimate node can immediately find out that ismalicious by noting that the distance between and is farmore larger than the normal transmission range  In additiongeographic routing protocols such as [16] have been identifiedin [1] as promising solutions resistant to sinkhole and wormholeattacks The reason is that they construct the routing topologyon demand using only localized interactions and geographic in-formation To apply such schemes however the location in-formation advertised from neighboring nodes must be authenti-cated We provide such a guarantee by the LBKs and the loca-tion-based neighborhood authentication schemeWe note that our scheme itself cannot prevent the sinkholeattacks against routing protocols with routing metrics such asremaining energy or end-to-end reliability The major reasonis that the authenticity of these information is very difficult toverify by cryptographic means alone As far as we know therelated countermeasure thus far remains an open challengingissue and is an interesting topic worthy of further studyV LOCATION-BASED FILTERING OF BOGUS DATAIn this section we first describe the bogus data injection at-tack We then present a LTE scheme as the countermeasure Atlast we evaluate the performance of LTE in terms of energysavingsA Bogus Data Injection AttackAs mentioned before neighborhood mutual authentication issufficient to prevent external adversaries from injecting bogusdata into the network but will fail in the presence of internaladversaries By a single compromised node internal adversariescan induce arbitrary and seemingly authentic data reports intothe network Without precaution this kind of attack may do a lotof damage to the network eg causing false alarms or networktraffic congestion Even worse it can deplete the precious en-ergy of relaying nodes on any forwarding path to the sink whichis often tens or even hundreds of hops away from the sources ofdata reports It is therefore important to design effective andefficient countermeasures against this attackSince there is no way of hindering internal adversaries frominjecting bogus data we attempt to figure out ways to mitigatetheir impact Our first goal is to filter bogus data reports as earlyas possible before they reach the sink Our second goal is to de-tain adversaries from freely fabricating the originating locationsof injected bogus data reportsWe achieve the first goal by a threshold-endorsement methodThat is a data report should be co-signed by nodes for it tobe considered authentic A report without a correct endorse-ment will be regarded as a fake one and discarded by any le-gitimate node after verifying it Our method is motivated by theobservation that every point in the sensor field should be cov-ered by at least nodes known as the -coverage problem [30]The -coverage property is required by many security-sensitiveWSN applications such as intrusion detection to facilitate fine-grained surveillance In our case adversaries will have muchgreater difficulty in injecting seemingly authentic yet bogus datareports as they now have to compromise at least nodes insteadof only one as beforeZHANG et al: LOCATION-BASED COMPROMISE-TOLERANT SECURITY MECHANISMS FOR WSNS 253Fig 1 Node deployment modelWe fulfill the second objective by embedding the locationinformation of a data report’s originating area in the joint en-dorsement it carries To inject a bogus data report that origi-nates from a certain area and can survive the filtering by legiti-mate intermediate nodes adversaries must actually compromiseat least nodes holding keying material of that area Even sothey cannot utilize the acquired keying material to fake data re-ports that seem to originate from other areas Another benefit isthat once determining that some arriving reports are unfilteredbogus ones the sink can pinpoint their originating areas andthen take specific remedy actionsBelow we detail how to actually realize the above ideasB Generation and Distribution of Cell KeysTo enable LTE we propose the notion of cell keys For the sakeof simplicity we assume that the sensor field is a rec-tangle whose lower-left corner is at location  The sensorfield is divided into square cells of equal side length  Eachcell is labeled with a pair of integers  for and Prior to deployment and are preloadedto each node Also note that our LTE can be easily extended foruse with any other node deployment model (Fig 1)We define the cell key of cell as which shall be used to endorse any report originating from thatcell The next question is how to distribute to nodes incell  Let denote the th node with locationin cell  The naive method of letting each holdone copy of obviously suffers from single node compro-mise Instead we propose to utilize the secret-sharing technique[31] to assign a share of to each  The purpose is tomake reconstructible by any nodes in cell  whileirrecoverable by any less than of them To do this prior to net-work deployment the TA additionally generates a -de-gree polynomial  with coefficientsrandomly selected from 3 It also selects another systemparameter whose use is explained shortly We consider thefollowing two cases of cell-key share distribution depending onwhether node localization is range-based (cf Section III-B1) orrange-free (cf Section III-B2)1) Range-Based Cell-Key Distribution: In this approach theleading robot is preloaded with the polynomial  In ad-dition to determining a node’s location it decides that node’s3 denotes the set n fOg where fOg is the identity element of present cell by simple geometric calculations Consider nodeas an example Its location  ie  willsatisfy and Then the leading robot derivesand a set of authenticators  whereand  Note that it just needs to dothese computations once for each cell Next the leading robotcalculates  referredto as node ’s share of  Finally and aresecurely sent to node along with and its LBK (cfSection III-B1)can be reconstructed from any shares of it but is irre-trievable from any or fewer shares In particular letdenote the number of nodes in cell and be a -ordersubset of  We can compute(3)where Regarding the choice of  there is a tradeoffbetween resilience to node compromise and node density Ba-sically the larger  the more resilient the network is to nodecompromise the higher the required node density is and viceversa This issue is closely related to the well-studied -coverageproblem [30] We refer interested readers to [30] about how tostrike a good balance between these two competing metricsTo ensure high-level -coverage of cell boundaries with re-gard to security it is also important to let some nodes possesscell-key shares of adjacent cells In particular we require thatthe nodes out of a cell but within of the cell boundary also holdcell-key shares of that cell For example if node also has the authenticator vector and ashare of cell key  Likewise if  it ownsand a share of as well In addition for theboundaries of the sensor field it is often necessary to purposelydeploy some sensors beyond the field boundaries The choiceof represents a tradeoff between cell-boundary -coverage andtolerance to node compromise The greater  the higher level-coverage of cell boundaries the more vulnerable a cell key isto node compromise because more nodes have a cell-key shareand vice versa Its concrete value is also germane to that of andnode density2) Range-Free Cell-Key Distribution: In this method eachnode is preloaded with the polynomial in addition to thenetwork master secret  Consider again node as an ex-ample Once determining its own location  it also knowsthat it resides in cell  Therefore besides generating itsLBK (cf Section III-B2) node employs to first de-rive and then its share  Moreover it computes theauthenticator vector 4 If within of adjacent cells’ bound-aries node should as well compute a cell-key share andthe authenticator vector for each of those cells Upon finishingall these operations it should securely erase  and all thecomplete cell keys from its memory4The authenticators v (1  j  t   1) may be precalculated and pre-loaded to each node to reduce the computational overhead254 IEEE JOURNAL ON SELECTED AREAS IN COMMUNICATIONS VOL 24 NO 2 FEBRUARY 2006C Performing Threshold-Endorsements of Data ReportsNow we explain how to perform threshold-endorsements ondata reports Without loss of generality we take cell asan example in the following descriptionIn general sensor nodes generate a report when triggered bya special event such as the appearance of adversaries or in re-sponse to a query made by the sink Assume that such a stimulusoccurs in cell and is detected by nodes If the eventoccurs closely to the cell boundary then the nodes may includenodes in different adjacent cells To simplify our presentationhowever we assume that all of them are in cell  By localinteractions the detecting nodes can reach a consensus on a finalreport denoted by and containing application-dependent in-formation such as the type occurrence time and location of theeventThe detecting nodes are required to elect among them-selves an AP To obtain a threshold-endorsement of  theAP chooses a random and computesbroadcasted to the other detecting nodes Upon receipt of each detecting node endorses the report by com-puting  It then sends to the APencrypted and authenticated with the pairwise key sharedwith the AP [cf Section III-D] Once receiving over suchendorsements the AP randomly selects of the endorsersdenoted by a set notation which may include itself Itthen calculates (cf(3)) and  The threshold-endorsementof is and the final report is of formatIt is possible that some of the endorsers have been compro-mised and thus may provide the AP with falsely computedendorsements Fortunately our LTE scheme can well handlethis situation In particular once deriving  the AP isrequired to verify its authenticity by checking if the equationholds The check should succeedfor a valid because bythe bilinearity of and  Otherwise theAP proceeds to verify each received by checking ifThe verification works because of the following equations:(4)The third-line equation holds because is bilinear If the checksucceeds the AP considers node legitimate and compro-mised otherwise In this way the AP is able to pinpoint all theendorsers offering false endorsements and delete them from Subsequently it replenishes with the corresponding numberof endorsers randomly selected from the unused ones and re-calculates  As long as there are at least le-gitimate endorsers a correct threshold-endorsement can alwaysbe generatedIt is worth noting that the pinpoint-identification capabilityof the AP may deter the compromised endorsers (if any) fromproviding false endorsements As a result it is highly possiblethat the AP can derive an authentic threshold-endorsement in thefirst round In the light of this we let the AP verify the individualendorsements only when the threshold-endorsement is incorrectrather than at the beginning thereby reducing its computationalloadIn some cases the AP itself may be a compromised node Itmay either not at all send a final report to the sink or transmit abogus report with an incorrect or a wrong orboth Both attacks can be easily detected by the legitimate de-tecting nodes which in turn elect a new AP among themselvesto generate a new threshold-endorsement and send the final re-port to the sink Also note that dealing with the latter attack re-quires the legitimate detecting nodes to verify the threshold-en-dorsement in the final report The verifications are similar to thefiltering operations by intermediate nodes on the way to the sinkwhich are explained in what followsD Probabilistic Enroute Filtering of Data ReportsThe AP sends to the sink the final report along a multihoppath discovered via the underlying routing protocol Dependingon different applications end-to-end and/or link-layer se-curity measures can be enforced on the report transmission(cf Sections III-D and III-E) We denote by the samplingprobability which is a system-wide parameterUpon receipt of a report to be for-warded with probability  each intermediate node say  de-duces the originating cell information from the event lo-cation embedded in  It then computes(5)where is the public system parameter defined inSection III-A If the report is authentic we will have(6)Therefore if  node considers the reportauthentic and then forward it to the next hop Otherwise itthinks of the report a fabricated one and simply dumps itOur LTE scheme is a simplified adaptation of the provablysecure threshold version [32] of Hess’s ID-based signaturescheme [33]ZHANG et al: LOCATION-BASED COMPROMISE-TOLERANT SECURITY MECHANISMS FOR WSNS 255Fig 2 The probability p of filtering one bogus report as a function of thesampling probability p and the number  of hops a bogus report travelsE Efficacy and Security AnalysisWe first quantify the efficacy of probabilistic enroute filteringof fabricated data reports There might be compromised nodeslying on the forwarding path to the sink which just relay bogusreports to the next hop without verifying them Since we areonly interested in the energy consumption of legitimate inter-mediate nodes we merely consider a “valid” forwarding pathfrom which compromised nodes are extracted Given the sam-pling probability  the probability that a bogus report can bedetected and dropped within hops is  andthe average number of hops a bogus report traverses is(7)Fig 2 shows how changes with and  We can seethat even when assumes a small value say 03 over 83%of bogus reports can be filtered within five hops and less than3% of them can travel beyond ten hops Therefore for large-scale WSNs often involving very long forwarding paths ourLTE is highly effective in filtering bogus reports during theirearly transmission stages thereby saving the precious energy oflegitimate nodesDue to the probabilistic verifications at intermediate nodes abogus report might escape the filtering and reach the sink witha small probability  where indicates the for-warding path length As the last line of defense the sink is re-quired to verify the threshold-endorsement of each received re-port and discard those failing the testThe choice of represents a tradeoff between the early fil-terability of bogus reports and the computational overhead in-volved in verifying authentic reports On the one hand if istoo small a bogus report will statistically traverse more hopsbefore being filtered On the other hand if is too large itmay incur unnecessary computational overhead on intermediatenodes in verifying authentic reports can be either fixed ordynamically adjusted as time goes on For example if the sinkreceives many alarms of bogus reports from sensor nodes ordetects many unfiltered bogus reports by itself during a prede-termined time period it can increase by a certain amountor else decrease it The new can be securely conveyed tosensor nodes using a TESLA-like [34] broadcast authentica-tion protocolOur LTE scheme has strong resilience against node compro-mise It guarantees that as long as there are less than com-promised nodes holding cell-key shares of a same cell adver-saries are unable to forge data reports that seem to originatefrom that cell and can escape the filtering by enroute interme-diate nodes and the sink In the worst-case scenario adversariesmay manage to compromise at least nodes with cell-key sharesof a same cell We refer to this event as cell compromise For-tunately adversaries can only utilize the reconstructed cell keyto fabricate reports in that cell but not in other cells due to thelocation-dependent nature of the cell key Therefore if the sinkinitially accepts a report with a correct endorsement but finallyfinds that it is a bogus one by further field investigations or othermeans the sink can immediately detect the cell-compromiseevent and take corresponding remedy actions that are outsidethe paper scopeAdversaries might launch denial-of-service attacks by trap-ping legitimate nodes into endless verifications of data reportsConsequently if a legitimate node detects too many bogus re-ports in a short time window we assume that there are efficientways for it to report such an abnormality to the sink Anotherpossible attack is that a compromised intermediate node maystall the reporting of real events to the sink by either directlydropping any received report or tampering with the report con-tent before forwarding it to the next hop This attack is orthog-onal to the bogus data injection attack we focus on but we wouldlike to suggest several possible ways to withstand it One way isto utilize a SPREAD-like [35] secure multipath routing protocolto transmit copies of a report along multiple disjoint paths to thesink Another possible approach is through local monitoring en-abled by the broadcast nature of radio transmissions In partic-ular if an intermediate node receives a report from the prehopnode multiple neighbors of it can hear that packet as well Like-wise these neighbors can overhear the packet it transmits to thenext hop and thus be able to tell whether it behaves good ornot We leave the further investigation on this issue and its com-bination with the bogus data injection attack to a separate paperF Performance EvaluationIn this section we evaluate the performance of our LTE inachieving energy savings1) Pairing parameters: In our evaluation the bilinear mapused is the Tate pairing [20] The elliptic curve is defined over where is a 512-bit prime The order of and is a160-bit prime According to [19] our chosen parameters deliveran equivalent level of security to that of 1024-bit RSAWe use the following method to quantify the computationtime and energy consumption of the Tate pairing We assumethat the sensor CPU is a low-power high-performance 32-bitIntel PXA255 processor at 400 MHz The PXA255 has beenwidely used in many sensor products such as Sensoria WINS256 IEEE JOURNAL ON SELECTED AREAS IN COMMUNICATIONS VOL 24 NO 2 FEBRUARY 200630 and Crossbow Stargate According to [36] the typical powerconsumption of PXA255 in active and idle modes are 411 and121 mW respectively It was reported in [37] that it takes 752 msto compute the Tate pairing with the similar parameters as ourson a 32-bit ST22 smartcard microprocessor at 33 MHz There-fore the computation of the Tate pairing on PXA255 roughlyneeds ms and the energy consumptionis approximately 255 mJ2) Overhead Analysis: For an authentic report forwardedalong a -hop path LTE statistically involves filtering op-erations while it takes only one filtering operation to detect anddump a bogus report A filtering operation requires one expo-nentiation in  one hash function evaluation and two evalua-tions of the Tate pairing Due to the stationarity of sensor nodeseach sensor is more likely to forward reports from the same setof cells As a result each node can evaluate a limited set ofvalues beforehand each correspondingto a potential cell from which a report may come from By doingso one of the pairing evaluations can be eliminated As noted in[33] the pairing evaluation by far takes the most running time ofa filtering operation Thus for the sake of simplicity we useto approximate the energy consumption of an enroute filteringoperationOur LTE requires each report to carry a threshold-endorse-ment of format in addition to the normalfields Since is a point of  only one of its andcoordinates needs to be transmitted because the other can beeasily derived using the curve equation resulting in an over-head of 512 bits Also assume that the hash function is im-plemented using SHA-1 [21] with a 20-byte output Then thetotal packet overhead introduced by LTE is bytes toachieve a high level of security as that of 1024-bit RSA3) Energy Savings: Our LTE aims to save the energy of in-termediate nodes along the forwarding path to the sink throughits early detection and dropping of bogus data reports On theother hand the introduced packet overhead and the probabilisticenroute filtering operations incur both communication and com-putation energy consumption In the following we employ asimilar model to that of [4] to analyze the energy savings causedby LTE For the sake of simplicity we ignore the energy con-sumption of the report generation process which is consideredto be negligible as compared with that of transmitting it to thedistant sinkWe denote by the hop-wise energy consumption for trans-mitting and receiving one byte As reported in [38] a ChipconCC1000 radio used in Xrossbow MICA2DOT motes consumes286 and 592 J to receive and transmit one byte respectivelyat an effective data rate of 124 kb/s Thus we haveJ which is used as an exemplary value throughout ourevaluationWe also denote by the byte length of an original data re-port without using LTE and by the average number of hops anoriginal report travels toward the sink To simplify our evalua-tion we assume that is fixed to be 256 bytes We further as-sume that the ratio of legitimate data traffic to bogus data trafficis and is called the bogus traffic ratio hereafter As men-tioned before our LTE spends filtering operations in veri-fying an authentic report while merely one filtering operationFig 3 Comparison of E and E as a function of the bogus traffic ratio where  = 50 and the optimal p ’s are usedto sift a bogus report Let and be the normalized en-ergy consumed to deliver all the traffic without and with LTE inplace respectively Then we have(8)and(9)with equality if and only if Fig 3 compares with  where the optimal ’s areused and  We can see that increases dramaticallyalong with the increase of bogus data reports while al-ways maintains a rather stable level The reason is that mostbogus reports can be detected and dropped during their earlytransmission stages with LTE in place In addition when thereis no bogus traffic our LTE increases the energy consumptionby about 32% due to the introduced packet overhead Howeverwhen the bogus traffic starts to exceed the legitimate trafficLTE demonstrates growingly remarkable energy savings Forexample when and 5 our LTE saves more than 37%and 63% of energy respectivelyIn most WSN applications data delivery is event-driven andlegitimate traffic occurs only when some events of interest ap-pear in the sensor field In contrast to increase the impact oftheir attacks adversaries often inject into the network a largeamount of bogus traffic which is often several orders of magni-tude greater than that of legitimate traffic [4] Our LTE is partic-ularly useful for these scenarios in saving a great deal of energyby early filtering bogus data reportsIn reality it is often difficult to obtain an accurate estimateof the bogus traffic ratio  Therefore to some extent Fig 3reflects the upper-bound performance of our LTE There areZHANG et al: LOCATION-BASED COMPROMISE-TOLERANT SECURITY MECHANISMS FOR WSNS 257Fig 4 Comparison of E and E as a function of the bogus traffic ratio where  = 50 and nonoptimal p ’s are usedFig 5 Comparison ofE andE as a function of the average path length where  = 2 and p = 0:2two possible ways to approach this upper bound In the first ap-proach the sink estimates the current based on the received re-ports and possible alarms from sensor nodes It then derives theoptimal sampling probability  which is conveyed to sensornodes using a TESLA-like [34] broadcast authentication pro-tocol The other approach is for each node itself to estimate theas the ratio of bogus traffic to legitimate traffic in the total trafficsampled during a certain period Then it can compute the newlocally optimal to itselfEven if without using an optimal  the energy savings re-sulting from our LTE are still remarkable Fig 4 depicts the casethat nonoptimal values of are used The advantages of usingour LTE are quite obvious under all the three sampling proba-bilities Another observation is that when becomes largershould be increased as well in order to filter bogus data reports asearly as possible Likewise the new can either be determinedby the sink as a network-wide common value or be decided in-dividually by each node based on its local observationsNext we investigate the impact of the average path lengthon the energy-saving performance of LTE As can be seen fromFig 5 the further the originating cells of bogus data reports areawayfromthesink themoreenergysavings ourLTEcanachieveWe note that adversaries may inject bogus data reports to con-sume the energy resources of the nodes that are only several hopsaway from the sink For this case our LTE might not achievethe desirable objective because the energy savings from early fil-tering bogus reports may be offset by the energy consumptionincurred by our scheme However bogus reports injected in thedistant cells away from the sink are much more detrimental thanthose injected in the sink’s vicinity because their transmissionsinvolve many more intermediate nodes In addition we believethat it is much easier for the sink to detect the bogus data injec-tion attack mounted in its vicinity than in the distant cellsVI RELATED WORKRecent years have witnessed growing interest in sensor net-work security Due to space limitations here we merely discussprior art that is more germane to this paperHow to set up a pairwise shared key between two sensors isa topic which by far has attracted extensive attention As a pio-neering solution Eschenauer and Gligor propose a probabilistickey predistribution scheme [7] The main idea is to preload eachsensor with a random subset of keys from a global key poolin a way that any two nodes can share at least one commonkey with a certain probability This scheme has been improvedlater by several other proposals such as [8]–[10] in terms of net-work connectivity memory usage and resilience against nodecompromise among others Unfortunately these probabilisticschemes suffer from a few drawbacks that may limit their po-tential in large-scale WSNs demanding a high level of securityFirst of all as noted in [39] these schemes are vulnerable tonode compromise attacks in that adversaries who compromisedsufficiently many nodes could also obtain a large fraction ofpairwise keys shared between noncompromised nodes Secondthey are subject to all the attacks discussed in Section IVThird they are designed to establish pairwise shared keysamong neighboring nodes As a result they are both inefficientand insecure in setting up a pairwise key shared between twononneighboring nodes or two neighboring nodes without apriori shared knowledge Fourth most of them fail to providesecure neighborhood authentication which is prerequisite forguaranteeing link-level security Although the random pairwisekeys scheme in [8] offers mutual authentication between twoneighbors having a preloaded pairwise key the resulting costis the much restricted supportable network size [3] Fifththese schemes all have an upper limit on the network size andoften require each node to store tens or even hundreds of keysleading to the poor network scalability Finally all of themdo not offer support for nonrepudiation of digital signatureswhich is one of the fundamental security requirementsAs compared with the above schemes our schemes enabledeterministic secure and efficient establishment of a sharedkey between any two network nodes be they immediate neigh-bors or multiple hops apart Our IPK and MPK establishmentmethods both have perfect resilience against node compromisebecause of their reliance on the private LBK’s of individualnodes In addition our schemes can not only limit the impactof compromised nodes to their vicinity but also withstandother notorious attacks like those mentioned in Section IV258 IEEE JOURNAL ON SELECTED AREAS IN COMMUNICATIONS VOL 24 NO 2 FEBRUARY 2006Moreover our schemes provide secure location-based neigh-borhood authentication and support nonrepudiation of digitalsignatures Furthermore our schemes merely require each nodeto memorize its own IBK and LBK and allow the addition ofan arbitrary number of new nodesSome other proposals [11]–[14] propose to use the knowndeployment information to facilitate more secure and efficientpairwise key establishment These solutions still belong to thecategory of the probabilistic schemes thereby suffering fromeither some or even all of the aforementioned drawbacks In ad-dition concrete geographic locations of individual nodes are notused in all of them More recently Lazos et al [40] present a lo-cation-based solution to deal with the wormhole attack This so-lution addresses neither the establishment of multihop pairwisekeys nor the issue of node addition (or the network scalabilityissue)Aside from the probabilistic schemes another notable workcalled LEAP is proposed by Zhu et al in [27] In LEAP eachnode is preloaded with a global shared secret through whichit can authenticate neighboring nodes and establish pairwiseshared keys with them once deployed However the MPK es-tablishment method of LEAP suffers from both the significantcommunication overhead and the vulnerability to the compro-mise of intermediate nodes In addition LEAP does not supportnonrepudiation of digital signaturesWe are aware of two existing solutions to the bogus data in-jection attack namely SEF [4] and IHA [5] Both schemes canachieve the same objective of energy savings as our LTE by de-tecting and dropping bogus reports as early as possible How-ever adversaries who compromised nodes carrying keys fromdifferent key partitions can render SEF completely uselessas noted in [4] Likewise IHA breaks down once adversariescompromise over nodes and thus are able to forge data re-ports seeming to originate from arbitrary network locations Ina large-scale WSN with many more than nodes however itseems unlikely to prevent adversaries from compromising overnodes In addition IHA suffers from the considerable com-munication overhead in maintaining the per-route interleavedstructure of nodes as compared with both SEF and our LTEBy comparison our LTE is able to localize the impact of com-promised nodes to their vicinity due to its location-dependentnature It can tolerate the compromise of up to nodesholding cell-key shares of the same cell and thus many morenodes regarding the whole network Therefore our LTE exhibitsmuch better compromise-tolerant performance than both SEFand IHAThere are many other related work in sensor network secu-rity Carman et al [41] investigate the performance of a numberof key management schemes over different hardware platformsBasagni et al [6] utilize tamper-resistant hardware in periodi-cally updating the key shared by all the nodes Perrig et al [34]propose SNEP a protocol for data confidentiality and two-partydata authentication and TESLA a protocol for broadcast dataauthentication TESLA is further improved by Liu and Ning in[42] Przydatek et al [43] construct efficient random samplingmechanisms and interactive proofs to ensure secure informationaggregation in WSNs Karlof and Wagner [1] discuss variousattacks against existing sensor network routing protocols andpoint out some possible solutions Newsome et al [3] analyzein detail the impact of the Sybil attack on sensor networks andpropose several defensesVII DISCUSSIONIn this section we discuss the use of symmetric-key versuspublic-key cryptography (PKC) in WSNsIt was a common belief that PKC is too complex slow andpower hungry and thus ill-suited for use in resource-con-strained WSNs For this reason PKC has often been ruledout for securing WSNs and most previous proposals such as[7]–[14] are purely based on symmetric-key cryptographyHowever many researchers [38] [44]–[47] have recently chal-lenged this belief by showing that traditional PKC such as RSAor elliptic-curve cryptography is rather viable in WSNsMoreover we have mentioned previously that the pure sym-metric-key solutions have a number of drawbacks due to the in-herent limitations of symmetric-key cryptography In additionthey may not be so energy efficient as they are claimed to be Forexample most of the probabilistic key predistribution schemessuch as [7]–[10] require a secure “puzzle-solving” method to setup a shared key between two neighboring nodes In particularone node broadcasts a key-discovery message containing a chal-lenge and ciphertexts for  where is apotential pairwise key the other node may have If the other nodecan correctly decrypt any of the ciphertexts it can establisha pairwise key with the broadcasting node Since there are oftenseveral tens or even hundreds of potential pairwise keys thetotal energy consumption caused by communication and sym-metric-key encryption and decryption operations may have beenalready higher than that of a public-key solution Therefore webelieve that it is both necessary and feasible to design public-keysolutions for security-sensitive WSNs to establish shared keysfor subsequent use with efficient symmetric-key algorithmsOur proposed schemes are public-key solutions built uponthe pairing-based IBC which is more appropriate than tradi-tional PKC for WSNs (cf Section II-A) Therefore our schemeseliminate the need for transmitting and verifying conventionalpublic-key certificates As an emerging technique IBC is underrapid development For example according to the recent re-sult in [48] the Tate pairing can be evaluated up to ten timesfaster than previously reported implementations We have alsobeen aware of the efficient hardware implementations of the Tatepairing on smartcards [37] PDAs [49] and FPGAs [50] Thereal implementation of the pairing on sensor node hardware ispart of our ongoing workVIII CONCLUSIONTo counteract the impact of compromised nodes this paperpresents a comprehensive set of location-based compromise-tolerant security mechanisms for WSNs We first propose thenotion of LBKs by binding private keys of individual nodesto both their IDs and concrete geographic locations We thendevelop an LBK-based neighborhood authentication protocolwhich is able to constrain the impact of compromised nodes totheir vicinity We also present efficient methods to set up pair-wise shared keys between any two network nodes be they di-ZHANG et al: LOCATION-BASED COMPROMISE-TOLERANT SECURITY MECHANISMS FOR WSNS 259rect neighbors or multihop away In addition we demonstratethe capability of LBKs in withstanding some notorious attacksagainst WSNs Moreover we design a LTE scheme to filterbogus traffic injected by adversaries during their early trans-mission stages The remarkable energy savings resulting fromLTE have been confirmed by detailed performance evaluationAs the future research we plan to evaluate the performance ofthe proposed schemes in real sensor platforms We also intend tofurther investigate the potential applications of LBKs in WSNssuch as misbehavior detection secure distributed storage securerouting and target trackingREFERENCES[1] C Karlof and D Wagner “Secure routing in wireless sensor networks:Attacks and countermeasures” Ad Hoc Netw vol 1 no 2 pp 293–3152003[2] J R Douceur “The Sybil attack” in Proc 1st Int Workshop on Peer-to-Peer Syst Cambridge MA Mar 2002 pp 251–260[3] J Newsome E Shi D Song and A Perrig “The sybil attack in sensornetworks: Analysis & defenses” in Proc 3rd Int Symp Inf ProcessSensor Netw Berkeley CA Apr 2004 pp 259–268[4] F Ye H Luo S Lu and L Zhang “Statistical en-route filtering of in-jected false data in sensor networks” in Proc IEEE INFOCOM HongKong China Mar 2004 pp 2446–2457[5] S Zhu S Setia S Jajodia and P Ning “An interleaved hop-by-hopauthentication scheme for filtering of injected false data in sensor net-works” in Proc IEEE Symp Security Privacy Oakland CA May 2004pp 259–271[6] E R S Basagni K Herrin and D Bruschi “Secure pebblenets” inProc ACM MobiHoc Long Beach Oct 2001 pp 256–263[7] L Eschenauer and V Gligor “A key-management scheme for dis-tributed sensor networks” in Proc ACM CCS Washington DC Nov2002 pp 41–47[8] H Chan A Perrig and D Song “Random key predistribution schemesfor sensor networks” in Proc IEEE Symp Security Privacy OaklandCA May 2003 pp 197–213[9] W Du J Deng Y Han and P Varshney “A pairwise key predistributionscheme for wireless sensor networks” in Proc ACM CCS WashingtonDC Oct 2003 pp 42–51[10] D Liu and P Ning “Establishing pairwise keys in distributed sensornetworks” in Proc ACM CCS Washington DC Oct 2003 pp 52–61[11]  “Location-based pairwise key establishments for static sensor net-works” in Proc ACM SASN Fairfax VA Oct 2003 pp 72–82[12] W Du J Deng Y Han S Chen and P K Varshney “A key man-agement scheme for wireless sensor networks using deployment knowl-edge” in Proc IEEE INFOCOM Hong Kong China Mar 2004 pp586–597[13] D Huang M Mehta D Medhi and L Harn “Location-aware key man-agement scheme for wireless sensor networks” in Proc ACM SASNWashington DC Oct 2004 pp 29–42[14] Y Zhou Y Zhang and Y Fang “LLK: A link-layer key establishmentscheme in wireless sensor networks” in Proc IEEE WCNC New Or-leans LA Mar 2005 pp 1921–1926[15] A Cerpa J Elson D Estrin L Girod M Hamilton and J Zhao“Habitat monitoring: Application driver for wireless communicationstechnology” in Proc ACM SIGCOMM Workshop Data Comm LatinAmerica and the Caribbean Costa Rica Apr 2001 pp 20–41[16] B Karp and H Kung “GPSR: Greedy perimeter stateless routing forwireless networks” in Proc ACM MobiCom Boston MA Aug 2000pp 243–254[17] K Barr and K Asanovic “Energy aware lossless data compression” inProc 1st Int Conf Mobile Syst Applicat Services San Francisco CAMay 2003 pp 231–244[18] A Shamir “Identity based cryptosystems and signature schemes” inLecture Notes in Computer Science New York: Springer-Verlag1984 vol 196 Proc CRYPTO pp 47–53[19] D Boneh and M Franklin “Identify-based encryption from the Weilpairing” in Lecture Notes in Computer Science New York: Springer-Verlag 2001 vol 2139 Proc CRYPTO pp 213–229[20] P Barreto H Kim B Bynn and M Scott “Efficient algorithmsfor pairing-based cryptosystems” in Lecture Notes in Computer Sci-ence New York: Springer-Verlag 2002 vol 2442 Proc CRYPTOpp 354–368[21] Digital Hash Standard Federal information processing standards pub-lication 180-1 Apr 1995[22] S ˇCapkun and J-P Hubaux “Secure positioning of wireless deviceswith application to sensor networks” in Proc IEEE INFOCOM MiamiFL March 2005 pp 1917–1928[23] Y Zhang W Liu and Y Fang “Secure localization in wireless sensornetworks” in Proc IEEE MILCOM 2005[24] L Lazos and R Poovendran “Serloc: Secure range-independent local-ization for wireless sensor networks” in Proc ACM WiSe PhiladelphiaPA Oct 2004 pp 21–30[25] D Liu P Ning and W Du “Attack-resistant location estimation insensor networks” in Proc IPSN Apr 2005 pp 99–103[26] W Du L Fang and P Ning “LAD: Localization anomaly detectionfor wireless sensor networks” in Proc IPDPS Denver CO Apr2005[27] S Zhu S Setia and S Jajodia “LEAP: Efficient security mechanismsfor large-scale distributed sensor networks” in Proc ACM CCS Wash-ington DC Oct 2003 pp 62–72[28] L Chen and C Kudla “Identity based authenticated key agreement pro-tocols from pairings” Cryptology ePrint Archive 2002[29] Y Hu A Perrig and D Johnson “Packet leashes: A defense againstwormhole attacks in wireless ad hoc networks” in Proc IEEE IN-FOCOM San Francisco CA Apr 2003 pp 1976–1986[30] S Kumar T Lai and J Balogh “On k-coverage in a mostly sleepingsensor network” in Proc ACM MobiCom Philadelphia PA Sep/Oct2004 pp 144–158[31] A Shamir “How to share a secret” in Commun ACM vol 22 1979pp 612–613[32] J Baek and Y Zheng “Identity-based threshold signature from the bi-linear pairings” in Proc Int Conf Inf Tech: Coding Comput LasVegas NV Apr 2004 pp 124–128[33] F Hess “Efficient identity based signature schemes based on pairings”in Proc SAC St John’s NF Canada Aug 2002 pp 310–324[34] A Perrig R Szewczyk J Tygar V Wen and D Culler “Spins: Securityprotocols for sensor networks” ACM Wireless Netw pp 521–534 Sep2002[35] W Lou W Liu and Y Fang “SPREAD: Enhancing data confidentialityin mobile ad hoc networks” in Proc IEEE INFOCOM Hong KongChina Mar 2004 pp 2404–2413[36] Intel PXA255 Processor Electrical Mechanical and Thermal Specifi-cation http://wwwintelcom/design/pca/applicationsprocessors/man-uals/278780h% tm[37] G Bertoni L Chen P Fragneto K Harrison and G Pelosi1 “Com-puting Tate pairing on smartcards” White Paper STMicroelectronics2005 [Online] Available: http://wwwstcom/stonline/products/fami-lies/smartcard/ast_ibehtm[38] A Wander N Gura H Eberle V Gupta and S Chang “Energy anal-ysis for public-key cryptography for wireless sensor networks” in ProcIEEE PerCom Pisa Italy Mar 2005[39] A Perrig J Stankovic and D Wagner “Security in wireless sensor net-works” in Commun ACM vol 47 Jun 2004 pp 53–57[40] L Lazos R Poovendran C Meadows P Syverson and L Chang “Pre-venting wormhole attacks on wireless ad hoc networks: A graph theo-retic approach” in Proc IEEE WCNC New Orleans LA Mar 2005pp 1193–1199[41] D Carman P Kruus and B Matt “Constraints and approaches for dis-tributed sensor network security” NAI Labs Tech Rep 00-010 Sep2000[42] D Liu and P Ning “Efficient distribution of key chain commitments forbroadcast authentication in distributed sensor networks” in Proc NDSSSan Diego CA Feb 2003 pp 263–276[43] B Przydatek D Song and A Perrig “SIA: Secure information aggre-gation in sensor networks” in Proc ACM SenSys’03 Los Angeles CANov 2003 pp 255–265[44] D J Malan M Welsh and M D Smith “A public-key infrastructurefor key distribution in tinyos based on elliptic curve cryptography” inProc IEEE SECON Santa Clara CA Oct 2004 pp 71–80[45] N Gura A Patel A Wander H Eberle and S C Shantz “Comparingelliptic curve cryptography and RSA on 8-bit CPUS” in Proc CHESBoston MA Aug 2004 pp 119–132[46] R Watro D Kong S fen Cuti C Gardiner C Lynn and P Kruus“Tinypk: Securing sensor networks with public key technology” in ProcACM SASN Washington DC Oct 2004 pp 59–64[47] G Gaubatz J Kaps and B Sunar “Public keys cryptography in sensornetworks—revisited” in Proc ESAS Heidelberg Germany Aug 2004pp 2–18[48] P Barreto B Lynn and M Scott “On the selection of pairing-friendlygroups” in Lecture Notes in Computer Science New York: Springer-Verlag 2004 vol 3006 Proc Sel Areas Cryptography pp 17–25260 IEEE JOURNAL ON SELECTED AREAS IN COMMUNICATIONS VOL 24 NO 2 FEBRUARY 2006[49] M Scott “Computing the Tate pairing” in Proc Cryptographers’ Trackat the RSA Conf San Francisco CA Feb 2005 pp 293–304[50] T Kerins W Marnane E Popovici and P Barreto “Efficient hard-ware for the Tate pairing calculation in characteristic three” in ProcWorkshop on Cryptographic Hardware and Embedded Syst EdinburghScotland Aug/Sep 2005 pp 412–426Yanchao Zhang (S’03) received the BE degree incomputer communications from Nanjing Universityof Posts and Telecommunications Nanjing Chinain 1999 and the ME degree in computer applica-tions from Beijing University of Posts and Telecom-munications Beijing China in 2002 He is currentlyworking towards the PhD degree in the Departmentof Electrical and Computer Engineering Universityof Florida GainesvilleHis research focuses on security trust and privacyin network and distributed systems with current em-phases on mobile ad hoc networks wireless sensor networks wireless meshnetworks and hybrid wired/wireless networksWei Liu received the BE and ME degrees in elec-trical and information engineering from HuazhongUniversity of Science and Technology WuhanChina in 1998 and 2001 respectively and the PhDdegree in electrical and computer engineering fromthe University of Florida Gainesville in 2005Currently he is a Senior Technical Member withScalable Network Technologies His research interestincludes cross-layer design and communication pro-tocols for mobile ad hoc networks wireless sensornetworks and cellular networksWenjing Lou (S’01–M’03) received the MAScdegree from Nanyang Technological UniversitySingapore in 1998 the BE degree in computerscience and engineering the ME degree fromXi’an Jiaotong University China in 1993 and 1996respectively and the PhD degree in electrical andcomputer engineering from the University of FloridaGainesville in 2003She is an Assistant Professor in the Electricaland Computer Engineering Department WorcesterPolytechnic Institute Worcester MA From 1997 to1999 she worked as a Research Engineer in the Network Technology ResearchCenter Nanyang Technological University Her current research interests arein the areas of ad hoc and sensor networks with emphases on network securityand routing issuesYuguang Fang (S’95–M’99–SM’99) received theBS and MS degrees in mathematics from QufuNormal University Qufu Shandong China in 1984and 1987 respectively the PhD degree in systemsand control engineering from the Department ofSystems Control and Industrial Engineering CaseWestern Reserve University Cleveland OH in1994 and the PhD degree in electrical engineeringfrom the Department of Electrical and ComputerEngineering Boston University Boston MA in1997From 1987 to 1988 he held Research and a Teaching position in both theDepartment of Mathematics and the Institute of Automation Qufu Normal Uni-versity From 1989 to 1993 he was a Teaching/Research Assistant in the De-partment of Systems Control and Industrial Engineering Case Western ReserveUniversity where he held a Research Associate position from January 1994 toMay 1994 He held a Postdoctoral position in the Department of Electrical andComputer Engineering Boston University from 1994 to 1995 From 1995 to1997 he was a Research Assistant in the Department of Electrical and ComputerEngineering Boston University From 1997 to 1998 he was a Visiting Assis-tant Professor in the Department of Electrical Engineering University of Texasat Dallas From 1998 to 2000 he was an Assistant Professor in the Departmentof Electrical and Computer Engineering New Jersey Institute of TechnologyNewark In May 2000 he joined the Department of Electrical and ComputerEngineering University of Florida Gainesville where he received an early pro-motion to Associate Professor with tenure in August 2003 and to Full Professorin August 2005 He has published over 150 papers in refereed professional jour-nals and conferences His research interests span many areas including wirelessnetworks mobile computing mobile communications wireless security auto-matic control and neural networksDr Fang is a member of the Association for Computing Machinery (ACM)He received the National Science Foundation Faculty Early Career Award in2001 and the Office of Naval Research Young Investigator Award in 2002He also received the 2001 CAST Academic Award He is listed in MarquisWho’s Who in Science and Engineering Who’s Who in America and Who’sWho in the World He has actively engaged in many professional activitiesHe is an Editor for the IEEE TRANSACTIONS ON COMMUNICATIONS the IEEETRANSACTIONS ON WIRELESS COMMUNICATIONS the IEEE TRANSACTIONSON MOBILE COMPUTING ACM Wireless Networks and the IEEE WirelessCommunications He was an Editor for the IEEE JOURNAL ON SELECTEDAREAS IN COMMUNICATIONS: Wireless Communications Series an Area Editorfor ACM Mobile Computing and Communications Review an Editor for WileyInternational Journal on Wireless Communications and Mobile Computingand Feature Editor for Scanning the Literature in IEEE Personal Communica-tions He has also been actively involved with many professional conferencessuch as ACM MobiCom’02 (Committee Co-Chair for Student Travel Award)MobiCom’01 IEEE INFOCOM’06 INFOCOM’05 (Vice-Chair for Tech-nical Program Committee) INFOCOM’04 INFOCOM’03 INFOCOM’00INFOCOM’98 IEEE WCNC’04 WCNC’02 WCNC’00 (Technical Pro-gram Vice-Chair) WCNC’99 IEEE Globecom’04 (Symposium Co-Chair)Globecom’02 and the International Conference on Computer Communicationsand Networking (IC3N) (Technical Program Vice-Chair)
LowEnergy-Key Management WSN-pdf,A Low-Energy Key Management Protocol for Wireless Sensor NetworksGaurav Jolly Mustafa C Kuúçu Pallavi Kokate and Mohamed Younis Computer Science and Electrical EngineeringUniversity of Maryland Baltimore CountyBaltimore Maryland 21250{jolly1 kuscu1 pallavi2 younis}@umbcedu*Abstract Wireless sensor networks have a widespectrum of civil and military applications that call forsecurity eg target surveillance in hostile environmentsTypical sensors possess limited computation energy andmemory resources; therefore the use of vastly resource-consuming security mechanisms is not possible In thispaper we propose a cryptographic key managementprotocol which is based on the IBSK scheme but only twosymmetric keys are required to be pre-deployed at eachsensor The protocol supports the eviction of thecompromised nodes Simulation shows that the energyconsumption overhead introduced by the key managementis remarkably low thanks to the  multi-tier networkarchitecture in which only sensor-to-gateway securesessions are allowed and reports order-of-magnitudeimprovement in energy saving as compared to the originalIBSK scheme and Kerberos-like schemes1 IntroductionMany compelling applications like distributedinformation gathering and distributed micro sensing inradiology military and manufacturing drive the research insensor networks Typically sensor networks comprise of a large set of distributed low power sensors scattered over thearea to be monitored  The sensors have the ability to gatherdata and process and forward it to a central node for furtherprocessing A major challenge for the sensor networks isthe limitations on the sensor hardware Contemporary wireless sensors have limited batterycomputation and memory capacity Such resource-constrained environment has motivated extensive researchthat addresses energy-aware hardware and software designissues [1][2] Much effort has been on the energy-efficientcommunication protocols [3][4][5] The comparativeprogress in making these networks secure has beeninsignificant This is despite the fact that in certainapplications of sensor networks like military applicationssecurity becomes importantThe energy-constrained nature of the sensor networksmakes the problem of incorporating security verychallenging Many well-known security mechanismsintroduce significant computational/memory-wiseoverhead  The design of the security protocols for sensornetworks should be geared towards conservation of thesensor resources The level of security versus theconsumption of energy computation and memoryresources constitute a major design trade-offIn this paper we focus on the design of a very lowenergy key management scheme for a sensor network Ourprotocol which is an extension of the Identity-BasedSymmetric Keying (IBSK) scheme [10] introducesflexibility to IBSK by supporting the addition of sensorsand the revocation of the network nodes (their keys) aswell as key renewals Our scheme inherits the advantagesof the pre-deployed keying nature of the IBSK In order tofurther reduce the energy consumption by the sensors werule out the direct end-to-end communication amongsensors feature while preserving the hop-by-hop routingfunctionality We also provide simulation results for the energy consumption (Section 4)The organization of the rest of the paper is as followsSection 2 describes the sensor network architecture that westudy In Section 3 we present a hierarchical keymanagement protocol that consists of sub-protocols for thekey distribution and the initialization steps as well as forthe addition of sensors and the revocation of the networknodes and a key renewal mechanism for our sensornetwork We list the assumptions and design trade-offs inSection 3 Section 4 describes the simulation environmentand results Section 5 summarizes the related work onsensor network security and key management FinallySection 6 concludes the paper and discusses open problems* Mustafa C Kuúçu is the contact author He can be reached byphone at (410) 455-3968 by FAX at (410) 455-3969 and by e-mail as kuscu1@umbcedu The authors would like to thank Dr Alan Sherman and William Byrd for their valuable comments1Proceedings of the Eighth IEEE International Symposium on Computers and Communication (ISCC’03) 1530-1346/03 $1700 © 2003 IEEE 2 Sensor network architecture 3 Key managementA key management procedure is an essential constituentof network security Symmetric key systems require thekeys to be kept out of reach of the adversary Moreoversensor networks have energy-wise and computationalconstraints; therefore it is necessary to maintain a balancedsecurity level with respect to those constraints In this section we propose a key management scheme for sensornetworks whose objective being the minimization of thesensor’s computational communications-wise and storageoverhead due to the key management operationsWe adopt the sensor network model proposed byYounis et al [3][6] In this model a sensor networkconsists of a large number of sensors distributed over an area of interest There is a command node in charge of thenetwork’s mission The model also introduces super-nodescalled gateways in addition to the sensor nodes The gateways have considerably high energy resourcescompared to the sensors and are equipped with high performance processors and more memory As shown inFigure 1 the gateways partition the sensors into distinctclusters using a clustering algorithm eg [7] Each clusteris composed of a gateway and a set of sensor nodes (distinctfrom other sets) which gather information and transmit tothe gateway of their cluster The gateway fuses the datafrom the different sensors performs mission-related dataprocessing and sends it to the command node via long-haultransmissionIn military reconnaissance scenarios the sensors and thegateways are likely to be deployed in the enemy territoryThe sensors in each cluster will report the sensed enemymovements to the gateway that in turn will process that dataand forward it to the command node The command node isdeployed in the friendly environment Therefore we canassume that the command nodes are secure while thegateways and sensors can be compromisedCommand NodeSensor nodesGateway Node31 AssumptionsIn a data gathering setup like ours the end-to-endcommunications between sensors is not common Thesemantic of the sensor-to-sensor communication can beviable in system models that require the sensors to performdata fusion and setup the routes1 In our model this is notthe case instead all traffic within a cluster flows over thegateway of the cluster Therefore the high overhead ofestablishing secure sessions between individual sensors canbe avoided Moreover we assume that each sensor uses direct communications with the gateway during keymanagement operationsFigure 1 Multi-gateway clustered sensor networkOn the other hand typical sensors are extremelyconstrained in resources For example a MICA sensor [9]is quite restrictive: TinyOS operating system 4K RAM128K flash memory and Atmel ATmega processor (8-bit4MHz) and runs with 2 AA batteriesWe assume that the functionality of intrusion detectionis available (eg tamper detection network intrusiondetection) to the command node although we are not awareof any intrusion detection for sensor networks and althoughwe do not specify how one is going to workIn our model [3][6] the energy-aware operation of thesensors is mainly achieved by keeping the quiescent sensorsin the sleep mode by using a Time Division MultipleAccess (TDMA) based Media Access Control wherein thegateway assigns distinct activity slots to the sensors Otherthan the sleep mode the sensor can be either active or idleIn the active mode the sensor is transmitting receiving orsensing In the idle mode the sensor is idle but its circuitryis on The sensors transmit in the slots assigned to them andthereafter in order to conserve energy make a transition to sleep mode The computation part of the sensor is alwayson except in the sleep mode In the sleep mode the circuitry is switched off and hence the sensor can save energy andextend its lifetimeThe sensors and the gateways are randomly distributedand are not aware of the topology prior to the deploymentSome assumptions on the network nodes are as follows:i Sensors We are not making any trust assumptions onsensors or any assumptions on the capabilities of theadversary Each sensor is capable of determining itslocation by using GPS during bootstrapping Sensorsremain stationary during the operation of the networkii Gateways Each gateway can directly communicatewith every other gateway in the network Moreover weIn the next section we focus on the key managementaspects for a sensor network used in militaryreconnaissance setup1 During bootstrapping sensors may need to communicate witheach other We are not addressing the security of networkbootstrapping2Proceedings of the Eighth IEEE International Symposium on Computers and Communication (ISCC’03) 1530-1346/03 $1700 © 2003 IEEE assume that broadcast communication among gateways isavailable We also assume that there is secure group communications among the gateways The clusteringalgorithm eg [7] can be easily extended to bring in the setting up of the secure communications The gateways can establish the group key using a group key agreementprotocol Carman et al discuss those protocols in [10]iii Command node The command node is assumed tobe secure and is trusted by all of the nodes in the sensornetwork The intrusion detection mechanism will operateintegral to the command node and the eviction of acompromised node will be triggered by the intrusiondetection mechanism32 Proposed approachOur key management protocol is a symmetric-keymechanism and consists of the sub-protocols that definehow keys are distributed added revoked and renewedduring the lifetime of the sensor network The approachdoes not call for any sensor to generate keys or to performany extensive computation associated with keymanagementDistribution of the keys We utilize a secret-keymechanism and each sensor stores only two keys One keyis shared with a gateway and the other is shared with thecommand node Since the sensors are not trusted and arememory-constrained storing a small number of keys isadvantageous for the security of the network as well as itsaves the memory The gateways have rich memoryresources and can store large number of keys; howeverthey cannot be completely trusted Assigning all the keys tothe gateway will compromise the entire network even in the case of compromise of a single gateway The commandnodes are assumed to be secure and have sufficientmemory Therefore the command node can store all of thesecret keys in the network The sensor keys areprogrammed into the memory of the sensors before they aredeployed They can be stored in the flash RAM and beerased when necessaryTable 1: Notation used in the key management protocolsNotation DescriptionC command node Gi gateway iSi sensor node iG set of all gateways in the networkS set of all sensors idi identifier for node inonce random nonce valuesdata Sensor location and energy level data A  BKsecret key shared between A and B(A and B each can be Si Gi or C)E(K …) symmetric encryption function using key K& concatenation operatorGh head gateway (used for revocation)Table 1 displays the notation used in the protocoldescriptions The number of keys stored by the commandnode is equal to G S  where G  is the number of gateways and S  is the number of sensors Each gatewaystores the keys it shares with the sensors in its cluster andthe key it shares with the command node It also shares onekey with exactly one other gateway in the network alongwith the group key shared with all the gateways The keysare pre-deployed therefore there is no keytransmission/reception overhead (consumes energy) at thesensor side during the bootstrapping Initialization phase At the time of deployment each gateway is randomly assigned S G  keys Then eachgateway forms clusters using a cluster formation algorithmand thereafter acquires the keys of the sensors in its cluster from the other gateways After the key exchange at thegateway level each gateway keeps the keys of the sensorsthat in its cluster others keys are erased This is essentialsince if a gateway is captured then the keys of only its cluster become available to the adversary The protocol forthe initialization phase is as follows:Si broadcasto id id E(  nonce sdata)j i i jG S S GK& & & (i1)Each sensor is preloaded with the identifier of thegateway ( idjG) that contains its shared key The sensorincludes this identifier in the “hello” message it broadcastsafter its deployment (i1)(Clustering process) (i2)GioG id E(  nonce {id} )iG GK& &i(i3)After the cluster formation each Gi identifies the set ofsensors {id}i that reside in its cluster and broadcasts to theother gateways (The broadcast helps reduce the volume of inter-gateway traffic)GimGj  E(  nonce {(  id )} )ki j k j S iG G S GK K& (i4)3Proceedings of the Eighth IEEE International Symposium on Computers and Communication (ISCC’03) 1530-1346/03 $1700 © 2003 IEEE Each Gj replies to Gi with its set of keys{( where {id} id )}k j kS G S iKi is a subset of {id}j Then each sensor Sl in Gi’scluster receives a message from Gi that assigns Gi as its gateway:SlmGi id E(  nonce id msg)i l j iG S G GK& & &i&(i5)Addition of sensors The new sensors are arbitrarilydeployed; they cannot be pre-assigned to a clusterHowever they are preloaded with two keys as othersensorsThe command node transmits the list of (identifier key)pairs to a randomly selected gateway Gh (not to the wholegateway group to reduce the risk of compromise) whichbecomes the gateway that shares the keys of the newsensors:CoGi  E(  nonce {(  id )} )kS ii k iG C S GK K& (a1)Besides each added sensor node broadcasts a 'hello'message as in the initialization step i1 The clusteringmechanism adjusts itself (possibly by reconfiguring theclusters) Each gateway broadcasts the sensors in its rangeto the gateways in G requesting the keys for those sensorsSlobroadcastid id E(  nonce sdata)h l l jG S S GK& & & (a2)(Clustering process) (a3)GioG id E(  nonce {id} )iG GK& & (a4)Gh responds to those requests Then each new sensor Slis assigned its gateway GiGimGh  E(  nonce {(  id )} )kS ii h k hG G S GK K&(a5)SlmGi id E(  nonce id msg)i ilG hS G GK& &(a6)Revocations Key revocations (and node evictions) areperformed after detecting the compromised nodes The(hypothetical) intrusion detection mechanism informs thecommand node of the compromised nodes If a group of sensors are compromised they can be trivially evicted fromthe command node’s sensor list by the command node aswell as from their cluster by the gateway (Note that thegateway reconfigures its intra-cluster hop-by-hop routingignoring the evicted sensors)In the case of the revocation of a gateway (Gj) key thecommand node evicts Gj from G and chooses anuncompromised gateway Gh as a head gateway To Gh itsends the identifiers each sensor and its new gateway (Gi)and the new key to be shared with Gi Also the newgateway-sensor secret keys are sent to Gi through groupbroadcast After this a re-clustering step takes place CoGh  E  nonce id id E(  nonce' id ) E(  nonce'' id )(){}()ih ki ik kji ik kG C S GG C S S GS C G S GKK KK K& & && & && &(r1)(Clustering process) (r2)On successfully decrypting the message the sensorreceives its new key (the last component in the r1 step)shared with Gi Thus it accepts Gi as its new gateway and ignores the further messages from GjGio  Sk  E(  nonce  id )k iS C G S GK K& & k i (r3)Key renewals Using the same encryption key for extendedperiods may incur a cryptanalytic risk A remedy can be toignore this threat which can be suitable for short-livingnetworks eg where the sensor battery drains quickly [8]For other networks it will be necessary to renew theencryption keys occasionally [11] In order to accomplishthe renewal of the sensor keys the command nodegenerates the new keys and pushes the keys to thegateways as in the case of the revocationThe time interval between subsequent renewals maydepend on the data traffic volume the strength ofunderlying cryptographic primitives and the extraprocessing load incurred at the gateways4 Simulation We simulate the key management energy consumptionby using a Visual C++ based sensor networksimulator [3][6]We model the sensor energy dissipated during the keymanagement The computational component is a smallfraction as compared to the communication therefore it is not considered From the previous section we can see thatthe sensors transmit in the steps i1 a2 and receive in i5 a6r3 The clustering process is not considered We areinterested in the initialization part as each sensor performsi1 and i5Our metrics are the energy consumption per node theaverage energy consumption within overall network and the overhead of security in terms of the energyconsumptionThe average energy consumption for a uniformly 10-cluster network is less than 50µJ as can be seen in Figure1 In Figure 2 we can see that fewer than 30% of thesensors consumed more than 50µJ The density of gateways4Proceedings of the Eighth IEEE International Symposium on Computers and Communication (ISCC’03) 1530-1346/03 $1700 © 2003 IEEE can be increased to further reduce the average energyconsumption5 Related workDuring the past few years the architecture and design of sensor networks and hardware have progressedsignificantly [4][5][12][13]Recently security has become a topic of interest in sensor networks research The detailed survey by Carman et al [10] analyzes the existing key management technologieson the sensor networks They observed that pre-deployedkeying which requires deployment of keys to the sensorsprior to their use is very energy efficient; however it posesinflexibility to configuration changes and requires storageof high number of keys One way to do pre-deployedkeying is to use a pre-deployed group keying approachHowever compromise of a single node results in the compromise of the entire network because all nodes sharethe same key In the node-specific pre-deployment methoda unique key is stored for each node pair For large networks the number of stored keys at each node can betoo highA protocol proposed in [10] is the Identity-BasedSymmetric Keying (IBSK) which is a node-specific pre-deployment technique is very similar to our approach aswell This protocol requires the distinct shared keys to bepre-deployed in the sensor nodes Therefore the scalability in the number of stored keys is a major concern with IBSKMoreover post-deployment key management operationsare sophisticated and energy-inefficient For instanceconsider the key renewal operation on a single sensorSince the sensor shares keys with a high number of remotenodes (possibly as large as the size of a cluster) eachsensor has to be updated with a new key; and the originalsensor has to be updated with a large number of keys Theupdates require excessive communication which hasadverse effects on the sensor energy level and lifetimeQuantitatively speaking renewing a single node in an n-node cluster will require an (n – 1)-key-long transfer to thatnode and (n – 1) single key transfers to the other nodes inthe cluster Total key transfers add up to 2(n – 1) Thismeans each sensor consumes approximately (average)86mJ per sensor which is quite high This is mainlybecause of the fact that IBSK assumes that node-to-nodecommunication is a necessary feature This assumption isvalid because sensor networks can stage ad-hoc behaviorHowever for many data gathering applications a clusteredarchitecture and a sensor-to-gateway traffic pattern aresufficient In fact the data gathering applications thatutilize sensor networks eventually have an inherent centralized architecture (flow of data towards a central node) This observation was already made by Perrig etal [8] to reduce the key management overhead Byrestricting IBSK its energy consumption would besignificantly reduced and the keys at the sensors will be manageable without sacrificing network functionalityAverage Energy Consumption (µJ)203040506070500 600 700 800 900 1000Number of SensorsFigure 1 The average energy consumed by sensors in a network with 10 clustersE n e r g y C o n s u m p t io n  D is t r ib u t io n( 1 0 0 0  s e n s o r s   7  c lu s t e r s )0 - 5 0 µ J 5 0 - 1 0 0 1 0 0 - 1 5 0 1 5 0 - 2 0 001 0 02 0 03 0 04 0 05 0 06 0 07 0 08 0 0SensorsFigure 2 Distribution of sensor energy consumption with ourapproachA trusted third party Key Distribution Center (KDC)such as Kerberos is an alternative to pre-deployed keyingHowever KDC schemes are not energy-conservingBecause for every secure session sensor messagetransmission and reception are necessary for the session keyestablishment After simulating Kerberos we observe thatthe majority of the sensors in Figure 3 dissipate energy inthe 15 - 30mJ range which is too high (Remember that our approach consumed energy in the µJ range)6 Conclusions and future workWe have presented an energy conserving method toprovide key management for sensor networks The method5Proceedings of the Eighth IEEE International Symposium on Computers and Communication (ISCC’03) 1530-1346/03 $1700 © 2003 IEEE uses pre-deployed symmetric keying A critical observationis that sensor-to-sensor secure channel establishment is notnecessary for many monitoring applications Thereforepre-deployed keying has become sufficient cost-effectiveapproach to provide a keying infrastructure for securityprotocols that use those keys The overhead per sensorappears to be feasible and none of the sensors are requiredto store large numbers of keys Moreover our approachsupports key revocation and renewal mechanisms as well Our work is an improvement in the energy-aware designof the key management functionality for limitedenvironments like sensor networksFormal analysis about the security strength of theproposed scheme remains as future work Thebootstrapping phase of the network may require someadditions to the protocol as proposed by Bobba et al in[16] An open problem is to design a lightweight intrusiondetection mechanism to detect compromised nodes in thenetworkReferences[1] J Rabaey et al “PicoRadios for Wireless Sensor Networks: The Next Challenge in Ultra-Low-Power Design” in Proceedings of the International Solid-State CircuitsConference (San Francisco CA) February 2002[2] S Hollar “COTS Dust” Master's thesis ElectricalEngineering and Computer Science Department UC Berkeley 2000 [3] M Younis M Youssef and K Arisha “Energy-AwareRouting in Cluster-Based Sensor Networks” in Proceedingsof the 10th IEEE/ACM International Symposium on Modeling Analysis and Simulation of Computer andTelecommunication Systems (MASCOTS2002) (Forth Worth TX) October 2002Energy Consumption of sensorsusing Kerberos01002003004005005006007008009001000No of SensorsSensor distribution0-15 mJ15-30 mJ30-45 mJ45-60 mJ60-75 mJFigure 3 Distribution of sensor energy consumption using Kerberos[4] V Raghunathan C Schurgers S Park and M B Srivastava“Energy Aware Wireless Microsensor Networks” IEEE Signal Processing Magazine March 2002[5] E Shih B Calhoun S-H Cho and A Chandrakasan“Energy-Efficient Link Layer for Wireless Microsensor Networks” in Proceedings of the Workshop on VLSI 2001(WVLSI '01) (Orlando Florida) April 2001[6] K Arisha M Youssef and M Younis “Energy-AwareTDMA-Based MAC for Sensor Networks” in Proceedings of the IEEE Workshop on Integrated Management of PowerAware Communications Computing and Networking(IMPACCT 2002) May 2002[7] G Gupta M Younis "Performance Evaluation of Load-Balanced Clustering of Wireless Sensor Networks" in theProceedings of the 10th International Conference onTelecommunications (ICT'2003) Tahiti Papeete – FrenchPolynesia February 2003 (to appear)[8] A Perrig R Szewczyk V Wen D Culler and J D Tygar“SPINS: Security Protocols for Sensor Networks” Wireless Networks vol 8 no 5 pp 521-534 2002[9] M Horton et al “Mica: The commercialization of microsensor motes” Sensors Online Magazine April 2002http://wwwsensorsmagcom/articles/0402/40/mainshtml[10] D Carman P Kruus and B Matt “Constraints andapproaches for distributed sensor network security” TechRep 00-010 NAI Labs September 2000 http://downloadnaicom/products/media/nai/zip/nailabs-report-00-010-finalzip[11] W Fumy and P Landrock “Principles of key management” IEEE Journal of Selected Areas in Communications vol 11pp 785-793 June 1993[12] E Shih S-H Cho N Ickes R Min A Sinha A Wang andA Chandrakasan “Physical Layer Driven Algorithm andProtocol Design for Energy-Efficient Wireless Sensor Networks” in the 7th ACM Annual International Conferenceon Mobile Computing and Networking 2001) July 2001[13] S-H Cho and A Chandrakasan “Energy Efficient Protocolsfor Low Duty Cycle Wireless Microsensor Networks” inInternational Conference on Acoustics Speech and Signal Processing 2001 May 2001[14] A Perrig et al “SPINS: Security Protocols for Sensor Networks” in Seventh Annual International Conference onMobile Computing and Networks (MobiCOM 2001) (Rome Italy) 2001[15] L Eschenauer and V D Gligor “A Key ManagementScheme for Distributed Sensor Networks” in 9th ACM Conference on Computer and Communications Security—CCS 2002 November 2002 [16] RB Bobba L Eschenauer V Gligor W Arbaugh “Bootstrapping Security Associations for Routing in Mobile Ad-Hoc Networks” Institute for Systems Research ISRTechnical Report 2002-44 May 20026Proceedings of the Eighth IEEE International Symposium on Computers and Communication (ISCC’03) 1530-1346/03 $1700 © 2003 IEEE 
PANJA- MADRIA- AND BHARGAVA-pdf,This research is partially supported by NSF grant EIA-0323630Energy and Communication Efficient Group Key Management Protocol for Hierarchical Sensor Networks Biswajit Panja Sanjay Kumar Madria Bharat Bhargava Department of Computer Science University of Missouri-Rolla Mo 65401 bptfcmadrias@umreduDepartment of Computer Science Purdue University West Lafayette IN 47907 bb@cspurdueeduAbstractIn this paper we describe group key management protocosl for hierarchical sensor networks where instead of using pre-deployed keys each sensor node generates a partial key dynamically using a function The function takes partial keys of its children as input The design of the protocol is motivated by the fact that traditional cryptographic techniques are impractical in sensor networks because of high energy and computational overheads The group key management protocol supports the establishment of two types of group keys; one for the sensor nodes within a group and the other in a group of cluster heads The protocol handles freshness of the group key dynamically and eliminates the involvement of a trusted third party (TTP) We have experimentally evaluated the time and energy consumption in broadcasting partial keys and group key under two sensor routing protocols (Tiny-AODV and Tiny-Diffusion) by varying the number of nodes and key sizes The performance study provides the optimum number of partial keys needed for computing the group key to balance the available security and power consumption The experimental study also concludes that the energy consumption in SPIN [9] increases rapidly as the number of group members increases in comparison to our protocol 1 Introduction Sensor networks [1] have become an important area of research because of their applications in military and disaster relief The most limiting factors of a sensor node are its battery capacity and available memory Thus the energy and storage conservation are two important issues at the node level and at network level  Security is one of the most important issues in distributed ad hoc sensor networks For example a wireless sensor network uses a radio frequency (RF) channel [10] which is not a secure channel It is also difficult to prevent an adversary sensor node from compromising the security of sensor networks because of untraceable sensor nodes and less physical protection [235] To control information access in a hierarchical sensor environment only authorized sensors should have the cryptographic keys by which they can decode the disseminated information Thus a group key management is required for such a hierarchical environment as it can implement different access control policies at each level and provide mechanisms for secure group communication by eliminating compromised nodes In the traditional cryptographic techniques for security every sensor node would need a {private public} key pair which is impractical because of high energy consumption and scalability  In this paper we propose a group key management protocol using a hierarchical architecture consisting of different groups with a unique group key Using this approach multi-level security can be achieved to secure the group of sensors at different levels There are two types of group keys: intra-cluster and inter-cluster  The intra-cluster group key is used for encryption/decryption of messages inside a sensor network group whereas the inter-cluster group key is used for groups of cluster heads The two most important advantages of dynamic partial keys over pre-deployed keys are that (1) sensor nodes need not store too many keys and (2) the dynamic key may not be compromised because it changes frequently In our proposed scheme every sensor node in a group generates a partial key dynamically and used it for computing the group key in a bottom up fashion Once the sensor network is deployed it is organized in a hierarchical fashion After that a cluster head (leader) gets messages from all its group members to know their level and location in the sub-tree and in response it sends a message It also requests the leaf nodes (initiator) to compute their partial keys In this protocol the partial keys are computed using the function associated with each node which uses partial keys of their descendents as arguments The key computation starts by leaf nodes generating random numbers as their partial keys because they have no descendents The cluster head computes the group key using an optimum number of partial keys The decision for choosing the number of Proceedings of the IEEE International Conference on Sensor Networks Ubiquitous and Trustworthy Computing (SUTC’06) 0-7695-2553-9/06 $2000 © 2006 IEEE partial keys to be used is based on the security and energy consumption In this paper we modified the Tree Based Group Diffie-Hellman (TGDH) protocol [7] for group key management using a general tree structure In addition Diffie-Hellman protocol [9] is used for computing the group key Using the modified TDGH a new group key management scheme is presented The experiments with a sensor network environment created in NS-2 and TinyOS are performed using two sensor routing protocols (Tiny-AODV and Tiny-Diffusion) by varying nodes key sizes and energy consumption It is observed that Tiny-AODV is slower than Tiny-Diffusion in terms of broadcasting the partial keys and the group key Also the Tiny-AODV takes more time to re-establish a route and re-send the partial keys The experiments for energy computation and delivery of partial keys helped in selecting the optimum partial key and group key sizes It is observed that a 300-bits group key size would be reasonable considering memory and communication overheads In experiments the optimum (energy security) group key size is 300 bits which can be computed from 15 partial keys of 20 bits each It is known that decrypting 300-bits group key needs 2300 micro seconds with the decryption rate of 1 bit per micro second [10]  We performed experiments to compute energy consumption and concluded that the protocol consumes very small amount of energy (approximately 0245 joule) in the process of computing 15 partial keys broadcasting them computing and broadcasting the group key The energy consumption is very small compared to the total available energy of 461700 joule (for 15 nodes with two batteries each having 15390 joule per battery) The proposed protocol conserves energy and communication with respect to SPIN [6] and pre-deployed key protocol To save communication cost and energy re-keying of the group is done by the cluster head by sending a message to the sensor nodes which contains information for adding or removing certain partial keys to generate the new group key To guarantee that all the nodes in a group received the information they send a reply (REP) message If the cluster head does not get the REP from every node it re-broadcasts the message  2 Related work Kim et al [7] proposed a group key agreement protocol called Tree Based Group Diffie-Hellman protocol [TGDH] which is based on the Diffie-Hellman key exchange In this protocol a distributed key agreement has been considered rather than a centralized group key agreement Different group agreement protocols have been proposed In centralized group key distribution one key server generates keys and distributes them to the group while in decentralized approaches the key is computed dynamically The basic requirements for group key agreement protocols [1 5] are key freshness group key secrecy (forward and backward) and key independence  In SPIN [6] two security concepts are used: SNEP (Secure network encryption protocol) and micro TESLA (Time efficient streaming loss-tolerant authentication protocol)  The advantages of SNEP are low communication overhead and semantic security A DES-CBC chaining algorithm is used to maintain data confidentiality in SPIN and a MAC is used to keep messages unaltered A special counter is used to maintain the sequence of messages The counter value will never be the same so the encrypted message is different for the same data The disadvantages of SPIN are that (1) it is based on one-to-one communication but nodes in sensor networks work in groups and (2) it does not consider the security in hierarchical structure and clustering which are important for sensor network applications such as in military  Eschenauer et al [4] presented a key management scheme which has selective distribution and revocation of keys in sensor nodes Their scheme is based on the probabilistic distribution of the key which guarantees that two neighboring nodes will have at least one common key in their key ring This key is used by the neighboring nodes to encrypt/decrypt messages The disadvantage of this approach is that pre-deployed keys are comparatively easy to forge than a dynamic key Also each node needs more memory to store many keys and therefore it is impractical 3 Hierarchical sensor network modelIn this section the architecture of a hierarchical sensor network with multiple levels consisting of sensor nodes cluster heads and relay nodes is described There are two types of sensor groups; one is a group of sensor nodes lead by a cluster head and the other is a group of cluster heads with one cluster head as head of that group Figure 1 shows the architecture In this model each sensor group collects data from a particular geographical area and sends the data to the nearest sensor nodes If the neighboring nodes are relay nodes they forward those data using the appropriate routing path Finally the cluster head aggregates the data and forwards that to its upper level cluster head  Three different types of identifications are used in this model: a unique identification (ID) for each sensor node each cluster head and each group of clusters The assignments of the IDs are done in the following ways: x The IDs of sensor nodes are given by the cluster head of that particular group x The IDs of cluster heads are given by the Head of Cluster Heads [HCH] of a particular geographical area HCH is the cluster head which is responsible for leading the group of cluster heads Proceedings of the IEEE International Conference on Sensor Networks Ubiquitous and Trustworthy Computing (SUTC’06) 0-7695-2553-9/06 $2000 © 2006 IEEE x Also the IDs of the group of sensor nodes are given by HCH Figure 1 Hierarchical architecture4 Partial key computation In this section we describe the scheme for computing the partial key in each sensor node We assume that after the organization the cluster head of each group knows the position (Pos<lv>)  (level in the sub-tree) of its group members It send a message Msg(Pos<lv>) to let them know their position Next the cluster head sends a message (Rep<initnode>) to the leaf nodes to compute the partial keys The function f(partial key of child1 partial key of child2) is used to compute the partial keys in each node As the leaf nodes do not have any decedents they generate random numbers as their partial keys Then it uses a simple approach to compute the partial keys of non-leaf nodes The parents of the leaf nodes compute their partial keys using a function f() The function is pkkf kk mod)( 2121 D  where p is the prime number D  is the primitive root of P and k1 k2 are keys (k1k2<p) The arguments of the function are the partial keys of their children Using a bottom up approach all non-leaf sensor nodes can compute their partial keys  If the tree is binary then the function for computing the partial key K is f (K<l+1 2v> K<l+1 2v+1> )where l is the level in the tree and v is the position of the node from left For example in Figure 2 to compute the K<2 0> we need the function f(K<3 0>  K< 3 1> ) The computation of K<2 1> is not possible using f(K<3 2>  K< 3 3> ) as children now have different parents If the function f(K<l+1 2v+1> K<l+1 2v+2> ) is used then we are able to compute K<2 1> From this we observe that the levels l do not change but the position v changes depending on the number of children In a non-binary tree the algorithm needs to count the siblings in the left part of the sub-tree for calculating a key for the parent node It then computes m where m = siblings - 2 so the function would be f(K<l+1 2v+m>  K<l+1 2v+1+m> )Figure 2 Dynamic partial key computation The advantage of this function is that it is difficult to decode When the nodes know the function ( pkkf kk mod)( 2121 D ) then they do not need to analyze the known function The complexity of the protocol is O(logn+mn) because the partial keys and the group key are computed in a tree structure For nnodes it takes O(logn) time and computing the mpartial keys from n nodes takes O(mn) time A one time symmetric key is used for generation and verification of the MAC first time This key is also used for encryption/decryption of partial keys intermediate keys and group key Once the group key is computed the symmetric key is discarded Figure 3 provides the algorithm for computing the partial keys in a tree which is based on the position of the nodes in that group           Figure 3 Algorithm for dynamic partial key computationAlgorithm: 1 if (tree is binary) then 2  {    f (K<l+1 2v> K<l+1 2v+1>)    } 3 else if (it is not binary) then 4        {     f (K<l+1 2v+m> K<l+1 2v+1+m>)m = [ If there is sub-tree left side of node left siblings – (number of sub-tree)x 2 – 2 ] } 5 if (no sub-tree in the left side of the node) then 6  {    f (K<l+1 2v> K<l+1 2v+1>)    } 7 else if (sub-tree is there in the left side of the node) then 8       {    f (K<l+1 2v+m> K<l+1 2v+1+m>)   } Level 1Cluster head General sensor  nodes Relay  nodes Level 2(00(10 (11(20 (21(22 (23(30 (31 (32 (33 (34 (35 (36 (37 (38Proceedings of the IEEE International Conference on Sensor Networks Ubiquitous and Trustworthy Computing (SUTC’06) 0-7695-2553-9/06 $2000 © 2006 IEEE 5 Group key computation We have used the multi-party Diffie-Hellman and TGDH protocol [7] to propose a new group key computation method for sensor networks To accomplish this proposition the leaf nodes work as the initiators and the cluster head as the leader Starting from the initiator sensor nodes every sensor node contributes its partial key for computing the group key The leader node accumulates all partial keys for computation of the group key This is a bottom up approach as partial keys are accumulated from leaf nodes to the parent nodes In the following subsection we show the group key computation with and without using the blind factor The blind factor is a unique number generated by a sensor node 51 Group key computation without blind factor We use the following approach for group key computation without the blind factor [1] As the leaf nodes act as the initiators they first broadcast their partial keys The parent nodes of the leaf nodes get the partial keys and then add their own partial keys and rebroadcast it As it is a bottom up approach the cluster head will have all the partial keys and it will compute the group key using its partial key contribution After that the cluster head broadcasts the group key  Initially a pre-deployed one time symmetric key is used to encrypt and decrypt the partial keys and the group key There after only the group key is used for this purpose The identification of the nodes is attached with the encrypted partial keys The sensor nodes check the identification before decrypting the partial keys as the parent nodes only need the partial keys of their children In this way they can have early rejection of packets which saves communication and computation overheads The other group members cannot compute the group key because they cannot get the partial key of the cluster head since it does not broadcast its partial key In Figure 4 the leaf nodes are M1 M2 … M9  To start M1 computes the partial key gS1 and broadcasts it The parent node M10 gets the partial keys from M1 andother children Here g is a generator of the multiplicative group ZP* (ie the set {1 2… p-1} p isthe prime) and S1 is a randomly chosen secret number for member M1 Likewise member M2 computes gS2and broadcasts it and the parent M10 gets the partial keys In this way member M10 receives gS1S2S3 and raises the power by S10 to get the intermediate key (IK)Here gS10 is the partial key contribution of M10In the following paragraphs we discuss two types of group keys: the intra-cluster and the inter-cluster  The intermediate keys in M10 M11 and M12 are  IK1 = g S1 S2 S3 S10  IK2 = g S4 S5 S6 S11  and  IK3 = g S7 S8 S9 S12 respectively The intermediate keys are encrypted using a one time symmetric key as explained earlier The cluster head computes the group key K using IK1IK2 and IK3 and its contribution gs13K = g S1 S2 S3 S10 S4 S5 S6 S11 S7 S8 S9 S12s13   [Intra-cluster group key] Then it encrypts the group key using the symmetric key The authentic nodes which have the symmetric key can decrypt the group key The cluster head broadcasts the group key to its group members so that every sensor node gets the group key This group key is called the intra-cluster group key and is used for encryption/decryption of messages inside the group of sensor nodes  Cluster head General sensor nodesM1 M2 M3 M4 M5 M6 M7 M8 M9M10 M11 M12gs2 gs3 gs4 gs5 gs6 gs7 gs8 gs9gs1s2s3s10gs1gs4s5s6s11 gs7s8s9s12gs1s2  s12s13Figure 4 Intra-Cluster key computation For inter-cluster encryption/decryption a different group key is computed The inter-cluster group key is not known to the general sensor nodes Figure 5 shows the computation of the inter-cluster group key The intermediate key in C7 C8 C9 are IK1inter = gC1C7  IK2inter = gC2C3C8  and IK3inter = gC4C5C6C9The head of the cluster heads (HCH) computes the inter-cluster group key C using intermediate keys IK1inter IK2inter IK3inter and its contribution gc10C = g C1C7C2C3C8C4C5C6C9c10  [Inter-cluster group key] The HCH broadcasts the inter-cluster group key to the cluster heads The cluster heads use this group key for encryption/decryption of messages among the cluster heads 52 Group key computation using blind factor We can compute the group key using a blind factor The advantage of using a blind factor is that an attacker will not be able to get the group key when the cluster head broadcasts the group key In Figure 4 the intermediate keys are IK1 = g S1 S2 S3 S10  IK2 = g S4 S5 S6 S11 and IK3 = g S7 S8 S9 S12 After computation of IK1 IK2 and IK3 the parent nodes M10 M11 M12 broadcast the intermediate keys The children of M10 M11 andM12 are interested in those keys as they need to Proceedings of the IEEE International Conference on Sensor Networks Ubiquitous and Trustworthy Computing (SUTC’06) 0-7695-2553-9/06 $2000 © 2006 IEEE remove their contribution from the IK Then they insert a randomly chosen blind factor B The keys after inserting blind factor are as follows IKB1 = g B1 S2 S3 S10  IKB2 = g S1 B2 S3 S10  and               IKB9 = g S7 S8 B9 S12 The cluster head gets the broadcasted keys IKB1… IKB9 The cluster head then computes the group key K using IKB1…IKB9 and its contribution gs13K = g B1 S2 S3 S10 S4 S5 S6 S11 S7 S8 S9 S12s13 After the group key computation the cluster head broadcasts the group key with blind factor Now the authentic sensor node can recognize its blind factor Each member remove its blind factor that it received from the cluster head They reinsert their original contribution Si (i = 1n) for getting the group key The same method is used to compute the inter-cluster group key A symmetric key is used for encryption and decryption of partial keys The cluster head uses the same symmetric key for encryption of the group key C1 C2 C3 C4 C5 C6C7 C8 C9gc2gc1 gc3 gc4 gc5 gc6gc1c7 gc2c3c8 gc4c5c6c9gc4  c9c10C10Cluster headFigure 5 Inter-Cluster key computation53 Updating a group key Our key management protocol provides a scalable approach for updating group keys for large dynamic groups Section 3 shows that large dynamic groups re-keying the group on each membership change becomes unsustainable One of the approaches to keep the key fresh is by re-keying the group at fixed intervals; this approach is computationally expensive as the partial keys and the group key will be computed again Another approach for updating the key would be to send a message from the cluster head to its group members consists of instructions to remove or add a certain partial key from the group key in order to get the new group key The group key K which is described in Section 51 is: K = g S1 S2 S3 S10 S4 S5 S6 S11 S7 S8 S9 S12s13 [Old group key] For example the cluster head sends an encrypted message to its group member for removing S10 from their group key The new group key K would be: K = g S1 S2 S3 S4 S5 S6 S11 S7 S8 S9 S12s13 [New group key] To guarantee that all the sensor nodes received the message to update the part of the group key nodes send an acknowledgment (ACK) message to the cluster head If the cluster head receives the reply (REP) from all the nodes then it sends the next message that “the new group key is in effect now” If the cluster head does not receive the reply message REP from all its group members then it resends (broadcast) the message until it can get a reply message or it can come to know events such as a particular sensor node does not have battery power left for communication To keep track of all the partial keys the cluster head can use a primary index by sorting the IDs of its group member nodes  54 Analysis: Energy and security level with          respect to key size This subsection explains the analysis of balancing the energy consumption verses security level by choosing the appropriate key sizes in the proposed protocol  Notations:fL   Leaf level nodes in the hierarchy vtL   Leaf level lfK    Partial keys in the leaf nodes Pk   Pre-deployed key in the network                 can be symmetric or asymmetric   pK    Parent key of the sub-tree nP  Parent nodes of each sub-tree             vL   Levels in the hierarchy as in figure 1 f ( )  Function with the partial keys of                  children as arguments E  Energy consumption (joule)totalP      Total energy in the network (joule) consumedP Consumed energy for group key                computation G           Group of sensors in the network gN  Number of groups in the network S  Size of key nL  Number of levels in each group nC  Number of partial keys considered for the   group key V Battery voltage (volt) C Capacitance (farad) f Frequency  (Hz) Proceedings of the IEEE International Conference on Sensor Networks Ubiquitous and Trustworthy Computing (SUTC’06) 0-7695-2553-9/06 $2000 © 2006 IEEE Let fL  vtL and vL =1 2 ……n [ vL = 0 is the root] The parent key pK is computed from the function f( lfK  1lfK ) where pkfk mod)( D The energy remaining in each sensor node is computed using their levels in the architecture It is known that the energy consumption in a circuit is : Power P = V2f CIf the power (energy) consumption at each level is P then the total power in all groups is: Total power = ¦ uu gv NLPEnergy remaining = totalP - ¦ uu gv NLPThe energy required at each level will compute the total energy needed in the computation of the group key and is given by vnL³1 ¦ uu nv LLPBy considering the partial keys at each node level and at their parent level energy consumption would be:  udPnLfnpv LKL )( nlfp PkK If n partial keys are considered to form the group key then the energy consumption with respect to key size would be: consumedP = ECKK nplf uu )(The energy consumption for the group key must be less than the total available energy Thus gtotalnplf NEPECKK udduu )(It is assumed that there exists more than one group in the network If the partial key size varies from 20 to 100 bits then the energy consumption would be: ¦ uu 10020)(byteSnplf SCKKEThe partial key sizes are based on the group key size the number of partial keys considered for the group key and the available energy   The energy consumption for computing the partial keys and the group key proportional to the security requirement in terms of key sizes can be expressed as follows: GCn lfp KK    | SecEKKC lfpn vuu )(where Sec  is the time to the decrypt the key at a decryption rate of 1 bit per micro second It is observed that as the key size increases the security and energy consumption would increase and it is not possible to have totalconsumed PP t IfconsumednvtnfPELLELL )()( uu#uu1d then the cluster head can choose the partial keys from the leaf nodes From the above we can find the number of partial keys to be used for balancing the security requirement based on key size verses the energy consumption  6 Performance evaluation and observation For performance analysis we have implemented the group key management protocol in TinyOS and NS-2 As NS-2 is not developed for sensor network a sensor network environment is created in NS-2 by plugging in sensor agent energy model and multi-channel model developed by the United States Navy  The cluster head computes the group using the method as described in Section 5 It chooses a certain number of partial keys in order to compute the group key It also stores the identification of the nodes along with the partial keys so that it can save memory by discarding the partial keys received earlier In order to measure how fast the partial keys are delivered to the cluster head we did experiments using two sensor routing protocols: Tiny-AODV and Tiny-Diffusion The sensor nodes which do not fall in a 10 meters range generate partial keys so that the cluster head can get the partial keys from different regions in its group Then they establish a route to the cluster head using the routing protocol and send the partial keys using that route The reasons for restricting the number of sensor nodes and broadcasting the partial keys are to reduce communication overhead and energy consumption Figure 6 shows the time taken by the network to send the first 25 partial keys to the cluster head using the Tiny-AODV and Tiny-Diffusion routing protocols The algorithm for generating and broadcasting partial keys and computing the group key was kept the same in both cases Routing Protocols Tiny-AODV Tiny-Diffusion Area 2000 x 2000 meter Number of nodes per group 50Channel Single (wireless) Simulation time 160 sec Transmitting   power 0175 mW Receiving power 0175 mW Idle  00 W Initial energy 05 Joule Sensing power 000000175 mW Table 1 Parameters for simulation Proceedings of the IEEE International Conference on Sensor Networks Ubiquitous and Trustworthy Computing (SUTC’06) 0-7695-2553-9/06 $2000 © 2006 IEEE We observed that the Tiny-AODV takes approximately 54 seconds to deliver the first 25 partial keys to the cluster head; whereas Tiny-Diffusion takes almost 15 seconds This experiment is performed to determine the effectiveness of routing protocols in terms of how fast the partial keys can reach the destination After that the group key is computed by the cluster head Then it is broadcasted to all its group members We found that both routing protocols take a comparably small amount of time for broadcasting partial keys Figure 7 shows the time taken by the network to broadcast the group key generated based on the collection of partial keys using the Tiny-AODV and Tiny-Diffusion routing protocols From experiments it is observed that the group members whose IDs are 1 through 25 receive the group key in approximately 757 seconds if Tiny-AODV is used whereas if Tiny-Diffusion is used then it takes approximately 1182 seconds The reason is that Tiny-Diffusion uses a routing table for creating routes and therefore it takes more time to deliver the initial packets compared to Tiny-AODV because of its proactive features There is a very small time difference in broadcasting the group key using Tiny-AODV and Tiny-Diffusion  Thus delivering the partial keys (as shown in Figure 7) to the cluster head using Tiny-AODV takes more time than Tiny-Diffusion because of the partial key broadcast from every node and then delivering it to the cluster head requires many-to-one communication  In Figure 8 we present the results for time taken in broadcasting partial keys of size 20 and 30 bits The group key in the cluster head is computed using the first 15 partial keys The group key size would be 300 and 450 bits respectively We observed that the time taken to accumulate partial keys of size 300 and 450 bits remains almost same Theoretically the time required to decrypt 300 bits key size is 2300 micro seconds at a rate of 1 bit decrypt per micro second Therefore the forgery time for size of 300 bits group key is quite high  01000020000300004000050000600001 3 5 7 9 11 13 15 17 19 21 23 25Number of nodesPartial key delivery time (mSec)Tiny-AODVTiny-DiffusionFigure 6 Partial key delivery to the cluster head020004000600080001000012000140001 3 5 7 9 11 13 15 17 19 21 23 25Number of nodesGroup key delivery time (mSec)Tiny-AODVTiny-DiffusionFigure 7 Broadcasting group key We performed another experiment to analyze the energy consumption in the proposed model As a reminder the power consumed by the sensor nodes for transmission and reception is set at 175 mW for sensing 000000175 mW and the initial energy of the general sensor nodes is 05 joule The cluster head consumes the same power for transmission and reception with its initial energy is set to 25 joules Figure 9 shows the energy consumption graph for generating 20 partial keys and delivering those to the cluster head This also includes the energy consumption for communication before delivering the partial keys From this experiment we observe that changing the number of senders has impact on the energy consumption and this experiment helps to decide the number of partial keys that should be chosen in order to balance the energy consumption and security The optimum number of partial keys is 15 with respect to the current configuration Although the total power consumption for generating partial keys delivering computing the group key and broadcasting back is not shown in the figure it is approximately 0245 joule One way to protect the network from intruders is by updating (re-keying) the group keys frequently so that an intruder cannot get enough time to forge the group key In our model we update the group key using the technique described in Section 53 As explained earlier in order to save communication and computation cost instead of re-computing the partial keys and the group key the cluster head sends a message to its group members for removing or adding certain partial keys from the group key to obtain the new group key  In Figure 10 the energy consumption by SPIN and our key management protocol are compared Though SPIN is used for one-to-one node communication here it used for group communication It is observed that SPIN takes more time for communicating within a group We observed that the energy consumption of Proceedings of the IEEE International Conference on Sensor Networks Ubiquitous and Trustworthy Computing (SUTC’06) 0-7695-2553-9/06 $2000 © 2006 IEEE SPIN increases exponentially with the increase of the number of nodes in a group  1480014820148401486014880149001492014940149601 3 5 7 9 11 13 15Number of partial keysTime (mSec)Partial key size 20 bitPartial key size 30 bitFigure 8 Time taken for different key sizes 001020304051 4 7 10 13 16 19Partial keysEnergy consumption (Joule)Energy consumptionFigure 9 Energy consumption verses the number of partial keys 0020406081121 3 5 7 9 11 13 15 17 19Number of nodesEnergy consumption (joule) Dynamic keymanagement protocol SPINFigure 10 Comparison of dynamic key management protocol with SPIN 7 Conclusions In this paper we have described a group key management protocol where the partial keys are computed dynamically instead of using pre-deployed keys A group key is generated based on the partial keys of the group members The dynamic partial keys have some advantages over pre-deployed keys as many pre-deployed keys need to be stored to provide secure communication which is not feasible in sensor nodes because of the limited memory It is easy to re-compute the partial keys as each node uses a function with the partial keys of its children as arguments of the function to compute its partial key  Using a detailed simulation study it is shown that the proposed protocol is able to compute the partial keys and the group key within a very small time period We observed that the energy consumption for generating the partial keys and the group key is very small compared to the total available energy It is also sown by an experiment that the energy consumption of SPIN increases exponentially as the number of group nodes increase but our proposed protocol consumes a very small amount of energy after the first group key computation  8 References [1] David W Carman Peter S Kruus and Brian JMatt Constraints and approaches for distributed sensor network security NAI Labs Technical Report #00-010September 2000 [2] H Chan A Perrig and D Song Random key predistribution schemes for sensor networks in IEEE Symposium on Security and Privacy Berkeley California May 11-14 2003 [3] Wenliang Du Jing Deng Yunghsiang S Han Shigang Chen and Pramod Varshney A Key Management Scheme for Wireless Sensor Networks Using Deployment Knowledge To appear in IEEE INFOCOM 2004[4] L Eschenauer and V D Gligor A key-management scheme for distributed sensor networks in Proceedings of the 9th ACM conferenceon Computer and communications security Washington DC USA 2002 [5] Wenliang Du Jing Deng Yunghsiang S Han and Pramod Varshney A Pairwise Key Pre-distribution Scheme for Wireless Sensor Networks In Proceedings of the 10th ACM Conference on Computer and Communications Security (CCS) Washington DC October 27-31 2003 [6] A Perrig R Szewczyk V Wen D Culler and JD Tygar SPINS: Security protocols for sensor networks In Proceedings of Mobicom 2001 [7] Michael Steiner Gene Tsudik Michael Waidner Key Agreement in Dynamic Peer Groups IEEETransactions on Parallel and Distributed Systems 11(8): 769-780 2000 [8] A Shamir How to Share a Secret Communications of the ACM 22(11):612–613 1979 [9] Whitfield Diffie and Martin E Hellman Privacy and authentication An introduction to cryptography Proceedings of the IEEE 67(3):397–427 March 1979 [10] William Stallings Network Security Essentials Applications and StandardsProceedings of the IEEE International Conference on Sensor Networks Ubiquitous and Trustworthy Computing (SUTC’06) 0-7695-2553-9/06 $2000 © 2006 IEEE 
SCADA-pdf,A Forward & Backward Secure Key Managementin Wireless Sensor Networks for PCS/SCADAHani Alzaid1 DongGook Park2 Juan González Nieto1 Colin Boyd1 andErnest Foo11Information Security Institute Queensland University of TechnologyBrisbane QLD 4000 Australia{halzaid juanma cboyd efoo}@isiquteduau2School of Information Technology Sunchon University Koreadgpark6@sunchonackrAbstract Process Control Systems (PCSs) or Supervisory Control andData Acquisition (SCADA) systems have recently been added to the al-ready wide collection of wireless sensor networks applications The PCS/SCADA environment is somewhat more amenable to the use of heavycryptographic mechanisms such as public key cryptography than othersensor application environments The sensor nodes in the environmenthowever are still open to devastating attacks such as node capture whichmakes designing a secure key management challenging In this paper akey management scheme is proposed to defeat node capture attack byoffering both forward and backward secrecies Our scheme overcomes thepitfalls which Nilsson et al's scheme suffers from and is not more ex-pensive than their schemeKey words: wireless sensor network forward and backward secrecykey management process control systems supervisory control and dataacquisition1 IntroductionProcess Control Systems (PCSs) or Supervisory Control and Data Acquisition(SCADA) systems are used to monitor and control a plant or equipment in in-dustries such as energy oil and gas refining and transportation These systemsencompass the transfer of data between the network manager and a numberof Remote Terminal Units (RTUs) sensor nodes etc A SCADA system gatherscritical information (such as where a leak in a pipeline has occurred) and thentransfers this information back to the network manager The network manageris responsible for alerting the home station about the leak and carrying outnecessary analysis such as determining whether the leak is critical or notThe owners and operators of SCADA systems aim to increase the monitoringsensitivity of their systems and reduce the day to day running cost wherever itis possible Due to the intelligent monitoring capabilities of the Wireless Sen-sor Networks (WSNs) integration between SCADA and WSNs can be one way toachieve these aimsWSNs facilitate the monitoring process by performing specifictasks such as sensing physical phenomena at a remote field and then reportingthem back to the network manager They can form the "eyes and ears" of SCADAsystems Nodes which are capable of performing functions such as gas detec-tion and temperature sensing provide information that can tell an experiencedoperator how well oil/gas pipelines are performingRoman et al highlighted the role thatWSNs can play in SCADA [14] They ar-gued that WSNs can aid SCADA's functionalities by providing monitoring alertsand information on demand However vulnerabilities related to WSNs can beintroduced to SCADA One of those potential vulnerabilities is the security com-promise of sensor nodes given the lack of tamper resistance packaging [4] Anadversary can gain control of one or more sensor nodes and readily access sen-sitive information such as keys or passwords The adversary therefore can easilyget access to the plain text of the encrypted messages that are routed throughthe controlled nodes  this compromises the data confidentiality The adversarymay also inject their own commodity nodes into the network by fooling nodesso that they believe that these commodity nodes are legitimate members of thenetwork Another adversary activity is launching a selective forwarding attackwhere the node that is under the control of the adversary selectively dropslegitimate packets in order to affect the overall performance of the system [5]In this paper we focus on strengthening the security level at the weakestcomponent of the SCADA system which exists in remote fields [1] The remotefield has the weakest physical security requirements and consists of substationsand intelligent electronic devices such as sensors (will be discussed in a latersection) We propose a new key management protocol that updates the sharedsymmetric key between the network manager and a sensor node or between thenetwork manager and a group of sensor nodesThe rest of this paper is organized as follows Section 2 provides an overviewof SCADA systems Section 3 explains the different types of the adversarial modelSection 4 discusses some of the related work Section 5 explains the proposedkey management protocol Finally the paper is concluded in Section 62 SCADATo best understand the added value of the proposed scheme some understand-ing of SCADA is in order Today's SCADA systems (the third generation) are acombination of legacy and modern technology [9] It has become an open sys-tem architecture rather than a vendor controlled architecture as in the secondgeneration of SCADA It uses open standards and protocols which facilitate dis-tribution of the functionalities of SCADA We refer the readers interested in thedifferences between these generations to the paper by McClanahan [9] Figure 1shows a simplified SCADA system architecture which is composed of the followingcomponents:HistorianMaster CenterRemote FieldCommunication SystemsRemote FieldCommunication SystemsFig 1 The simplified version of PCS/SCADAMaster Center The master center component contains the network managerhuman machine interaction database storage processing server etc It has thehighest physical security level compared to other components Generally speak-ing it receives monitoring information from remote fields (through the commu-nication system component) processes it and then makes decisionsHistorian The historian is a backup for the SCADA system data which is oftenlocated in a separate subnet different to the one where the master center com-ponent exists The master center component is able to access the historian inorder to backup the data of the SCADA systemRemote Fields The remote fields are composed of substations (gateways) andintelligent electronic devices (IEDs) [1] which can be physically distant from theSCADA master center and in many cases are not physically secured due to thelargeness or remoteness of the coverage area The substation connects IEDs withthe master center component through the communication component It has ahigh degree of complexity and might have better physical security than IEDsThe IEDs can be sensor nodes remote terminal units or relays to name a fewCommunication System The communication systems are responsible fortransferring monitored data (control data) from remote field components (mastercenter) to master center component (remote field components) This communi-cation can be done via fiber optics radio satellite etc3 Adversary Model and Security ConcernsWhen designing a key management protocol forWSNs the most challenging andunique security threat would be node capture With limited resources in sensornodes defeating this type of threat is very hard Node capture will translateinto compromise of all the credentials stored in the sensor node Furthermorethe adversary can compromise all the software codes installed within the sensornode especially random number generation functions For example he can mod-ify the codes or replace them with his own codes to mislead functions related toSCADA/PCS use a fixed number for random numbers for input to security pro-tocols or launch a selective forwarding attack However the computation powerof the adversary falls short of compromising the network manager and gate-ways which have reasonable physical security Their physical security increasesin proportion to the importance of the domain where a SCADA/PCS is deployedOur purpose in this paper is to design a key management scheme which isresilient to node capture: ie a scheme that enables sensor nodes to recoverits secure status even after they have been captured and then released backConsequently we are interested in what the adversary can do both when a nodeis captured and after it is released back Key disclosure is technically simple[4]; what else should be done by the adversary to keep control of the node afterhe put it back to the field? He will hope that the node uses values of his choicefor all cryptographic keys or keying materials For this purpose he may try tomodify software components (especially the random number generation part)and monitor all or part of the subsequent key update messages In this regardwe use the following criteria to classify the adversaries The adversary can read and modify all the software codes and configurationsincluding secret keys installed in the sensor node The adversary can carry out seamless monitoring of all the subsequent keyupdate protocol exchangesAccording to the above two criteria we divide the adversaries into four distincttypes as shown in Figure 2 Type I is the weakest adversary: neither seamlessmonitoring nor software compromise; Type IV is the strongest: seamless monitor-ing and software compromise Type IV is so much powerful that it is unlikely todevise any practical cryptographic countermeasure forWSNs The use of tamper-proof technology will be needed to cope with this type of adversary but it isoutside the scope of this paper Our goal in the paper is to have a new keymanagement scheme which is resilient to all the other three types of attackersonly with cryptographic countermeasuresOne interesting point here is that the assumption of software modification isequivalent to that of software-based random number generation in terms of theirconsequence in the context of cryptographic protocols Software algorithm-basedrandom number generation does not give true random numbers which can onlybe obtained from a strong physical source of randomness One consequence of thisequivalence is that it makes no sense to use expensive tamper-proof technologieswhile true random number generation not used Put a different way we do notFig 2 Classification of Adversaries Seamless monitoring means the adversarykeeps monitoring every subsequent key update message after compromising a sensornode; software modification includes alteration of any software installed in the nodeespecially the random number generatorhave to bother with true random number generation when software modificationis assumed to be an easy work for the adversaryHaving identified different types of adversaries we have the following con-cerns with regard to node capture and the consequent disclosure of all the inter-nal data of the captured node: Past key secrecy: The past keys should not be compromised Future key secrecy: The future keys should not be compromisedThe requirement of resilience to node capture rules out the use of any long-termkeys; the keys must change or evolve continuously over time with old prior keysdeleted securely In other words we require a key evolution scheme in order toachieve past/future key secrecy against the threat of node captureTerminology To the best of our knowledge the terms past/future keysecrecy have never been used in previous literature Similar terminology include(perfect) forward secrecy and backward secrecy which has always been quiteconfusing The term (perfect) forward secrecy goes back to Günther [3] Theoriginal term assumes a long-term key and session keys established by the keyand means that the current session key is not compromised by the future(thus the expression forward) exposure of the long-term key This terminologysomehow seems to have got a slightly different usage in the context of groupkey communication; it concerns about the contamination of a group key at aparticular time by the compromise of an older/newer group key The inherentambiguity has brought a twin terminology: backward secrecy Some authorschoose the term backward secrecy to mean forward secrecy called by otherauthors and vice versa To avoid all this confusion we will use a new moreconcrete expression: past/future key secrecyThe notation to be used in the rest of the paper can be found in Table 14 Related WorkThere are several papers dealing with key management designs for SCADA sys-tems such as [212] However these designs either use heavy cryptographic mech-Table 1 Notations for the proposed schemeName DescriptionM Network managerN Sensor nodeKMN Shared pairwise key between M and N s0 t0 Pre-installed global secret data in every N KiG The i-th group key (i ≥ 0)rX Random nonce chosen by entity X(K−1M  KM ) Asymmetric key pair of network manager{m}K Encryption of message m under the key Kh(·) A cryptographic hash functionMACK(m) A message authentication code function on musing the key Kanisms which do not suit resource constrained devices or do not consider theintegration of WSNs within SCADATo the best of our knowledge the only existing key management in the wire-less control environment that considers the integration between SCADA/PCS andWSNs has been proposed by Nilsson et al [10] They designed two key updateprotocols: the first one updates the pairwise symmetric key between the networkmanager M and a sensor node N (as described in Protocol 2) while the otherscheme updates the global or group key among M and the whole group G ofsensor nodes (as described in Protocol 1) They claimed that the protocols pro-vide both forward and backward secrecy (or in our newly defined terminologythey provide both past and future key secrecy) It is unfortunately not the caseProtocol 1 Group key update protocol from [10]M : generates a new group key K′G and a random number rM1 M → N : {K′G rM}KMN2 M ← N : MACK′G(N rM )Protocol 2 Pairwise key update protocol from [10]N : generates a random number rN1 M ← N : {rN}KM  MACKMN ({rN}KM )MN : compute the new pairwise key K′MN = h(KMN  rN )To initiate the group key update protocolM generates a new group key K′Grandomly It then encrypts it with another random number rM  and sends itover the network to the target group No node in the group has any clue whetherthe received key is fresh or not In other words the freshness property from theviewpoint of N does not hold since the two values (the new group key K′G andthe random number rM ) are random values chosen by M  It is both impracticaland insecure for each sensor node to maintain a list of keys that have been usedThus an external adversary will be able to record a rekeying message and thenre-inject it into the network which leads to updating the group key with an oldkey Consequently the group enters a key mismatch phase where the key versionthat the group of sensors uses and what M has are differentOne good security practice is to minimize the damage caused by a compro-mised node However the authors did not consider common attacks in WSNsthat an adversary is capable of launching attacks such as selective forwarding[5] or node compromise [4] If a single sensor node has the ability to affect theoperation of a good number of sensor nodes then the adversary will try to com-promise that node For example if an adversary compromised a sensor node (saynode Nb) in a multi-hop path then it would be able to enforce all other nodesdownstream to enter the key mismatch phase The adversary simply drops therekeying message from M for the group key and then use the new group keyto calculate MACs on their identities and the received nonce which results in asuccessful impersonation attack We can easily fix the problem by replacing theMAC data with another one: eg MACKMN (K′G rM )Moreover to initiate the pairwise key update protocol N generates a randomnumber rN  and encrypts it with KM  It subsequently computes the MAC onthe encryption result and sends this MAC and the encryption result over thenetwork to M  The new pairwise key can be calculated at the sender N and atthe receiver M  by hashing rN with the previous pairwise key This means thatthe new pairwise key is always determined by N  The adversary consequently isable to know all the future keys once he compromised N  A closer look at theprotocols Protocol 1 and Protocol 2 reveals more serious defects of them Defect I The whole value of the new group key are directly carried by theprotocol messages encrypted under the pairwise keyKMN  The consequenceis that compromise of the pairwise key for just one node leads to compromiseof the group key for the whole group This is a more serious problem thanit might appear because the pairwise key compromise does not necessarilyrequire node capture Defect II The value of the new pairwise key K′MN is only determined bythe sensor node When the adversary of Type II or IV (he can compromisethe key generation codes stored in the node) captures the node all the futurepairwise keys for the node can be pre-determined by the adversaries Namelyphysical compromise of the node immediately leads to compromise of all thefuture pairwise keys if the adversary can modify the codes installed in thenode This in turn leads to compromise of all the future group keys as wellbecause as mentioned in Defect I the group key is delivered encrypted underthe pairwise key Hence contrary to their claim the scheme does not providefuture key secrecy against node compromise for either the pairwise key orthe group key Defect III Although not explicitly shown in the protocol descriptionsabove the key input rN for the new pairwise key K′MN is not really randomin their scheme; it is in fact a function of a pre-installed secret key and acounter value stored in the node This means that when the node is capturedand all the installed data including keys exposed to the adversary all thepast pairwise keys as well as the future keys can immediately be computedeven without recording a single key update message! In fact this disaster isnot just because of Defect III but also due to Defect II Note that due toDefect III combined with Defect II the adversary does not have to modifythe node's software at all in order to extract all the past and future pairwisekeys Hence no minimum level of past or future key secrecy against nodecompromise in their scheme Moreover the adversary can extract any groupkey in the past or future if he has got the records of the corresponding groupkey update message Note also that for this seamless monitoring is notneeded by the adversary What does this mean? The scheme is in terms ofeither kind of key neither forward nor backward secure against node com-promise for all the types of adversary I II III and IV (see Figure 2)As for past key secrecy we note two proposed schemes in the WSN context:Klonowski et al [6] and Mauw et al [8] Both schemes use hash functions inorder to achieve key evolution Both schemes however are intended to be usednot for group key update but for updating pairwise keys for node-to-node [613]or node-to-base station communication [8]On the other hand as for future key secrecy Mauw et al's protocol does notprovide this property The protocol is based on a hash chain scheme originallyproposed for RFID security [11] In RFID environments protecting secret taginformation from tampering in the future is a big concern while it does not seemto be such a prime concern inWSNs This is because it is more authentication andintegrity than privacy that really matters inWSNs especially SCADA/PCS Hencefuture key secrecy is more valued than past key secrecy On the other hand theprotocol proposed by Klonowski provides future key secrecy in a weak sense;namely it will be computationally hard for the adversary to compute a futurekey from the current compromised key if he fails to record say ten subsequentevolution steps [13]5 The Proposed SchemeDevising a key management for WSNs is not trivial and in particular may not besuccessfully accomplished by simple adaptation of security solutions designed forwired networks This is because of the limited resources such as limited energylifetime slow computation small memory and limited communication capabili-ties which exist in WSNs [1617] In this section we describe a key managementscheme which secures communication between remote fields (where the WSN re-sides) and the master center (where the network manager resides) by consideringvulnerabilities that are associated with WSNs 51 Key Management ProtocolsThis paper focuses on updating two types of keys which are the group key andthe pairwise key in the wireless process control environments A pairwise keyis shared between the network manager M and each sensor node N  while thegroup key is shared among M and the whole group of sensor nodesGroup Key Update Protocol Our solution for group key rekeying also ex-ploits the idea of key evolution using a hash chain in order to achieve past keysecrecy The protocol uses a hash chain hi(s0) where s0 is a pre-installed keycomponent at the pre-deployment phase and i ≥ 0 denotes the index for keyupdate phasesAs for future key secrecy we use the reverse hash chain technique whichwas first introduced by Lamport [7] The network manager prepares in advancea hash chain of length n starting from a random seed tn−1 and ending with thefinal value t0:tn−1 tn−2 := h(tn−1) tn−3 := h(tn−2)     t1 := h(t2) t0 := h(t1) For reasons of convenience which will become clearer shortly we write h−i(t0)instead of ti although h is not an invertible function and h−1(x) can only meanthe set of all preimages of x in a strict sense Roughly speaking h−i(t0) is the i-thpreimage of t0 in the reverse hash chain The secret data t0 will be pre-installedinto sensor nodes together with another key component s0Now with two secret key components s0 and t0 pre-installed within all sensornodes using Protocol 3 the group key KiG evolves as follows:KiG = hi(s0) ⊕ h−i(t0)  i ≥ 0 where we define h0(s0) = s0 and h0(t0) = t0 Figure 3 explains the key evolutionin the protocolProtocol 3 The protocol for group key update1 M → N : i {h−i(t0)}KMN2 M ← N : hKMN (KiG)M N : update the value of the group key (ie KiG = hi(s0) ⊕ h−i(t0) )Any sensor node can easily compute the i-th hash image hi(s0) from hi−1(s0)while only the network manager knows the value of the i-th preimage h−i(t0)0t 0s 1 0( )h s 0( )ih s0( )ih t 1 0( )h t1GKiGK0GKFig 3 Key evolution in the proposed protocolThus it is only the network manager who can release the preimage into the sensorfield As a consequence the first message in the protocol provides the sensor nodewith a weak form of signature from the network manager: the message could havebeen generated only by the network manager not by any sensor nodes includingthe node itself The check of the preimage (ie h(h−i(t0)) = h−(i−1)(t0) ) alsomakes sure that the key update message is freshAfter the i-th key update the sensor node stores the index i and the secretdata: hi(s0) h−i(t0) and KiG Considering the highly lossy communication en-vironment of sensor networks the sensor node may sometimes fall behind thegroup key update schedule The sensor node however will soon be able to catchup at the next rekeying: it can compute the correct value of the new group keysimply by checking the difference of two index values  the received and thestored  and applying the corresponding number of hash operationsNow let's assume that the adversary has somehow extracted the current valueof the group key KiG However he cannot extract from this the previous keyKi−1G because he cannot compute the value of hi−1(s0) Note that this holdseven when the adversary has recorded all the previous key update messagesand compromised all the previous manager-to-node pairwise keys In fact thenode capturing and extracting all the stored secret data does not surrenderthe past group key to the adversary This is because the previous values forhi(s0) were never exchanged over the air and were deleted after group keycomputation Hence we can say that the protocol provides past key secrecy forany kind of compromise: group key compromise pairwise key compromise andthe compromise of the node itselfThe protocol also provides future key secrecy in the sense that the adversaryjust with knowledge of the current group key KiG cannot predict the next groupkey Ki+1G  The computation of Ki+1G requires knowledge of h−(i+1)(t0) whichhas not yet been exchanged In the next step of the key update the adversarywithout knowledge of the pairwise key KMN  will not be able to obtain the valueof h−(i+1)(t0) from the protocol message In fact the pairwise key compromisealone does not lead to the future group key compromise; it will only happen whenthe adversary captures a sensor node thereby extracting the hidden componenthi(s0) Hence the protocol satisfies future key secrecy in the face of group keyand/or pairwise key compromise; simple delivery of the encrypted value of thenew group key as in [10] cannot provide this kind of resilience The protocol willfail to provide future key secrecy only when the node is physically captured Evenin the case of capture the adversary should listen to the key update message toextract the future group key Furthermore when the pairwise key is updatedany adversary of type I II or III will not be able to have any knowledge ofthe new pairwise key This in turn leads to the adversary's failure to have anyknowledge of the new group key established using the new pairwise key Hencewe achieve the future group key secrecy even after node capture as far as theadversary has no ability to modify the software codes stored in the nodeThe protocol uses the pairwise key KMN to encrypt the i-th preimage h−i(t0)in the first message and also to provide key confirmation by computing keyedhash of the new group key This is in order to rule out any compromised orsuspicious sensor nodes from group key updateOur protocol however has one limitation: it is vulnerable to a kind of collu-sion attack Assume that a sensor node was captured at a key update phase iand another node was subsequently captured again at the phase i + 10 Thenthe adversary can extract all the group keys for the phases i to i+10 Of coursethis compromise is limited to the past keys not the future keys We call thisattack sandwich attack  which will be considered in our future workProtocol 4 The protocol for pairwise key update1 M → N : i {h−i(t0) grM }Ki−1G# broadcast message2 M ← N : {grN }KMN  hKMN (grM  grN )N : keeps the hashed value of the current pairwise key: K1MN = h(KMN )M N : increment the group key index from i − 1 to i and update the values of thepairwise key (ie KMN := grM rN) and the group key (ie to KiG)Pairwise Key Update Protocol Protocol 4 shows the rekeying protocol forthe pairwise key shared between the network manager and the sensor node Thisprotocol is based on Diffie-Hellman protocol which has recently become not onlyfeasible on resource constrained nodes but attractive forWSNs [15] The networkmanagerM first generates a secret random number rM  and computes the Diffie-Hellman component grM  It then broadcasts Message 1 which includes the indexi of the next group key and ciphertexts of the next group key component h−i(t0)and a Diffie-Hellman component grM  encrypted under the current group keyKi−1G The inclusion of the group key index i in the first message enables each sensornode to check if it keeps the current value of the group key; if not the node canrequest the network manager to send the latest key component h−i(t0) Thusthe group key rekeying protocol exchange as described in Protocol 3 can beinserted between Messages 1 and 2 of the protocol in the case of group key indexmismatchAfter retrieving the plaintext of Message 1 using the group key the nodechecks the preimage if h(h−i(t0)) = h−(i−1)(t0) This check provides evidence forthe node that M has really started the pairwise key update session Consideringthat Message 1 is a broadcast message encrypted using the group key it wouldbe simply impossible to achieve this evidence without using the preimage as usedhere Of course using digital signature/verification is a different storyNow the node constructs the second message of the protocol: it generatesits own Diffie-Hellman component grN  encrypts it and generates the keyedhash of both Diffie-Hellman components under the current pairwise key KMN After sending the message to M  the node computes the new group key KiG =hi(s0) ⊕ h−i(t0) increments the group key index from i− 1 to i and computesthe Diffie-Hellman key grMrN to be used as the new pairwise key while keepingthe hash h(KMN ) of the old pairwise key and safely deleting the old keyOn receiving Message 2 M decrypts grN  and verifies the keyed hash fromN  The inclusion of grM and grN in the hash provides M with confidence aboutthe freshness and authenticity respectively of the messageUse of Diffie-Hellman key agreement for the pairwise key update provides thepast and future pairwise key secrecy; the key inputs are temporary randoms andthus no relation to the previous or next key inputs Even after node compromiseif the attacker is not able to modify the software codes in the node (ie theadversary of type I or III) or if he fails to record the key update messages(ie the adversary of type I or II) the node will escape from the control of theadversary to recover the secure status Thus our scheme satisfies past pairwisekey secrecy for all the adversary types and future pairwise key secrecy for anyadversary type except type IV even against node capture and its compromiseImpersonation attack If the adversary is in full control of a compromisednode in which he installed his own malicious attacking software then the ad-versary's node can still impersonate M to some other victim node succeedingin causing the victim to receive a fake Diffie-Hellman component say gx Butthe attack is limited to that The attacking node has only two options whenreceiving Message 2 of the victim node: (1) forward the message verbatim to M or (2) cut out the message In the former case M will get not the expected hashhKMN (grM  grN ) but a strange one hKMN (gx grN ) In the latter caseM will seeno response from N  In both cases M will issue Message 1 again through theunicast channel to N  which will finally lead to key agreement between M andN Delivery failure management The delivery failure in theWSNs will leadto key mismatches of group keys and/or pairwise keys With no long term keyavailable in our key update protocols key mismatch is a big concern and shouldbe handled carefully Simple retransmission of the protocol messages is not asolution; it may open the door to replay attacks Moreover it may require thesensor node to go back to the old key even after it has successfully updated thepairwise key Consequentially the node must keep two keys at the same time:the old key and the new updated keyOur solution is to use key evolution here again With no response from thenode N  the manager M initiates Protocol 5 over the unicast channel to N Protocol 5 The protocol to handle delivery failure1 M → N : i j {h−i(t0) grM }KjMN# unicast message2 M ← N : {grN }KjMN hKjMN(grM  grN )M N : update the values of the pairwise key (ie KMN := grM rN)N : increments the indice i and j and updates the values of the pairwise key (ieKMN := grM rN) and the group key (ie to KiG) and then keeps the hashed valueof old key: Kj+1MN := h(KjMN )Here KjMN = hj(KMN ) is a hashed copy of the current key from M 's view-point For the time of the first protocol run the index j is set to 1; it will beincremented by one whenever the protocol is retried On receipt of Message 1over the unicast channel the sensor node N compares the received group keyindice i j with the stored indice i′ j′ and executes the required action as fol-lows: Case 1: i = i′ and j ≥ j′ For simplicity consider the case j = j′ = 1The pairwise key update protocol (Protocol 4) has just been run but thereply message of the protocol failed to arrive at M  The node N has beenkeeping the hashed copy K1MN = h(KMN ) of the old pairwise key which isapplied to the ciphertext for Message 1 of Protocol 5 The retrieved valueof h−i(t0) ensures the authenticity of the message; the entity other than N in possession of h−i(t0) and K1MN  should be M  The node decrypts theencrypted part of Message 1 using K1MN  Then N follows exactly the samestep as in 4 except that it uses the hash of the old pairwise key instead of thecurrent pairwise key At the end of the protocol run N will end up with anew pairwise key and the hash of K1MN  ie K2MN ; now j = 2 The currentpairwise key is simply deleted One or more failure again will be followed byreinitiation of the protocol by M with j incremented It could also happenthat Message 1 itself fails to arrive at N  and subsequently M retries theprotocol This will lead to the case j > j′ Case 2: i = i′ and j < j′ This cannot happen; otherwise it is simply abogus message from another sensor node N should ignore Message 1 Case 3: i > i′ This happens when the node N has never been involvedin the pairwise key update protocol due to delivery failure of Message 1 ofProtocol 4 In this case N applies the hash to the current pairwise key jtimes and uses the resulting value as the description key for Message 1 Case 4: i < i′ This is another case of replay attack N should ignoreMessage 1Now the old key does not need to be kept just for handling key mismatch;Protocol 5 does not come with any breach of securityFig 4 Relations between keys and keying materials and the significance of node com-promise52 Putting it all togetherIn our scheme the pairwise key is used for secure delivery of the group key updateinformation in Protocol 3; the group key in turn encrypts the Diffie-Hellmancomponents to establish a new pairwise key in Protocol 4 This combinationhelps the sensor networks to recover its security quickly after some sensor nodesare captured and their keys are compromisedFigure 4 illustrates how all the keys and keying data are related to each otheras they evolve over time Note that no keys are delivered over the air; only theirkeying materials such as h−i(t0) are exchanged or even never exchanged overthe air (eg hi(s0) ) Thus unlike the scheme of Nilsson et al (see Defect I inSection 4) the pairwise key compromise alone does not lead to the group keycompromise and vice versaUsing the inverse hash chain as well as the hash chain we achieve bothpast/future group key secrecy at the same time; furthermore the group keyupdate message provides an inherent message authenticityBoth M and N contribute their Diffie-Hellman inputs to the computationof the new pairwise key and thus the adversary can not determine the futurevalues of the pairwise key even after node capture and the resulting compromiseof the built-in software which was not the case in the scheme of Nilsson et al(see Defect II in Section 4)Carefully designed with node capture in mind our scheme does not surrenderall the key components required to retrieve the past/future group/pairwise keysOnly the adversary equipped with seamless monitoring and software compromise(ie the type IV adversary) can keep the control of the once-captured nodeGroup key not disclosedPairwise key not disclosedGroup key disclosedPairwise key disclosedGroup key not disclosedPairwise key disclosedGroup key disclosedPairwise key not disclosedNot monitoredMonitored & SW not compromisedCapturedkey update protocolkey updateProtocolkey updateProtocolkey update protocolkey updateProtocolkey updateProtocolkey update protocolkey updateProtocolMonitored & SW compromised key updateProtocolkey updateProtocolFig 5 State diagram of key disclosureFigure 5 shows how the node recovers its secure state with the help of thekey update protocols after it has been captured and all the keys in it are com-promised Without seamless monitoring (ie adversary types I and II) the ad-versary will soon lose all the control of the keys Even with adversary type III(ie seamless monitoring but no software compromise) the node will eventuallyrecover the secrecy of both keys Only for adversary type IV (ie both seamlessmonitoring and software compromise) there is no path available back to theoriginal secure state We argue that a non cryptographic countermeasure suchas tamper-proof technology is additionally required to fight against the strongestadversary of type IV6 ConclusionWireless sensor networks (WSNs) has brought a devastating security threat:node capture The threat is so powerful that almost all existing key managementprotocols are just helpless because it overthrows the fundamental assumption forcryptographic system design: long term secret keys are securely stored This iswhy so called forward secrecy and backward secrecy are required in cryptographickey management protocols for WSNs Both terminologies are rather misleadingand confusing and so we propose more proper ones: future key secrecy and pastkey secrecyNilsson et al [10] have recently proposed a key management scheme for WSNapplications in PCS/SCADA environments which was incorrectly claimed toprovide future and past key secrecies Some proposals (only for pairwise keyupdate) provide past key secrecy but not future key secrecy [86]We noticed that any cryptographic countermeasure alone cannot prevent themost powerful adversary in the WSN context; he can capture a node to extractall confidential data modify any built-in codes and seamlessly monitor to keepcontrol of the node This kind of attackers can only be fought by using tamper-proof technologies as well as cryptographic ones The assumption regarding thistype of adversaries however is by no means the most usual or reasonable as-sumption Seamless monitoring requires the adversary not to lose every singlesession for group key or pairwise key update The task of modification of randomnumber generation codes will add another burden to thatIn order to measure the resilience of key management protocols we derivedfour different types of adversaries varying in their capability with regard toseamless monitoring and software manipulation As shown in Section 3 Nilssonet al's scheme contrary to their claims turned out to provide neither pastkey secrecy nor future key secrecy against node compromise by any type ofadversariesWe applied Lamport's reverse hash chain as well as usual hash chain toprovide both past and future key secrecies Our scheme avoids the delivery ofthe whole value of new group key for group key update; instead only the halfof the value is transmitted from the network manager to the sensor nodes Thisway the compromise of a pairwise key alone does not lead to the compromise ofthe group key which was not the case in the scheme by Nilsson et al The newpairwise key in our scheme is determined by Diffie-Hellman based key agreementAs for the scheme of Nilsson's et al it uses key transport not key agreementwhere the new pairwise key is determined by the sensor node and then deliveredto the network manager by using public key encryption This has brought a vitalflaw to their schemeIn short our scheme provides a very strong resilience; both past and futurekey secrecies against node capture by all the adversary types except the strongestone Type IV A sensor node attacked by the adversary of Type IV in theorycannot be quarantined by a cryptographic method alone; a non-cryptographiccountermeasure such as tamper-proof protection is needed togetherReferences1 Cheryl Beaver Donald Gallup William Neumann and Mark Torgerson Keymanagement for SCADA Technical Report SAND2001-3252 Sandia NationalLaboratories - Cryptography and Information Systems Surety Department March20022 Robert Dawson Colin Boyd Ed Dawson and Juan Manuel González NietoSKMA: a key management architecture for SCADA systems In Rajkumar BuyyaTianchi Ma Reihaneh Safavi-Naini Chris Steketee and Willy Susilo editorsACSW Frontiers volume 54 of CRPIT pages 183192 Australian Computer So-ciety 20063 Christoph G Günther An identity-based key-exchange protocol In EURO-CRYPT pages 2937 19894 Carl Hartung James Balasalle and Richard Han Node compromise in sensornetworks: The need for secure systems Technical Report CU-CS-990-05 Universityof Colorado at Boulder - Department of Computer Science January 20055 Chris Karlof and David Wagner Secure routing in wireless sensor networks: attacksand countermeasures Ad Hoc Networks 1(2-3):293315 20036 Marek Klonowski Miroslaw Kutylowski Michal Ren and Katarzyna RybarczykForward-secure key evolution in wireless sensor networks In Feng Bao San LingTatsuaki Okamoto Huaxiong Wang and Chaoping Xing editors CANS volume4856 of Lecture Notes in Computer Science pages 102120 Springer 20077 Leslie Lamport Password authentification with insecure communication Com-mun ACM 24(11):770772 19818 Sjouke Mauw Ivo van Vessem and Bert Bos Forward secure communication inwireless sensor networks In John A Clark Richard F Paige Fiona Polack andPhillip J Brooke editors SPC volume 3934 of Lecture Notes in Computer Sciencepages 3242 Springer 20069 Robert McClanahan SCADA and IP: is network convergence really here? IndustryApplications Magazine IEEE 9(2):2936 Mar/Apr 200310 Dennis K Nilsson Tanya Roosta Ulf Lindqvist and Alfonso Valdes Key man-agement and secure software updates in wireless process control environments InVirgil D Gligor Jean-Pierre Hubaux and Radha Poovendran editors WISECpages 100108 ACM 200811 Miyako Ohkubo Koutarou Suzuki and Shingo Kinoshita Cryptographic approachto privacy-friendly tags In In RFID Privacy Workshop 200312 Ludovic Pietre-Cambacedes and Pascal Sitbon Cryptographic key managementfor SCADA systems-issues and perspectives International Journal of Security andits Applications 2(3):3140 July 200813 Michal Ren Tanmoy Kanti Das and Jianying Zhou Diverging keys in wirelesssensor networks In ISC pages 257269 200614 Rodrigo Roman Cristina Alcaraz and Javier Lopez The role of wireless sensornetworks in the area of critical information infrastructure protection InformationSecurity Technical Report 12(1):2431 March 200715 Piotr Szczechowiak Leonardo B Oliveira Michael Scott Martin Collier and Ri-cardo Dahab NanoECC: Testing the limits of elliptic curve cryptography in sensornetworks In Roberto Verdone editor EWSN volume 4913 of Lecture Notes inComputer Science pages 305320 Springer 200816 Marcos August M Vieiral Claudionor N Coelho Jr Di6genes Cecilio da Silva Ju-nio and Jose M da Mata Survey on wireless sensor network devices volume 1pages 537544 September 200317 John Paul Walters Zhengqiang Liang Weisong Shi and Vipin Chaudhary Wire-less sensor network security: A survey chapter 17 in Security in Distributed Gridand Pervasive Computing Auerbach Publications CRC Press 2006
Secure Auth-Resource Limited-Tseng-pdf,A secure authenticated group keyagreement protocol forresource-limited mobile devicesYUH-MIN TSENGDepartment of Mathematics National Changhua University of EducationJin-De Campus Chang-Hua 500 Taiwan ROCCorresponding author: ymtseng@ccncueedutwWith rapid growth of mobile wireless networks many mobile applications have received significantattention However security will be an important factor for their full adoption Most securitytechnologies currently deployed in wired networks are not fully applicable to wireless networksinvolved in resource-limited mobile nodes because of their low-power computing capability andlimited energy The design of secure group key agreement protocols is one of many importantsecurity issues in wireless networks A group key agreement protocol involves all participantscooperatively establishing a group key which is used to encrypt/decrypt transmitted messagesamong participants over an open channel Unfortunately most previously proposed group keyagreement protocols are too expensive computationally to be employed in mobile wireless networksRecently Bresson et al proposed an authenticated group key agreement protocol suitable for amobile wireless network This mobile wireless network is an asymmetric wireless one that consists ofmany mobile nodes with limited computing capability and a powerful node with less restrictionHowever this protocol does not satisfy some important security properties such as forward secrecyand contributory key agreement In this paper we propose a new authenticated group key agree-ment protocol which is well suited for this asymmetric wireless network The proposed protocolnot only is efficient but also meets strong security requirements We demonstrate that the proposedprotocol is a real contributory group key agreement one and provides forward secrecy as well asimplicit key authentication The proposed protocol is provably secure against passive adversariesand impersonator’s attacks A simulation result shows that the proposed protocol is well suited formobile devices with limited computing capabilityKeywords: Security contributory group key agreement mobile device provably secure resource-limitedReceived 9 January 2006; revised 25 June 20061 INTRODUCTIONRecently many mobile applications have rapidly developedsuch as wireless internet services mobile access services andmobile e-commerce Cellular mobile networks [1] wirelesslocal area networks [2] wireless ad hoc networks [3] andmobile peer-to-peer networks [4] are several importanttechnologies for providing mobile communicationsAlthough mobile applications deployed on mobile deviceshave received significant attention the security issue will bean important factor for their full adoption Because of thelow-power computing capability of mobile devices in a wire-less network most security technologies currently deployedin wired networks are not fully applicable to wireless net-works [35] On the other hand mobile devices in wirelessnetworks adopt some wireless mediums (ie radio wave) tocommunicate with each other An intruder is easy to interceptcommunications over the open wireless network thus thereare more security threats than with the wired communicationsConsidering the low-power computing capability of mobiledevices the design of security protocols well suited for wire-less mobile networks is a nontrivial challenge because mostcryptographic algorithms require many expensive computa-tions The design of secure group key establishment protocolsis one of many important security issues A group key esta-blishment protocol allows participants to construct a groupkey that is used to encrypt/decrypt transmitted messagesamong the participants over an open channel There are twokinds of group key establishment protocols: group keyThe Computer Journal Vol 50 No 1 2007 The Author 2006 Published by Oxford University Press on behalf of The British Computer Society All rights reservedFor Permissions please email: journalspermissions@oxfordjournalsorgAdvance Access published on July 21 2006 doi:101093/comjnl/bxl043 at Fraunhofer-Gesellschaft - FhG on January 29 2014http://comjnloxfordjournalsorg/Downloaded from distribution [6789] and group key agreement [10111213141516] In a group key distribution protocol a trusted orelected entity is responsible for generating and distributingthe group key A group key agreement protocol involves allparticipants cooperatively establishing a group key Oneadvantage of the key agreement protocol compared with thekey distribution one is that no participant can predeterminethe group key In many scenarios the group key distributionprotocol is not appropriate because the elected entity mightact a single point of failure for the group’s security Mean-while the design of group key agreement protocols shouldbe rigidly proven to provide confidence and authenticationIn this paper we focus on the design of secure authenticatedgroup key agreement protocol for mobile wireless networksAteniese et al [12] proposed an authenticated group keyagreement protocol that made each participant explicitlyaware of the exact group membership However the securityof this protocol has not been rigidly proven and thereforeconfidence in it is limited [17] Bresson et al [1314]developed the first formal security model for an authenticatedgroup key agreement protocol as well as proposing severalprotocols that were demonstrated to be secure However theirprotocols require O(n) rounds to construct a group key wheren is the number of participants Consequently as group sizegrows large these protocols become impractical In 2003Katz and Yung [15] proposed a scalable compiler that cantransform any group key establishment protocol into anauthenticated one Katz and Yung also applied their compilerto the Burmester–Desmedt protocol [11] which presented aprovable secure authenticated group key agreement protocolwith three roundsIn 2005 Tseng [16] proposed a robust group key agree-ment protocol resistant to malicious participants Theproposed protocol requires only two rounds to establisha group key and provide forward secrecy The proposedprotocol is provably secure against passive adversariesFurthermore the protocol provides fault tolerance againstmalicious participants Fault tolerance means that even in theevent of malicious participants attempting to disrupt theestablishment of a group key the other honest participantswill still be able to compute the group key Neverthelesscomputational complexity of these previously proposedprotocols [1213141516] is beyond the computationalcapabilities of mobile devices in wireless networksThe design of group key agreement protocols for a mobilewireless network must not only meet strong securityrequirements but also consider the computational capabilitiesof mobile devices In 2000 Asokan and Ginzboorg [18]proposed a first group key agreement protocol for a cluster ofmobile nodes However their protocol are suited for a smallgroup of powerful devices (ie laptops) the protocol becomesimpractical when low-power mobile devices come into playThat is their protocol is not suited for some resource-limitedmobile devices such as handheld computers personal digitalassistants and smart phones In 2003 Boyd and Nieto [19]proposed an efficient group key agreement protocol with aconstant round In their protocol only one of all participantsrequires a linear amount of computation and other parti-cipants require only a fixed computation that is independentof the number of participants It is provably secure againstpassive adversaries under the random oracle model [20] butlacks forward secrecy Forward secrecy means that thepreviously established group keys cannot be compromisedif a long-term secret key is compromised This property isimportant and has been included in most key agreementprotocols and standards [21]Considering cellular mobile networks [1] wireless localarea networks [2] wireless ad hoc networks [3] and mobilepeer-to-peer networks [4] they may be regarded as anasymmetric wireless network that consists of many resource-limited mobile nodes and a powerful node with lessrestriction Attempt to shift the computational burden to thepowerful node and reduce the computational cost of mobilenodes is a flexible approach for designing group keyagreement protocols in a mobile environment RecentlyBresson et al [22] proposed an authenticated group keyagreement protocol suitable for this asymmetric wirelessnetwork However their protocol does not satisfy someimportant security properties such as forward secrecy andimplicit key authentication [23] In 2005 Nam et al [24]proposed a non-authenticated group key agreement protocolfor an asymmetric wireless network They adopted Katz–Yung’s compiler [15] to transform their group key agreementprotocol into an authenticated one Both Bresson et aland Nam et al protocols claimed that their protocols arecontributory key agreement ones Unfortunately Tseng [25]has presented that both protocols [2224] are not real contri-butory key agreement ones Detailed analysis and relateddiscussions will be presented in the next sectionIn this paper we propose a secure authenticated group keyagreement protocol which is well suited for asymmetricwireless networks The proposed protocol also adopts anasymmetric computation technique to shift the computationalburden to the powerful node Let mobile nodes (low-powernodes) perform most of the cryptographic computationsoffline The computational cost of each mobile node isreduced to only one exponential one hash function and manymultiplication operations The proposed protocol requires onlytwo rounds to construct a group key In contrast with thepreviously proposed protocols [2224] for asymmetric wirelessnetworks we demonstrate that the proposed protocol is a realcontributory group authenticated group key agreement oneMeanwhile a simulation result on a PDA (Personal DigitalAssistant) device shows that the proposed protocol is wellsuited for mobile devices with low-power computingcapability Despite meeting the requirement of computa-tional capability restrictions for mobile nodes the proposedprotocol is provably secure against passive adversaries and42 Y-M TsengThe Computer Journal Vol 50 No 1 2007 at Fraunhofer-Gesellschaft - FhG on January 29 2014http://comjnloxfordjournalsorg/Downloaded from impersonator’s attacks We show that the proposed protocol issecure against passive adversaries under the well-knownDecision Diffie–Hellman problem [262728] We alsoshow that the proposed protocol is provably secure againstimpersonator’s attacks under the decision Diffie–Hellmanand the discrete logarithm assumptions and provides mutualauthentication between mobile nodes and the powerful nodeThe remainder of this paper is organized as follows In thenext section we present the system model and notationsAfterwards we analyze Bresson et al’s authenticated groupkey agreement protocol as well as the related discussionsIn Section 3 a secure authenticated group key agreementprotocol well suited for resource-limited mobile devices ispresented In Section 4 we demonstrate the security analysisof the proposed protocol In Section 5 the performanceevaluation of the proposed protocol is given Finally we drawour conclusions and future works in Section 62 PRELIMINARIES AND DISCUSSIONS OFRELATED WORKSBoth Bresson et al’s authenticated protocol [22] and ournew authenticated protocol are suitable for an asymmetricwireless network (also called imbalanced wireless network)that consists of many mobile nodes with limited computingcapability as well as a wireless gateway with less restrictionTherefore we first present the model of the asymmetricwireless network and some system notations Afterwards wereview Bresson et al’s authenticated group key agreementprotocol and discuss its security weaknesses21 Model and notationsThe system environment is an asymmetric wireless networkwhich consists of some mobile nodes with strict computa-tional capability restrictions and a wireless gateway with lessrestriction We consider a set of resource-limited mobilenodes (also called low-power nodes) communicating with awireless gateway (also called powerful node) in which eachlow-power node can send messages to the powerful node viauni-cast communication and the powerful node can broadcastor uni-cast messages to each low-power node The powerfulnode covers an entire wireless region called a cell such as thebase station of cellular mobile networks [1] the access pointof wireless local area networks [2] and the cluster-head ofmobile ad hoc networks [3]Without loss of generality let U ¼ {U1 U2    Un} be theinitial set of low-power nodes that want to generate a groupkey with powerful node S Each low-power node as wellas the powerful node hold a pair of secret/public keys Thefollowing system parameters and notations are used through-out the paper q: a large prime p: a large prime such that p ¼ 2q +1 Gq: a subgroup of quadratic residues in Zp that isGq ¼ fi2 j i 2 Zpg g: a generator for the subgroup Gq SKi: a low-power node Ui’s secret key in Zq PKi: a low-power node Ui’s public key such thatPKi ¼ gSKi mod p SKS: the powerful node S’s secret key in Zq PKS: the powerful node S’s public key such thatPKS ¼ gSKSmodp H(): a one-way hash function H with arbitrary lengthinput and a fixed length output [29] ie {0 1} !{0 1}k where k is the length of output Sign(SKi m): the signing algorithm based on ElGamal[30] or DSA [31] schemes under the secret key SKi andthe signed message m Verify(PKi m di): the verifying algorithm correspondingto the signing algorithm under the public key PKi thesigned message m and the corresponding signature diAs we all know most cryptographic algorithms (digital sig-nature or common-key establishment) require many expens-ive computations such as inverse and exponential operationsIn 2001 Shamir and Tauman [32] proposed an online/offlinesignature scheme based on the discrete logarithm assumption[3031] The online computational complexity is equivalentto about only one modular multiplication The security of thissignature scheme is secure against adaptive chosen messagesattacks under the discrete logarithm assumption BothBresson et al’s protocol [22] and our new protocol adoptthis online/offline signature scheme to reduce the computa-tional complexity of the low-power mobile nodes Certainlysome offline pre-computation values must be stored on oneadd-on memory card of the low-power mobile nodes Untilnow storage limitation is becoming less of a concerning issueas many add-on memory cards are widely available22 Analysis and related discussions ofBresson et al’s protocolRecently Bresson et al [22] adopted the offline signaturetechnique [32] to propose an authenticated group keyagreement protocol for an asymmetric wireless networkTheir protocol is a two-round protocol and computationallyasymmetric For comparing with our proposed protocol webriefly review their protocol as followsStep1 (Round 1): Initially each low-power node Ui(i ¼ 12     n) selects a random value xi in Zq and then pre-computes yi ¼ gxi mod p Zi ¼ PKxiS modp as well as a sig-nature di ¼ Sign(SKi yi) under the secret key SKi Then eachlow-power node Ui sends (yi di) to the powerful node S Notethat the (yi Zi di) should be stored in the memory storageof the low-power node in advanceStep2 (Round 2): For each (yi di) the powerful node Schecks the signature di by Verify(PKi yi di) under the publicA group key agreement protocol for resource-limited mobile devices 43The Computer Journal Vol 50 No 1 2007 at Fraunhofer-Gesellschaft - FhG on January 29 2014http://comjnloxfordjournalsorg/Downloaded from key PKi If the verification is correct the powerful node Suses his secret key SKS to compute the following valuesZi ¼ Zi ¼ ySKSi (for i ¼ 12     n) Then S selects a counter cand computes a group key K ¼ H(c k Z1 k k Z2 k  k Zn)and computes the shared secret value: Ki ¼ K  H(ckzi) (fori ¼ 12     n) where k denotes the concatenation Finallythe powerful node S sends (c Ki) to the low-power nodeUi(i ¼ 12     n)Step3 Group key computation: Upon receiving (c Ki)each low-power node Ui computes the shared secret keyK ¼ Ki  H(c k Zi) the group session key GK is computed byGK ¼ H(K k Ui k S) where Ui s are identities of the low-power nodes and S is the identity of the powerful nodeTheir original protocol provides only the powerful nodeto authenticate the lower-power nodes by validating thesignatures di If the low-power nodes want to authenticate thepowerful node one hash function operation is required byeach low-power node while n hash function operationsare required by the powerful node For providing mutualauthentication among mobile nodes each low-power nodemust compute n  1 hash function operations and two extrarounds must are requiredAlthough Bresson et al claimed that their authenticatedprotocol offers partial forward secrecy and secure againstsome attacks unfortunately Nam et al [23] pointed out thatBresson et al’s authenticated protocol has some securityweaknesses In fact their protocol does not provide partialforward secrecy and implicit key authentication AfterwardsNam et al [24] proposed a non-authenticated group keyagreement protocol for an asymmetric wireless networkBy its very nature a non-authenticated group key agreementprotocol cannot provide participant and message authenti-cation so it must rely on the authenticated network channel oruse another scheme to provide authentication such as theKatz–Yung transformation [15] Employing the Katz–Yungscalable compiler can transform their two-round protocolsinto authenticated group key agreement protocols with threerounds However this transformation increases the originalprotocol by one new round as well as one signaturegeneration and n  1 verifications for each low-powernode In this case the computational cost is expensive formobile devicesBoth Bresson et al’s [22] and Nam et al’s protocols [24]claimed that their protocols are contributory key agreementones However Tseng [25] has presented that both protocolsare not contributory key agreement ones In this case someefficient group key distribution protocols [789] may bedeployed in this asymmetric wireless network to replace bothBresson et al’s and Nam et al’s protocols Nevertheless thedesign of a secure authenticated group agreement protocolwell suited for wireless mobile networks is a nontrivialchallenge which inspires us to propose a provably secureauthenticated group agreement protocol3 THE NEW AUTHENTICATED GROUP KEYAGREEMENT PROTOCOLIn this section we propose a new authenticated group keyagreement protocol well suited for low-power mobiledevices The proposed protocol is a provably secure groupkey agreement protocol which is secure against passiveadversaries and provides mutual authentication between thepowerful node and low-power nodesFor achieving authentication each mobile node Ui gene-rates a temporary Diffie–Hellman key pair (xi yi) [26] where(xi yi) And Ui generates a signature for yi to let the powerfulnode S authenticate Ui Then the powerful node S mustcompute a Diffie–Hellman session key based on yi using hissecret key thus the Diffie–Hellman session key establishedenables the mobile node Ui to authenticate the powerful nodeS Meanwhile each yi is used to involve in the key agreementconstruction of a group key shared among all low-powernodes and the powerful node S As depicted in Figure 1 thenew authenticated group key agreement protocol runs in tworounds as follows:Step1 (Round 1): Initially each low-power node Ui(i ¼ 12     n) selects a random value xi in Zq and then pre-computes xi x1i  as well as a signature di ¼ sign(SKi yi)under the secret key SKi Then each low-power node Ui sends(yi di) to the powerful node S Note that (xi x1i  ai yi di)should be stored in the memory storage of the low-powernode in advance and each tuple (xi x1i  ai yi di) is used onlyonceStep2 (Round 2): For each (yi di) the powerful node Schecks the signature di by Verify(PKi yi di) under the publickey PKi If the verification is correct the powerful node Srandomly selects a value x in Zq and then computes X ¼ gxand the following values (for i ¼ 12     n):zi ¼ y xi mod pa0i ¼ ySKsi mod p:Then the powerful node S computes a checking value C ¼H(X  z1    zn) and a group key K ¼ XQnj¼1 zj mod pFinally the powerful node S broadcasts C and ðai0‚ ziÞi ¼ 12     n to all low-power nodesStep3 Group key computation: Upon receiving Cand ða0i‚ ziÞ i ¼ 12     n each low-power node Uichecks whether ai ¼ a0i holds or not If the check holds Uicomputes X ¼ Zx1ii mod p Then Ui checks whether C ¼H(X  Z1    Zn) and Zi 6¼ 1 for i ¼ 12     n hold ornot If the checks hold Ui computes the group keyK ¼ XQnj¼1 zj mod p¼gxþxx1þxx2þþxxn mod pAs mentioned in Step 1 many tuples (xi x1i  ai yi di)should be stored in the memory storage (eg smart card) of thelow-power node in advance and each tuple (xi x1i  ai yi di)is used only once In this case the used tuple (xi x1i  ai yi di)must be erased as soon as they are no longer useful for44 Y-M TsengThe Computer Journal Vol 50 No 1 2007 at Fraunhofer-Gesellschaft - FhG on January 29 2014http://comjnloxfordjournalsorg/Downloaded from providing forward secrecy Besides for protecting theseunused tuples (xi x1i  ai yi di) stored in the memory storageof the low-power node one protecting mechanism shouldbe provided to securely store these unused tuples such asself-protected smart cards [33] Meanwhile note that thelow-power node adopts the Shamir–Tauman online/offlinesignature scheme [32] to generate the signature di ¼Sign(SKi yi) in which the online computational complexityis mainly involved the time stamp or the nonce into thesignature The detailed procedure refers to [32] In additionin each conference the group key is different Thereforewhen a secure conference was terminated or finished theestablished group key should be erased from the memorystorages of both low-power nodes and the powerful nodeIn the following we show that the proposed protocol isa real contributory group key agreement protocol becauselow-power nodes are able to confirm that their contributionshave been involved in the group keyTHEOREM 1 By running the proposed protocol if eachlow-power node checks that C ¼ H(X  z1    zn) holdsthen an identical group key can be established by all low-power nodes thus the proposed protocol is a contributorygroup key agreement oneFIGURE 1 New authenticated group key agreement protocolA group key agreement protocol for resource-limited mobile devices 45The Computer Journal Vol 50 No 1 2007 at Fraunhofer-Gesellschaft - FhG on January 29 2014http://comjnloxfordjournalsorg/Downloaded from Proof According to the proposed protocol the powerfulnode S broadcasts C and ða0i‚ ziÞ for i ¼ 12     n to alllow-power nodes and each low-power node Ui (1  i  n)may use its secret exponent xi to compute X and thechecking value H(X  z1    zn) and then checks whetherC ¼ H(X  z1    zn) holds or not If the check holdseach low-power node can compute an identical group keyK ¼ XQnj¼1 zj mod p Since the identical group key K hasbeen established this means that the following equationholdsK ¼ gxYnj¼1zj mod p¼ Zx111Ynj¼1Zj mod p¼    ¼ Zx1nn Zj mod pThus we have a value V¼K · ðQnj¼1 zjÞ1 mod pmod psuch thatV ¼ Zx111 mod p¼ Zx122 mod p¼    ¼ Zx1nn mod p:Therefore we havez1 ¼ Vx1 mod p‚z2 ¼ Vx2 mod p‚zn ¼ Vxn mod p:Observing the above equations each zi includes the low-power node Ui’s secret exponent xi Since K ¼ Zx1iiQnj¼1 Zjfor i ¼ 12     n we have K ¼ VQnj¼1 zj mod p Thereforethe group key K contains each low-power node’s secretexponent xi that is each low-power node can confirm that itscontribution has been included in the group key In this casethe proposed protocol is a contributory group key agreementone &From Theorem 1 since the proposed protocol is acontributory group key agreement it means that eachlow-power node equally contributes to the group key andguarantees its freshness in each group key construction Oneadvantage of the key agreement protocol compared with thekey distribution one is that no participant can predeterminethe group keyIn an asymmetric wireless network to shift the computa-tional burden to the powerful node and reduce the compu-tational cost of low-power nodes is a flexible approachfor designing group key agreement protocols However forreducing the computational complexity of the low-powernodes low-power nodes do not authenticate each other andverify the transmitted messages Meanwhile all messagessent to low-power nodes are through the powerful node solow-power nodes cannot verify them This is an inherentweakness in this asymmetric wireless network As Bressonet al’s protocol [22] and Nam et al’s protocol [24] theproposed protocol has the same problem Therefore singlepoint of failure still existed in the proposed protocol thus alot of trust to the powerful node still existsIn the next section we will show that the proposed protocolis provably secure against passive adversaries as well asimpersonator’s attacks Besides we will also show that theproposed protocol achieves implicit key authentication andprovides forward secrecy4 SECURITY ANALYSISIn Step 1 of the proposed protocol the low-power nodeadopts the Shamir–Tauman online/offline signature scheme[32] to generate the signature di ¼ Sign(SKi yi) The onlinecomputational complexity is equivalent to about only onemodular multiplication This online computational complex-ity is mainly involved the time stamp or the date into thesignature Therefore the proposed protocol is secure againstthe replay attack Some offline pre-computation values mustbe stored on one smart card of the low-power mobile nodesTherefore one self-protected mechanism [33] should beprovided to securely store these unused messages on thesmart card41 Passive adversariesPassive adversary is that if an attacker is unable to obtainthe established group key by eavesdropping messages trans-mitted over the broadcast channel the group key agreementprotocol is secure against passive adversaries We need asecurity assumption to prove it Here we adopt the DecisionDiffie–Hellman problem assumption to prove that the pro-posed protocol is secure against passive adversaries Severalpapers [2728] have demonstrated the security as well as thevariants of the Decision Diffie–Hellman problemASSUMPTION 1 Decision Diffie–Hellman Problem There areseveral domain parameters that are primes p and q suchthat p ¼ 2q + 1 and a generator g 2 Zp with order q for thesubgroup Gq where Gq is a subgroup of quadratic residues inZp For a given ya ¼ gxa mod p and yb ¼ gxb mod p where xaand xb are randomly chosen from Zq the following two tuplesof random variables ðya‚ yb‚ gxaxb mod pÞ and (ya yb R)where Ris a random value in Zq are computationallyindistinguishable In other words there is no efficientalgorithm A that satisfiesjPr½Aðgxa ‚ gxb‚ gxaxbÞ ¼ true Pr½Aðgxa ‚ gxb‚ RÞ ¼ truej > 1QðjqjÞfor any polynomial Q where the probability is over therandom choice of xa xb and RIn the following theorem we use the contradiction prooftechnique to prove that the proposed protocol is secureagainst passive adversaries under the Decision Diffie–Hellman problem The concept is presented as followsAssume that there is an efficient algorithm A run by a passiveattacker that can distinguish the established group key of46 Y-M TsengThe Computer Journal Vol 50 No 1 2007 at Fraunhofer-Gesellschaft - FhG on January 29 2014http://comjnloxfordjournalsorg/Downloaded from the proposed protocol from a random value Then based onthe efficient algorithm A we can construct another efficientA0 to distinguish the key gxaxb based on Diffie–Hellman keyagreement scheme from the random value It will be acontradiction for Assumption 1THEOREM 2 Under Assumption 1 the proposed protocol issecure against passive adversariesProof A passive attacker tries to learn secret informationabout the group key by listening to the broadcast channel Thepassive attacker may obtain all (yi Zi) where yi ¼ gxi mod pand zi ¼ gxxi mod p for 1  i  n Here we show thatthe passive attacker cannot get any information about thegroup key K ¼ XQnj¼1 zj mod p ¼ gxQnj¼1 zj mod p fromall (yi Zi) Under Assumption 1 we shall prove that(yi‚ zi‚ K ¼ gxQnj¼1 Zj mod p and (yi zi R) for 1  i  nare computationally indistinguishable where R is a randomvalue in GqBy contradiction proof assume that there exists analgorithm A which can efficiently distinguish ðyi‚ zi‚ K ¼gxQnj¼1 zj mod pÞ and (yi zi R) for 1  i  n where R is arandom value in Gq Based on the algorithm A we show thatwe can construct another algorithm A0 that can efficientlydistinguish ðya‚ yb‚ gxaxb mod pÞ from (ya yb R) whereya ¼ gxa mod p yb ¼ gxb mod p and xa xb 2 Zq First thevalues ya yb and R are the input of algorithm A0 Without lossof generality let y1 ¼ ya and Z1 ¼ yb Then algorithm A0randomly selects t1 t2     tn1 from Zq and computes thefollowing values:y2 ¼ yt11 mod p‚ Z2 ¼ Zt11 mod py3 ¼ yt21 mod p‚ Z3 ¼ Zt21 mod pyn1 ¼ ytn21 mod p‚ Zn1 ¼ Ztn21 mod pyn ¼ ytn11 mod p‚ Zn ¼ Ztn11 mod p:Therefore the algorithm A0 has constructed (yi Zi for1  i  n and computes RQnj¼1 zj mod p then A0 calls Awith these values Since the algorithm A can compute thegroup key K ¼ RQnj¼1 zj mod p then the algorithm A0 canobtainR ¼ gxaxb  That is A0 can apply A to efficientlydistinguish ðya‚ yb‚ gxaxb mod pÞ and ðya‚ yb‚ RÞ which is acontradiction for Assumption 1 Thus the proposed protocolis secure against passive adversaries under the DecisionDiffie–Hellman problem assumption &42 Impersonator’s attacksHere we discuss the security of the proposed protocolregarding an attack by an impersonator Impersonator’sattacks are that impersonators who want to impersonate parti-cipants in a group key agreement protocol Mutual authen-tication ensures that the proposed protocol can withstandimpersonator’s attacks Here we show that the proposedprotocol provides mutual authentication between the power-ful node and mobile nodesIn the first we show that the powerful node can authenti-cate mobile nodes under the discrete logarithm assumption[3031] using the signatures di ¼ Sign(SKi yi) sent by mobilenodes Here we assume that the signature is generated usingthe Shamir–Tauman online/offline signature scheme [32] inwhich the security is based on the difficulty of computing thediscrete logarithm modulo a large primeLEMMA 1 If computing the discrete logarithm modulo a largeprime is hard any malicious attacker E cannot generate thevalid di ¼ Sign(SKi yi) of any low-power node UiProof Since the signature di ¼ Sign(SKi yi) is generatedusing the Shamir–Tauman online/offline signature schemethe proof can directly refer to that in [32] We omit the detailsof the proof They have proved the following fact: if amalicious attacker E without knowing secret key SKi canimpersonate Ui to generate valid di with a non-negligibleprobability « then the malicious attacker E can computethe discrete logarithm modulo a large prime efficiently Thusthe proposed protocol ensures that the powerful node canauthenticate other low-power nodes under the discretelogarithm assumption &Second in the following Lemma we prove that low-powernodes can authenticate the powerful node under the DecisionDiffie–Hellman problem assumptionLEMMA 2 Under Assumption 1 any malicious attacker Ecannot generate valid a0i ¼ ySKSi mod p to pass the verifica-tion of the corresponding low-power node UiProof We know that the low-power node Ui pre-computesthe value ai ¼ PKxiS mod p and keeps it in his storage wherePKS ¼ gSKS mod p and then ai ¼ gxiSKS mod p Since thebroadcast message is only yi ¼ gxi mod p the maliciousattacker E must compute ai0 ¼ gxiSKS mod p using two publicmessages PKS ¼ gSKS mod p and yi ¼ gxi mod p Obviouslythat is the malicious attacker E must efficiently distinguishðgSKS‚ gxi‚ gSKSxi mod pÞ from ðgSKS ‚ gxi‚ RÞ where R is arandom value in Gq It is easy to see that this problem is acontradiction to the Decision Diffie–Hellman problem ofAssumption 1 Thus the proposed protocol ensures that thelow-power node can authenticate the powerful node S underAssumption 1 &Based on the above Lemmas we demonstrate that theproposed protocol provides mutual authentication and issecure against impersonator’s attacksTHEOREM 3 Under the discrete logarithm assumption andAssumption 1 the proposed protocol is secure againstimpersonator’s attacksProof By Lemma 1 we know that only one legal low-power node Ui with the secret key SKi can generate valid diSince an impersonator does not know the legal low-powerA group key agreement protocol for resource-limited mobile devices 47The Computer Journal Vol 50 No 1 2007 at Fraunhofer-Gesellschaft - FhG on January 29 2014http://comjnloxfordjournalsorg/Downloaded from node’s secret key the impersonator cannot compute thevalid di This provides authentication to low-power nodes inthe proposed protocol By Lemma 2 it is obvious to see thatonly a legal powerful node with knowing the secret key SKScan compute ai0 ¼ gxiSKS mod p That is any attacker cannotimpersonate the powerful node to low-power nodes thus itprovides authentication to the powerful node in the proposedprotocol Therefore the proposed protocol is secure againstimpersonator’s attacks and provide mutual authenticationbetween the powerful node and low-power nodes &43 Implicit key authenticationHere we show that the proposed protocol provides implicitkey authentication under the difficulty of computing discretelogarithm modulo a large prime and Assumption 1 Withoutloss of generality let U ¼ {U1 U2    Un} be the set of low-power nodes The group key agreement protocol providesimplicit key authentication if each Ui 2 U is assured that noparty Uq =2 U can learn the group key (unless aided by adishonest Uj 2 U) [101214]THEOREM 4 Under the difficulty of computing discretelogarithm modulo a large prime and Assumption 1 theproposed protocol provides implicit key authenticationProof By Lemma 1 we have shown that any maliciousattacker cannot generate the valid di ¼ Sign(SKi yi) of anylow-power node Ui under the difficulty of computing discretelogarithm modulo a large prime Therefore only Ui 2 U cangenerate the valid di ¼ Sign(SKi yi) that is Ui really owns thetuple (xi x1i  ai yi di) Since Ui owns x1i  he/she cancompute X ¼ Zx1ii mod p and K ¼ XQnj¼1 zj mod p In addi-tion we show that no party Uq =2 U can learn the group key Infact it is clear that the attacker Uq is a passive adversary sinceUq =2 U By Theorem 2 we have proved that the proposedprotocol is secure against passive adversaries Thereforethe proposed protocol provides implicit key authentication&44 Forward secrecyA key agreement protocol offers forward secrecy if com-promise of a long-term key cannot result in the compromiseof previously established session keys As mentioned inStep 1 of the proposed protocol (xi x1i  ai yi di) is storedin the memory storage of the low-power node and eachtuple (xi x1i  ai yi di) is used only once In this case (xix1i  ai yi di) must be erased as soon as they are no longeruseful Obviously since the low-power nodes’ long-termkeys SKi are used only for authentication and they are notused for hiding the group key the leakage of any mobilenode’s long-term key does not reveal anything about thegroup key At the same reason the long-term key SKS of thepowerful node is used to generate the authenticationmessage ai and is not embedded into the group key Theleakage of the long-term key SKS does not reveal anythingabout the group key Thus the proposed protocol providesforward secrecyThe random oracle model [20] assumes that the one-wayhash function is actually a true random function and thatthe computing discrete logarithm modulo a large prime ishard We demonstrate that the proposed protocol providesforward secrecy under the random oracle model and theAssumption 1THEOREM 5 Under the random oracle model and Assump-tion 1 the proposed protocol provides forward secrecyProofWithout loss of generality let U ¼ {U1 U2    Un}be the set of low-power nodes that have established a groupkey K with the powerful node S at some past time t Afterfinishing the group session the used tuple (xi x1i  ai yi di)of each low-power node and the used (x X) have beenerased Suppose that an adversary obtains all secret keys SKiof low-power nodes as well as the secret key SKS of thepowerful node at time t + 1 Therefore the adversary obtainonly C and ðdi‚ yi‚ zi‚ ai0Þ for i ¼ 12     n Obviously di isa signature for yi under the low-power nodes’ long-term keysSKi and it is used only for authentication and they are notused for hiding the group key The leakage of any mobilenode’s SKi does not reveal anything about the group key Onthe other hand if the adversary can get gx or X then he/shecan compute the group key K Here we show that theadversary cannot get any information about the group keyK ¼ XQnj¼1 zj mod p ¼ gxQnj¼1 zj mod p In the followingwe will discuss three cases to show that the adversary cannotobtain X gx or KCASE 1 If the adversary tries to obtain X from C ¼ H(X z1    zn) the probability is negligible under the randomoracle model [20] In the random oracle model the hashfunction is a true random function and the adversary mayquery a random oracle Q After qH queries the probability isqH/2k where k is the output-length of the hash functionTherefore the successful probability of obtaining X fromC ¼ H(X  z1    zn) is negligibleCASE 2 If the adversary gets xi of any low-power node Uihe/she can compute X from zi The adversary has two possibleways to get xi but we show that the difficulty of getting xi isbased on the computing discrete logarithm modulo a largeprime The adversary may try to obtain xi from yi directly orfrom ai0 with known SKS If the adversary tries to obtain xifrom ai0 with known SKS it is clear that only yi can becomputed Obviously to obtain xi from yi directly is equal tothe difficulty of computing the discrete logarithm modulo alarge primeCASE 3 Finally the adversary tries to derive the groupkey from (yi Zi) for i ¼ 12     n This case is the same as the48 Y-M TsengThe Computer Journal Vol 50 No 1 2007 at Fraunhofer-Gesellschaft - FhG on January 29 2014http://comjnloxfordjournalsorg/Downloaded from attack of passive adversaries By Theorem 2 we have shownthat the proposed protocol is secure against passiveadversaries under Assumption 1 Therefore the adversarywill fail to obtain the group key K from (yi Zi) fori ¼ 12     nAccording to the above discussions of three cases eventhough secret keys SKi of low-power nodes as well as thesecret key SKS of the powerful node are compromised theydo not reveal anything about the group key Thus theproposed protocol provides forward secrecy &5 DISCUSSIONS AND COMPARISONSIn the following we analyze the computational complexityand the communication cost of the proposed protocol Forconvenience the following notations are used to analyze thecomputational complexity and the communication cost TSIGis the time for computing one signature; TVER is the timefor verifying one signature; TEXP is the time for modularexponentiation; TINV is the time for modular inverse; TH isthe time for computing one hash function; TMUL is the timefor modular multiplication; jmj denotes the bit-length of amessage mConsidering the computational cost of the powerful nodethe powerful node is regarded as a wireless gateway with lesscomputational restriction In Step 2 of the proposed protocolthe powerful node checks the signature di by Verify(PKiyi di) i ¼ 12     n If verifications are correct the powerfulnode S randomly selects a value x in Zq and then computesX ¼ gxmod p and computes the values ðai0‚ ziÞ for i ¼12     n Finally the powerful node S computes a check-ing value C ¼ H(X  z1    zn) and a group key K ¼XQnj¼1 zj mod p Thus nTVER + (2n + 1)TEXP + nTMUL + THis required for the powerful nodeIn the following let us discuss the computational cost oflow-power nodes in the proposed protocol In Step 1 eachlow-power node Ui uses the offline pre-computing techniqueto compute yi ¼ gxi mod p‚ ai ¼ PKxiS mod p and a signaturedi ¼ Sign(SKi yi Certainly some tuples ðxi‚ x1i ‚ ai‚ yi‚ diÞshould be stored in the memory storage of the low-powernode in advance When the low-power node Ui wouldlike to participate a group session he gets one tupleðxi‚ x1i ‚ ai‚ yi‚ diÞ from his storage card and sends (yi di tothe powerful node S The offline computational cost forthis step is TSIG + 2TEXP + TINV According to the Shamir–Tauman online/offline signature scheme [32] the onlinecomputational complexity is equivalent to about only onemodular multiplication TMUL In Step 3 upon receivingðai0‚ ziÞ i ¼ 12     n then the low-power node gets ai fromthe used ðxi‚ x1i ‚ ai‚ yi‚ diÞ in Step 1 to check whether ai ¼ai0 holds or not Afterward each low-power node Ui computesX ¼ Zx1ii  And then Ui checks whether C ¼ H(X  Z1    Znand computes the group key K ¼ XQnj¼1 zj mod p This steprequires TEXP + TH + nTMUL Therefore online computationalcost for each low-power node is TEXP + TH + (n + 1) TMULIn the proposed protocol each low-power node Ui sends(yi di to the powerful node S via uni-cast communication andthe powerful node S broadcasts C and ðai0‚ ziÞ i ¼ 12     nto low-power nodes Thus the message sizes sent by eachlow-power node and the powerful node are 3jpj and jHj+2njpj where jHj is k bit-length of the adopted hash functionNote that since the powerful node broadcasts messages toall low-power nodes the broadcast communications couldadopt multiple uni-casts or multicasts to achieve this functionIn this case the communication cost of the multiple uni-castsis large than one of one broadcast Therefore commun-ication cost required by the proposed protocol is large thanone required by Bresson et al’s protocol Nevertheless theimportant point is that the proposed protocol provides moresecurity properties than Bresson et al’s protocolTable 1 lists the comparisons between Bresson et al’sauthenticated protocol [22] and the proposed one Weconsider the comparisons in terms of forward secrecycontributory property the number of rounds the onlinecomputational complexity required for each low-power nodeand computational complexity of the powerful node as wellas communication costs of each low-power node and thepowerful node If mutual authentication among all low-power nodes is provided some extra online computationalcosts are required for each low-power node In this case thecomputational cost is too expensive for low-power nodesOne alternative is that each low-power node does notauthenticate other low-power nodes Both protocols provideonly mutual authentication between the powerful node andlow-power nodes and do not consider mutual authenticationamong all mobile nodes Certainly when the proposedprotocol is employed into cellular mobile networks orwireless local area networks another alternative approach isthat the low-power nodes may use the authenticationprocedures [343536] provided by these attached networksto authenticate with the powerful node each other in advanceThe online computational complexity required by eachlow-power node in the proposed protocol is larger than that inBresson et al’s protocol Nevertheless advanced smart-cardarchitecture has been studied and shown the capability forthe exponentiation and the multiplication computations [37]We present the computational time by a simulated environ-ment to provide the evidence that the proposed protocol iswell suitable for the low-power nodeIn the following a simulation result for the computationaltime on the low-power node (PDA) is presented The simu-lation environment is that the low-power node is ASUSMyPal A620 Pocket PC PDA [38] with Pocket PC 2003(Windows Mobile 2003) [39] to execute simulation programsThe ASUS A620 features a 400 MHz PXA 255 Intel XScaleprocessor and 32 MB of Flash ROM and 64 MB of RAMThe modular multiplication and the modular exponentiationA group key agreement protocol for resource-limited mobile devices 49The Computer Journal Vol 50 No 1 2007 at Fraunhofer-Gesellschaft - FhG on January 29 2014http://comjnloxfordjournalsorg/Downloaded from are developed by the Ewesoft Software Development Kit(EWE SDK) [40]All contributions are selected from the Diffie–Hellmanproblem with a 1024-bit prime modulus p The computationaltime of a modular multiplication is measured by computinga · bmod p where jaj¼jbj¼jp¼ 1024 The computationaltime of a modular exponentiation is measured by computing1024-bit modular exponentiation with 256-bit exponent Theaverage computational costs of the modular multiplicationand the modular exponentiation are calculated for 1000and 100 runs respectively The hashing function utilizesSHA-1 [29] The simulation results for two kinds of modularoperations and hash operation are depicted in Table 2 Eventhough the number of group members is 100 the compu-tational cost required by each low-power node for computingTEXP + 2TH + (n + 1)TMUL is only about 2 s It is obvious thatthe required computational complexity required by the low-power node is reasonable We suspect that an implementationwith elliptic curve groups [4142] would yield better resultsCONCLUSIONSIn this paper a secure authenticated group key agreementprotocol well suited for mobile devices with low-powercomputing capability has been proposed We show that theproposed protocol is a real contributory group key agreementone thus each low-power node equally contributes to thegroup key and guarantees the group key’s freshness in eachgroup key construction We demonstrate that the proposedprotocol is provably secure against passive adversaries underthe decision Diffie–Hellman assumption We also show thatthe proposed protocol is provably secure against impersona-tor’s attacks under the decision Diffie–Hellman and thediscrete logarithm assumptions and provides mutual authen-tication between low-power nodes and the powerful nodeMeanwhile a simulation result on a PDA device shows thatthe proposed protocol is well suited for mobile devices withlow-power computing capability The proposed protocol isefficient in terms of the computational cost of each low-power node and the number of rounds Furthermore inmobile/wireless networks a low-power node often movesfrom cover-area of one powerful node to one of anotherpowerful node As considering this situation into the designof group key agreement protocols handover (or handoff)problem should be addressed Therefore how to achieve fastand seamless handover is an important issue in the futureACKNOWLEDGEMENTSThe author would like to thank the referees for their valuablecomments and constructive suggestions This research waspartially supported by National Science Council TaiwanROC under contract no NSC94-2213-E-018-009REFERENCES[1] ETSI TS-123-060 (2002) General Packet Radio Services(GPRS) Service Description (Stage 2)  European Telecom-munications Standards Institute ETSI TS-123-060 SophiaAntipolis Cedex FranceTABLE 1 Comparisons between two authenticated group key agreement protocolsBresson et al’s protocol [22] Proposed protocolForward secrecy No FullContributory group key agreement No YesImplicit key authentication No YesNumber of rounds 2 2Computational complexity required by eachlow-power node (online)TH+TMUL TEXP + TH + (n + 1)TMULComputational complexity required by the powerful node nTVER + nTEXP + (n + 1)TH nTVER + (2n + 1)TEXP + nTMUL + THMessage size sent by each low-power node 3|p| 3|p|Message size sent by the powerful node |c| + n|H| |H| + 2n |p|Mutual authentication between the powerful nodeand low-power nodesPartiala YesExtra computational complexity required by eachlow-power node (online)TH 0Extra computational complexity required by the powerful node nTH 0aBresson et al’s protocol needs extra computation costs to provide that each low-power node authenticate to the powerful nodeTABLE 2 Time measurements of low-level cryptographicoperationsModularmultiplicationHashfunctionModularexponentiationAverage time (ms) 12 3 78050 Y-M TsengThe Computer Journal Vol 50 No 1 2007 at Fraunhofer-Gesellschaft - FhG on January 29 2014http://comjnloxfordjournalsorg/Downloaded from [2] ANSI/IEEE Std 80211 (1999) Wireless LAN media accesscontrol (MAC) and physical layer (PHY) specificationsANSI/IEEE Std 80211 (E) Part 11 ISO/IEC 8802-11 IEEEStandards Association Piscataway USA[3] Yang H Luo H Ye F Lu S and Zhang L (2004) Securityin mobile ad hoc networks: challenges and solutions IEEEWireless Commun 11 38–47[4] Campadello S (2004) Peer-to-Peer Security in MobileDevices: A User Perspective In Proc Fourth Int ConfPeer-to-Peer Computing (P2P’04) Zurich SwitzerlandAugust 15–17 pp 252–257 IEEE Press NJ[5] Phan T Huang L and Dulan C (2002) Challenge:integrating mobile wireless devices into the computationalgrid MobiCom’02 Atlanta Georgia USA September 23–28pp 271–278[6] Ingemaresson I Tang T D and Wong C K (1982)A conference key distribution system IEEE Trans InfomTheory 28 714–720[7] Hwang M S and Yang W P (1995) Conference keydistribution schemes for secure digital mobile communicationsIEEE J Sel Areas Comm 13 416–420[8] Tseng Y M (2002) Cryptanalysis and improvement of keydistribution system for VS AT satellite communicationInt J Informatica 13 369–376[9] Tseng Y M and Jan J K (1999) Anonymous conference keydistribution systems based on the discrete logarithm problemComput Commun 22 749–754[10] Steiner M Tsudik G and Waidner M (1998) CLIQUES:A new approach to group key agreement In Proc 18th IntConf Distributed Computing Syst (ICDCS’98) AmsterdamThe Netherlands May 26–29 pp 380–387 IEEE Press NJ[11] Burmester M and Desmedt Y (1994) A secure and efficientconference key distribution system In Advances inCryptology—Proceedings of Eurocrypt’94 Perugia ItalyMay 9–12 LNCS 950 pp 275–286 Springer-Verlag Berlin[12] Ateniese G Steiner M and Tsudik G (2000) New multi-party authentication services and key agreement protocolsIEEE J Sel Areas Comm 18 628–639[13] Bresson E Chevassut O Pointcheval D and Quisquater JJ (2001) Provably Authenticated Group Diffie-Hellman KeyExchange In Proc 8th Annual ACM Conf Computer andCommunications Security Philadelphia Pennsylvania USANovember 5–8 pp 255–264 ACM Press New York[14] Bresson E Chevassut O and Pointcheval D (2002)Dynamic Group Diffie-Hellman Key Exchange under StandardAssumptions In Proc Eurocrypt 2002 Amsterdam TheNetherlands April 28–May 2 LNCS 2332 pp 321–336Springer-Verlag Berlin[15] Katz J and Yung M (2003) Scalable Protocols forAuthenticated Group Key Exchange Advances inCryptology—Proceedings of Crypto’03 Santa Barbara CAAugust 17–21 pp 110–125 LNCS 2729[16] Tseng Y M (2005) A robust multi-party key agreementprotocol resistant to malicious participants Comput J 48480–487[17] Pereira O and Quisquater J J (2001) A security analysis ofthe cliques protocol suites In Proc 14th IEEE ComputerSecurity Foundations Workshop Cape Breton Nova ScotiaCanada June 11–13 pp 73–81 IEEE Press NJ[18] Asokan N and Ginzboorg P (2000) Key agreement in ad hocnetworks Comput Commun 23 1627–1637[19] Boyd C and Nieto G (2003) Round-optimal contributoryconference key agreement In Proc Public-Key Crypto-graphy’03 Miami USA January 6–8 LNCS 2567pp 161–174 Springer-Verlag Berlin[20] Bellare M and Rogaway P (1993) Random oracles arepractical: a paradigm for designing efficient protocols In Proc1st Annual ACM Conference on Computer and Communi-cations Security (ACM CCS’93) Fairfax Virginia November3–5 pp 62–73 ACM Press New York[21] Tseng Y M (2002) Robust generalized MQV key agreementprotocol without using one-way hash functions Comput StandInterface 24 241–246[22] Bresson E Chevassut O Essiari A and Pointcheval D(2004) Multual authentication and group key agreement forlow-power mobile devices Comput Commun 27 1730–1737[23] Nam J Kim S and Won D (2005) A weakness in theBresson-Chevassut-Essiari-Pointcheval’s group key agreementscheme for low-power mobile devices IEEE Commun Lett 9429–431[24] Nam J Kim S and Won D (2005) DDH-based group keyagreement in a mobile environment J Syst Software 7873–83[25] Tseng Y M (2006) On the security of two group keyagreement protocols for mobile devices In Int Workshop onFuture Mobile and Ubiquitous Information Technologies(FMUIT2006) Nara Japan May 9–12 pp 59–62 IEEEPress NJ[26] Diffie W and Hellman M E (1976) New directions incryptography IEEE Trans Infom Theory 22 644–654[27] Boneh D (1998) The decision Diffie-Hellman problem In Proc3rd Algorithmic Number Theorey Symp Portland Oregon June21–25 LNCS 1423 pp 48–63 Springer-Verlag Berlin[28] Shoup V (1997) Lower bounds for discrete logarithmsand related problems In Advances in Cryptology—ProcEurocrypt’97 Konstanz Germany May 11–15 LNCS 1233pp 256–266 Springer-Verlag Berlin[29] NIST/NSA FIPS 180-2 (2005) Secure Hash Standard (SHS)NIST/NSA Gaithersburg MD USA[30] ELGamal T (1985) A public-key cryptosystem and asignature scheme based on discrete logarithms IEEE TransInform Theory 31 469–472[31] NIST (1992) The Digital Signature Standard (DSA) CommunACM 35 36–40[32] Shamir A and Tauman Y (2001) Improved on-line/off-linesignature schemes In Proc Advances in Cryptology—Crypto’01 Santa Barbara CA August 19–23 LNCS 2139pp 355–367 Springer-Verlag Berlin[33] Rankl W Effing W and Wolfgang R (2000) Smart CardHandbook (2nd edition) John Wiley & Sons UK[34] 3GPP TS 33102 (2003) 3GPP Technical Specification GroupServices and System Aspects; 3G Security; Security archi-tecture (Release 6) 3GPP Technical Specification GroupValbonne FranceA group key agreement protocol for resource-limited mobile devices 51The Computer Journal Vol 50 No 1 2007 at Fraunhofer-Gesellschaft - FhG on January 29 2014http://comjnloxfordjournalsorg/Downloaded from [35] Arkko J and Haverinen H (2003) EAP AKA Authenticationdraft-arkko-pppext-eap-aka-11 The Internet Engineering TaskForce (IETF) VA USA[36] Tseng Y M Yang C C and Su J H (2004) Authenticationand Billing Protocols for the Integration of WLAN and 3GNetworks Wireless Pers Commun 29 351–366[37] Gupta V and Gupta S (2002) Experiments in wirelessinternet security In Proc IEEE Wireless Communications andNetworking Conf (WCNC) Orlando Florida March 17–21pp 859–863 IEEE Press NJ[38] ASUS (2003) MyPal A620 PDA Available at: http://wwwmobiletechreviewcom/asus_mypal_A620htm[39] Microsoft (2003) Pocket PC 2003  Available at: http://wwwmicrosoftcom/windowsmobile/defaultmspx[40] Ewesoft (2005) Software Development Kit (SDK) Availableat: http://wwwewesoftcom/[41] Gupta V Stebila D and Fung S (2004) Speeding up secureweb transactions using elliptic curve cryptography In Proc11th Network and Distributed Systems Security SympCalifornia February 5–6 pp 231–239 Internet Soceity(ISOC) VA USA[42] Vanstone S A (2003) Next generation security forwireless: elliptic curve cryptography Comput Secur 22412–41552 Y-M TsengThe Computer Journal Vol 50 No 1 2007 at Fraunhofer-Gesellschaft - FhG on January 29 2014http://comjnloxfordjournalsorg/Downloaded from 
Secure Group Comm-SelfHealing-WSN-pdf,Secure Group Communication with Self-healingand Rekeying in Wireless Sensor NetworksFirdous Kausar1 Sajid Hussain2 Jong Hyuk Park3 and Ashraf Masood11 College of Signals National University of Science and Technology (NUST)Rawalpindi Pakistanfirdousimam@gmailcom ashrafm61@gmailcom2 Jodrey School of Computer Science Acadia University Nova Scotia Canadasajidhussain@acadiauca3 Department of Computer Engineering Kyungnam University Masan Koreaparkjonghyuk@gmailcomAbstract We have developed a self-healing key distribution schemefor secure multicast group communications for wireless sensor networkenvironment We present a strategy for securely distributing rekeyingmessages and specify techniques for joining and leaving a group Accesscontrol in multicast system is usually achieved by encrypting the contentusing an encryption key known as the group key (session key) that isonly known by the group controller and all legitimate group membersIn our scheme all rekeying messages except for unicast of an individualkey are transmitted without any encryption using one-way hash func-tion and XOR operation In our proposed scheme nodes are capable ofrecovering lost session keys on their own without requesting additionaltransmission from the group controller The proposed scheme providesboth backward and forward secrecy We analyze the proposed schemeto verify that it satisfies the security and performance requirements forsecure group communicationKeywords: sensor networks security key distribution secure groupcommunication one-way hash chains1 IntroductionWireless sensor network (WSN) consists of a large number of small low costsensor nodes which have limited computing and energy resources Usually sensornodes perform in-network processing by reducing large streams of raw data intouseful aggregated information Therefore compromised nodes could deviate thenetwork behavior by injecting false data or modifying data of correct nodesThus it must be guaranteed that compromised nodes do not take part in thegroup communicationSecure group communication needs a secret shared by all the group membersfor group oriented applications in wireless sensor networks (WSNs) The sharedkey provides group secrecy and source authentication A single symmetric keyknown only to the group members can effectively protect a multicast groupH Zhang et al (Eds): MSN 2007 LNCS 4864 pp 737–748 2007c© Springer-Verlag Berlin Heidelberg 2007738 F Kausar et alHowever only legitimate users should have access to the group communicationin order to achieve privacy [1] In rekeying the session keys are updated period-ically when new users join or old users leave the group The keys are securelyredistributed to the existing members of the group in order to provide forwardsecrecy (FS) as well as backward secrecy (BS) The newly joined users shouldnot be able to derive the previous group keys even if they are able to derivefuture group keys with subsequently distributed keying information Similarlythe revoked users should not be able to derive the future session keys even ifthey are able to compute the previous session keys with previously distributedkeying informationThe rekeying is performed by the group controller (GC) The most importantparameters when performing group rekeying are as follows: the number of keysstored by the group controller the number of keys stored by each group memberthe number of keys delivered in the initialization stage bandwidth required forupdating the keys and latency for updating the session key [2]As the size of the group grows and/or the rate of membership change in-creases the frequency of rekeying becomes the primary bottleneck for rekeyingon each membership change Therefore scalable group rekeying is an importantand challenging problem to be addressed in order to support secure multicastcommunicationAnother important problem in multicast communication is reliability Sincemulticasting is an unreliable mode of communication packets may be lost duringthe communication If a packet containing key updating information is lostauthorized receivers may not be able to calculate the session key This mayinfluence rekeying and so the rekeying system must be self-healing if packetloss occurs In a large and dynamic group communication over an unreliablenetwork the main concept of self-healing in key distribution schemes is thatusers can recover lost session keys on their own without requesting additionaltransmissions from the group manager even if some previous key distributionmessages are lost This reduces network traffic the risk of user exposure throughtraffic analysis and the work load on the group managerThe key idea of self-healing key distribution schemes is to broadcast informa-tion that is useful only for trusted members Combined with its pre-distributedsecrets this broadcast information enables a trusted member to reconstruct ashared key On the contrary a revoked member is unable to infer useful infor-mation from the broadcast The only requirement that a user must satisfy torecover the lost keys through self-healing is its membership in the group bothbefore and after the sessions in which the broadcast packet containing the keyis sent A user who has been off-line for some period is able to recover the lostsession keys immediately after coming back on-line Thus self-healing approachof key distribution is statelessThe need to form a group might be driven by the query being propagatedthrough a node As a result a node may need to define a multicast group tomake the query initiated in those nodes and then collect the result efficientlySecure Group Communication with Self-healing and Rekeying in WSNs 739and securely Further a node may also modify such queries effectively over thetime For instance a multicast group could be a region defined with a geometricshapeThis paper provides a computationally secure and efficient group key dis-tribution scheme with self-healing property and time-limited node revocationcapability for large and dynamic groups over insecure WSNs The session keysare updated periodically where the update is performed regardless of changesin network (group) topology Periodic rekeying can significantly reduce both thecomputation and communication overhead at the GC and the nodes and thusimprove the scalability and performance of key distribution protocols It is shownthat the proposed scheme can tolerate high channel loss rate and hence makea good balance between performance and security which is suitable for WSNapplicationsThe paper is organized as follows In Section 2 related research is describedIn Section 3 we describe the preliminaries assumed throughout the paper Wedescribe the security properties in Section 4 and give details of our proposedscheme in Section 5 In Section 6 we present an analysis of proposed schemeFinally we summarize our paper in Section 72 Related WorkRecently there have been several proposals to address the secure group commu-nication issues The most known technique is the construction of a logical keytree where group members are associated with leaves and each member is givenall the keys from his leaves to the root as proposed in [3] [4] [5] [6] where rootkey is the group key This approach allows reducing the communication cost forkey update on the event of group membership change to O(logM) where M isthe number of group membersSeveral extensions are proposed to deal with reliability [7] node dependentgroup dynamics [8] and time variant group dynamics [9] Extensions to wire-less networks are discussed in [10] and several secure multicast protocols areproposed in [11] [12]Park et al [13] propose a lightweight security protocol(LiSP) for efficientrekeying in dynamic groups LiSP utilizes broadcast transmission to distributethe group keys and uses one-way key chains to recover from lost keys While thisscheme is very efficient LiSP requires the use of static administration keys toperform periodic administrative functions This leaves those keys vulnerable todisclosureWong et al [14] propose the the group re-keying which relies only on currentrekeying message and the node’s initial configuration A non-revoked node candecrypt the new session keys independently from the previous re-keying messageswithout contacting the GC even if the node is off-line for a while They usekeys of multiple granularity to reduce the rekeying overhead associated withmembership management740 F Kausar et alCarman et al [15] give a comprehensive analysis of various group key schemesand find that the group size is the primary factor that should be considered whenchoosing a scheme for generating and distributing group keys in a WSNStaddon et al [16] propose a self-healing group key distribution scheme basedon two-dimension t-degree polynomials Liu et al [17] further improve the workin [16] by reducing the broadcast message size in situations where there arefrequent but short-term disruptions of communication as well as long-term butinfrequent disruptions of communication Blundo et al [18] also present a designof self-healing key distribution schemes which enables a user to recover from asingle broadcast message where all keys are associated with sessions where it isa member of the communication groupJiang et al [19] propose a key distribution scheme with time-limited noderevocation based on dual directional hash chains for WSNs Dutta et al [20]propose two constructions for self-healing key distribution based on one-way hashkey chains with t revocation capability using polynomial based node revocation3 PreliminariesDefinition 1 A one-way hash function H can map an input M of the arbitrarylength to an output of the fixed length which is called hash value h : h = H(M)where the length of M is m-bits One-way hash function H has the followingproperties [21]:– Given a hash value h it is computationally infeasible to find the input Msuch that H(M) = h– Given an input M  it is computationally infeasible to find a second input M´such that H(M´) = h where M´ = MDefinition 2 Let H be a one-way hash function and s be a random seed Thena hash chain can be deduced by iteratively hashing s which can be written as:Hi(s) = H(H(i−1)(s)) i = 1 2    where s is regarded as “trust anchor” of theone-way hash chain The hash chain includes a sequence of hash values whichcan be denoted by h1 = H(s) h2 = H(h1)     hi = H(hi−1) i = (1 2   )Definition 3 Let G(x y) = H(x)⊕y where H is a one-way hash function and⊕ denotes the bitwise XOR Given x and G(x y) without the knowledge of yit is computationally infeasible to find y´ such that G(x y´) = G(x y)Node Revocation The concept of node revocation can be described as followsLet G be the set of all possible group nodes and R be the set of revoked nodeswhere R ⊆ G The group node revocation is required to offer a secure way forGC to transmit rekeying messages over a broadcast channel shared by all nodesso that any node ni ∈ {G− R} can decrypt the rekeying messages whereas anynode in R ni ∈ R cannot decrypt rekeying messagesSecure Group Communication with Self-healing and Rekeying in WSNs 741Session Key Distribution with Confidentiality The confidentiality in thesession key distribution requires that for any node ni the session key is effi-ciently determined from the personal secret of ni and the broadcasted rekeyingmessage from GC However for any node in R it is computationally infeasibleto determine the session key What any node ni learns from broadcast rekeyingmessage it cannot be determined from broadcasts or personal keys alone Leta group of k nodes is defined as n1 n2     nk If we consider separately eitherthe set of m broadcasts {B1     Bm} or the set of k personal keys {S1     Sk}it is computationally infeasible to compute session key SKj (or other usefulinformation) from either setLet m denote the total number of sessions in the life cycle of the group commu-nication Each node is assigned a pre-arranged life cycle (t1 t2) which dependson the time of joining In other words it can be said that each node will par-ticipate in the group communication for k = t2 − t1 number of sessions Due towhich once a node’s life cycle is expired it is automatically detached from thegroup session without requiring the direct intervention of the GCFor a group with life cycle (0m) the group key for session j is as follows:SKj = KFj + KBm−j+1 (1)where KFj is the forward key and KBm−j+1 is the backward key for session j4 Security PropertiesA rekeying scheme should provide the following types of securityDefinition 4 A rekeying protocol provides forward secrecy if for any set R ⊆ Gwhere all nl ∈ R are revoked before session j it is computationally infeasible forthe members in R to get any information about SKi for all i ≥ j even with theknowledge of session keys {SK1     SKj−1} before session jDefinition 5 A rekeying protocol provides backward secrecy if for any set J ⊆G where all nl ∈ J are newly joined nodes after session j it is computationallyinfeasible for the members in J to get any information about SKi for all i ≤ jeven with the knowledge of group keys {SKj+1     SKm} after session jDefinition 6 A rekeying protocol is key-independent if it is both forward-secretand backward-secret5 Our Proposed SchemeIn this section we provide the details of our proposed scheme of self-healingkey distribution with time limited node revocation capability First nodes aredivided into groups where each group is managed by the group controller (GC)However the groups are dynamic and regrouping is done after specific durationThe details of group formation is not discussed in this paper The group life742 F Kausar et alcycle is given by m which determines the total number of sessions for a groupThe GC uses the pseudorandom number generator (PRNG) of a large enoughperiod to produce a sequence of m random numbers (r1 r2     rm) The GCrandomly picks two initial key seeds the forward key seed SF and the backwardkey seed SB In the pre-processing time it computes two hash chains of equallength m by repeatedly applying the same one-way hash function on each seedFor KF0 = SF and KB0 = SB the hash sequences are generated as follows:{KF0  H(KF0 )     Hi(KF0 )     Hm−1(KF0 ) Hm(KF0 )}{KB0  H(KB0 )     Hi(KB0 )     Hm−1(KB0 ) Hm(KB0 )}During the initial configuration setup each node ni is first assigned a prear-ranged life cyle (t1 t2) where t1 ≥ 1 and t2 ≤ m ni will participate in the groupcommunication k = t2 − t1 + 1 number of sessions The node ni joins the groupat time t1 in session p and will have to leave the group at time t2 in session qwhere q > pThe node ni receives its personal secret from GC consisting of: 1) a forwardkey in session p ie KFp  and 2) k number of random numbers correspondingto the sessions in which node ni will participate in the group communicationFurther GC securely sends the personal secret to ni using key encryption keyKEKi shared between ni and GC as shown below:GC → ni : EKEKi(KFp  (rp rp+1     rq))MAC(KFp ‖(rp rp+1     rq))The node ni decrypts the message by its corresponding KEKi to retrieveits secret In the j-th session the GC locates the backward key KBm−j+1 in thebackward key chain and computes the broadcast messageBj = G(KBm−j  rj) (2)When the nodes receive the broadcast message Bj  the session key is generatedas follows:– First when any node ni in the group receives the broadcast message itrecovers the backward key KBm−j+1 for session j from Bj  by applying XORon both Bj and rj  as given below:KBm−j+1 = Bj ⊕ rj (3)From Equation 2 and Equation 3:KBm−j+1 = G(KBm−j  rj) ⊕ rj (4)By substituting the value of G ie G(x y) = H(x)⊕y backward key is givenas follows:KBm−j+1 = H(KBm−j) ⊕ rj ⊕ rj (5)The backward key is obtained:KBm−j+1 = H(KBm−j) (6)Secure Group Communication with Self-healing and Rekeying in WSNs 743– Second the node ni computes the j − th forward key by applying one-wayhash function on its forward key KFp as follows:KFj = Hj−p(KFp ) (7)– Finally the node ni computes the current session key SKj as follows:SKj = KFj + KBm−j+1 (8)51 Adding a Group MemberWhen a node ni wants to join an active group the corresponding actions (steps)are described as follows:– The node ni obtains the permission to attach to the group communicationfrom the GC If it is successful ni establishes a common secret key KEKishared with the GC– GC assigns a life cycle to ni ie t1 t2– Then the GC sends the current system configuration to ni using an Init-GroupKey message as shown below:GC → ni : EKEKi(KFp  (rp rp+1     rq))MAC(KFp ‖(rp rp+1     rq))where KFp and (rp rp+1     rq) are shared personal secret for ni with lifecycle (t1 t2)– Upon receiving the broadcast message from GC ni computes the currentsession key and participates in the network communication52 Node RevocationA node with a life cycle (t1 t2) detaches from the group at time t2 Figure 1 showsa time line to illustrate node life cycle and revocation The node participatesonly between t1 and t2 where the interval is divided into a l number of sessionsFurther as each node is assigned with a l = t2 − t1 + 1 number of randomnumbers it cannot derive the session keys SKt = KFt + KBm−t+1 for t < t1 andt > t2 These l random numbers correspond to the sessions in which the nodeparticipate in the group So these random numbers can be used for specifiedsessions only and cannot be used for the remaining sessions In order to recoverKBm−t+1 at time t from the Bt it requires rt which is not available Thus a timelimited node revocation is achieved implicitly without any intervention from theGC As a result the communication and the computation overhead on the GCand group nodes are remarkably reducedCompromised Node If a compromised node is detected all nodes are forcedto be re-initialized Let ni with life cycle (t1 t2) is compromised in session kwhere t1 < k < t2 as shown in Figure 1 The GC re-initializes the group com-munication system by re-computing a new random number sequence of lengtht2 − k + 1 and then unicast it to all group nodes securely744 F Kausar et alt > tt < t 1k2re−initializationt21tFig 1 Node Revocation6 AnalysisIn this section we show that the proposed scheme realizes self-healing key dis-tribution scheme with time limited revocation capability Further the forwardand backward secrecy is assured with the time-limited node revocationWe consider a group of sensor nodes as G G = {n1 n2     nN} R representsa set of revoked nodes R ⊆ G J represents a set of newly joining nodes J ⊆ Gand m is the total number of sessions in the group life cycle61 Self-healing PropertyConsider a node nk ∈ G with life cycle (t1 t2) which means that nk joinsthe group at t1 (session p) and leaves the group at time t2 (session q) where1 ≤ p ≤ q as shown in Figure 2Suppose node nk goes offline in session p+1 and comes online again in sessionp + j where (p + j) < q as shown in Figure 2 As a result the node nk willmiss the broadcast messages Bp+1 · · ·Bp+j−1 from GC; hence the session keysSKp+1 · · ·SKp+j−1 will not be available When node nk comes online in sessionp+j it receives the broadcast message Bp+j from GC and recovers the backwardkey KBm−(p+j)+1 for session p + j So it can obtain the sequence of backwardkeys {KBm−(p+j−1)+1   KBm−(p+1)+1} by repeatedly applying H on KBm−(p+j)+1The node nk also holds the forward key KFp = Hp(KF0 ) of the session p andhence can obtain the sequence of forward keys {KFp+1    KFp+j} by repeatedlyapplying H on KFp  Now nk can find all the session keys from session p + 1 tosession p + j without requiring any extra information from GC62 Key IndependenceThe proposed scheme also meets the security requirement for forward and back-ward secrecy which gives key independence Informally forward-secrecy meansthat the compromise of one or more secret keys does not compromise previoussecret keys Likewise backward-secrecy refers to that the compromise of oneor more secret keys does not compromise future secret keys Key-independencemeans that the secret keys used in different sessions are basically independentThus even if the attacker finds out the secret key of a certain session it doesnot give any advantage in finding the secret keys of other sessionsSecure Group Communication with Self-healing and Rekeying in WSNs 745Session # Forward key Backward Key1 H(KF0 ) Hm(KB0 )2 H2(KF0 ) Hm−1(KB0 )p Hp(KF0 ) Hm−(p)+1(KB0 ) ←− t1p + 1 Hp+1(KF0 ) Hm−(p+1)+1(KB0 ) offlinep + j − 1 Hp+j−1(KF0 ) Hm−(p+j−1)+1(KB0 )p + j Hp+j(KF0 ) Hm−(p+j)+1(KB0 ) onlineq Hq(KF0 ) Hm−(q)+1(KB0 ) ←− t2m − 1 Hm−1(KF0 ) H2(KB0 )m Hm(KF0 ) H(KB0 )Fig 2 Self-healing in node life cycleForward Secrecy It is shown that a single revoked node or a collusion of re-voked nodes cannot learn anything about the future group keys since the secretsthey knew while they were authorized member of the group will no longer beused in any future rekeying messageLet R be the set of revoked nodes and all nodes nk ∈ R are revoked beforethe current session j The node nk cannot get any information about the currentsession key SKj even with the knowledge of {SKi SKi+1     SKj−1} beforesession j where i is the earliest session of all the nodes in R or in other wordsi is the minimum for all t1’s of nodes in R In order to find SKj node nk needsthe random number rj of that session and that rj will not be available to nkAlso because of the one-way property of H  it is computationally infeasible tocompute KBj1 from KBj2for j1 < j2 The nodes in R may know the sequenceof backward keys KBm    KBm−j+2; however they cannot compute KBm−j+1 inorder to find current session key SKjBackward Secrecy Let J is the set of nodes that join the group in sessionj The collusion of newly joining nodes cannot get any information about anyprevious session keys before session j even with the knowledge of group keys aftersession j Each nk ∈ J when joins the group GC gives it j − th forward key ieKFj  instead of initial forward seed KF0  As KFj = H(KFj−1) it is computationallyinfeasible for nk to compute the previous forward keys which are required tocompute session keys before current session j Hence the proposed scheme isbackward secure746 F Kausar et alTable 1 Time and memory requirements for Tmote SkyAlgorithm Time (seconds) RAM (bytes) ROM (bytes) Energy (Joules)SHA-1 10545×10−3 128 4 048 5694×10−6MD5 5757×10−3 176 12 500 3109×10−663 Storage RequirementsIn our scheme the GC and all nodes do not need any encryption/decryptionprocess of a re-keying message to update session keys All computation neededfor re-keying is one-way hash function and XOR operation and all informationneeded for re-keying is in the current transmission and the initial informationWe implement two one-way hash algorithms SHA-1 and MD5 using nesC [22]programming language in TinyOS for Moteiv’s Tmote Sky sensors We have con-sidered voltage level of 3 volts and nominal current (with Radio off) as 18×10−3amps as given in Tmote Sky’s data sheet [23] We take data stream of 64 bytesAs shown in Table 1 for SHA-1 the code consumes 128 bytes of RAM 4048 bytesof ROM takes approximately 105 ms to produce a 160-bit hash of a 64-bytemessage and the energy consumption is 5694 μJoules MD5 produces a 128-bitmessage digest for a given data stream The code consumes 176 bytes of RAM125 KB of ROM takes approximately 575 ms to hash a message of 64 bytesusing 64-byte blocks and the energy consumption is 3109 μJoules The aboveimplementation shows that SHA-1 consumes less memory than MD5; howeverit’s processing overhead is almost double than MD57 ConclusionEfficient solutions for the problem of key distribution are essential for the feasibil-ity of secure group communication in sensor networks In this paper we developa key distribution scheme for secure group communication in WSNs The schemeprovides a self-healing mechanism for session key-recovery on possible packet lossin the lossy environment using one-way key chainOther features include periodic re-keying of group key and time-limited groupnode revocation The session keys are updated periodically where the update isperformed regardless of changes in network (group) topology Periodic rekeyingsignificantly reduces both the computation and communication overhead at theGC and the nodes and thus improves the scalability and performance of theproposed scheme Further the time-limited node revocation is achieved withoutany intervention from the GCThe analysis shows that the proposed scheme is computationally secure andmeets the security requirements for forward and backward secrecy The imple-mentation of two one-way hash algorithms SHA-1 and MD5 on resource con-straint sensor nodes (Tmote Sky) shows the feasibility of the proposed schemeSecure Group Communication with Self-healing and Rekeying in WSNs 747for current wireless sensor network technology Hence the scheme results scal-able and particularly attractive for large dynamic groupsAcknowledgmentThis work is in part supported by Higher Education Commission (HEC) Pak-istans International Research Support Initiative Programs scholarship given toFirdous Kausar to conduct her research at Acadia University Canada Fur-ther we would like to thank National Science and Engineering Research Council(NSERC) Canada for their support in providing RTI and Discovery grants toDr Hussain at Acadia University Canada This research is also supported byKyungnam UniversityReferences1 Wallner D Harder E Agee R: Key management for multicast: Issues and ar-chitectures (1999)2 Canetti R Garay J Itkis G Micciancio D Naor M Pinkas B: MulticastSecurity: A Taxonomy and Some Efficient Constructions In: INFOCOMM 1999(1999)3 Kurnio H Safavi-Naini R Wang H: A secure re-keying scheme with key re-covery property In: Proceedings of the 7th Australian Conference on InformationSecurity and Privacy pp 40–55 Springer London UK (2002)4 Wang L Wu CK: Authenticated group key agreement for multicast In: The5th International Conference on Cryptology and Network Security Springer Hei-delberg (2006)5 Ki JH Kim HJ Lee DH Park CS: Efficient multicast key management forstateless receivers In: Lee PJ Lim CH (eds) ICISC 2002 LNCS vol 2587pp 497–509 Springer Heidelberg (2003)6 Pegueroles J Bin W Soriano M Rico-Novella1 F: Group rekeying algorithmusing pseudo-random functions and modular reduction In: Li M Sun X-HDeng Q-n Ni J (eds) GCC 2003 LNCS vol 3032 pp 875–882 SpringerHeidelberg (2004)7 Yang YR Li XS Zhang XB Lam SS: Reliable group rekeying: a perfor-mance analysis In: SIGCOMM 2001 Proceedings of the 2001 conference on Appli-cations technologies architectures and protocols for computer communicationspp 27–38 ACM Press New York NY USA (2001)8 Poovendran R Baras JS: An information theoretic analysis of rooted-tree basedsecure multicast key distribution schemes In: Wiener MJ (ed) CRYPTO 1999LNCS vol 1666 pp 624–638 Springer Heidelberg (1999)9 Noubir G Zhu F Chan AH: Key management for simultaneous join/leave insecure multicast In: Proceedings of MILCOM (2003)10 Gong L Shacham N: Multicast security and its extension to a mobile environ-ment Wirel Netw 1(3) 281–295 (1995)11 Bruschi D Rosti E: Secure multicast in wireless networks of mobile hosts: pro-tocols and issues Mob Netw Appl 7(6) 503–511 (2002)748 F Kausar et al12 Kostas T Kiwior D Rajappan G Dalal M: Key management for secure mul-ticast group communication in mobile networks In: Proceedings of DARPA Infor-mation Survivability Conference and Exposition (2003)13 Park T Shin KG: Lisp: A lightweight security protocol for wireless sensor net-works Trans on Embedded Computing Sys 3(3) 634–660 (2004)14 Wong CK Gouda M Lam SS: Secure group communications using key graphsIEEE/ACM Trans Netw 8(1) 16–30 (2000)15 Carman D Matt B Cirincione G: Energy-efficient and low-latency key manage-ment for msn networks In: Proceedings of 23rd Army Science Conference OrlandoFL (2002)16 Staddon J Miner S Franklin M Balfanz D Malkin M Dean D: Self-healingkey distribution with revocation In: Proceedings of IEEE Symposium on Securityand Privacy pp 241–257 (2002)17 Liu D Ning P Sun K: Efficient self-healing group key distribution with re-vocation capability In: CCS 2003 Proceedings of the 10th ACM conference onComputer and communications security pp 231–240 ACM Press New York NYUSA (2003)18 Blundo C Darco P Santis AD Listo M: Design of self-healing key distribu-tion schemes Des Codes Cryptography 32(1-3) 15–44 (2004)19 Jiang Y Lin C Shi M Shen X: Self-healing group key distribution with time-limited node revocation for wireless sensor networks Ad Hoc Networks 5(1) 14–23(2007)20 Dutta R Chang EC Mukhopadhyay S: Efficient self-healing key distributionwith revocation for wireless sensor networks using one way key chains In: ACNS2007 Proceedings of 5 th International Conference on Applied Cryptography andNetwork Security (2007)21 NIST: Secure hash standard In: National Institute for Standards and TechnologyGaithersburg MD USA (April 1995)22 Gay D Levis P von Behren R Welsh M Brewer E Culler D: The nesc lan-guage: A holistic approach to networked embedded systems SIGPLAN Not 38(5)1–11 (2003)23 http://wwwmoteivcom/products/docs/tmote-skydatasheetpdf
self healing key distribution-WSN-pdf,triirghuologyEngiline 2Abstract1 Introduction cast channel the combination of group communica-ogy due to nodes’ attachment and detachment it isnecessary to refresh the TEK to prevent thedetached node from accessing future communica-tions and the newly attached node from accessingprevious communications Group Key Managererved* Corresponding authorE-mail addresses: yxjiang@csnet1cstsinghuaeducn (YJiang) clin@csnet1cstsinghuaeducn (C Lin) mshi@bbcruwa-terlooca (M Shi) xshen@bbcruwaterlooca (X (S) Shen)Ad Hoc Networks 5 (201570-8705/$ - see front matter  2006 Elsevier BV All rights resApplications of wireless sensor networks (WSNs)have attracted great attention from both academiaand industry recently Secure group communicationis increasingly used as an efficient communicationmethod for group-oriented applications in WSNsCommunications within each sensor node groupshould not be eavesdropped by other groups ormalicious nodes Given the open nature of broad-tion and WSNs is more susceptible to unauthorizedaccess Thus it is required to provide the confiden-tiality in group communications so that non-legiti-mate nodes are prevented from having access tothe secret content whereas only legitimate nodescan decrypt the multicast data even if the data isbroadcast to the entire network Traffic EncryptionKey (TEK) a symmetric key is used to encrypt databy the source and decrypt them by the destination[1] Moreover considering the dynamic node topol-A novel key distribution scheme with time-limited node revocation is proposed for secure group communications inwireless sensor networks The proposed scheme offers two important security properties: the seal-healing re-keying messagedistribution which features periodic one-way re-keying with implicitly authentication efficient tolerance for the lost re-keying messages and seamless Traffic Encryption Key (TEK) switch without disrupting ongoing data transmissions;and the time-limited dynamic node attachment and detachment so that both forward and backward secrecy is assuredby dual directional hash chains It is shown that the communication and computation overhead of the proposed protocolis light and the protocol is robust under poor communication channel quality and frequent group node topology change 2006 Elsevier BV All rights reservedKeywords: Self-healing; Node revocation; Key distribution; Group communicationSelf-healing group key disnode revocation for wYixin Jiang a* Chuang Lin a Mina Department of Computer Science and Technb Department of Electrical and ComputerAvailable ondoi:101016/jadhoc200605007bution with time-limitedeless sensor networksi Shi b Xuemin (Sherman) Shen b Tsinghua University Beijing 100084 Chinaneering University of Waterloo Canada3 June 200607) 14–23wwwelseviercom/locate/adhocY Jiang et al / Ad Hoc Networks 5 (2007) 14–23 15(GKM) which is located in sensor network control-ler is responsible for distributing re-keyingmessages to the nodes in the group securely byencrypting them using the Key Encrypting Key(KEK) [2]The TEK is updated by trigging a re-keyingprocess after a node attaches to or detaches froman active group session The process ensures that anew node cannot decrypt previous multicast dataand prevents a detached node from eavesdroppingfuture multicast data Since each node topologychange triggers a new re-keying process TEK renewmessages may impact the performance and scalabil-ity when node topology frequently changesA number of approaches have been proposed toefficiently tackle the scalability problem of keydistribution with high dynamic node topologySome surveys are available in [34] Consideringthe interdependency of re-keying messages for revo-cation group key distribution scheme with revoca-tion can be classified into two distinct classes:stateless or stateful scheme In stateful scheme[56] a legal node’s state in the current re-keying willaffect its ability to decrypt future group keys How-ever the group re-keying in a stateless scheme [6–9]relies only on current re-keying message and thenode’s initial configuration A non-revoked nodecan decrypt the new TEK independently from theprevious re-keying messages without contactingthe GKM even if the node is off-line for a whileThe property makes stateless scheme more usefulin scenarios where some nodes are not constantlyon-line or suffer from burst packet lossesIn addition to re-keying and the node revocationsome recent works address the self-healing issue thata group node can recover the missed session keysfrom the latest re-keying message on its own Basedon two-dimension t-degree polynomials a self-heal-ing group key distribution scheme is first presentedin [10] and improved in [1112]Typically group key distribution protocols forWSNs should take both security and service qualityinto consideration The basic security requirementsinclude [34] (1) Group confidentiality: nodes thatare not the part of the group should not have accessto any key that can decrypt any data broadcast tothe group (2) Forward secrecy: a node thatdetaches from the group should not have accessto any future keys so that it cannot decrypt futuredata (3) Backward secrecy: a new node thatattaches to the session should not have access toany old key so that it cannot decrypt previous dataThe impaired channel usually results in schemefailure if nodes cannot communicate with GKMThe dynamics of the node topology also increaseservice disruption probability since some nodesmay lose connections temporarily Hence it isrequired to offer a reliable re-keying process withsufficient small number and size of re-keying mes-sages In addition the re-keying scheme must notrequire either a large number of storage keys or highcomputation overhead at GKM or the nodes in thegroupIn this paper we propose an efficient self-healinggroup key scheme with time-limited node revocationbased on dual directional hash chains (DDHC)which assures forward and backward secrecy in highpacket loss environment Comparing with existingliterature the scheme offers a practical seal-healingmethod and an implicit node revocation algorithmwith lightweight computation and communicationoverhead favouring the group application scenariosin WSNs which employ dynamic node topology andbroadcast channel with high packet loss or error rateThe TEK is re-keyed periodically instead of on everynode topology change Periodic or batch re-keyingcan remarkably reduce both the computation andcommunication overhead at the GKM and thenodes and thus improve the scalability and perfor-mance of key distribution protocols The proposedscheme also offers seamlessTEK refreshmentwithoutdisrupting the ongoing data transmission The per-formance of the proposed scheme under poor broad-cast channel condition is evaluated by both analysisand numerical results It is shown that the proposedscheme can tolerate high channel loss rate and hencemake a good balance between performance and secu-rity which is suitable for WSN applicationsThe rest of the paper is organized as follows InSection 2 the basic principle of time-limited groupnode revocation and self-healing method are intro-duced In Section 3 the proposed self-healing groupkey distribution protocol for wireless sensor net-works is described in detail In Section 4 the securityand the performance analysis are presented respec-tively followed by the conclusion in Section 52 Self-healing and time-limited node revocation21 One-way hash chainWe first introduce the concept of one-way hashfunction which is the foundation of dual directionalhash chain (DDHC) A hash function takes a binarystring of arbitrary length as input and outputs abinary string of fixed length A one-way functionH satisfies the following two properties: (1) givenx it is easy to compute y such thaty = H(x); (2)given y it is computationally infeasible to com-putexsuch thaty = H(x)A one-way hash chain is a sequence of hashvalues {xn   x j   x0} such that {xjj"j: 0 < j 6n xj1 = H(xj)} The random xn is a secret seed ofthe one-way hash chain Thus there exists thethe re-keying message whereas the nodes in Rcannot decrypt re-keying messageThe proposed time-limited group node revoca-tion scheme is implemented by DDHC Let z denotethe lifecycle of the group communication systemThen the maximum number of time periods isz + 1 Without loss of generality assume that z isan integer ie the system starts at time 0 and endsat time z We argue that this constrain on themaximum number of time periods should not be16 Y Jiang et al / Ad Hoc Networks 5 (2007) 14–23following relation: x1 = H(x2) =    = Hn2(xn1) =Hn1(xn)Due to the one-way property of hash function Hgiven xi it is computationally infeasible to calculatexj (j < i) but is easy to compute any xj (j > i) withxj = Hji(xi)22 Dual directional hash chainsA dual directional hash chain (DDHC) is com-posed of two one-way hash chains with equallength a forward hash chain KF and a backwardhash chain KB It can be derived as follows: (1) gen-erating two random key seed values KF0 and KB0  forforward and backward hash chains with the sizez + 1 respectively; (2) repeatedly applying the sameone-way function on each seed to produce two hashchains of equal length z + 1 The dual hashsequences are generated as KF0 ;HðKF0 Þ;    ;HiðKF0 Þ;    ;HzðKF0 Þg and KB0 ;HðKB0 Þ;    ;HiðKB0 Þ;   ;HzðKB0 Þg23 Time-limited node revocation schemeThe concept of node revocation can be describedas follows Let N be the set of all possible groupnodes and R the set of revoked nodes whereR  N The group node revocation is required tooffer a secure way for GKM to transmit re-keyingmessages over a broadcast channel shared by allnodes so that any node Ui 2 {NnR} can decryptFig 1 Time-limited node revoconsidered as a limitation in a group communicationDuring the system lifecycle when a node attachesto an active group the GKM assigns the pairHt1ðKF0 Þ;Hzt2ðKB0 Þ to the new node according toits prearranged lifecycle (t1 t2) Due to the DDHConce a node’s lifecycle is expired it is forced todetach from the group session without requiringthe direct intervention of the GKMThe application of the DDHC in time-limitednode revocation mechanism is shown in Fig 1The range of hash keys hidden from the group nodewith the lifecycle (t1 t2) are presented with greybackground The forward hash chain guaranteesthe backward secrecy A new node that participatesin the group communication at time t1 cannot calcu-late the previous hash keys KF0 ;HðKF0 Þ;    ;Ht11ðKF0 Þg before t1 because of the property ofone-way hash function Similarly the backwardhash chain guarantees the forward secrecy Once anode detaches from the group session at time t2 itcannot compute the subsequent hash keysHzt21ðKB0 Þ;Hzt22ðKB0 Þ;    ;KB0 after t2For a group system with lifecycle (0z) the trafficencryption key (TEK) at time x is defined as a func-tion of x HxðKF0 Þ HzxðKB0 Þ and RKi respectivelyTEKi ¼ f HxðKF0 Þ;HzxðKB0 Þ;RKi ; ð1Þwhere 0 6 x 6 z and RKi denotes the ith re-keyingmessage from GKM which will be described laterDue to the one-way property of the DDHC agroup node with Ht1ðKF0 Þ;Hzt2ðKB0 Þ is restrictedcation based on DDHChealing scheme can efficiently tolerate high packetloss or error rate3 Proposed group key distribution schemeWe propose a lightweight and robust group keydistribution scheme with time-limited node revoca-tion to protect the group communications in WSNsY Jiang et al / Ad Hoc Networks 5 (2007) 14–23 17in accessing the TEKs in the time-range of (t1 t2)since the group node can only use the pre-assignedseeds Ht1ðKF0 Þ;Hzt2ðKB0 Þ to compute HxðKF0 Þ andHzxðKB0 Þ as HxðKF0 Þ ¼ Hxt1 Ht1ðKF0 Þ and HzxðKB0 Þ ¼ Ht2x Hzt2ðKB0 Þ  respectively Howeverout of the time-range (t1 t2) it cannot computeHxðKF0 Þ and HzxðKB0 Þ for x 6 t1 or xP t2 Further-more it cannot calculate the TEK at time x eitherThus an implicit time-limited node revocation isimplemented Each group node can only be givenaccess to a pre-defined contiguous range of theTEK according to its lifecycle (t1 t2)24 Self-healing re-keying mechanismSelf-healing re-keying mechanism offers equiva-lent reliable RK transmission over impaired broad-cast channel As described above each legal nodecan derive the TEK at time x(0 6 x 6 z) byTEKi ¼ f HxðKF0 Þ;HzxðKB0 Þ;RKi  where HxðKF0 Þand HzxðKB0 Þ are not required to be transmitted ateach re-keying Each node can individually computethem according to the pre-assigned seeds Ht1ðKF0 Þ;Hzt2ðKB0 ÞÞ and current time x RKi is encapsulatedin the re-keying message which is periodically sentby the GKM to all nodesAt the initial phase the GKM first selects a secretseed RKn and then uses the seed to pre-compute aone-way hash chains {RKiji = 12   n} where nis reasonably large Specifically the GKM choosesRKn as the last key in the hash chain and repeatedlyperforms the hash functionH to compute all the restof keys as RKi = H(RKi+1) 0 6 i 6 n  1 All RKssatisfies RK0 = H(RK1) =    = Hn2(RKn1) =Hn1(RKn)In the subsequent re-keying phases all RKii = 12   n will be released to all nodes by theGKM in reverse order ie RK0 will be releasedfor session 0 RK1 for session 1    and RKn forsession n and so on Given current RKj in the hashchain nodes can only use one-way function H tocompute the previous keys {RKij0 6 i 6 j} recur-sively however they cannot compute other keys{RKijj + 1 6 i 6 n}Consider that each re-keying message containsonly one RK in current session Then though there-keying messages may be lost during the transmis-sion self-healing can be achieved since the lost RKsin previous re-keying messages can be recovered byusing the one-way hash function and the lastreceived RK Furthermore the TEK will be success-fully derived by each node Thus the proposed self-As shown in Fig 2 the scheme consists of the twocomponents: self-healing and TEK switchingThe self-healing mechanism provides a robustway for tolerating the packet loss in impairedbroadcast channel On receiving a RefreshKey mes-sage each node implicitly verifies the authenticity ofthe received RK by using pre-stored RKs If neces-sary the node recovers the lost RKs using the newRK without requesting GKM to re-transmit themThe proposed self-healing mechanism relies on theone-way property of a hash function Similar mech-anism is also used in LiSP [13] and lTESLA [1415]The proposed mechanism improves (1) efficiency inthat each node only buffers the constant number ofkeys whereas TESLA is required to buffer all thereceived messages until the node receives an authen-tic message; and (2) implicit time-limited node revo-cation while it is not considered in LiSPThe TEK Switching module seamlessly switchesthe TEK without disrupting ongoing data transmis-sions Two key-slots are set up for each node whichcan be operated concurrently When the RK in onekey-slot is used for data encryption or decryptionthe received new RK will be written into the otherkey-slot At the middle point of the key updateinterval the node switches the active key-slot tothe one with the new RKThere are three types of signal messages used inthe proposed key distribution scheme: InitGroup-Key RequestKey and RefreshKey respectively Init-GroupKey and RequestKey are unicasted betweenGKM and a group node while RefreshKey is broad-casted to all group nodes The InitGroupKey mes-sage is sent to nodes to initiate re-keyingparameters at the initial phase The RefreshKeyInitGroupKeyRefreshKey…Traffic Encryption Key Switch ModuleRK2RK1RKt+2 RKt+1 RK3Self-healing ModuleTEK2TEK1Fig 2 Self-healing group key distribution with time-limited noderevocationmessage periodically broadcasts the next RK in thekey sequence to nodes The RequestKey message isused by each node to explicitly request the currentRK in the key sequence The RequestKey messagewill be generated by a node when it fails to receiveRK over t renewal intervals31 Initial configuration setupw=aimettyfoGKMkHrengwhere TEKi+1 is the active TEK at the time whenRefreshKey message is broadcastedAlgorithm 3 TEK refreshment and RK recovery01: Function TEK_Refresh_Recover (){02: while (RefreshKey message received){03: Decrypt it with TEKi+1 to get{RKi+t+2RKi+1};04: if (H(RKi+1)5RKw){05: Discard the rekey message{ETEKi+1 (RKi+t+2 RKi+1)};06: continue;Algorithm 2 Refresh key timer01: Function Refresh_Key_Timer(){02: if (RefreshKeyTimer triggered){03: Right-shift the key buffer and key-slot;04: e ++ ; RKw = {the inactive key in thekey slots};05: }06: Set active RKs in key slots;07: Set RefreshKeyTimer to Trefresh;08: if (e == t) send RequestKey message to18 Y Jiang et al / Ad Hoc Networks 5 (2007) 14–23code using a hash function eg MD5; Ht1ðKF0 Þand Hzt2ðKB0 Þ are the corresponding seeds in theDDHC for node Ui with lifecycle (t1 t2)Algorithm 1 Initial group communication system01: Function Init_TEK (){02: if (Receiving InitGroupKey message){03: Decrypt InitGroupKey to get{RKt+2tT refresh};04: Allocate a key buffer with length t(kb[1]   kb[t])and two key-slots (ks[1]ks[2]);05: for (i = 1; i < = t  1; i ++ ) dokb[i] = Hti(RKt+s);06: ks[2] = Ht(RKt+s); ks[1] = Ht+1(RKt+s);07: RKw = Ht+2(RKt+s);08: Set key ks[1] as the data encryption key;09: Set RefreshKeyTimer to Trefresh /2;}}whekeyit is the length of RK buffer; Trefresh is the re-period; MAC(Æ) generates a message digest! Ui : EKEKi tkRKtþ2kT refreshkHt1ðKF0 Þt2ðKB0 ÞkMAC tkRKtþ2kT refreshkHt1ðKF0 ÞkHt2ðKB0 Þ ;theauthentication At time tinit the GKM sendsllowing message to Uisecrentiis shared only between GKM and Ui viaKeyn Key Encryption Key KEKi for InitGroup-essage encryption and its authentication ThisRKia mH(RKi+1) 0 6 i 6 n  1 Each node Ui keepsone- ay RK sequence {RKiji = 12   n} such thatTEK At the initial phase the GKM pre-computes aF  3 illustrates how to initialize and refresh theigFig 3 Initial setup and TEK refreshmentWhen node Ui receives the InitGroupKey mes-sage it processes this message according to Algo-rithm 1 Fig 3 also illustrates how the node copiesRK sequence into its key buffer and key-slots com-putes TEK and seamlessly switches the active TEKafter obtaining RKt+2If the timer is expired each node will trigger theexecution of Algorithm 2 which performs theright-shift operations so that RK can be automati-cally renewed at each interval Trefresh Here eachnode maintains two variables e and RKwSentryRKw tracks the most recent futile RK ande tracks the number of RK that the node fails toreceive32 TEK refreshment: re-keying with implicitauthenticationAfter the initial phase the GKM periodically dis-closes the next RK in the pre-computed RKsequence to all nodes Assume that the initial phaseends at time tinit For the ith re-keying the GKMbroadcasts RefreshKey message with RKi+t+2 i =0   n  t  2 to all nodes at time tinit + i Æ Trefresh:GKM!Uj ðj¼ 1;    ;mÞ : fETEKiþ1ðRKiþtþ2;RKiþ1ÞgGKM;}07: }the GKM If it is successful UJoin can establisha common secret KEKi shared with the GKMThe GKM then sends the current systemconfiguration to UJoin via an InitGroupKeymessageY Jiang et al / Ad Hoc Networks 5 (2007) 14–23 19On receiving the RefreshKey message each nodeprocesses the message following Algorithm 3 TheTEK can be synchronously renewed with the newre-keying message (line 10 in Algorithm 3) Due tothe one-way property of RK sequence the Refresh-Key message does not need message authenticationcode since the receiver can verify if the receivedRK belongs to the same key sequences by checkingH(RKi+1)5RKw Such implicit authentication nota-bly decreases the message sizeThe computation overhead in re-keying is notheavy since it only needs to handle low-cost hashoperations The communication overhead is alsolightweight since the proposed key distributionscheme provides an implicit authentication for re-keying messages without message retransmissions33 Recovery of lost TEKThe RefreshKey message provides a self-healingmechanism to recover the lost RKs Suppose thatthere are r(6t) RKs reserved in the key buffer dueto the previous lost messages so there are e =t  r empty slots in the key buffer Let fRK 0r;    ;RK 01g denote these r RKs in the key buffer {kb[r]  08: RKw = the inactive key in key slots};09: Right-shift kb[1] = RKi+3 to the inactivekey slot;10: TEKiþ3 ¼ f HtðKF0 Þ;HztðKB0 ÞRKiþ3 ;11: for (i = 1; i < = t  1; i ++ ) dokb[i]! kb[i  1];12: if (e50){/* there are lost RKs */13: for(j = 0; j < = e; j ++ ) do /* recoverlost RKs */14: Hj(RKi+t+2)! kb[t  j];15: e = 0;/* reset value e */}}}kb[1]} respectively They also belong to the sameRK sequence and satisfy HðRK 0rÞ ¼ RK 0r1;    ;HðRK 02Þ ¼ RK 01Algorithm 3 also shows the details of the self-healing mechanism (line 12–15) Upon getting aRefreshKey message each node checks ifH(RKi+1) = RKw and uses RKi+t+2 to recover thelost RKs in the same key sequence if it holdsFig 4 illustrates lost RKs recovery Assume that anode receives a RefreshKey with RKt+2 Due toH(RKt+2) = RKt+1 and e = 0 there are no messageloss If the re-keying messages are lost in the nexttwo intervals e = 2 and there are t  2 RKs in thekey-buffer Afterwards the node receives an authen-tic RefreshKey message with RKt+5 SinceHðRK3Þ ¼ RKw it can recover previous two lostRKs as RKt+3 =H2(RKt+5) and RKt+2 =H3 (RKt+5)34 Dynamic participation mechanismThe dynamic participation mechanism as a basicsecurity requirement allows that any node canattach to or detach from the active group whileassuring the freshness of the TEKNode attachment: When a node UJoin attaches toan active group the corresponding actions (steps)are described as follows:1 Step 1: Node UJoin first obtains the permissionto attach to the group communication fromFig 4 Self-healing scheme: recovering the lost TEKGKM ! U Join : EKEKJoin tkRKkkT refreshkHt1ðKF0 ÞkHzt2ðKB0 ÞkMAC tkRKkkT refreshkHt1ðKF0 ÞkHzt2ðKB0 Þ;where Ht1ðKF0 Þ and Hzt2ðKB0 Þ are the correspond-ing seeds in the DDHC for UJoin with lifecycle(t1 t2)2 Step 2: On receiving InitGroupKey message UJoingenerates the message following Algorithm 1and then attaches to the active group communi-cation It can receive the subsequent re-keyingmessages and renew the TEK synchronously asshown in Algorithm 3calculate HxðKF0 Þ before it joins the group session(x < t1) nor HzxðKB0 Þ after it leaves the group ses-sion (x > t2) due to the one-way property of DDHCTherefore it is only restricted in access the TEKs inthe time-range of (t1 t2) The forward and backwardsecrecy is assured with the time-limited noderevocationWe assume each occurrence of RK loss is random20 Y Jiang et al / Ad Hoc Networks 5 (2007) 14–23Node revocation: Assume that a node TQuit withlifecycle (t1 t2) detaches from the session at timet2 It cannot derive the TEK by TEKi ¼ f HxðKF0 Þ;xHzxðKB0 Þ;RKiÞ for x 6 t1 or xP t2 Thus a time-limited node revocation is achieved implicitly with-out the need of intervention from the GKM so thatthe communication and the computation overheadon the GKM and group nodes are remarkablyreduced35 Re-initialization mechanismThe GKM re-initializes the group communica-tion system if (1) all nRKs in the RK sequence havebeen used up; and (2) a node has explicitly requestedRK since more than t RKs are lost In the formerscenario all nodes are forced to be re-initializedGKM re-computes a new RK sequence fRK 0iji ¼1; 2;    ; ng and then broadcasts a new InitGroup-Key message with RK 0tþs to all the nodes In thelatter scenario the GKM only sends the requestingnode the InitGroupKey message with currentconfiguration The node can then periodically renewthe TEK by the received RefreshKey message4 Performance analysisWe analyze the proposed scheme to verify that itsatisfies the security and performance requirementsfor secure group communication described in Sec-tion 141 Security analysisThe proposed scheme meets the security require-ment for forward and backward secrecy since it canassure the refreshment of the TEK by periodic ordynamic re-keying mechanism when a nodeattaches to or detaches from an active group ses-sion and when the two cases discussed in 35 occurThe time-limited node revocation algorithm offersan efficient way to assure forward and backwardsecrecy Assume that a node Ui with lifecycle (t1 t2)attaches to the session at time t1 and detaches fromthe session at time t2 During the lifecycle (t1 t2) Uican use its pre-assigned seeds Ht1ðKF0 Þ;Hzt2ðKB0 Þ to compute the respective hash values HxðKF0 Þ andHzxðKB0 Þ and derive the TEK at time x asTEKj ¼ f HxðKF0 Þ;HzxðKB0 Þ;RKj :However when x 6 t1 or xP t2 Ui cannotderive the corresponding TEK since it can neitherand mutually independent Let state Si denote thatthere are i lost RK packets and thus there are iempty slots in the key-buffer The state transitionis triggered by two events: packet lost or receivinga re-keying RK packet successfully Let ps = Pr{RKmessage is received} Without loss of generality wealso assume that each transmitted message via thechannel has the same loss probability or error rateie pl = Pr{RK Message is lost} The assumption isreasonable since the channel does not distinguishthe different packetsLet P(k) denote the steady-state probability ofstate Si that there are exactly k empty slots SincePtk¼0P ðkÞ ¼ 1 according to the global balanceequations we haveP ðiÞ  ðps þ plÞ ¼ P ði 1Þ  pl; i ¼ 1;    ; tP ð0Þ  pl ¼ P ðtÞ þPt1i¼1P ðiÞ  ps(:ð2ÞHence the steady-state distributions P(k) are givenasP ð0Þ ¼ ð1 plÞ= 1 ptþ1l P ðiÞ ¼ Pð0Þ  pkl ; k ¼ 1; 2;    ; t(: ð3Þpsps 1S0psS1 St-1 St…pl pl pl pl42 Steady Markov state distributionTo evaluate the performance of RK renewal wequantify the cost of the communication and compu-tation overheads when nodes renew TEKAs shown in Fig 5 we first apply the Markovchain to derive the steady-state distributions ofkey-buffer states for a node Then we investigatethe communication and computation overheadFig 5 State transition diagram of each group user43 Communication overheadTo evaluate the communication overheadbetween the GKM and nodes we normalize theexpected communication overhead Ccomm by thecost of sending the RefreshKey messages Let Cinitand Crefresh denote the communication cost fortransmitting InitGroupKey and RefreshKey messagerespectively Let a = Cinit/Crefresh be the ratio ofcommunication cost of InitGroupKey to that ofRefreshKey a > 1 since the InitGroupKey messageneeds more bandwidth or resources than Refresh-and a = 10 The choice of a implies that the cost oftransmitting and processing the InitGroupKey mes-sage is higher than that of transmitting the Refresh-Key message It can be seen that the key-bufferlength t in each node determines the communicationcost A larger t can significantly reduce the commu-nication overhead44 Computation overheadSince the GKM is usually a high-performanceY Jiang et al / Ad Hoc Networks 5 (2007) 14–23 21Key message As discussed before the GKM needsto transmit the InitGroupKey message when a nodeattaches to an active group session or when allnRKshave been used or when a node has explicitlyrequested RK Note that in case 2 all nodes arerequired to be reinitialized while in cases 1 and 3only the specific node needs to be reinitialized bybeing sent InitGroupKey message Besides thesecases GKM periodically broadcasts RefreshKeymessages Therefore the expected communicationcost of a node is E½Ccomm ¼ Cinit  ½1=nþ PðtÞþpj þ Crefresh Pt1k¼0P ðkÞ where pj denotes the proba-bility when a node attaches to a group session Toanalyze the dynamic of RK update we assume thatthe frequency of attachment is low According to(3) the communication cost Ccomm can be normal-ized with Crefresh as:Ccomm ¼ a  ½1=nþ ptl  P ð0Þ þXt1k¼0pkl  P ð0Þ: ð4ÞIf the value of Ccomm is close to 1 it indicates thatmost RefreshKey messages should work well Bycontrast if Ccomm is close to a the protocol worksless efficientlyFig 6 shows the relationship between Ccomm andthe key buffer length t where n = 500 pl = 01–050051152253354451 2 3 4 5 6 7 8 9 10p1=010p1=020p1=030p1=040p1=050Fig 6 Normalized communication costs Ccomm vs the key bufferlength t (n = 500 a = 10)server which is capable for heavy computation weonly focus on the computation complexity requiredin the nodes The main computation overhead overnodes is the hash computations per RefreshKeymes-sage Let Nh denote the number of hash computa-tions per RefreshKey message If there are k emptyslots the corresponding conditional expected valueof Nh E[Nhjk slots] can be derived asE½N hjk slots ¼0  pl þ ðk þ 1Þ  ð1 plÞ; ðk < tÞðt þ 1Þ  pl þ ðt þ 1Þ  ps; ðk ¼ tÞ¼ ðk þ 1Þ  ð1 plÞ; ðk < tÞ;t þ 1; ðk ¼ tÞ:ð5ÞThen the expected value of Nh isE½N h ¼Xtk¼0E½Nhjk slots  P ðkÞ ¼ ðt þ 1Þ  P ð0Þ ptl þXt1k¼0ðk þ 1Þ  ð1 plÞ  P ð0Þ  pkl : ð6ÞFig 7 depicts the computation cost Ccomp =E[Nh] as a function of the key buffer length t wherepl vary from 01 to 05 under the assumption ofn = 500 Fig 7 also indicates that the computationcost of each node is low since each node only com-putes less than two hash functions per RK refresh-ment even in the worst case eg pl = 0500511522 4 6 8 10 12 14 16 18p1=01p1=02p1=03p1=04p1=05Fig 7 Computation costs of node vs key buffer length t(n = 500)The performance analysis indicates that proposed22 Y Jiang et al / Ad Hoc Networks 5 (2007) 14–23key distribution scheme is suitable for WSNs groupcompunctions applicationsAcknowledgementsThis research has been supported in part by theNSFC under contracts No 60573144 6021800360429202 and 90412012 and Intel IXA UniversityResearch PlanReferences[1] H Harney C Muckenhirn Group Key ManagementProtocol (GKMP) Specification RFC 2093 1997[2] H Harney C Muckenhirn Group Key ManagementProtocol (GKMP) Architecture RFC 2094 1997[3] S Rafaeli D Hutchison A survey of key management forsecure group communication ACM Computing Surveys 35(3) (2003) 309–329[4] Y Challal H Seba Group key management protocols: anovel taxonomy International Journal of InformationTechnology 2 (1) (2005) 105–119[5] DMWallner EJ Harder RC Agee KeyManagement forMulticast: Issues and Architectures RFC 2627 June 1999[6] CK Wong MG Gouda SS Lam Secure group commu-nications using key graphs IEEE/ACM Transaction onNetworking 8 (1) (2000) 16–30[7] D Naor M Naor et al Revocation and tracing schemesfor stateless receivers Proc of Advances in Cryptology(CRYPTO 2001) Springer-Verlag LNCS 2139 2001 pp41–62[8] A Fiat M Naor Broadcast encryption in: Proceedings ofAdvances in Cryptology–CRYPTO’93 LNCS vol 7731994 pp 480–491From Figs 6 and 7 the desirable number of keybuffer should satisfy tP 10 so that the normalizedcommunication or computation cost is lower andin the range of 1–15 which indicates that the pro-posed scheme is efficient in terms of communicationand computation overhead even in high packet lossor error rate environment5 ConclusionIn this paper we have developed a novel key dis-tribution scheme for secure group communicationsin WSNs The scheme can offer two important secu-rity properties: self-healing group key distributionwhich features periodic re-keying with implicitauthentication efficient tolerance for the lost re-keying messages and seamless TEK switching with-out disrupting ongoing data transmissions; andtime-limited group node revocation so that theforward and backward secrecy can be assuredTechnology Tsinghua UniversityChina He received the ME degree inComputer Science from Huazhong Uni-versity of Science and Technology in2002 In 2005 he was a Visiting Scholarwith the Department of Computer Sci-ences Hong Kong Baptist UniversityHis current research interests includesecurity and performance evaluation inwireless communication and mobile computing He has publishedmore than 20 papers in research journals and IEEE conferenceproceedings in these areasChuang Lin is a Professor and the headof the Department of Computer Scienceand Technology Tsinghua UniversityBeijing China He received the PhDdegree in Computer Science fromTsinghua University in 1994 In 1985–1986 he was a Visiting Scholar with theDepartment of Computer Sciences Pur-due University In 1989–1990 he was aVisiting Research Fellow with theDepartment of Management Sciencesand Information Systems University of Texas at Austin In1995–1996 he visited the Department of Computer ScienceHong Kong University of Science and Technology His currentresearch interests include computer networks performance eval-uation network security logic reasoning and Petri net and itsapplications He has published more than 200 papers in researchjournals and IEEE conference proceedings in these areas and haspublished three books Lin is an IEEE senior member and theChinese Delegate in IFIP TC6 He serves as the General ChairACM SIGCOMM Asia workshop 2005; the Associate EditorIEEE Transactions on Vehicular Technology; and the AreaEditor Journal of Parallel and Distributed Computing[12] A Blundo P D’Arco A De Santis M Listo Design ofself-healing key distribution schemes Design Codes andCryptography 32 (1–3) (2004) 15–44[13] T Park KG Shin LiSP: a lightweight security protocol forwireless sensor networks ACM Transactions on EmbeddedComputing Systems 3 (3) (2004) 634–660[14] A Perrig R Szewczyk V Wen D Culler JD TygarSPINS: security protocols for sensor netowrks in: Proceed-ings of IEEE/ACM MobiCom’01 2001 pp 189–199[15] D Liu P Ning Multilevel lTESLA: broadcast authentica-tion for distributed sensor networks ACM Transactions onEmbedded Computing Systems 3 (4) (2004) 800–836Yixin Jiang is a PhD candidate of theDepartment of Computer Science and[9] D Halevy A Shamir The LSD broadcast encryptionscheme in: Proceedings of Advances in Cryptology–CRYPTO’02 LNCS vol 2442 2002 pp 47–60[10] J Staddon S Miner M Franklin Self-healing key distri-bution with revocation in: Proceedings of IEEE Symposiumon Security and Privacy 2002 pp 241–257[11] D Liu P Ning K Sun Efficient self-healing group keydistribution with revocation capability in: Proceedings ofthe 10th ACM CCS 2003 pp 231–240Minghui Shi received a BS degree in1996 from Shanghai Jiao Tong Univer-sity China and an MS degree in 2002from the University of WaterlooOntario Canada both in electricalengineering He is currently workingtoward a PhD degree at the Universityof Waterloo His current research inter-ests include wireless LAN/cellular net-work integration and network securityXuemin (Sherman) Shen received theBSc (1982) degree from Dalian Mari-time University (China) and the MSc(1987) and PhD degrees (1990) fromRutgers University New Jersey (USA)all in electrical engineering From Sep-tember 1990 to September 1993 he wasfirst with the Howard UniversityWashington DC and then the Univer-sity of Alberta Edmonton (Canada)Since October 1993 he has been with theDepartment of Electrical and Computer Engineering Universityof Waterloo Canada where he is a Professor and the AssociateChair for Graduate Studies His research focuses on mobility andresource management in interconnected wireless/wireline net-works UWB wireless communications systems wireless securityand ad hoc and sensor networks He is a coauthor of two booksand has published more than 200 papers and book chapters inwireless communications and networks control and filtering Hewas the Technical Program Co-Chair for IEEE Globecom ’03Symposium on Next Generation Networks and Internet ISPAN’04 IEEE Broadnet ’05 QShine ’05 and is the Special TrackChair of 2005 IFIP Networking Conference He serves as theAssociate Editor for IEEE Transactions on Wireless Communi-cations; IEEE Transactions on Vehicular Technology; ACM/Wireless Networks; Computer Networks; Wireless Communica-tions and Mobile Computing (Wiley); and International Journalof Computers and Applications He also serves as Guest Editorfor IEEE JSAC IEEE Transactions Vehicular Technology IEEEWireless Communications and IEEE Communications Maga-zine He received the Premier’s Research Excellence Award(PREA) from the Province of Ontario Canada for demonstratedexcellence of scientific and academic contributions in 2003 andthe Distinguished Performance Award from the Faculty ofEngineering University of Waterloo for outstanding contribu-tion in teaching scholarship and service in 2002 He is a regis-tered Professional Engineer of Ontario CanadaY Jiang et al / Ad Hoc Networks 5 (2007) 14–23 23
Shell-pdf,Location-Aware CombinatorialKey Management Scheme forClustered Sensor NetworksMohamed F Younis Senior Member IEEE Kajaldeep Ghumman andMohamed Eltoweissy Senior Member IEEEAbstract—Recent advances in wireless sensor networks (WSNs) are fueling the interest in their application in a wide variety ofsensitive settings such as battlefield surveillance border control and infrastructure protection Data confidentiality and authenticity arecritical in these settings However the wireless connectivity the absence of physical protection the close interaction between WSNsand their physical environment and the unattended deployment of WSNs make them highly vulnerable to node capture as well as awide range of network-level attacks Moreover the constrained energy memory and computational capabilities of the employedsensor nodes limit the adoption of security solutions designed for wire-line and wireless networks In this paper we focus on themanagement of encryption keys in large-scale clustered WSNs We propose a novel distributed key management scheme based onExclusion Basis Systems (EBS); a combinatorial formulation of the group key management problem Our scheme is termed SHELLbecause it is Scalable Hierarchical Efficient Location-aware and Light-weight Unlike most existing key management schemes forWSNs SHELL supports rekeying and thus enhances network security and survivability against node capture SHELL distributes keymanagement functionality among multiple nodes and minimizes the memory and energy consumption through trading off the numberof keys and rekeying messages In addition SHELL employs a novel key assignment scheme that reduces the potential of collusionamong compromised sensor nodes by factoring the geographic location of nodes in key assignment Simulation results demonstratethat SHELL significantly boosts the network resilience to attacks while conservatively consuming nodes’ resourcesIndex Terms—Wireless sensor networks secure group communications key management location-aware protocols exclusion basissystems combinatorial optimization energy efficient design collusion attacks1 INTRODUCTIONIN recent years there have been major advances in thedevelopment of low power microsensor nodes (sensorsfor short) The emergence of such sensors has led practi-tioners to envision networking a large set of sensorsscattered over a wide area of interest into a wireless sensornetwork (WSN) for large-scale event monitoring and datacollection and filtering [1] A typical high-level architectureof a WSN consists of a large number of sensors that arecapable of probing the environment and reporting thecollected data to a command center using wireless channels[2] To ensure scalability and to increase the efficiency of thenetwork operation sensors are often grouped into clustersWSNs can serve many applications such as monitoringnuclear reactors and test areas disaster managementcombat field surveillance and border control Sensors aresignificantly constrained in the amount of available re-sources such as energy storage and computationalcapacity In addition many applications may requireunattended operation of the networks These constraintsmake the design and operation of WSNs considerablydifferent from contemporary wireless networks and neces-sitate the development of resource conscious protocols andmanagement techniquesConfidentiality authenticity availability and integrityare typical security goals for WSNs Indeed securing thenetwork for applications such as border control and tacticaldefense operations is among the main design objectivesHowever the close interaction of WSNs with their physicalenvironment and the unattended deployment of WSNs inhostile environments make them highly vulnerable toattacks These attacks may be external such as trafficjamming and node damaging or internal such as collusionamong some nodes to reveal the fundamentals of theemployed security scheme WSN vulnerability to numerousattacks may diminish their value and curtail their use [3][4] Thus secure communications in WSNs is vital to theiracceptance and broader adoptionThe energy-constrained nature of WSNs the absence ofthe static infrastructure the use of wireless channels andthe large number of nodes make the task of incorporatingsecurity in WSNs a challenging problem Most of the well-known security schemes designed for traditional wire-lineand wireless networks introduce significant computationand communication overhead and thus cannot be readilyapplied to WSNs The design of security schemes for WSNsshould be geared toward resource conservation ThereforeIEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS VOL 17 NO 8 AUGUST 2006 865 MF Younis and K Ghumman are with the Department of ComputerScience and Electrical Engineering University of Maryland BaltimoreCounty 1000 Hilltop Circle Baltimore MD 21250E-mail: {younis kajal1}@csumbcedu M Eltoweissy is with the Bradley Department of Electrical and ComputerEngineering Virginia Tech Falls Church VA 22043E-mail: toweissy@vteduManuscript received 11 Aug 2005; accepted 21 Dec 2005; published online26 June 2006Recommended for acceptance by S OlariuFor information on obtaining reprints of this article please send e-mail to:tpds@computerorg and reference IEEECS Log Number TPDS-0368-08051045-9219/06/$2000  2006 IEEE Published by the IEEE Computer Societythe level of security versus the consumption of energycomputation and memory resources constitute a designtrade-offWe observe that operations in a WSN are inherentlycollaborative where the autonomous nodes forming theWSN collectively perform tasks Therefore secure groupcommunications should be utilized to support efficientWSN operations Secure group communications requiresthat each authorized member of a secure network haveknowledge of one or more communication key(s) (alsotermed session keys) shared by a group(s) of nodes Themessage source uses the communication keys for encrypt-ing data packets before sending them to the groupNumerous conditions may introduce the need to evict anode or a set of nodes For example nodes may experiencefailure due to energy depletion Also nodes may becompromised and exhibit anomalous behavior [5] [6] [7][8] [9] When a member node is evicted from the group thecommunication keys known to that member must bechanged in order to maintain data confidentiality Allremaining group members receive the new communicationkeys by secure transmission which is typically accom-plished by broadcasting a message containing the newkey(s) to the group Such a message must be indecipherableto the evicted member in order to prevent it from obtainingthe new key Rekeying messages are encrypted usingadministrative keys that are not known to the expellednodes Moreover the administrative keys known to anevicted node should also be replaced Consequently keymanagement is a core component in any secure groupcommunicationsIn this paper we present a novel solution to the problemof key management in WSNs Specifically we propose alightweight scheme for clustered WSNs based on acombinatorial formulation of the group key managementproblem The solution is1 hierarchical resulting in scalable key managementand multigranularity secure communications;2 distributed splitting the different activities related tokey management among multiple nodes;3 employs the Exclusion Basis System methodology[15] allowing for efficient rekeying in large net-works; and4 collusion resistant reducing the potential for collu-sion among compromised nodesOur solution minimizes the energy and memory consump-tion of the security protocol through trading off the numberof keys and rekeying messages We also introduce a novelkey assignment scheme for reducing the potential ofcollusion by factoring the geographic location of nodes inkey assignment We call our solution SHELL abbreviatingits attributes Scalable Hierarchical Efficient Location-aware and Light-weight while implicitly implying itsprotection of the sensor network SHELL is validatedthrough simulation and is shown to boost the networkresilience to attacks while imposing little burden on theresource constrained sensor nodesThe balance of this paper is organized as follows:Section 2 describes the system and threat models andhighlights the design goals In Section 3 we discuss ourproposed security solution Section 4 addresses the problemof collusion among compromised nodes In Section 5 wereport on the validation and performance assessment of oursecurity solution The related work is discussed in Section 6Finally we conclude in Section 72 SYSTEM AND THREAT MODELS21 System ModelWe consider a wireless sensor network consisting of acommand node and numerous sensor nodes which aregrouped into clusters The clusters of sensors can be formedbased on various criteria such as capabilities locationcommunication range etc [10] [11] Each cluster iscontrolled by a cluster head also known as gateway whichcan broadcast messages to all sensors in the cluster Weassume that the sensor and gateway nodes are stationaryand the physical location and communication range of allnodes in the network are known [12] [13] Each gateway isassumed to be reachable to all sensors in its cluster eitherdirectly or in multihop Sensors perform two main func-tions: sensing and relaying The sensing component isresponsible for probing their environment to track a target/event The collected data are then relayed to the gatewayNodes that are more than one hop away from the gatewaysend their data through relaying nodes Sensors commu-nicate only via short-haul radio communication The gate-way fuses reports from different sensors processes the datato extract relevant information and transmits it to thecommand node via long-haul transmission The networkarchitecture is depicted in Fig 1Each tier of the network possesses different capabilitiesThe command node is resource-rich However the amountof traffic flowing between the command node and gatewayscauses the communication channel between the commandnode and gateways to be restrained Most often thecommand node is situated at a considerable distance fromthe deployment region and might only be reachablethrough slow satellite links Larger communication dis-tances also incur increased security vulnerability and packetloss during long haul transmissions These concerns havemotivated us to reduce the role of the command node in ourkey management protocol as we later explain The gate-ways are moderately powerful with sufficient energy totransmit to the command node as well as perform therequired key management functions Finally the sensornodes are constrained in energy computation and com-munication resources An example of the capabilities of a866 IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS VOL 17 NO 8 AUGUST 2006Fig 1 Multigateway clustered sensor networktypical sensor node is the MICA mote which includes4K RAM and an 8-bit 4MHz processor and runs with twoAA batteries [14]Given such resource constraints and the highly vulner-able environment providing security services for WSNs isnot a trivial task In the remainder of this paper we proposean efficient key management scheme for WSNs22 Threat ModelIn this paper we mainly consider an adversary that tries tomanipulate the system through capturing and compromis-ing some network nodes No trust assumptions are made onthe sensors When sensors are captured; their memory canbe read and erased or tampered with Therefore anadversary would know the keys of a compromised sensorThe gateways are not assumed to be tamperproof eitherThey can be compromised by an adversary However it isassumed that the compromise of a gateway is more difficultthan that of a sensor A gateway’s compromise includes theuncovering of its keys through spoofing the physicaldamaging of its processing and/or communication cap-abilities and the manipulation of its operation after beingcaptured by an adversary A simplifying assumption in ourdesign is that the adversary does not launch a coordinatedattack ie if more than one sensor node were to becaptured a compromised node would not be aware of thelocation of other compromised nodes unless they are itsimmediate neighbors In addition we assume that theadversary does not have any prior knowledge of what isstored at each node and thus cannot selectively direct theattack to a particular node based on what that node hasWe assume that the goal of the adversary is to uncoverthe keys used in the system so that he/she can discern thenetwork operation To achieve such a goal the adversaryattacks individual nodes and fosters collusion amongcompromised nodes The main objective of node collusionis to incrementally aggregate the uncovered keys ofindividual nodes to a level that allows revealing allencrypted traffic in the network The following scenarioscan be identified for the compromised nodes to collude:1 The compromised nodes have direct communicationlinks: In such a case collusion can be very subtle andhard to prevent2 The compromised nodes can only communicatethrough multihops: This would require the compro-mised nodes to be aware of the location/ID of othercompromised nodes3 The adversary sets up separate channels for com-promised nodes to communicate: This scenarioimplies a coordinated network attack and is nothandled by SHELL We argue that the opencommunication among compromised nodes or witha coordination center would make it easy to detectand thwart the attack In addition the adversarycannot simply use the radio of the compromisednode and would have to provide an independentradio which may not be always possibleIn this paper we provide a solution to counter thescenario in 1) above through careful assignment of keys tocommunicating neighboring nodes A fitting example of theassumed model of attacks is in a battlefield or in a bordermonitoring application In such environments attacks aretypically covert and start localized in scope before spread-ing For example in a battlefield covert infiltration is acommon tactic The use of a dedicated radio channel forcoordination among members of the adversary unit wouldrisk the detection of the infiltration attempt Using theavailable radio channels of the compromised nodes wouldbe hard to detect and gives the attackers an opportunity forcausing serious damage They may decide to stay dormantand disrupt the network operation at the most serious timeeg manipulate the network only when the troops start acombat operation in order to cause maximum chaos Thegoal of our key assignment approach is to assign the keys insuch a way that even though compromised nodes maycollude and share their keys an adversary would not beable to access all the keys of the network unless many nodesare compromised In other words we try to reduce theprobability that the entire network will be captured Theremainder of this paper focuses on our proposed keymanagement solution; SHELL3 DESCRIPTION OF SHELLIn this section we present our key management schemeSHELL with the objective of enhancing network surviva-bility against node capture while incurring low computa-tion communications and storage overhead We assumethat the command node is secure while the gateways andsensors can be compromised by an adversary All nodes inthe network have unique identifiers The next sectionoverviews the principal building block of SHELL theExclusion Basis Systems Section 32 lists the assumedcapabilities and describes the role of each node in thesecurity framework Details of network initialization andoperation follow in Section 33 Analysis of potentialcompromises and description of the recovery process arepresented in Section 3431 The Exclusion Basis Systems (EBS)SHELL employs an Exclusion Basis System (EBS) developedby Eltoweissy et al in [15] EBS is a combinatorial optimiza-tion methodology for key management of group commu-nication setups It exploits the trade-off between the numberof administrative keys “k” and the number of rekeyingmessages “m” A set of ðkþmÞ administrative keys is used tosupport a set of N nodes where each node is assigned adistinct combination of “k” keys A node can be simplyadmitted to the group by assigning one of the unused set of“k” keys out of the total of Cðkþm; kÞ ie ðkþmÞ!=ðk!m!Þdistinct combinations Eviction of a compromised node canbe performed by broadcasting replacement of the “k” keysthat the evicted node knows using the “m” keys that the nodedoes not know The EBS approach proves to be very scalablefor large networks and enables great flexibility in networkmanagement by controlling the values of “k” and “m” Large“k” increases the storage requirements at the node whilelarge “m” increases communication overhead for keymanagement In this section we provide an overview of thebasic concepts of EBSAn EBS is defined as a collection  of subsets of the set ofmembers [15] Each subset corresponds to a key and theelements of a subset A 2  are the nodes that have that keyAn EBS  of dimension ðN; k;mÞ represents a situation in asecure group where there are N members numbered 1through N  and where a key server holds a distinct key foreach subset in  If the subset Ai is in  then each of themembers whose number appears in the subset Ai know theYOUNIS ET AL: LOCATION-AWARE COMBINATORIAL KEY MANAGEMENT SCHEME FOR CLUSTERED SENSOR NETWORKS 867distinct key (provided by the key server) for that subsetFurthermore for each t 2 ½1; N there are m elements in whose union is ½1; N  ftg From this it follows that the keyserver can evict any member t rekey and let all remainingmembers know the replacement keys for the k keys they areentitled to know by multicasting m messages encrypted bythe keys corresponding to the m elements in  whose unionis ½1; N  ftg Each new key is encrypted by its predecessorin order to limit decipherability only to the appropriatemembersAccording to EBS every node has a unique set of keysstored at it The total number of keys in the system canbe a maximum of kþm and the maximum number ofkey combinations is given by the binomial coefficientCðkþm; kÞ An EBS exists when Cðkþm; kÞ  N (theproof is in [15])To construct EBSðN; k;mÞ for feasible values ofN  k andm we employ a canonical enumeration of all possibleways offorming subsets of k objects froma set of kþm objectsWedothis because the construction is based on such an enumera-tion There are several algorithms for producing such asequential enumeration We choose an enumeration whereeach element of the sequence is a bit string of length kþmwhere a 1 in the ith position of a string means that object i isincluded in that subset for all ið1  i  kþmÞ Note thatevery bit string in this enumeration will have exactly k onesFor any k and m let Canonicalðk;mÞ be the canonicalenumeration of all Cðkþm; kÞ ways to form a subset ofk elements from a set of kþm objects For the sequence of bitstrings inCanonicalðk;mÞ we form amatrixA whoseCðkþm; kÞ columns are the successive bit strings of length kþmeach with k ones “A” is called the canonical matrix forEBSðN; k;mÞ For example the canonical matrix A forEBSð10; 3; 2Þ contains the enumeration of all Cð5; 3Þ waysto form a subset of three keys from five keys as shown in theTable 1We illustrate rekeying an EBS-based system with thehelp of the following example Assume that there are10 members in the group with keys as per Table 1 Supposemember M0 has been compromised Since M0 possesseskeys K1 K2 and K3 these will have to be redistributedNow the set ðK4 [K5Þ is the set of keys known to allmembers except M0 Hence the keys used for rekeying willbe K4 and K5 The following messages will be generated forrekeying:Message 1: EðK4ðS0;EðK1ðK01ÞÞ;EðK2ðK02ÞÞ;EðK3ðK03ÞÞÞÞMessage 2: EðK5ðS0;EðK1ðK01ÞÞ;EðK2ðK02ÞÞ;EðK3ðK03ÞÞÞÞ;where EðK1ðK01ÞÞ ! keyK01 is encrypted with key K1 andS0w is the new session key for the clusterThe way these messages are constructed ensures thatonly the legitimate nodes will be able to decrypt the newkeys Thus as a result of the above messages beingbroadcasted member M0 will be evicted and the new keysK01 K02 and K03 will be made available to only those nodesthat possessed keys K1 K2 and K3A drawback of the original EBS is that it is highlyvulnerable to collusion attacks It is likely that when nodesin the system collude their combined set of keys will revealmany keys to the colluding nodes We present a novelsolution for mitigating collusion attacks in EBS-based keymanagement for WSNs32 System’s Components and Capabilities321 Sensor NodesEach sensor belongs to a cluster headed by a gateway It isassumed that the gateway can directly reach each node in itscluster The sensors communicate with the gateway of theircluster via one hopormultihop transmissions The commandnode stores a database of all node IDs Each sensor has apreloaded discovery key Ksg as well as a one-way hashfunction to recompute Ksg as explained in Section 33 Eachnode also has two preloaded keysKSCH and KSKey for initialkey distribution In addition every node should have thecapacity for storing K administrative keys and c commu-nication keys The parametersK and c can be set based uponthe trade off between the bandwidth utilization versus thememory available for keying functions at the sensors Weassume that the gateway is capable of detecting andidentifying compromised sensors in its cluster However agateway can be compromised even though it is harder tocompromise a gateway than a sensor We assume that thegateway/command node can launch an effective investiga-tion procedure to accurately identify compromised sensors/gateway if it suspects some abnormal node behavior Thedetection algorithm is beyond the scope of this paper and ispart of our future research plan322 GatewaysEach gateway can directly communicate with at least twoother gateways in the network The keys known to eachgateway are: Kgc: This is the preloaded key of the gateway and isused for direct communication between the gatewayand the command node Kgi;gj: This is the intergateway key for communica-tion between gateway i and gateway j The inter-gateway keys are supplied by the command nodeduring the bootstrapping phase Ksg: This is the sensor discovery key which isprovided to each gateway by the command node868 IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS VOL 17 NO 8 AUGUST 2006TABLE 1The Canonical Matrix A for EBS(10 3 2)Each gateway acts as the head of a cluster of a number ofsensors Each cluster will be assigned a set of distinctcommunication keys for data encryption Sharing the samekey among sensors in a cluster will enable selectivedecryption of data messages for the purpose of aggregationDifferent communication keys will provide for subgroupingof nodes within a cluster based on application criteria ega separation of concerns if different subgroups are taskedwith different (sets of) functions The following are the keyresponsibilities of every gateway with respect to security: forming an EBS matrix and generating the commu-nication key of its own cluster generating administrative keys for other clusters asand when requested to do so refreshing data keys of its cluster after networksetup and detecting and evicting compromised sensor nodes inits cluster323 Command NodeAll tasks for the sensors are delegated by the commandnode The data gathered by individual sensors is trans-mitted (often after some processing) to the gateways Thegateways then channel this information to the commandnode The command node is assumed to be a trusted entityand cannot be compromised The following are the keyresponsibilities of the command node: acts as a repository for valid IDs and preloaded keys(Ksg KSCH and KSKey) of all sensors in the region authenticates the gateways and the sensors bothinitially deployed as well as latently added nodes distributes keys for intergateway communicationsand for detecting the compromise/failure of anygateway and periodically performs key renewal for the intergate-way communication and triggers renewal of gate-way-to-sensor communication keys in order tocounter potential on-going spoofing33 System Initialization and OperationIn this section we focus on the procedures involved insystem initialization and operation under normal condi-tions The next section discusses the handling of compro-mised nodes Table 2 lists the notation used in describingSHELL A formal presentation of the scheme is included inAppendix A (which can be found on the CS Digital Libraryat http://wwwcomputerorg/tpds/archiveshtm)331 Network BootstrappingWe use the term network bootstrapping to designate thestage when gateways establish contacts among themselvessensors are discovered and clusters are formed Thebootstrapping process has three main phases namelygateway registration sensor discovery and clusteringand works as follows:1 Gateway Registration At the time of deploymenteach gateway i establishes connection with thecommand node The gateway broadcasts announce-ments of its ID along with its location encryptedYOUNIS ET AL: LOCATION-AWARE COMBINATORIAL KEY MANAGEMENT SCHEME FOR CLUSTERED SENSOR NETWORKS 869TABLE 2List of Used Notationwith its preloaded Kgc;i key Upon receiving theannouncements from all gateways the commandnode establishes link-specific keys for intergatewaycommunication (that is for each pair of gateways iand j the command node establishes keysKGi;Gj 6¼ KGj;Gi) The command node then sends toeach gateway i a message that contains its intergate-way keys encrypted by Kgc;i The gateways use theintergateway communication keys to establish con-tact with each other and find out which links areworking and which are broken The command nodealso sends each gateway the Ksg key to be used forestablishing the initial contact with sensors It is to benoted that even though gateways are more capablethan sensor nodes they still may be limited inresources Consequently we chose not to useasymmetric keys for intergateway communicationsEmploying asymmetric keys for such communica-tions is a subject of further research2 Sensor Discovery After establishing the commandnode to gateways and intergateway links sensordiscovery starts Sensors broadcast repeatedly ifnecessary their ID and location to the gatewaysThese announcements are encrypted using Ksg Weassume that sufficient number of gateways is de-ployed in order to ensure area coverage and boost theprobability of discovering all sensors Upon receptionof one of the sensor announcements a gateway willdecrypt the message and tabulate the sensor’s ID andlocation As soon as the sensor discovery is completesensors generate a new Ksg using a one-way hashingfunction such as SHA1 [18] or MD5 [19] The hashingfunction is known to the command node aswell as thesensor nodes but not disclosed to the gateways Thegoal is to make the current Ksg keys known to thegateways obsolete This process will be critical to therecovery fromagateway compromise aswediscuss inSection 343 Clustering Sensor nodes are to be partitioned intodisjoint clusters Each cluster is managed by agateway denoted GCH½i where i is the clusternumber The gateways collaborate among them-selves to form clusters Sensors’ communicationrange type and geographical location are possiblecriteria for grouping the nodes into clusters [10][11] Each sensor should be uniquely assigned to acluster for which the sensor is directly reachable tothe cluster’s gateway Once the clustering process iscompleted every gateway tabulates the ID andlocation of the sensors in its cluster and informsthem with their cluster association At this point thenetwork bootstrapping stage is concluded It isworth noting that we pursue clustering to spreadthe functionality of key management among multi-ple gateways and prevent an individual gatewayfrom being a single point of failure (vulnerability) Inaddition clustering enable scalability by splittingother nonsecurity related network managementtasks among multiple data collection nodes332 Initial Key DistributionEBS formation Once every gateway has a list of all sensorsin its region the initial key distribution starts with eachgateway defining the EBS-based key combinations for everysensor in its cluster The gateway performs an analysis fordefining the number of administrative keys needed for thecluster As discussed earlier EBS offers trade-offs withrespect to the storage requirements and number of rekeyingmessages An increase in k increases the storage per nodewhile an increase in m leads to increased overhead incommunicating the new keys Depending on the size of thecluster and available memory in the sensor the gatewaydecides on the parameters k and m of an EBS For a largecluster it might be better to increase M to limit the storagerequirements per node Other deciding factors include theexpected lifetime of a sensor and how risky the deploymentarea is Such factors affect the frequency of sensor evictionIt would be advisable to increase the number of keys ifsensor eviction rate is expected to be high in order tominimize rekeying traffic In this paper we investigateanother factor related to the effect of the values of k and mon the network resilience to collusion attacks (see Section 5)These quantitative results provide additional insight forselecting appropriate valuesUpon conclusion of such analysis the list of sensorsalong with the EBS table of key combinations is sent to thecommand node It must be noted that these key combina-tions are just symbolic representations of the keys and notthe real keys themselves The actual keys are generated anddistributed as explained below In Section 4 we describe anovel algorithm for designating key combinations to thevarious sensors so that the potential of collusion amongcompromised nodes is reducedAssigning key-generating gateways The commandnode designates for each cluster Ci a number of gateways(eg two) other than the cluster head that will generateadministrative keys for that cluster This is a systemparameter whose value may depend on the hostility ofthe operating environment Let these gateways be denotedby GK1½i and GK2½i (assuming that two gateways areassigned that role) The command node will then informGK1½i and GK2½i about their role as key generators for thecluster Ci Subsequently GCH½i sends the relevant portionof the EBS matrix it has formed to GK1½i and GK2½iBasically GCH½i informs GK1½i about the keys and nodeassociation without revealing the other keys a node wouldhave from GK2½i and vice versa For example if the node Swould have three keys from GK1½i and two keys fromGK2½i GCH½i would not let GK1½i know that S would haveany keys from GK2½i Such an arrangement limits the abilityof GK1½i and GK2½i if captured by an adversary tomanipulate the nodes of Ci Based on the EBS matrix thatGCH½i has formed and the keys each of GK1½i and GK2½i hasgenerated the command node sends to GCH½i the keysKSCH of all sensors in its cluster and forwards to GK1½i andGK2½i the keys KSKey of all sensors that are supposed toknow the administrative keys they generate Thus GCH½iwould know the key combinations of each node in itscluster without generating the keys themselves and wouldknow only one of the preloaded sensor keys On the otherhand GK1½i and GK2½i would know the second prelaodedand the administrative keys for each sensor in Ci The goalof such partitioning is to prevent a single gateway frommanipulating the sensors of a particular cluster as we laterelaborateAnother approach is to have each key generatinggateway generate the entire set of k+m EBS keys thenhave the sensor key generated based on the keys collected870 IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS VOL 17 NO 8 AUGUST 2006from the gateways A threshold-based t-out-of-n approachwill work in this case This approach however may bemore taxing on the limited resources of the sensor nodeKey distribution Upon generation of the keys eachsensor node is informed about the set of administrative keysthat it was assigned The following steps are repeated foreach cluster i:1 GK1½i constructs one message per individual admin-istrative key for each sensor Sj 2 Ci which issupposed to know that key The message isencrypted by KSKey½Sj and further encrypted byKGK1½i;GCH½i before being sent to GCH½i2 GCH½i decrypts the message Since GCH½i does notknow KSkey½Sj it cannot reveal the administrativekey that GK1½i had included in the message GCH½ithen encrypts the contents using keys KSCH½Sj andsends it out to the sensors in its cluster This isrepeated for every sensor in cluster “i” The recipientsensor Sj would use both of its preloaded keys touncover its administrative keys3 Steps 1 and 2 above are repeated for GK2½i4 GCH½i generates a communication key CK1½i ormultiple of them for its cluster and informs gate-ways GK1½i and GK2½i about it GK1½i and GK2½i inreturn generate messages that contain the CK1½iencrypted with the administrative keys for cluster“i” that they have generated These messages arethen sent back to GCH½i encrypted by the corre-sponding intergateway keys GCH½i will decryptthese messages and broadcast the contents to thesensors of its clusterIt is worth noting that if the link layer imposes someconstraints on the packet size a message can be furtherpartitioned For example instead of sending 10 administra-tion keys in one packet we can send them using twopackets and add an indicator in the message to alert thesensor about the total number it should expect (eg keys 1-5 out of 10 etc) The same can be applied to the exchange ofan EBS matrix between two gateways eg by sending onerow or a column at a time It is also important to note thatthe intergateway overhead is linear in the number ofgateways and is mainly dependant on the network size andthe choice of K and M333 Normal Network OperationAt the end of the network bootstrapping phase thegateways would have received their intergateway keysand generated the cluster communication keys In additionthe sensors would have their respective administrative keysas well as communication keys required for exchanginginformation All data messages either originating at anysensor or being relayed by a sensor are to be encryptedwith a communication key Sharing same data encryptionkeys among the nodes in the cluster would facilitate dataaggregation and dissemination This enables secure in-network processing which has been reported in [40] as alimitation of other key management schemes such as [8] [9][38] [39] During normal network operation the keymanagement scheme will be invoked in case of rekeyingor the accommodation of new nodes Handling of compro-mised nodes follows in the next sectionKey Refresh The keys used in the network areperiodically refreshed in order to thwart on-going crypta-nalytic attacks We emphasize that the rekeying procedurewould not involve the command node To refresh commu-nication key(s) the cluster head GCH½i sends the newcommunication key(s) to GK1½i and GK2½i which encryptthem using the administrative keys of the sensors andresend the encrypted message to GCH½i for further deliveryto the sensors of the cluster Needless to say that interactionbetween GCH½i and GK1½i and GK2½i are secured throughthe use of their respective intergateway keys The admin-istrative keys of the cluster can also be changed in thefollowing way: Gateways GK1½i and GK2½i generate newadministrative keys and encrypt them with their respectiveolder counterpart These messages can then be encryptedwith the intergateway keys and sent to GCH½i GCH½idecrypts these messages and broadcasts to the sensors in itscluster It is worth noting that GCH½i will not be able touncover the new keys since it does not know the currentones The refresh procedure is illustrated in Fig 2Addition of New Sensors At times the application maydemand a more vigorous sensing of the environment or anextension of the area being sensed In such scenarios newsensors are usually added to the network To support theinclusion of the new nodes the command node first notifiesthe gateways that sensors are being deployed to boostcoverage and informs the gateways of the Ksg to be usedThe new sensors broadcast discovery messages containingtheir IDs and locations encrypted with Ksg The gatewayswill decide among themselves on the cluster that the sensorshould join Once the new sensors are discovered andassigned to a cluster every gateway that has new memberswill assign key combinations to these sensors and notify thecommand node of the sensor’s ID The command node willauthenticate the sensor’s identification since it has a list ofall valid IDs in the system as well as IDs of all evictedsensors Hence the command node will only authenticatevalid and unused sensor IDs Upon certifying the authen-ticity of the added nodes the command node will informGCH½i GK1½i and GK2½i about KSKey and KSCH of the newYOUNIS ET AL: LOCATION-AWARE COMBINATORIAL KEY MANAGEMENT SCHEME FOR CLUSTERED SENSOR NETWORKS 871Fig 2 Procedure of refreshing the communication key(s) of a clustersensors in every cluster “i” for all clusters that have newsensors GCH½i GK1½i and GK2½i will then repeat the keydistribution steps of Section 332 for the new sensors Fig 3illustrates the basic protocol for node addition In case thatthere is no key combination available the gateway has toincrease the number of administrative keys for the clusterThe reader is referred to [15] for description of expandingan EBS Such scenario is unlikely unless the m and kparameters are not carefully selected The availability ofunused key combinations can also be a factor during theassignment of sensors to a cluster If all key combinationsfor a cluster are assigned to nodes that cluster may not getselected to host the added sensor34 Attack/Failure MitigationKey revocation procedures are involved after detectingcompromised or faulty nodes The gateway is responsiblefor monitoring sensors’ behavior/health and detecting theirfailure or compromise The command node is expected todo the same for the gateways In this paper we assume thatthere is an appropriate compromise detection mechanismemployed at the command and gateway nodes We do notdistinguish the handling of a failure and a compromiseFrom the key management point of view supportingrevocation operations is sufficient In this section wediscuss the handling of node failure/compromise341 Gateway CompromiseWe assume that the compromise or the failure of thegateway will be detected by the command node Onidentifying a compromised gateway the command nodenotifies all gateways to relinquish the intergateway keysthey share with the compromised gateway Recovery from acompromised gateway can be handled by either deployinga new gateway or by redistributing the sensors of thecompromised gateway’s cluster among the remaininghealthy/uncompromised gateways The choice of themethod to be used may depend on the application and/orthe position of the new gateway These two methods arediscussed below: Deploying a replacement If it is feasible to replacethe faulty or compromised gateway Gi with anotherthat has compatible capabilities in terms of compu-tational resources and transmission range theexisting node-to-clusters association is not impactedand the recovery procedure simply would be aregeneration and redistribution of keys for all nodesin Ci Upon deploying the new gateway thecommand node establishes keys for communicationbetween existing gateways and such a newlydeployed one Then the command node instructsthe new gateway to form a new EBS matrix andrepeat the initialization process generate adminis-trative keys for other clusters and repeat the keydistribution process of Section 332 above Thatmeans for every cluster j 6¼ i for which the Gevicted(where Gevicted is the compromised gateway belong-ing to cluster i) is either GK1½j or GK2½j a new set ofadministrative keys needs to be generated for cluster“j” Given Gevicted’s knowledge of only KSKey forsensors in cluster “j” it cannot manipulate themAlso since the intergateway keys are changed toisolate the evicted gateway Gevicted cannot interferewith the recovery process Sensors Redistribution Once a gateway is compro-mised sensors belonging to its cluster are calledorphaned sensors In case the deployment of a newgateway is infeasible we choose to redistribute theorphaned sensors among the remaining healthygateways Redistribution of the sensors is done inthe following way:a The command node generates new Ksg keys tomatch the keys that the sensors generated afterthe completion of the former discovery processThe healthy gateways are then notified with thenew Ksg It is worth noting that the use of a newsensor discovery key that is unknown to thegateways helps in preventing a compromisedgateway from disrupting the network by erro-neously initiating a discovery phaseb The healthy gateways will trigger a sensordiscovery phasec Each orphaned sensor is associated to a gatewayaccording to the cluster criteria eg geographi-cal proximityd The gateways with newly added sensors willperform the procedure for adding new nodesIf a replacement gateway is pursued and it is notreachable to the sensors of the affected cluster a recluster-ing and redistribution of fresh keys would be necessaryThe initialization protocol described in Section 33 will bethen applied Table 3 lists the potential threats of a gatewaycompromise and how SHELL handles them342 Sensor CompromiseWe assume that every gateway can detect the failure orcompromise of a sensor in its cluster In case of a sensorcompromise/failure the data keys of the entire cluster willhave to be changed This is done so that the adversarycannot decrypt future messages of the network Since GCH872 IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS VOL 17 NO 8 AUGUST 2006Fig 3 Addition of a new node to a clusterknows the EBS matrix for the cluster it can decide whichkeys need to be redistributed and which keys can be used toencrypt the new keys The EBS-based rekeying procedure isapplied to evict the compromised sensors similar to theexample of Section 31 Node eviction is illustrated in Fig 4and is performed as follows:1 Assume node S in cluster i must be evicted SinceGCH½i knows the EBS matrix of its cluster itdetermines the keys that S knows These keys mustbe replaced2 GCH½i informs GK1½i and GK2½i of the keys that needto be redistributed3 GK1½i and GK2½i will generate the new keys andencrypt them with the old keys This rekey messageis then encrypted with the keys that the evicted nodedoes not know4 GK1½i and GK2½i then send these messages to GCH½iafter having encrypted them with the intergatewaykeys KGK1½i;GCH½i and KGK2½i;GCH½i respectively5 The cluster head GCH½i decrypts the messages andbroadcasts the new administrative keys to thesensors in the cluster (note the cluster head cannotdecipher the new keys since it does not know thecurrent ones)4 COLLUSION PREVENTIONEBS-based key management can be prone to collusionattacks [16] Two nodes collude when they share their keyswith each other In other words colluding nodes wouldgrow their knowledge about the network security measuresIn SHELL keys are reused in multiple nodes and only keycombinations are unique Therefore it is conceivable thatfew compromised nodes can collude and reveal all the keysemployed in the network to an adversary Such a scenario isconsidered as capturing the entire network since theadversary would be capable of revealing all encryptedcommunications in the network Optimal assignment of keycombinations to nodes so that the scope of collusion isprevented from widening to the level of capturing thenetwork is a classical resource allocation problem and isthus NP-hard in nature In this section we present anefficient heuristic for key assignment that reduces theprobability of capturing the network SHELL exploits thephysical proximity of nodes so that a node would sharemost keys with reachable nodes The main idea is toincrease the number of nodes that need to be compromisedfor revealing all the employed keys In the next section weanalyze the potential for a collusion attack to lead tonetwork capture and develop a metric for quantifying suchpotential Section 42 builds on this analysis and presents akey assignment algorithm that increases the networkresilience to collusion41 Probability of Capturing the NetworkWe define a neighborhood of a node S1 as all those nodeswhich are in the transmission range of S1 In order tocollude two nodes must be in the transmission range of oneanother otherwise they have to collude through a thirdparty According to the attack model of Section 21collusion is most likely to occur when two neighboringnodes are compromised The compromise of a node impliesthat the node has been captured by an adversary and can beYOUNIS ET AL: LOCATION-AWARE COMBINATORIAL KEY MANAGEMENT SCHEME FOR CLUSTERED SENSOR NETWORKS 873TABLE 3Analysis of the Threats of a Gateway Compromise and Actions to Counter ThemFig 4 Procedure for evicting a faulty or a compromised nodemanipulated Thus when two nodes in the same neighbor-hood are compromised they may be manipulated tocollude As a result of collusion the two colluding nodeswould each know their own keys as well as the keys of thenode it has colluded with Collusion is transitive in natureIf S1 is a neighbor of S2 S2 is a neighbor of S3 and S1colludes with S2 the resultant keys known to both of themwould be KeysðS1Þ [KeysðS2Þ Thereafter if S2 and S3collude the keys known to S2 and S3 would beKeysðS1Þ [KeysðS2Þ [KeysðS3Þ Thus it can be seen that ifmultiple nodes collude they are likely to uncover allemployed keysIn an EBS system each key combination can berepresented in the form of bit strings of k 1’s and m 0’swhere k is the number of keys stored at each node and m isthe number of rekey messages required A value of ”1”indicates the node knows the corresponding key TheHamming distance between any two combinations isdefined as the number of bits that the two combinationsdiffer in Let d be the Hamming distance between a pair ofkey combinations The value of d is bounded by:2  d  2k k < m; ð1Þ2  d  2m m < k; ð2Þ2  d  kþm k ¼ m: ð3ÞWhen two nodes collude they both will know at leastd keys since d is the number of keys that they differ in Inaddition they will also know all the keys that are commonto both nodes The common keys are equal to k d=2 Thuswe get the number of keys known to the two colludingnodes as kþ d=2 This leads us to the conclusion that thelower the Hamming distance (the value of d) is the fewerthe total number of potentially revealed keys will be This isillustrated with the help of the following exampleConsider three nodes with the following key combina-tions:S1 : 1001100 S2 : 1001010 S3 : 0110001Hamming distance between S1 and S2 ¼ 2Hamming distance between S1 and S3 ¼ 6If S1 and S2 colluded they would both have a keycombination 1001110If S1 and S3 colluded they would both have a keycombination 1111101Therefore collusion of S1 and S3cause more keys to be uncovered than the collusion of S1and S2Since EBS is based on the distinction between the keycombinations assigned to nodes rather than the keysthemselves a minimum of two nodes would be requiredto collude in order to reveal all keys used in the system anda maximum of N nodes will be required when every nodeknows just one key Even though the idea of every nodestoring just one key seems attractive in terms of increasingthe resilience of the network having the parameter k ¼ 1leads to numerous rekey messages which increases theoverhead for the network and is therefore not a desirableoption Therefore if “p” is the probability that a node can becompromised the probability “P” for capturing a networkof N nodes would be (assuming statistical independence):p2  P  pN We define a collusion chain to be the transitive closure ofa set of colluding nodes so that the union of assigned keysincludes all the kþm keys of the network For example inFig 5a although node 1 and node 3 have been compro-mised they cannot collude since node 2 is an uncompro-mised node and there is no direct communication linkbetween nodes 1 and 3 However in Fig 5b all three nodeshave been compromised and we have a collusion chainTherefore it is essential that the key combinations beassigned in a careful manner so that the cardinality (length)of the collusion chain increases Long chains will decreasethe probability of capturing the network (If x nodes arerequired in the collusion chain the probability that thenetwork is captured will be px Since p < 1 as x increases pxdecreases)Since two nodes cannot share their keys without being indirect communication range we exploit this requirement aswell as the location of nodes when assigning keysWe assignkey combinations to neighboring nodes such that combina-tionshavinga lowerHammingdistanceareassigned tonodesthat are physically closer to each other The advantage gainedby this assignment scheme is that even if these nodes colludethey will not have knowledge of all the keys in networkFurther collusions will be required to unveil all the keyswhichwould lower the probability of capturing the networkas we explained above42 Key Assignment ApproachIn this section we present a novel approach for diminishingthe probability of network capturing through collusionamong compromised nodes Before presenting our algo-rithm we formulate the assignment problem and analyzeits complexity421 Problem FormulationPer the EBS methodology we need to pick for each of theN nodes in the cluster a unique combination of “k” out of aset of kþm keys where k is the number of keys stored ateach node and m is the number of rekey messagesAssuming that the physical location and transmission rangeof all nodes are known the approach exploits the reasoningexplained earlier while assigning keys to nodes Nodes thatare in such a close physical proximity that make them in thereachable communication range of each other are assignedkey combinations with a lower Hamming distance thanthose that are far apart In other words we try to increasethe required number of colluding nodes for capturing thenetwork874 IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS VOL 17 NO 8 AUGUST 2006Fig 5 (a) Nodes 1 and 3 do not collude since they are not in directcommunication range (b) Nodes 1 2 and 3 can collude since they arein direct communication rangeWe represent the assignment problem as a graphGðV ;EÞ where V is the set of N nodes and E representsthe set of edges An edge is said to exist between two nodesif the nodes are in communication range of one another inwhich case we refer to them as neighbors Each edge isassigned a weight which is equal to the Euclidean distancebetween the nodes at each end of the edge The goal is toassign a unique key combination to each node such thatneighbor nodes are assigned combinations with the smallestmutual Hamming distances Edge weights are used toprioritize the neighbors Close neighbors are favored forlower Hamming distance combinations since they generallystay reachable for long time compared to further neighborswhose reachability may deteriorate over time due toincreased noise battery exhaustions or even the placementof obstaclesPerforming such key assignment can be modeled as aregister-allocation problemwidely considered in optimizingcompilers [20] The goal is to keep the most live variablesstored in registers inorder to expedite theprogramexecutionTypically variables aremodeled as vertices Two vertices areconnected by an edge if they represent live variables Whenpossible distinct registers are assigned to connected verticesso that overwrite is avoided and access to live variables fromthe nonregister memory is minimized In our case an edgeexists between two nodes if they are in the communicationrange of each other and key combinations with the smallestHamming distances are to be assigned to connected nodes inorder to minimize the probability of network capturing Theregister allocation problem is a knownNP-hard problem [20]and therefore we pursue a heuristic approach aswe explainnext422 Key Assignment AlgorithmWe propose an algorithm that strives to optimize the keyassignment locally and proceeds in a greedy fashion tocover the entire network For every combination KCa ofk keys we calculate the Hamming distance dab to everyother combination KCb ie 8b dabja 6¼ b & b 2 Cðmþ k; kÞWe then sort these combinations (ie KCb 8b) in anondecreasing order of the calculated Hamming distances(dab) The problem can now be stated as “given the keys of anode ‘i’ assign key combinations to the nodes f8 jjði; jÞ 2Eg picked in an ascending order of their Hammingdistance” That is we start assigning the key combinationwith the least Hamming distance and so on Since weemploy homogenous key combinations ie every combi-nation has k 1’s and m 0’s the Hamming distances will bebounded by (1) (2) and (3) given earlierThe algorithm starts with the node having the largestnumber of neighbors designating it as a root andproceeds ina breadth first manner After assigning a key combinationCKroot to the rootwe identify thenodes that are reachable to it(its neighbors) and assign some unused key combinationsthat have the least Hamming distance to CKroot As wementioned earlier closer neighbors are favored for combina-tions that has the least Hamming distances to CKrootSubsequently for every node that has not been visited thenode’s neighbors are identified and key combinations areassigned to eachof themAnalogous to graphswe refer to theneighbors of a node under consideration as its children Eachtime a key combination is assigned to a node we try to assignkeys in such a way that the Hamming distance to the keycombination of the node’s parent is minimal needless to saythat every node is assigned a unique key combinationVery often two nodes may share the same parent and beneighbors to each other at the same time In this case thekey assignment has to be done carefully SHELL calls forassigning key combinations to the nodes so that not only theHamming distances between the parent and the childrenare minimized but also those between any two childrenthat are connected with an edge This is done by eitherselecting another unused combination that satisfies theabove condition or by swapping the key combinationsbetween the node under consideration and any previouslyassigned combinations Since this can lead to potentiallytrying all combinations and making the assignment heur-istics lean toward an exhaustive search we limit theswapping to sibling nodes Such restriction is logical sincewe pursue a breadth-first ordering and the impact of keyassignment to one node will be limited to those nodes thatare on the same level or one level above in the parsinghierarchy [21] Again a swap is accepted only if it does notincrease the Hamming distance between the key combina-tion of the node chosen for swapping and the key sets of allits neighbors Thus SHELL tries to minimize the maximumHamming distance between any two combinationsThe swappingprocess is applied first to a child node and ifit turns to be unsuccessful swapping the keys of parent node(that is being visited) is tried Preference would be given toswapping with a neighbor sibling that matches the visiting/nonvisiting status of the childnodeunder consideration Twoneighbor nodes thatwere visitedmost probablywouldhavebeen assigned key combinations with the least possibleHamming distance Thus swapping the keys of these visitedneighbors has a high potential of being acceptable On theother hand it is better for nonvisited nodes to be swappedwith nonvisited siblings especially neighboring ones sincethe scope of the validation of such swappingwill be limited totheir parent in the parsing tree It should be noted that a nodewhose keys were swapped before with the same node ismarked as ineligible for considerationWhen a suitable swapis not possible an unused key combination with the leastpossible Hamming distance is picked In the balance of thediscussion we will illustrate the idea with an example Thepseudocode for the algorithm alongwith the definition of theused notation can be found in Appendix B (which can befound on the CS Digital Library at http://wwwcomputerorg/tpds/archiveshtm)Let us consider the scenario in Fig 6 For simplicity weassume all links span the same Euclidian distance Weemploy the EBS scheme with k ¼ 2 and m ¼ 3 Table 4 andTable 5 enumerate the possible key combinations and theirmutual Hamming distances Since the node A has thelargest degree (five links) we pick it as a root and assignKC1 to it Then nodes B C D E and F are assigned KC2toKC5 respectively and “A” is marked as visited Next weconsider node B and assign KC8 to G While the keys of Band C fit nicely B and F do not since the HammingYOUNIS ET AL: LOCATION-AWARE COMBINATORIAL KEY MANAGEMENT SCHEME FOR CLUSTERED SENSOR NETWORKS 875Fig 6 An example of an 8-node network with an assumed equal linklengthdistance between KC2 and KC6 is high Because KC7would not make things better we look for a swap Sincenode F has not been visited yet we can swap its keys witheither node C D or E all of whom have a Hammingdistance of 2 to the keys of B Let’s just pick E Thus Fswitches to KC5 and E gets KC6 It is now the turn fornode C for which the combinations assigned to itsneighbors B and D are perfect Node H is assigned KC10Node D has neighbors C and H with key combinations ofHamming distance of 2 However the Hamming distance tothe keys of the other neighbor E is 4KC7 is a perfect matchfor E since it fits nicely with node A andD When visiting Eno action is to be taken Finally node F is visited with all itsneighbors having good key combinations (each with aHamming distance of 2 to KC5) A pictorial illustration ofthe described steps is shown in Fig 75 VALIDATION AND PERFORMANCE EVALUATIONWe implemented the key assignment algorithm using C++A network was simulated by assigning random positions tothe sensors and creating an adjacency matrix assuming thesame transmission ranges for all sensors We analyze theperformance of SHELL in terms of the network’s resiliencyto being captured and the energy consumption overhead Inthis section we discuss the validation experiments and theperformance results51 Collusion PreventionWe have performed two sets of experiments to study theeffectiveness of our key assignment procedure againstnetwork capture As explained in Section 4 the network issaid to be captured when all keys used in the WSN areuncovered by the adversary through colluding nodes Bothsets of experiments have been performed on a single clusterWSN deployed in an area of 500m 500m assuming atransmission range of 55m for all nodes In the first set weassess the potential of network capture through nodecollusion by determining the length of collusion chains Inthe second set we study the effect of the size ofcompromised nodes’ population These experiments arediscussed separately in the sections below511 Assessing the Potential for CollusionAs explained earlier SHELL strives to minimize thepotential for network capturing by extending the length ofcollusion chain necessary to reveal all keys In theexperiments once the keys are assigned we check for theshortest collusion chain in the network Basically we startchecking the potential of a node colluding with eachindividual node in its neighborhood We repeat this stepfor every node in the network generating all possiblecollusion sets of two nodes We check whether any setwould have gained knowledge to all keys If not we repeatfor another iteration to form all possible collusion sets ofthree nodes We repeat these steps until a collusion chain isformed The length of the chain (number of iterations + 1)indicates the quality of the key assignment While thisprocedure is analogous to finding a route from a node toevery other node in the network the complexity is stillpolynomial in N and |E| In addition we stop when allkeys are known to a set of colluding nodes which usuallyhappens after a few iterations It should be noted that wefinish when all used not all possible keys in the network arerevealed This is important for small networks for whichonly a subset of the keys are assigned to nodes We willrevisit this point when we discuss the experimental resultsThe implementation of the described collusion assess-ment procedure is significantly simplified by the represen-tation of key combinations as a bit vector Two nodescolluding would mean that they collectively have knowl-edge of the keys known to each of them and thus can beperformed by a logical OR operation of the two vectors Thepseudocode for the collusion assessment procedure can befound in Appendix C (which can be found on the CS DigitalLibrary at http://wwwcomputer org/tpds/archiveshtm)Analysis of Results We ran experiments for varyingnumber of nodes in the system and observed how thesystem performs for different values of k and m Each set ofreadings was averaged over 10 test runs For each run adistinct seed is applied to generate a random networktopology We observed that with 90 percent confidencelevel the simulation results stay within 6-10 percent of thesample meanWe have chosen the k and m values such that the sum ofkþm is constant Table 6 shows the possible key combina-tions for different values of k and m The results plotted in876 IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS VOL 17 NO 8 AUGUST 2006TABLE 4Canonicalð2; 3ÞTABLE 5Mutual Hamming Distance among KCsFig 7 Illustration for how the algorithm is appliedFig 8 show the relation between different values of k andmand the corresponding number of nodes required in thecollusion chain for capturing the network As indicated kþm ¼ 10 and the number of nodes in the network varies from20 to 200 The right vertical axis reflects the length of thecollusion chain while the left vertical axis indicates the totalnumber of keys with “k” reported in the bottom part of thebar The experiments were repeated using random assign-ment of keys to nodes The results of such random allocationof keys are plotted in Fig 9 and are used as a baseline forcomparisonIt should be noted that for small networks and largenumber of key combinations SHELL tends to use the leastnumber of keys since it minimizes the Hamming distancesamong neighbors In the experiment we have consideredthe network to be captured when the set of “employed”keys are revealed which may not be all the allowed kþmkeys For example in Table 6 for k ¼ 4 there are210 different combinations However only 20 of these areassigned to nodes in case of a 20 node network Whenapplying SHELL only seven distinct (out of the 10) keyswere employed We also like to clarify that for largenetworks it is infeasible to use small values of k sinceinsufficient number of key combinations would be avail-able Based on Fig 8 and Fig 9 the following observationscan be made:1 SHELL consistently outperforms the random assign-ment and is distinctly more superior for smallk values To illustrate let us consider the case fork ¼ 4 N ¼ 120 Our approach achieves a collusionchain length of 11 nodes compared to three when arandom assignment is pursued For a probability ofa node compromise “p” of 01 the worst-case (best-case for an attacker) probability of capturing thenetwork using SHELL is lower by a factor of 10162 For a given number of nodes as the k value increasesthe number of hops required to collude is observed todecrease This is in agreement with the analyticalreasoning since uncovering all keys in the networkwould need the collusion of a fewer number ofcompromised nodes when the number of keys pernode increases (while keeping the kþm constant) Inother words the union of a fewer number of keycombinations will yield all the keys in the systemHowever SHELL makes this less threatening com-pared to the random key assignment3 As the network size grows Fig 8 indicates that thelength of the collusion chain increases in most caseswith one exception corresponding to the 200-nodesnetwork For small networks eg 20 40 and80 nodes a boost in the number of nodes wouldincrease the number of distinct keys employed bySHELL and thus would have a positive impact(recall our earlier note regarding the tendency ofSHELL in using the least number of distinct keys forsmall networks) However a significant enlargementof the network can have a negative effect since mostkey combinations would have to be assigned tonodes and our key assignment heuristics becomesomewhat constrained For example when increas-ing the network size from 120 to 200 nodes thelength of the collusion chain went down from 11 tofive when k ¼ 4 and from five to four when k ¼ 54 The results of Fig 9 show that a random keyallocation in contrary to SHELL does not takeadvantage of small networks in doing a better job incollusion prevention It is conceivable that thenetwork will be captured by as little as twocompromised nodes5 The results also can be insightful in determining thek and m parameters for the EBS scheme Whilecontemporary system design issues such as storagecommunication-related energy consumption andfrequency of rekeying are usually considered theimplication of the choice of k and m on the networkresilience to collusion attacks can lead to a trade-off512 Effect of Size of Compromised Nodes’ PopulationIn the second set of experiments we tried to capture thenumber of times the adversarywouldhave been successful incapturing thenetwork The experimentswereperformedonaYOUNIS ET AL: LOCATION-AWARE COMBINATORIAL KEY MANAGEMENT SCHEME FOR CLUSTERED SENSOR NETWORKS 877TABLE 6Possible Number of Key Combinations forDifferent Values of k and mFig 8 The length of the collusion chain for different “k” with kþm ¼ 10while using SHELL and for different networks sizesFig 9 The length of the collusion chain for different “k” with kþm ¼ 10under random key assignment and for varying networks sizesnetwork of 100 nodes again deployed in 500 500 metersarea and setting a transmission range of 55 meters The k andm parameters were chosen as 3 and 7 respectively We haverandomly picked a set of compromised nodes and checked tosee if they could successfully collude to uncover all the keysused in the system We ran the simulation for differentnumbers of compromised nodes The experiments were run100 times using both our key assignment and the randomkeyassignment methods We then counted the number of timesthe network was captured in both cases The results areshown in the Fig 10From the figure we can see that the number of times thenetwork was captured under the random key assignmentapproach is greater than the number of times it wascaptured using SHELL When the number of compromisednodes is few SHELL increases the resilience of the networkby at least a factor of two compared to the case of randomassignment of keys As more nodes are compromised thegain starts to decline since it becomes more difficult todefend the network under such an intense and large-scaleattack It is worth noting that similar effect was observedwhen the goal of the attacker was altered to be uncoveringonly a subset of the networks keys and SHELL continued todemonstrate significantly more resilience than a randomassignment52 Energy ConsumptionAlthough security is an important issue in sensor networksit is necessary to ensure that the security protocol does notweigh heavily on the scarce energy resources of the sensornodes Through SHELL we have tried to provide an energyefficient security solution We assume an efficient under-lying encryption scheme such as XTEA [46] or RC6 [47]that incurs negligible computational cost (as compared tokey communication cost) In the results discussed belowwe report the average energy consumed during keymanagement the energy overheads due to each stage ofthe protocol and the distribution of energy consumed bythe sensor nodes We compare SHELL to two securityprotocols The first is the Kerberos protocol [22] and thesecond is a low energy key management protocol [22]proposed by Jolly et al Kerberos is a trusted third partyscheme and requires to establish keys for every sessionJolly et al pursues a predeployed keying strategy usingpreloaded sensor keysWe used the environment of [23] which simulates theoperation of a sensor network in target tracking applicationThe cluster head manages the tasking of sensors and therouting of data We have instrumented traces in the sourcecode to capture the energy consumption related to thesecurity related activities We have considered the energyconsumed by gateways as well as that consumed by thesensors The command node’s energy is assumed tounlimited and therefore not considered in our analysisThe simulation parameters used are shown in Table 7 Inthe experiments we have considered a network with sevenclusters and number of nodes varying from 500 600 700800 and 900Fig 11 reports the average energy consumed by thesystem under normal operation To measure the energyoverhead we have considered energy consumed by thesensors as well as the gateways in transmission andreception during the entire simulation runtime It isimportant to include the gateway’s energy to compare thevarious schemes in a comprehensive way; especially whennoting that the approach of Kerberos performs all keymanagement by a trusted third party As depicted in Fig 11the average energy consumed by SHELL is in the order of20J whereas it is about 50J for the scheme of Jolly et alThe energy consumed by Kerberos is significantly higher(approximately 200J) The approach of Jolly et al involvesmore message exchange than ours during key renewal aswell as revocation phases Kerberos uses a trusted thirdparty and therefore not very energy efficient It is worthnoting that the number of keys in SHELL grows logarith-mically with an increase in the sensors’ population andthus for large networks the size of the EBS matrix does notgrow much Such property causes the overhead to increaseat a much lower rate (note that per node overheaddecreases as the network size grows) The same is also truefor increasing the number of gateways while fixing thenumber of sensors because the number of keys required percluster is reduced and the EBS matrix shrinks in size878 IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS VOL 17 NO 8 AUGUST 2006Fig 10 The number of times during 100 runs the network wascaptured due to collusion for varying levels of node compromisesTABLE 7List of Simulation Parameters UsedFig 11 Comparative average energy consumption in the networkFig 12 shows the energy consumed by each stage of theprotocol namely the bootstrapping the key renewal andthe gateway eviction phases as a percentage of the totalenergy consumed The total energy represents the energyconsumed by sensors and gateways for the specifiedduration of the simulation and includes both the energyoverhead due to the security protocol and energy consumedin normal network operation eg data routing The energyconsumed during key renewals represents the aggregateenergy consumed during all key renewal phases (keys arerefreshed periodically) Although a gateway eviction is notpart of the normal operation of the network we simulatedan attack on the gateway wherein the gateway iscompromised As explained in Section 3 we can recoverfrom gateway’s failure by using one of the two approaches:1) deploy a new gateway and 2) redistribute sensors of theevicted gateway During the experiment the approach usedwas decided by the position of a randomly deployed newgateway If the new gateway was within a certain range ofthe old gateway it was selected; otherwise the sensorswere redistributed The energy reported in the gatewayeviction phase represents the energy consumed in recover-ing from gateway compromisesFig 12 also indicates that the energy consumed duringbootstrapping is almost the same for SHELL as well as Jollyet al’s During the bootstrapping phase the energyconsumed is mainly in the gateway registration phasesand the sensor’s announcements These procedures arepresent in both schemes and therefore they consume almostthe same amount of energy On the other hand SHELLconsumes considerably lower energy during key renewalsand in recovering from gateway failure In SHELL keyrenewal is a matter of a single message from the keygenerating gateways to the cluster-head and the broadcastof this message to the sensors of the respective clusterwhereas in Jolly et al’s the new keys are generated by thecommand node and pushed to the gateways which furthertransmit these to the sensors of each cluster Also the lengthof the rekey messages is much smaller in our caseIt should be noted that the energy consumed in renewalphase reported in Fig 12 does not represent a single keyrenewal but is the energy consumedduring all key renewalsThe frequency of key renewals can be altered to trade offsecurity versus energy consumed In Jolly et al [22] recoveryfromagatewaycompromise isdone inamanner similar to thekey renewal procedure used by them whereas SHELL eitheradds a new gateway or redistributes the sensors of theevicted gateway’s cluster Adding a new gateway is notenergy consuming since it is similar to key refreshingHowever redistributing the sensors requires the key estab-lishment procedure to be repeated as in initial key establish-ment and therefore consumes considerably more energySince the choice of approach is decided at runtime the energyconsumed is averaged out during the 10 experiments It mustbe noted that we report here the average energy consumedduring gateway eviction6 RELATED WORKGroup key management schemes can be classified ascentralized decentralized or distributed [24] Examples ofcentralized schemes are Group Key Management Protocol(GKMP) [25] Logical Key Hierarchy (LKH) [26] [27] One-way Function Chain Tree (OFCT) [28] and Efficient LargeGroup ELK [29] Examples of decentralized group keymanagement schemes are MARKS [30] and Kronos [31]while examples of distributed protocols include ConferenceKey Agreement CKA [32] and Distributed LKH [33] Theobjective of most of these protocols is to balance commu-nications with storage ELK and Kronos also attempt tobalance security and efficiency by using small-size hintsand batch rekeying respectively A major drawback thathampers the use of most of these group key managementprotocols in WSNs is the lack of support for faulty andmisbehaving nodes and the overhead incurred to supportkey management activities including setup and rekeyingQuite recently the Hybrid Key Tree (HKT) scheme wasproposed in [34] to balance security and efficiency using atwo level hybrid key tree HKT has a sublinear storagecomplexity at the controller due to the use of clustersCluster sizes are adjusted to resist collusion Another effortis reported in [16] proposing an EBS-based key manage-ment solution for ad hoc networks with collusion resistanceamong evicted nodes However their work does notconsider collusion among active nodes currently in sessionSimilar to [16] [17] [34] The scheme presented in thispaper SHELL is also based on key management using EBSDistinguishing features of SHELL are the use of nodeproximity in a WSN to reduce the probability of collusionand the decoupling and partitioning of the keying functionsamong multiple nodesReliance on a trusted third party (key server) todistribute the cryptographic keys has been the approachof systems like Kerberos [35] and SPINS [36] In Kerberosparties wishing to communicate are required to establish asecure session by requesting secret keys from a trusted keyserver Although Kerberos provides authentication its maindrawback is the reliance on a single trusted key serverwhich is not scalable for WSNs In addition Kerberosrequires secure key establishment for every session makingit energy-inefficient In the SPINS protocol the base station(the gateway) is assumed to be a trusted entity Any pair ofcommunicating nodes uses the base station as an inter-mediary for trusted communication and the key distribu-tion is achieved through one-to-one communications whichdoes not scale well SHELL splits the responsibility of keygeneration and distribution among multiple gatewayswhich provides scalability and prevents the manipulationof the network due to gateway compromiseRecently a number of key predistribution schemes havebeen proposed for WSNs [8] [9] [38] [39] [40] Eschenauerand Gligor [8] proposed a probabilistic key predistributionscheme inwhich akey ringofnkeys randomly chosen fromalargepool of keys is assigned to eachnode For any twonodesYOUNIS ET AL: LOCATION-AWARE COMBINATORIAL KEY MANAGEMENT SCHEME FOR CLUSTERED SENSOR NETWORKS 879Fig 12 Percentage of total energy consumed by each protocol’s stageto communicate they need to find a common key from theirkey rings If there is no key in common intermediate nodeshave to be involved This idea has been extended by Chanet al [9] by proposing three new schemes for key predis-tribution in order to increase the network’s resiliency to nodecapture Further Liu et al [38] exploited the use of nodelocation in key selection Another effort by Du et al [39]presents a key predistribution approach in which theprobability that nodes other than the ones already compro-mised will be affected is close to zero if the number ofcompromised nodes is less than a threshold However keypredistribution schemes do not provide rekeying capabilitiesand theymay impede in-networkprocessingwhich iswidelypursued in WSNs to reduce communications traffic andconserve network resources [40]Another class of key management schemes is based onthreshold secret sharing For example in the MOCAframework [41] some mobile nodes (known as MOCA)within the network are designated to act as a distributedcertification authority A locality driven key managementscheme based on the principles of threshold cryptographyhas also been proposed in [42] This scheme uses a numberof mutually trusting certification authorities each of whichprovides authentication for its own community Mean-while the key establishment scheme of [43] is based on theprinciples of probabilistic key sharing and threshold secretsharing The proposed scheme is distributed in nature andis secure against collusion up to a certain number of nodesThreshold-based cryptographic solutions generally incurhigh communication and computation overhead and thusmay not be suitable for WSNsTo optimize the resource requirement for key manage-ment in WSNs Jolly et al [22] proposed a low energy keymanagement scheme that is based on the Identity-BasedSymmetric Keying scheme [5] Although their approachrequires very few keys to be stored at each node therekeying procedure is inefficient due to the higher numberof messages exchanged for key renewals In addition theyrequire the command node to play a major role in keymanagement We significantly reduce the command node’srole in key management In [45] Park et al present LiSP alightweight security protocol for WSNs that makes a trade-off between security and resource consumption LiSPemploys a hierarchical keying protocol that providesefficient key distribution However LiSP relies on a trustedthird party for authentication between any two entities Ourscheme SHELL use a group key for communication andadministrative keys for distributing and renewing thegroup key periodically Moreover SHELL reduces the roleof a central base station and distributes the key manage-ment responsibility among multiple gateways therebyproviding higher fault and attack tolerance7 CONCLUSIONThe number of sensor network applications is expected togrow especially in fields ranging from healthcare towarfareIt is important to ensure the security of data obtained fromthese networks An essential component of any key-basedsecurity solution is managing the encryption keys in thesystem In addition to guarding the network against attacksand localizing the effect of node compromises key manage-ment in such vast resource-constrained networks should beefficient and scalable In this paper we have presentedSHELL a distributed key management scheme for clusteredsensor networks SHELL decouples the key managementfunctions and distributes them among multiple nodes in thenetwork in order to provide attack/failure resilient solutionsand avoid unbalanced utilization of network resourcesSHELL is hierarchical; allowing scalable multigranularitysecure communications SHELL is also efficient in resourceutilization SHELL is based on Exclusion Basis Systems (EBS)methodology for group keymanagement EBS eliminates theneed of storing a large number of keys at each sensor node Itfurther allows trading off the number of keys stored versusamount of network traffic due to the rekeyingoperations EBSsimplifies the addition and eviction of nodes and performskey refreshing through the exchange of few messagesHowever EBS-based schemes can be prone to collusionattacks Therefore we have introduced a novel heuristic forkey assignment that decreases the probability of capturingthe network through the collusion of compromised nodesSHELLexploits thephysicalproximityofnodes so that anodewould share most keys with reachable nodes and thus veryfew additional keys would be revealed when colludingSimulation results have demonstrated that SHELL signifi-cantly boosts the network resiliency to node capture whileconservatively consuming the network’s critical resourcessuch as energyFuture work will include further reduction of theinvolvement of the command node in key managementextending SHELL to handle more dynamic networktopologies for example due to mobility of gateways orintroduction of new gateways and mitigating more sophis-ticated attacks on sensors and gateways for examplemultihop node collusionREFERENCES[1] IF Akyildiz W Su Y Sankarasubramaniam and E Cayirci“Wireless Sensor Networks: A Survey” Computer Networks vol 38no 4 pp 393-422 Mar 2002[2] S Tilak NB Abu-Ghazaleh and W Heinzelman “A Taxonomyof Wireless Microsensor Network Models” ACM Mobile Comput-ing and Comm Rev vol 6 no 2 pp 1-8 2002[3] H Yang et al “Security in Mobile Ad-Hoc Wireless Networks:Challenges and Solutions” IEEE Wireless Comm Magazine vol 11no 1 pp 38-47 Feb 2004[4] L Zhou and ZJ Haas “Securing Ad Hoc Networks” IEEENetworks vol 13 no 6 pp 24-30 Nov/Dec 1999[5] D Carman P Kruus and B Matt “Constraints and Approachesfor Distributed Sensor Networks Security” Technical Report 00-010 NAI Labs Sept 2000[6] G Jolly M Kuscu P Kokate and M Younis “A Low-Energy KeyManagement Protocol for Wireless Sensor Networks” Proc EighthIEEE Symp Computers and Comm (ISCC ’03) June 2003[7] TinySec http://wwwcsberkeleyedu/nks/tinysec/ 2006[8] L Eschenauer and V Gligor “A Key Management Scheme forDistributed Sensor Networks” Proc Ninth ACM Conf Computingand Comm Security (CCS ’02) Nov 2002[9] H Chan A Perrig and D Song “Random Key PredistributionSchemes for Sensor Networks” Proc IEEE Symp Security andPrivacy May 2003[10] G Gupta and M Younis “Load-Balanced Clustering in WirelessSensor Networks” Proc Int’l Conf Comm (ICC ’03) May 2003[11] O Younis and S Fahmy “HEED: A Hybrid Energy-EfficientDistributed Clustering Approach for Ad Hoc Sensor Networks”IEEE Trans Mobile Computing vol 3 no 4 pp 366-379 Oct-Dec2004[12] K Langendoen and N Reijers “Distributed Localization inWireless Sensor Networks: A Quantitative Comparison” Compu-ter Networks vol 43 no 4 pp 499-518 Nov 2003[13] A Youssef A Agrawala and M Younis “Accurate Anchor-FreeLocalization in Wireless Sensor Networks” Proc First IEEEWorkshop Information Assurance in Wireless Sensor Networks (WSNIA’05) Apr 2005880 IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS VOL 17 NO 8 AUGUST 2006[14] M Horton et al “Mica: The Commercialization of MicrosensorMotes” Sensors Online Magazine http://wwwsensorsmagcom/articles/0402/40/mainshtml Apr 2002[15] M Eltoweissy H Heydari L Morales and H Sadborough“Combinatorial Optimization of Key Management in GroupCommunications” J Network and Systems Management vol 12no 1 pp 33-50 Mar 2004[16] M Moharram R Mukkamala and M Eltoweissy “TKGS:Threshold-Based Key Generation Scheme for Wireless Ad HocNetworks” Proc IEEE Int’l Conf Computer Comm and Networking(ICCCN ’04) Oct 2004[17] M Eltoweissy M Younis and K Ghumman “Lightweight Multi-Granularity Key Management for Secure Wireless Sensor Net-works” Proc IEEE Workshop Multihop Wireless Networks (MWN’04) Apr 2004[18] D Eastlake and P Jones “US Secure Hash Algorithm 1 (SHA-1)”RFC 3174 IETF Sept 2001[19] R Rivest “The MD5 Message-Digest Algorithm” RFC 1320 MITand RSA Data Security Inc Apr 1992[20] P Briggs K Cooper K Kennedy and L Torczon “ColoringHeuristics for Register Allocation” Proc ASCM Conf ProgramLanguage Design and Implementation June 1989[21] R Diestel Graph Theory second ed Springer-Verlag Feb 2000[22] C Neuman and T Ts’o “Kerberos: An Authentication Service forComputer Networks” IEEE Comm vol 32 no 9 pp 33-38 Sept1994[23] M Younis M Youssef and K Arisha “Energy-Aware Manage-ment in Cluster-Based Sensor Networks” Computer Networksvol 43 no 5 pp 649-668 Dec 2003[24] S Rafaeli and D Hutchison “A Survey of Key Management forSecure Group Communication” ACM Computing Surveys vol 35no 3 pp 309-329 Sept 2003[25] H Harney and C Muckenhirn “Group Key ManagementProtocol (GKMP) Specification” Report # RFC 2093 The InternetSoc (ISOC) 1997[26] D Wallner E Harder and R Agee “Key Management forMulticast: Issues and Architectures” Report # RFC 2627 TheInternet Soc (ISOC) Reston Va 1999[27] K Wong M Gouda and S Lam “Secure Group CommunicationsUsing Key Graphs” IEEE/ACM Trans Networking vol 8 no 1pp 16-30 Feb 2000[28] R Canetti T Malkin and K Nissim “Efficient Communication-Storage Tradeoffs for Multicast Encryption” Proc Conf Advancesin Cryptology (EUROCRYPT ’99) pp 459-474 1999[29] A Perrig D Song and J Tygar “ELK A New Protocol forEfficient Large-Group Key Distribution” Proc IEEE Symp Securityand Privacy May 2001[30] B Brisco “MARKS: Multicast Key Management Using ArbitrarilyRevealed Key Sequences” Proc First Int’l Workshop NetworkedGroup Comm Nov 1999[31] S Setia S Koussih and S Jajodia “Kronos: A Scalable GroupRekeying Approach for Secure Multicast” Proc IEEE SympSecurity and Privacy May 2001[32] C Boyd “On Key Agreement and Conference Key Agreement”Proc Information Security and Privacy: Australasian Conf 1997[33] O Rodeh K Birman and D Dolev “Optimized Group Rekey forGroup Communication Systems” Proc Network and DistributedSystem Security Symp 2000[34] C Duma N Shahmehri and P Lambrix “A Hybrid Key TreeScheme for Multicast to Balance Security and Efficiency Require-ments” Proc 12th Int’l Workshop Enabling Technologies: Infrastruc-ture for Collaborative Enterprises (WETICE ’03) June 2003[35] A Perrig R Canetti JD Tygar and D Song “EfficientAuthentication and Signing of Multicast Streams over LossyChannels” Proc IEEE Symp Security and Privacy May 2000[36] A Perrig R Szewczyk V Wen D Culler and JD Tygar “SPINS:Security Protocols for Sensor Networks” J Wireless Networksvol 8 no 5 pp 521-534 Sept 2002[37] C Karlof and D Wagner “Secure Routing in Wireless SensorNetworks: Attacks and Countermeasures” J Ad-Hoc Networksvol 1 nos 2-3 pp 293-315 Sept 2003[38] D Liu and P Ning “Establishing Pairwise Keys in DistributedSensor Networks” Proc 10th ACM Conf Computer and CommSecurity (CCS ’03) Oct 2003[39] W Du J Deng YS Han and PK Varshney “A Pairwise KeyPredistribution Scheme for Wireless Sensor Networks” Proc 10thACM Conf Computer and Comm Security (CCS ’03) Oct 2003[40] S Zhu S Setia and S Jajodia “LEAP: Efficient SecurityMechanisms for Large-Scale Distributed Sensor Networks” Proc10th ACM Conf Computer and Comm Security (CCS ’03) Oct 2003[41] S Yi and R Kravets “MOCA: Mobile Certificate Authority forWireless Ad Hoc Networks” Proc Second Ann PKI ResearchWorkshop (PKI ’03) Apr 2003[42] G Xu and L Iftode “Locality Driven Key ManagementArchitecture for Mobile Ad-Hoc Networks” Proc First IEEE Int’lConf Mobile Ad-Hoc and Sensor Systems (MASS ’04) Oct 2004[43] S Zhu S Xu S Setia and S Jajodia “Establishing Pair-Wise Keysfor Secure Communication in Ad Hoc Networks: A ProbabilisticApproach” Technical Report ISE-TR-03-01 George Mason UnivMar 2003[44] B Dutertre S Cheung and J Levy “Lightweight Key Manage-ment in Wireless Sensor Networks by Leveraging Initial Trust”SDL Technical Report SRI-SDL-04-02 Apr 2004[45] T Park and KG Shin “LiSP: A Lightweight Security Protocol forWireless Sensor Networks” ACM Trans Embedded ComputingSystems vol 3 no 3 pp 634-660 Aug 2004[46] RM Needham and DJ Wheeler “TEA Extensions” technicalreport Computer Laboratory Univ of Cambridge Oct 1997[47] R Rivest MJB Robshaw R Sidney and YL Lin “The RC6Block Cipher” Proc First Advanced Encryption Standard (AES)Conf Aug 1998Mohamed F Younis received the BS degree incomputer science and the MS degree in en-gineering mathematics from Alexandria Univer-sity in Egypt in 1987 and 1992 respectively In1996 he received the PhD degree in computerscience fromNew Jersey Institute of TechnologyHe is currently an assistant professor in theDepartment of Computer Science and ElectricalEngineering at the University of Maryland Balti-more County (UMBC) Before joining UMBC hewas with the Advanced Systems Technology Group an AerospaceElectronic Systems R&D organization of Honeywell International IncWhile at Honeywell he led multiple projects for building integrated fault-tolerant avionics in which a novel architecture and an operating systemwere developed This new technology has been incorporated byHoneywell in multiple products and has received worldwide recognitionby both the research and the engineering communities He alsoparticipated in the development the Redundancy Management Systemwhich is a key component of the Vehicle and Mission Computer forNASA’s X-33 space launch vehicle His technical interest includesnetwork architectures and protocols embedded systems fault tolerantcomputing and distributed real-time systems Dr Younis has fourgranted and three pending patents He served on multiple technicalcommittees and published more than 60 technical papers in refereedconferences and journals He is a senior member of the IEEEYOUNIS ET AL: LOCATION-AWARE COMBINATORIAL KEY MANAGEMENT SCHEME FOR CLUSTERED SENSOR NETWORKS 881Kajaldeep Ghumman received the BE degreein information technology from Sardar PatelCollege of Engineering Mumbai India in 2002and the MS degree in computer science from theUniversity of Maryland Baltimore County in2004 She is currently working as a softwareengineer with Symantec Corporation in Red-wood City California Her research interestincludes mobile ad hoc and sensor networksMohamed Eltoweissy received the MS and BSdegrees in computer engineering from Alexan-dria University Egypt in 1989 and 1986respectively and the PhD degree in computerscience from Old Dominion University in 1993He is an associate professor in The BradleyDepartment of Electrical and Computer Engi-neering at Virginia Tech He also holds acourtesy appointment in the Department ofComputer Science He is founder and directorof the Center for Cyber Assurance and Trust (CyCare) His researchinterests are in the areas of information assurance and trust networkingin large-scale unstructured and resource-constrained environmentsservice-oriented architectures and group communications He has morethan 85 publications in archival journals and respected books andconference proceedings Among his research contributions are novelcombinatorial-based survivable key management schemes for sensorand ad hoc networks service-oriented architecture for sensor networksand stochastic models for the optimization of security protocolsDr Eltoweissy is the guest editor of the special issue of Elsevier’sJournal of Computer Communications on Sensor-Actuator Networks(SANETs) He also is active in serving on program committees and USNational Science Foundation panels in journal editorials and organiza-tion of professional meetings He is a senior member of the IEEE and amember of the ACM ACM SIGBED and ACM SIGSAC He is also amember of Upsilon Pi Epsilon and Phi Kappa Phi In 2003 he wasnominated for the Virginia SCHEV outstanding faculty awards; thehighest honor for faculty in Virginia For more information on this or any other computing topicplease visit our Digital Library at wwwcomputerorg/publications/dlib882 IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS VOL 17 NO 8 AUGUST 2006
Survey of key managment-pdf,Key Distribution Mechanisms for Wireless SensorNetworks: a SurveySEYIT A C¸AMTEPE and BU¨LENT YENERRensselaer Polytechnic InstituteAdvances in technology introduce new application areas for sensor networks Foreseeable wide de-ployment of mission critical sensor networks creates concerns on security issues Security of largescale densely deployed and infrastructure-less wireless networks of resource limited sensor nodesrequires efficient key distribution and management mechanisms We consider distributed and hier-archical wireless sensor networks where unicast multicast and broadcast type of communicationscan take place We evaluate deterministic probabilistic and hybrid type of key pre-distributionand dynamic key generation algorithms for distributing pair-wise group-wise and network-wisekeysGeneral Terms: SecurityTheoryAdditional Key Words and Phrases: Combinatorial key pre-distribution distributed wireless sen-sor network dynamic key generation group-wise key hierarchical wireless sensor network keydistribution key matrix key pre-distribution master key network-wise key pair-wise key pair-wise key pre-distribution polynomial key share random key pre-distribution1 INTRODUCTIONSensors are inexpensive low-power devices which have limited resources [Akyildizet al 2002] They are small in size and have wireless communication capabilitywithin short distances A sensor node typically contains a power unit a sensingunit a processing unit a storage unit and a wireless transmitter / receiver Awireless sensor network (WSN) is composed of large number of sensor nodes withlimited power computation storage and communication capabilities Environ-ments where sensor nodes are deployed can be controlled (such as home officewarehouse forest etc) or uncontrolled (such as hostile or disaster areas toxicregions etc) If the environment is known and under control deployment may beachieved manually to establish an infrastructure However manual deploymentsbecome infeasible or even impossible as the number of the nodes increases If theenvironment is uncontrolled or the WSN is very large deployment has to be per-formed by randomly scattering the sensor nodes to target area It may be possibleto provide denser sensor deployment at certain spots but exact positions of thesensor nodes can not be controlled Thus network topology can not be knownprecisely prior to deployment Although topology information can be obtained byusing mobile sensor nodes and self-deployment protocols as proposed in [Wang et al2004] and [Zou and Chakrabarty 2003] this may not be possible for a large scaleWSNSecurity in WSN has six challenges: (i) wireless nature of communication (ii)Authors’ address: Rensselaer Polytechnic Institute Computer Science Department Lally 310 1108th Street Troy NY 12180-3590Technical Report TR-05-07 (March 23 2005)TR-05-07 Department of Computer Science Rensselaer Polytechnic Institute2 · S A C¸amtepe and B Yenerresource limitation on sensor nodes (iii) very large and dense WSN (iv) lack offixed infrastructure (v) unknown network topology prior to deployment (vi) highrisk of physical attacks to unattended sensors Moreover in some deployment sce-narios sensor nodes need to operate under adversarial condition Security solutionsfor such applications depend on existence of strong and efficient key distributionmechanisms It is infeasible or even impossible in uncontrolled environments tovisit large number of sensor nodes and change their configuration Moreover useof a single shared key in whole WSN is not a good idea because an adversary caneasily obtain the key Thus sensor nodes have to adapt their environments andestablish a secure network by: (i) using pre-distributed keys or keying materials(ii) exchanging information with their immediate neighbors or (iii) exchanging in-formation with computationally robust nodes Although there are ongoing works[Malan et al 2004; Gaubatz et al 2004; Huang et al 2003] to customize public keycryptography and elliptic key cryptography for low-power devices such approachesare still considered as costly due to high processing requirements Key distributionand management problem in WSN is difficult one and requires new approachesMotivation of this paper is to evaluate the key distribution solutions Dependingon application types it is possible to discuss: (i) network architectures such asdistributed or hierarchical (ii) communication styles such as pair-wise (unicast)group-wise (multicast) or network-wise (broadcast) (iii) security requirements suchas authentication confidentiality or integrity and (iv) keying requirements suchas pre-distributed or dynamically generated pair-wise group-wise or network-wisekeys In this paper we provide a comparative survey and taxonomy of solutions Itmay not be always possible to give strict quantitative comparisons; however thereare certain metrics as described in the next section that can be used to evaluatethe solutions The structure of the paper is as follows: in Section 2 common termsand definitions are given in Section 3 network models are defined in Section 4security vulnerabilities and requirements are discussed in Sections 5 and 6 keydistribution solutions are evaluated and finally in Section 7 we provide summaryand discussions2 TERMS DEFINITIONS AND NOTATIONSTerms used throughout this paper are as follows:—key : symmetric key which is used to secure communication among two or more sensornodes—keying materials: any kind of information and algorithms which are used to generatekeys—credentials: keys keying materials and algorithms—key-chain: list of keys or keying materials which are stored on a sensor node—key-pool : list of all keys or keying materials which are used in the WSN—link-key : key which is used to secure communication over a direct wireless link—path-key : key which is used to secure communication over multi-hop wireless linksthrough one or more sensor nodes—pair-wise key : key which is used to secure unicast communication between a pair ofsensor nodes over single or multi-hop wireless linkTR-05-07 Department of Computer Science Rensselaer Polytechnic InstituteKey distribution mechanisms for wireless sensor networks: a survey · 3Abbreviations NotationsKDC Key Distribution Center N WSN sizeWSN Wireless Sensor Network KP Key-PoolHWSN Hierarchical WSN KC Key-ChainDWSN Distributed WSN K KeyHash Hash BS Base StationMAC Message Authentication Code S Sensor nodePRF Pseudo Random Function RN Random NonceENC Encryption P PolynomialDAG Directed Acyclic GraphTable I Abbreviations and notations Functions MAC and ENC accept a key and message togenerate message authentication code and encrypted message respectively Function PRF acceptsa seed to generate a random number Also it is used to generate a key in which case part of theseed must be secret information—group-wise key : key which is used to secure multicast communication among a groupof sensor nodes over single or multi-hop wireless link—network-wise key : key which is used to secure broadcast messages—key reinforcement : establishing a unique session key between two sensor nodes by usingexisting link- or path-key—key graph: a graph where nodes are sensor nodes and there is an edge in between twonodes if the corresponding sensor nodes are within each others radio range and if theyshare a key to secure their communication3 NETWORK MODELSCommunication in WSNs usually occurs in ad hoc manner and shows similaritiesto wireless ad hoc networks Likewise WSNs are dynamic in the sense that radiorange and network connectivity changes by time Sensor nodes dies and new sensornodes may be added to the network However WSNs are more constrained denserand may suffer (or take advantage) of redundant information WSN architecturesare organized in hierarchical and distributed structures as shown in Figure 1A Hierarchical WSNs (HWSN) is shown in Figure 1(a); there is a hierarchyamong the nodes based on their capabilities: base stations cluster heads and sen-sor nodes Base stations are many orders of magnitude more powerful than sensornodes and cluster heads A base station is typically a gateway to another networka powerful data processing / storage center or an access point for human interfaceBase stations collect sensor readings perform costly operations on behalf of sensornodes and manage the network In some applications base stations are assumedto be trusted and temper resistant Thus they are used as key distribution cen-ters Sensor nodes are deployed around one or more hop neighborhood of the basestations They form a dense network where a cluster of sensors lying in a specificarea may provide similar or close readings Nodes with better resources namedas cluster heads may be used collect and merge local traffic and send it to basestations Transmission power of a base station is usually enough to reach all sen-sor nodes but sensor nodes depend on the ad hoc communication to reach basestations Thus data flow in such networks can be: (i) pair-wise (unicast) amongTR-05-07 Department of Computer Science Rensselaer Polytechnic Institute4 · S A C¸amtepe and B YenerFig 1 Network Models: Hierarchical and Distributed Wireless Sensor Networkssensor nodes (ii) group-wise (multicast) within a cluster of sensor nodes and (iii)network-wise (broadcast) from base stations to sensor nodesA Distributed WSNs (DWSN) is shown in Figure 1(b); there is no fixed infras-tructure and network topology is not known prior to deployment Sensor nodesare usually randomly scattered all over the target area Once they are deployedeach sensor node scans its radio coverage area to figure out its neighbors Dataflow in DWSN is similar to data flow in HWSN with a difference that network-wise(broadcast) can be sent by every sensor nodes4 SECURITY VULNERABILITIES AND REQUIREMENTS41 Security VulnerabilitiesWireless nature of communication lack of infrastructure and uncontrolled environ-ment improve capabilities of adversaries in WSN Stationary adversaries equippedwith powerful computers and communication devices may access whole WSN froma remote location They can gain mobility by using powerful laptops batteriesand antennas and move around or within the WSN Also adversaries can planttheir own sensor nodes base stations or cluster heads in uncontrolled environmentsThey can replace compromise or physically damage existing ones Wireless com-munication helps adversaries to perform variety of passive active and stealth typeof attacks [Jakobsson et al 2003] In passive mode adversaries silently listen to ra-dio channels to capture data security credentials or to collect enough informationto derive the credentials In active attacks adversaries may actively intercept keymanagement systems capture and read the contents of sensor nodes They can usewireless devices with various capabilities to play man-in-the-middle or to hijack asession They can insert modify replay or delete the traffic jam a part of or wholenetwork [Karlof and Wagner 2003]Base stations are usually trust centers and store information such as securitycredentials sensor readings and routing tables Thus compromise of one or moreof them can render the entire network useless Similarly cluster heads whichare ordinary sensor nodes are the places where the sensor readings are mergedtogether Also they are accepted as trusted components and sensor nodes rely onrouting information from themContent of data flowing in a WSN can be classified into four categories: (i) sensorTR-05-07 Department of Computer Science Rensselaer Polytechnic InstituteKey distribution mechanisms for wireless sensor networks: a survey · 5readings (ii) mobile code (iii) key management and (iv) location information Inaddition to active and passive attacks on key management traffic adversaries mayimprove their capabilities by accessing mobile codes and location information Anadversary can insert a malicious mobile code which might spread to whole WSNpotentially compromising its security It can use the location information to locatecritical nodes capture and read their security contents [Jakobsson et al 2003]42 Security RequirementsWireless networks are more vulnerable to attacks then wired ones due to broadcastnature of transmission medium resource limitation on sensor nodes and uncon-trolled environments where they are left unattended Security requirements inWSNs are similar to those of ad-hoc networks [Zhou and Haas 1999] [Stajano andAnderson 1999] due to similarities between MANET and WSN Thus WSNs alsohave following general security requirements:—Availability : ensuring that service offered by whole WSN by any part of it or by asingle sensor node must be available whenever required—Authentication: authenticating other nodes cluster heads and base stations beforegranting a limited resource or revealing information—Integrity : ensuring that message or the entity under consideration is not altered—Confidentiality : providing privacy of the wireless communication channels to preventeavesdropping—Non-reputation: preventing malicious nodes to hide their activitiesIn addition to these general requirements WSNs have following specific require-ments:—Survivability : ability to provide a minimum level of service in the presence of powerloss failures or attacks—Degradation of security services: ability to change security level as resource availabilitychangesThese security requirements can be provided by a key distribution mechanismwith the requirements given below These are also used as metrics throughout thepaper to evaluate key distribution solutions—Scalability : ability to support larger networks Key distribution mechanism must sup-port large networks and must be flexible against substantial increase in the size of thenetwork even after deployment—Efficiency : storage processing and communication limitations on sensor nodes must beconsidered—Storage complexity : amount of memory required to store security credentials —Processing complexity : amount of processor cycles required to establish a key—Communication complexity : number of messages exchanged during a key generationprocess—Key connectivity (probability of key-share): probability that two (or more) sensor nodesstore the same key or keying material Enough key connectivity must be provided fora WSN to perform its intended functionality—Resilience: resistance against node capture Compromise of security credentials whichare stored on a sensor node or exchanged over radio links should not reveal informationTR-05-07 Department of Computer Science Rensselaer Polytechnic Institute6 · S A C¸amtepe and B YenerProblem Approach Mechanism Keying style PapersPair-wise Probabilistic Pre-distribution Random key-chain C E F JK N SPair-wise key EDeterministic Pre-distribution Pair-wise key G MCombinatorial P QDynamic Key Master key D LGeneration Key matrix APolynomial B GHybrid Pre-distribution Combinatorial P QDynamic Key Key matrix H M RGeneration Polynomial I RGroup-wise Deterministic Dyn Key Gen Polynomial B RThe papers are: A[Blom 1985] B[Blundo et al 1992] C[Eschenauer and Gligor 2002] D[Lai et al2002] E[Chan et al 2003] F[Pietro et al 2003] G[Liu and Ning 2003c] H[Du et al 2003] I[Liuand Ning 2003b] J[Zhu et al 2003] K[Du et al 2004] L[Dutertre et al 2004] M[Lee and Stinson2004b] N[Hwang et al 2004] P[Camtepe and Yener 2004] Q[Lee and Stinson 2004a] R[Huanget al 2004] S[Hwang and Kim 2004]Table II Classification of papers on pair-wise and group-wise key distribution problems in Dis-tributed WSNabout security of any other links in the WSN Usually higher resilience means lowernumber of compromised linksIn general resource usage scalability key connectivity and resilience are conflict-ing requirements; therefore trade-offs among these requirements must be carefullyobserved5 KEY DISTRIBUTION IN DISTRIBUTED WSNIn DWSNs sensor nodes use pre-distributed keys directly or use keying materials todynamically generate pair-wise and group-wise keys Challenge is to find an efficientway of distributing keys and keying materials to sensor nodes prior to deploymentSolutions to key distribution problem in DWSN can use one of the three approaches:(i) probabilistic (ii) deterministic or (iii) hybrid In probabilistic solutions key-chains are randomly selected from a key-pool and distributed to sensor nodesIn deterministic solutions deterministic processes are used to design the key-pooland the key-chains to provide better key connectivity Finally hybrid solutionsuse probabilistic approaches on deterministic solutions to improve scalability andresilience Table II classifies the papers which provide solutions to pair-wise andgroup-wise key distribution problem in DWSN Based on this classification wedescribe the solutions in Sections 51 and 5251 Pair-wise Key Distribution SchemesPair-wise key distribution schemes are grouped according to proposed keying styles(ie pair-wise key random key-chain master key   ) Proposed schemes consist ofthree phases in general: (i) key setup prior to deployment (ii) shared-key discoveryafter deployment and (iii) path-key establishment if two sensor nodes do not shareTR-05-07 Department of Computer Science Rensselaer Polytechnic InstituteKey distribution mechanisms for wireless sensor networks: a survey · 7a key511 Pair-wise key pre-distribution solutions The trivial solution in terms ofresource usage is to deploy single master key to all sensors Since an adversarymay capture a node and compromise the key very easily it has very low resilienceThe other extreme is to use distinct pair-wise keys for all possible pairs in theWSN For a network of size N each sensor Si (1 ≤ i ≤ N) stores a key-chainKCi = {Kij|i 6= j and 1 ≤ j ≤ N} of size N − 1 out of N(N − 1)/2 distinct keysNode Si stores a unique pair-wise key for each one of N-1 sensor nodes in the WSNHowever not all N-1 keys are required to be stored in nodes’ key-chain to havea connected key graph Although such an exhaustive solution creates unnecessarystorage burden on a sensor node this solution has very good key resilienceRandom pair-wise key scheme [Chan et al 2003] addresses unnecessary storageproblem yet provides very good key resilience It is based on Erdos and Renyi’swork Each sensor node stores a random set of Np pair-wise keys to achieve prob-ability p that two nodes are connected At key setup phase each node identity ismatched with Np other randomly selected node IDs with probability p A pair-wisekey is generated for each ID-pairs and is stored in both nodes’ key-chain along withthe ID of other party Each sensor uses 2Np units of memory to store its key-chainAt shared-key discovery phase each node broadcasts its ID; therefore each nodesends one message and receives one message from each node within its radio rangeNeighboring nodes can tell if they share a common pair-wise key This solutionhas very good key resilience It is more scalable in the sense that efficient use ofmemory spaces helps support larger WSNs However it sacrifices key connectivityto decrease the storage usageClosest (location-based) pair-wise keys pre-distribution scheme [Liu and Ning2003c] is an alternative to Random pair-wise key scheme [Chan et al 2003] Ittakes advantage of the location information to improve the key connectivity Sen-sor nodes are deployed in a two dimensional area and each sensor has an expectedlocation that can be predicted The idea is to have each sensor to share pair-wisekeys with its c closest neighbors In key setup phase for each sensor node SA aunique key KA and c closest neighbors SB1      SBc are selected For each pair(SA SBi) a pair-wise key KABi = PRF (KBi |IDA) is generated Node SA storesall pair-wise keys whereas node SBi only stores the key KBi and the PRF Thuseach sensor uses 2c+1 units of memory to store its key-chain With this extensiondeployments of new nodes are quite easy A new node SA can be preloaded withthe pair-wise keys for c sensor nodes in its expected location Solution decreasesmemory usage and preserves a good key connectivity if deployment errors are lowA sensor uses its CPU to search for a pair-wise key or to generate it with PRFfunction Similar to Random pair-wise key scheme [Chan et al 2003] this solutionhas very good key resilience and it is scalableID based one-way function scheme (IOS) [Lee and Stinson 2004b] assumes aconnected r-regular graph G which has an edge decomposition into star-like sub-graphs Pair-wise keys are distributed according to these subgraphs A sensor nodeSA receives a secret key KA and secret keys Hash(KB|IDA) if SA is in the star-like graph centered around node SB Node SB can always generate the secret keyHash(KB|IDA) by using its secret KB and public ID(A) In an r-regular graphTR-05-07 Department of Computer Science Rensselaer Polytechnic Institute8 · S A C¸amtepe and B YenerG each sensor node can be center of one and leaf of r/2 star-like subgraphs Thuseach sensor uses r + 1 units of memory to store keys and key IDs Solution hasvery good key resilience and it permits any pair of nodes to share a key in one orat most two hopsMultiple IOS [Lee and Stinson 2004b] is proposed to improve scalability of IDbased one-way function scheme (IOS) Every node in graph G corresponds to `nodes SA = SA1      SA`  Thus sensor nodes SAi store a common key KA and asecret Hash(KB|IDAi) Every node SBj in the class of node SB can use commonkey KB to generate the secret Hash(KB|IDAi) for node SAi  Multiple IOS de-creases memory usage by a factor of ` It sacrifices resilience because compromiseof a class key means compromise of the links of ` sensor nodes512 Master key based key pre-distribution solutions Broadcast session key ne-gotiation protocol (BROSK) [Lai et al 2002] is based on single master key whichis pre-deployed to sensor nodes A pair of sensor nodes (Si Sj) exchanges ran-dom nonce values They use master key Km to establish session key Kij =PRF (Km|RNi|RNj) Each sensor uses one unit of memory to store the masterkey It is possible to derive all link keys once the master key is compromised;therefore the scheme has very low resilienceLightweight key management system [Dutertre et al 2004] proposes a solutionwith slightly better resilience where more than one master key is employed It as-sumes a WSN where groups of sensor nodes are deployed in successive generations ofsize θ Each sensor node stores a group authentication key bk1 and a key generationkey bk2 If two sensor nodes SA and SB are from the same generation they authen-ticate each other by using the authentication key bk1 They exchange random noncevalues RNA and RNB and establish the session keyKAB = PRF (bk2|RNA|RNB)It is possible that nodes are from two different generations A sensor node SA ofan old generation i stores a random nonce RNA and a secret SAj for each newgeneration j Secret SAj is used to authenticate sensor nodes from new generationj Node SB of new generation j can authenticate itself by generating the secretSAj = PRF (gkj |RNA) given RNA Secret gkj is only known to nodes of new gen-eration j Once authenticated both parties use SAj as the key generation key togenerate the pair-wise key KAB If there are g such generations each sensor needsat most 4 + 2g units of memory to store the keys Resilience of the scheme is stilllow because an adversary only needs to compromise the secrets bk1 bk2 and gkj ofgeneration j to compromise all the links of nodes in generation j Furthermoreadversary may log the messages flowing in the network to process later when therequired credentials are compromised completely513 Random key-chain based key pre-distribution solutions Original solutionis provided by Basic probabilistic key pre-distribution scheme [Eschenauer andGligor 2002] which relies on probabilistic key sharing among the nodes of a ran-dom graph In key setup phase a large key-pool of KP keys and their identitiesare generated For each sensor k keys are randomly drawn from the key-poolKP without replacement These k keys and their identities form the key-chain fora sensor node Thus probability of key share among two sensor nodes becomesp = ((KP−k)!)2((KP−2k)!KP !)  In shared-key discovery phase two neighbor nodes exchangeTR-05-07 Department of Computer Science Rensselaer Polytechnic InstituteKey distribution mechanisms for wireless sensor networks: a survey · 9and compare list of identities of keys in their key-chains Basically each sensornode broadcasts one message and receives one message from each node within itsradio range where messages carry key ID list of size k Cluster key grouping scheme[Hwang et al 2004] proposes to divide key-chains into C clusters where each clus-ter has a start key ID Remaining key IDs within the cluster are implicitly knownfrom the start key ID Thus only start key IDs for clusters are broadcasted duringshared-key discovery phase which means messages carry key ID list of size c insteadof k Another solution is given by Pair-wise key establishment protocol [Zhu et al2003] which requires every sensor node to have a unique ID which is used as aseed to a PRF Key IDs for the keys in the key-chain of node SA are generated byPRF (IDA) Thus broadcast messages carry only one key ID Also storage whichis required to buffer received broadcast message before processing decreases sub-stantially But a sensor node has to execute PRF (ID) for each broadcast messagereceived from a neighbor Transmission range adjustment scheme [Hwang and Kim2004] proposes sensor nodes to increase their transmission ranges during shared-keydiscovery phase Nodes return to their original optimal transmission range oncethe keys are discovered Idea is to decrease communication burden in path-key es-tablishment phase and to save energy while still providing a good key connectivityIt is possible to protect key identities broadcasted in shared-key discovery by us-ing a method similar to Merkle Puzzle [Merkle 1978] which substantially increasesprocessing and communication usage After shared-key discovery phase some nodepairs may not be able to find a key in common These pairs apply path-key es-tablishment phase to communicate securely through other nodes Scalability andresilience of the solutions can be improved by using larger key pools But largerkey-pool means smaller probability of key share because key-chain size may notincrease due to storage limitations Probability that a link is compromised whena sensor node is captured is k/KP which is very high for small key-pools andproduces low resilienceThere are several key reinforcement proposals to strengthen security of the es-tablished link keys and improve resilience Objective is to securely generate aunique link- or path-key by using established keys so that the key is not com-promised when one or more sensor node is captured One approach is to increaseamount of key overlap required in shared-key discovery phase Q-composite ran-dom key pre-distribution scheme [Chan et al 2003] requires q common keys toestablish a link key Link key KAB between a pair of sensor nodes SA and SB isset as hash of all common keys KAB = Hash(K1||K2||K3||    ||Kq) The schemeimproves resilience because probability that a link is compromised when a sen-sor node is captured decreases from k/KP to (kq )/(KPq ) But probability of keysharing also decreases because a pair of nodes has to share q keys instead of oneAnother approach is to reinforce the established link key In Multi-path key re-inforcement scheme [Chan et al 2003] node SA generates j random key updatesrki and sends them through j disjoint secure paths SB can generate reinforcedlink key KrAB = KAB ⊕ rk1 ⊕    ⊕ rkj upon receiving all key updates Thisapproach requires nodes SA and SB to send and receive j more messages each ofwhich carries a key update Moreover each node on the j disjoint path has tosend and receive an extra message Similar mechanism is proposed by Pair-wiseTR-05-07 Department of Computer Science Rensselaer Polytechnic Institute10 · S A C¸amtepe and B Yenerkey establishment protocol [Zhu et al 2003] which uses threshold secret sharing forkey reinforcement SA generates a secret key KrAB j − 1 random shares ski andskj = KrAB⊕sk1⊕   ⊕skj−1 SA sends the shares through j disjoint secure pathsSB can recoverKrAB upon receiving all shares In Co-operative pair-wise key estab-lishment protocol [Pietro et al 2003] SA first chooses a set C = {c1 c2     cm} ofco-operative nodes A co-operative node provides a hash HMAC(Kc1B IDA) Re-inforced key is then KrAB = KAB⊕(⊕c∈C HMAC(KcB IDA))where KAB andKcB are the established link keys Node SA shares set C with node SB; thereforeSB can generate the same key This approach requires nodes SA and SB to sendand receive c more messages Moreover cooperative nodes have to send and receivetwo extra messages In addition to increased communication cost each cooperativenode has to execute HMAC function twice for SA and SB The key reinforcementsolutions in general increase processing and communication complexity but providegood resilience in the sense that a compromised key-chain does not directly affectsecurity of any links in the WSN But it may be possible for an adversary to re-cover initial link keys An adversary can then recover reinforced link keys from therecorded multi-path reinforcement messages when the link keys are compromisedSensor nodes which are far away from each other do not need to have commonkeys in their key-chains Similar to Closest pair-wise keys pre-distribution scheme[Liu and Ning 2003c] (as we explained in Section 511) Key pre-distribution byusing deployment knowledge scheme [Du et al 2004] uses location information Itmodels a deployment knowledge and develops a key pre-distribution scheme basedon the model The scheme divides sensor nodes into t× n groups Gij and deploysthem at a resident point (xi yj) for 1 ≤ i ≤ t and 1 ≤ j ≤ n where the pointsare arranged as two dimensional grids Resident points of a node m ∈ Gij followsthe pdf f ijm (x y|m ∈ Gij) = f(x − xi y − yj) where f(x y) is a two dimensionalGaussian distribution In key setup phase key-pool KP is divided into t × n key-pools KPij of size ωij  The pool KPij is used as key-pool for the nodes in groupGij  Given ωij and overlapping factors α and β key-pool is divided into subsetsas summarized in Figure 2 where (i) two horizontally and vertically neighboringkey-pools have α× ωij keys in common (ii) two diagonally neighboring key-poolshave β × ωij keys in common and (iii) non-neighboring key-pools do not share akey Basic probabilistic key pre-distribution scheme is applied within each groupProblem in this scheme is the difficulty to decide on parameters ωij  α and β toprovide a good key connectivity514 Combinatorial design based key pre-distribution solutions Key sharingprobability among the sensor nodes can be increased by designing the key-chainsCombinatorial design based pair-wise key pre-distribution scheme [Camtepe andYener 2004] is based on block design techniques in combinatorial design theoryIt employs symmetric and generalized quadrangles design techniques The schemeuses finite projective plane of order n (for prime power n) to generate a symmetricdesign (or symmetric BIBD) with parameters (n2+n+1 n+1 1) Design supportsn2 + n + 1 nodes and uses key-pool of size n2 + n + 1 It generates n2 + n + 1key-chains of size n+ 1 where every pair of key-chains has exactly one key in com-mon and every key appears in exactly n + 1 key-chains After the deploymentevery pair of nodes finds exactly one common key Thus probability of key sharingTR-05-07 Department of Computer Science Rensselaer Polytechnic InstituteKey distribution mechanisms for wireless sensor networks: a survey · 11Fig 2 Key pre-distribution with deployment knowledge where key-pool KPij has: (i) α × ωijkeys in common with key-pools KPi−1j KPij−1 KPij+1 and KPi+1j (ii) β × ωij keys incommon with key-pools KPi−1j−1 KPi−1j+1 KPi+1j−1 and KPi+1j+1 and (iii) zero keysin common with othersamong a pair of sensor node is 1 Probability that a link is compromised when asensor node is captured is ≈ 1/n Disadvantage of this solution is that parametern has to be a prime power; therefore not all network sizes can be supported for afixed key-chain size More scalable solutions can be provided by using generalizedquadrangles design with the property that not all pairs of neighboring nodes needto share a key directly In GQ a pair of key-chains may not have a key in commonbut GQ guarantees that there are other key-chains which share exactly one keywith both Proposed GQ designs GQ(n n) GQ(n n2) and GQ(n2 n3) supportnetwork sizes of orders O(n3) O(n5) and O(n4) in key-chain size and provideskey sharing probabilities of ≈ 1/n ≈ 1/n2 and ≈ 1/n15 respectively [Camtepeand Yener 2004] Although GQ is more scalable than symmetric design parame-ter n still needs to be a prime power Combinatorial design techniques are usedalong with probabilistic approaches yielding hybrid designs to support arbitrarynetwork sizes Hybrid design first generates core symmetric or GQ design of sizeM for a given target network size of N where M < N as summarized in Figure 3Complementary design of the core design is generated for the remaining N −Mkey-chains Complementary design is complements of the core design key-chainsKCi = KP\KCi in the key-pool KP  Hybrid design then randomly selects key-chains KC′i of size k among k-subsets of KCi Hybrid design improves scalabilityand resilience but sacrifices key sharing probability of the core symmetric or GQdesign Very similar approaches based on combinatorial design theory are proposedin [Lee and Stinson 2004a]515 Key matrix based dynamic key generation solutions All possible link keysin a network of size N can be represented as an N ×N key matrix It is possibleto store small amount of information to each sensor node so that every pair ofnodes can calculate corresponding field of the matrix and uses it as the link keyBlom’s scheme [Blom 1985] uses a public (λ + 1) × N matrix G and a privateN × (λ + 1) matrix D which is generated over GF(q) and where N is size of thenetwork Solution is λ-secure meaning that keys are secure if no more than λ nodesare compromised Matrix G must have (λ + 1) linearly independent columns (ieVandermonde matrix) to provide λ-secure property Key matrix is then defined as aTR-05-07 Department of Computer Science Rensselaer Polytechnic Institute12 · S A C¸amtepe and B YenerFig 3 Hybrid design with a symmetric (or GQ) core of size M and a probabilistic extension ofsize N −M  Key-chains KC′i of probabilistic extension are randomly selected among k-subsets ofKCi which are complements of core symmetric (or GQ) design key-chains KCiFig 4 Blom’s scheme Sensor node Si stores columni from matrix G as public informationand rowi from matrix (DG)T as private information Nodes Si and Sj exchange their publiccolumn vectors and generate Kij = rowi×columnj and Kji = rowj×columni respectively whereKij = Kjisymmetric matrix K = (DG)T G Sensor node Si stores columni of size λ+1 frommatrix G as public information and rowi of size λ+1 from matrix (DG)T as privateinformation A pair of sensor nodes (Si Sj) first exchange their public informationcolumni and columnj The link key is then generated as Kij = rowi × columnjand Kji = rowj × columni respectively as summarized in Figure 4 The schemerequires costly multiplication of two vectors of size λ + 1 where the elements areas large as the corresponding cryptographic key size Each sensor node broadcastsone message and receives one message from each node within its radio range wheremessages carry a vector of size λ+ 1Multiple space key pre-distribution scheme [Du et al 2003] improves the resilienceof Blom’s scheme [Blom 1985] It uses a public matrix G and a set of ω privatematrices D These matrices form ω spaces (Di G) for i = 1     ω For each sensornode a set of τ spaces are randomly selected among these ω spaces Requiredkeying materials for each selected space are stored to the sensor node as in Blom’sscheme; therefore each sensor node stores τ +1 vectors of size λ+1 In shared keydiscovery phase a pair of nodes first agrees on a common space for which nodesTR-05-07 Department of Computer Science Rensselaer Polytechnic InstituteKey distribution mechanisms for wireless sensor networks: a survey · 13has to exchange an extra message which includes τ space IDs It is possible thata pair of nodes does not share a common space in that case they have to applypath-key establishment phase to establish a key through intermediate nodesScalability of Blom’s scheme is improved inMultiple space Blom’s scheme (MBS)[Lee and Stinson 2004b] The scheme divides nodes into two sets U and V to formbipartite key connectivity graph That means not every pair of nodes has toshare a key Another difference from Blom’s scheme is that private matrix D isnot necessarily symmetric Secret information columnTuD is assigned to each nodeSu ∈ U and Dcolumnv is assigned to each node Sv ∈ V  Nodes Su and Sv also storepublic information columnu and columnv respectively Nodes can exchange theirpublic information to calculate secret key columnTuDcolumnv Larger networks aresupported byDeterministic multiple space Blom’s scheme (DMBS) [Lee and Stinson2004b] where ` copies of strongly regular (regular of degree r) graph R are usedEach vertex of R can be considered as a class of ` nodes such as Su = Su1      Su` An arbitrary direction is assigned to every edge in R and every edge e has arandom private matrix De which is not necessarily symmetric Each sensor nodeSui receives its public column vector columnu of size λ + 1 For a directed edge(Sui  Svj ) ∈ R source node Sui receives secret information columnTuDuv of sizeλ + 1 and destination node Svj receives secret information Duvcolumnv of sizeλ + 1 Thus each node stores vectors of size r(λ + 1) Nodes Sui and Svj canthen generate the link key as Kuivj = columnTuDuvcolumnv DMBS increasesscalability with the cost of decreased resilience because capture of one sensor nodecompromises credentials of `− 1 other516 Polynomial based dynamic key generation solutions Polynomial based keypre-distribution scheme [Blundo et al 1992] distributes a polynomial share (a par-tially evaluated polynomial) to each sensor node by using which every pair of nodescan generate a link key Symmetric polynomial P (x y) (P (x y) = P (y x)) of de-gree λ is used The coefficients of the polynomial come from GF (q) for sufficientlylarge prime q Each sensor node stores a polynomial with λ + 1 coefficients whichcome from GF(q) Sensor node Si receives its polynomial share of fi(y) = P (i y)Si (resp Sj) can obtain link key Kij = P (i j) by evaluating its polynomial sharefi(y) (resp fj(y)) at point j (resp i) Every pair of sensor nodes can establish akey The solution is λ-secure meaning that coalition of less than λ+1 sensor nodesknows nothing about pair-wise keys of othersPolynomial pool-based key pre-distribution scheme [Liu and Ning 2003b] considersthe fact that not all pairs of sensor nodes have to establish a key It combinesPolynomial based key pre-distribution scheme [Blundo et al 1992] with the key-pool idea in [Eschenauer and Gligor 2002; Chan et al 2003] to improve resilienceand scalability For key setup phase a set F of λ-degree polynomials over finite fieldGF(q) is generated Each sensor node Si receives a subset Fi of the polynomialset F (Fi ⊆ F ) There are several ways to select polynomial subsets for sensornodes In one approach along with the polynomial subset each sensor stores listof sensor ID’s with which it shares the polynomial In another approach a grid-based key pre-distribution scheme is employed For a network of size N  m×m (form = d√Ne) grid with a set of 2×m column and row polynomials {f ci (x y) f ri (x y)}(i = 0    m−1) are generated Each row i in grid is associated with a polynomialTR-05-07 Department of Computer Science Rensselaer Polytechnic Institute14 · S A C¸amtepe and B Yenerf ri (x y) and each column i with a polynomial fci (x y) Each sensor is assigned toa coordinate (i j) on the grid and receives polynomials {f ci (x y) f rj (x y)} A pairof sensor nodes only needs to check whether their column or row addresses overlapIn shared-key discovery phase if two sensor nodes have the same polynomial theycan establish a keyLocation information can help provide better key connectivity Similar to Closestpair-wise keys pre-distribution scheme [Liu and Ning 2003c] andKey pre-distributionby using deployment knowledge scheme [Du et al 2004] (as we explained in Sections511 and 513 respectively) Location-based pair-wise keys scheme using bivariatepolynomials [Liu and Ning 2003c] uses location information where deployment areais divided into R rows and C columns total of R×C cells The scheme is based onPolynomial based key pre-distribution scheme [Blundo et al 1992] For each cell atcth column and rth row a unique polynomial fcr(x y) is generated Each sensornode stores polynomial share of its home cell and four immediate neighbor cellstotal of five polynomials Two sensor nodes simply exchange their cell coordinatesto agree on a polynomial share Similarly Grid-group deployment scheme [Huanget al 2004] divides deployment area into cells over which groups of sensor nodesare uniformly distributed Polynomial pool-based key pre-distribution [Liu and Ning2003b] and Multiple space key pre-distribution [Du et al 2003](as we explained inSection 515) schemes are used to distribute pair-wise keys to a group of sensornodes located within a cell Also every sensor node selects exactly one sensor fromeach neighboring cell and shares a pairwise key with it52 Group-wise Key Distribution SchemesStraightforward approach is to use existing pair-wise keys to establish group-wisekeys For example Lightweight key management system [Dutertre et al 2004] con-siders a WSN where group of sensor nodes are deployed in different phases Itproposes to distribute group-wise keys through the links which are secured withpair-wise keys Yet another approach is to pre-distribute polynomial shares tosensor nodes by using which group members can generate a common group keyPolynomial based key pre-distribution scheme [Blundo et al 1992] proposes twomodels The first model is a non-interactive model where users compute a commonkey without any interaction A random symmetric polynomial P (x1     xt) in tvariables of degree λ is selected initially where the coefficients come from GF (q)for prime q which is large enough to accommodate the key length of the underlyingcryptosystem Each user Si receives share Pi(x2     xt) = P (i x2     xt) UsersSj1      Sjt can generate the conference key Kj1jt by evaluating their polyno-mial shares Each user Sji can evaluate Pji(j1     ji−1 ji+1     jt) and obtainthe conference key Kj1jt independently In the second interactive model inter-action is allowed in key computation Polynomial P (x y) of degree (λ + t − 2) isselected initially Each user Si receives share Pi(y) = P (i y) Users Sj1      Sjtcan calculate the conference key Kj1jt as follows: (i) Sjt selects a random keyK (ii) Sjt calculates Kjtj` = Pjt(j`) = P (jt j`) for each ` = 1     t− 1 (iii) Sjtsends χ` = Kjtj` ⊕K to each Sj` for (` = 1     t− 1) and (iv) each Sj` generatesKj`jt = Pj`(jt) and derives the secret K = χ` ⊕Kj`jt  Sensor node Sjt performst− 1 polynomial evaluations and sends t− 1 messages which carry a single χ valueto establish a group-wise keyTR-05-07 Department of Computer Science Rensselaer Polytechnic InstituteKey distribution mechanisms for wireless sensor networks: a survey · 15Problem Keying style PapersPair-wise BS oriented d i k l nMaster key g nGroup-wise Asymmetric keys a c eSymmetric keys nNetwork-wise Master key fTESLA based b d g h j k m nThe papers are: a[Burmester and Desmedt 1994] b[Perrig et al 2000] c[Steiner et al 2000]d[Chen et al 2000] e[Carman et al 2002] f[Slijepcevic et al 2002] g[Perrig et al 2002] h[Staddonet al 2002] i[Undercoffer et al 2002] j[Liu and Ning 2003a; 2003d] k[Deng et al 2003a; 2003b]l[Law et al 2003] m[Bohge and Trappe 2003] n[Zhu et al 2003]Table III Classification of solutions on pair-wise group-wise and network-wise key distributionproblems in Hierarchical WSN6 KEY DISTRIBUTION IN HIERARCHICAL WSNIn Hierarchical WSN there are one or more computationally robust base stationswhich may act like a key distribution center Initially base stations may share adistinct pair-wise key with each sensor nodes These keys can be used to secureestablishment process of other keys Table III classifies the papers which providesolutions to pair-wise group-wise and network-wise key distribution problem inHWSN Based on this classification we describe the solutions in Sections 61 62and 6361 Pair-wise Key Distribution SchemesIn hierarchical WSNs base station to sensor node or sensor node to base stationunicast communications require pair-wise keys Solution for such environmentsis straightforward; base station can share a distinct pair-wise key with each sen-sor node Very similar solutions are proposed in Perimeter protection scenario[Undercoffer et al 2002] Base station authentication protocols [Chen et al 2000;Deng et al 2003a; 2003b] and Localized encryption and authentication protocol(LEAP) [Zhu et al 2003] Since the base station shares pair-wise keys with sen-sor nodes it can intermediate establishment of a pair-wise key between any pairof sensor nodes Similar approach is used in ESA [Law et al 2003] where sensornodes are separated into domains which are supervised by base stations SNEP[Perrig et al 2002] proposes each pair of communicating party SA and SB toshare a master secret key χAB and a PRF SA and SB can then generate en-cryption keys KAB = PRF (χAB 1) and KBA = PRF (χAB 3) and MAC keysK ′AB = PRF (χAB 2) and K′BA = PRF (χAB 4)Localized encryption and authentication protocol (LEAP) [Zhu et al 2003] pro-poses that each sensor node can establishes pair-wise keys with its immediate neigh-bor In the key setup phase nodes receive a general key KI  A node Su can useKI and one-way hash function H to generate its master key Ku = HKI (IDu)In shared key discovery phase node Su broadcasts (IDu RNu) and a neighborSv responds with (IDvMACKv(RNu|IDv)) Node Su can then generate thekey Kv = HKI (IDv) and both nodes Su and Sv can generate the session keyKuv = HKv (IDu) Multi-hop pair-wise keys may be required to reach clusterTR-05-07 Department of Computer Science Rensselaer Polytechnic Institute16 · S A C¸amtepe and B Yenerheads In that case node Su generates secret Kuc and finds m intermediatenodes It divides the secret into shares Kuc = sk1 ⊕ sk2 ⊕    skm and sends eachshare through a separate intermediate node Svi (1 ≤ i ≤ m) Basically node Susends ENCKuvi (ski) Hski (0) to node Svi  and Svi sends ENCKvic(ski) Hski (0)to cluster head Sc Solution has high communication cost because Su sends mmessages through m intermediate nodes to increase resilience However security ofthe system depends on the general key KI which can be compromised by captureof a sensor node It is possible to compromise all the session keys generated byLEAP once KI is compromised62 Group-wise Key Distribution SchemesIn hierarchical WSNs sensor nodes require group-wise keys to secure multicastmessages One approach is to use secure but costly asymmetric cryptographyBurmester-Desmedt [Burmester and Desmedt 1994] and IKA2 [Steiner et al 2000]use a Diffie-Hellman based group key transport protocol These two algorithms arefurther improved by ID-STAR [Carman et al 2002] ID-STAR uses Identity basedcryptography [Shamir 1984; Boneh and Franklin 2001] where sensor nodes’ publickeys can be derived from their identities It is also possible to use existing pair-wisekey structure to establish groups-wise keys In an hierarchical network where a basestation share pair-wise keys with all the sensor nodes base station can intermediateestablishment of group-wise keys Localized encryption and authentication protocol(LEAP) [Zhu et al 2003] provides a mechanism to generate group-wise keys whichfollows LEAP pair-wise key establishment phase Node Su who wants to establisha group key with all its neighbors Sv1  Sv2      Svm  first generates a unique groupkey Kgu It then sends Kgu to its neighbors Svi as ENCKuvi (Kgu) Security ofthe scheme depends on security of the pair-wise keys which in turn has very lowresilience63 Network-wise Key Distribution Schemes631 Master key based solutions In hierarchical WSNs base station to sensornode broadcast traffic is secured with network-wise keys An insecure approach isto pre-distribute a single network-wise key to all sensor nodes Another approach isproposed by Multi-tiered security solution [Slijepcevic et al 2002] where data itemsare protected to a degree consistent with their value It considers three types ofdata flowing in WSN: mobile code locations of sensors nodes and application dataIt is assumed that sensor nodes are initially loaded with a list of m master keys aPRF and a seed They use the PRF with the seed to obtain an index within thelist of master keys Selected key is named as active master key and used to securecommunication RC6 is used as encryption algorithm Three security levels aredefined In level I a strong encryption algorithm and active master key is used tosecure mobile codes In level II sensors are divided into cells A common locationsecurity key is generated within each cell and used to secure location informationFinally in level III MD5 hash of the active master key is used to secure applicationdata Problem with this scheme is that public credentials such as master key listPRF and seed are subject to compromiseTR-05-07 Department of Computer Science Rensselaer Polytechnic InstituteKey distribution mechanisms for wireless sensor networks: a survey · 17632 TESLA based solutions Timed Efficient Stream Loss-tolerant Authenti-cation (TESLA) [Perrig et al 2000] is a multicast stream authentication protocolTESLA uses delayed key disclosure mechanism where the key used to authenticateith message is disclosed along with (i + 1)th message SPINS [Perrig et al 2002]uses µ − TESLA which is an adoption of TESLA for HWSNs SPINS employsbase station as key distribution center µ − TESLA provides authentication fordata broadcasts and requires that base station and sensor nodes be loosely timesynchronized Basically base station (BS) randomly selects last key Kn of a chainand applies one-way public function H to generate the rest of the chain K0 K1 Kn−1 as Ki = H(Ki+1) Given Ki every sensor node can generate the se-quence K0 K1  Ki−1 However given Ki no one can generate Ki+1 At ithtime slot BS sends authenticated message MACKi(Message) Sensor nodes storethe message until BS discloses the verification key in (i + 1)th time slot Sensornodes can verify disclosed verification key Ki+1 by using the previous key Ki asKi = H(Ki+1) In µ − TESLA nodes are required to store a message until theauthentication key is disclosed This operation may create storage problems andencourages DoS types of attacks An adversary may jam key disclosure messages tosaturate storages of sensor nodes µ− TESLA requires sensor nodes to bootstrapfrom the BS; that is they receive the first key of the chain which is called key chaincommitment Bootstrapping procedure requires unicast communication and canbe secured with pair-wise keys Also µ − TESLA is used in [Chen et al 2000;Deng et al 2003a; 2003b] to authenticate message broadcasts from BS in [Staddonet al 2002] to authenticate route update broadcasts and in LEAP [Zhu et al 2003]to update pre-deployed network-wise keys in case of a node compromise Anothervariant of TESLA is TESLA Certificate [Bohge and Trappe 2003] where a basestation is used as certificate authority (CA) In this scheme CA generates certifi-cate Cert(IDA ti+d MACKi()) for sensor node SA at time ti It discloses theTESLA key Ki at time ti+d when the certificate expiresBootstrapping of key chain commitments in µ− TESLA causes high volume ofpackets flowing in WSN and creates scalability problems µ− TESLA extensions[Liu and Ning 2003a; 2003d] propose five extensions to address scalability issuesIn predetermined key chain commitment commitment is pre-distributed to sensorsbefore the deployment In this solution key chain must cover lifetime of sensornodes to prevent bootstrapping requirements This can be achieved by using eitherlong chains or large time intervals A new coming node has to generate whole keychain from the beginning to authenticate recently disclosed key Thus long keychain means excessive processing for sensor nodes which are deployed at a latertime Large time interval means increased number of messages to store becausesensor nodes have to store incoming messages until the authentication key is dis-closed Two-level key chains scheme tries to address these problems There is ahigh-level key chain with long enough time interval to cover the life time of sensornodes and multiple low-level key-chains with short enough intervals as shown infigure 5(a) High-level key chain is used to distribute and authenticate randomlygenerated commitments of low-level key-chains In this scheme sensor nodes areinitialized with the commitment of high-level chain time intervals of high-level andlow-level key chains and one way functions of high and low-level chains HoweverTR-05-07 Department of Computer Science Rensselaer Polytechnic Institute18 · S A C¸amtepe and B YenerFig 5 µ − TESLA extensions: (a) two-level key chains scheme and (b) fault tolerant two-levelkey chains scheme Downward arrows show broadcast of the low-level key commitments for eachinterval: (a) commitments are broadcasted at the beginning of the interval (b) commitments arebroadcasted periodically throughout the intervallow-level keys are not chained together Thus loss of a low-level key disclosurecan only be recovered with a key which is disclosed later within the same inter-val Moreover loss of a low-level key commitment may also mean loss of entireinterval An adversary may take advantage of this and may jam disclosure oflow-level key commitments Fault tolerant two-level key-chains scheme is proposedto address these issues In this scheme the commitments of low-level key chainsare not randomly generated but obtained from high-level keys by using anotherone-way function as shown in figure 5(b) Low-level key commitments are periodi-cally broadcasted; however an adversary may still recover the commitment periodand can jam disclosure of low-level key commitments Fault tolerant two-level key-chains with random commitments scheme uses a random process to broadcast thelow-level commitments Finally multi-level chains scheme is proposed to providesmaller time intervals and shorter key chains7 SUMMARY AND DISCUSSIONSFigure 6 provides taxonomy of papers on key distribution problems in DWSN andHWSN In this figure graphs are DAGs (directed acyclic graphs) where nodesrepresent papers Directed edges show predecessor/successor relations among thepapers There is an edge from a paper to another one if latter provides improvementfor the solutions proposed by former Nodes (papers) are ordered over a horizontaltime axis according to their publication dates Vertical axis groups papers underthree problems: (i) pair-wise (ii) group-wise and (iii) network-wise key distributionproblems Each problem is represented with a specific node named as origin nodewhich has only outgoing edges The style of an edge (dotted dashed solid) inbetween two nodes represents the problem in which an improvement is providedTR-05-07 Department of Computer Science Rensselaer Polytechnic InstituteKey distribution mechanisms for wireless sensor networks: a survey · 19A paper may provide more than one solution to more than one problem; thereforecorresponding node may be reachable from more than one origin node and theremay be more than one edge with different styles in between two nodesDetailed evaluation for the edges in Figure 6 is given in Table IV Solutionscorresponding to nodes (papers) of directed edges are compared with each otherby considering the six metrics defined in Section 42: (i) scalability ”S” (ii) keyconnectivity ”K” (iii) resilience ”R” (iv) storage complexity ”M” (v) processingcomplexity ”P” and (vi) communication complexity ”C” Comparison results foreach metric are presented as ”↑” (increase) ”↓” (decrease) and ”-” (no change)Solutions described in Sections 5 and 6 are summarized in Table V where metricvalues for each solution are listedScalability ”S” is ability to support larger networks Larger networks can besupported if there is enough storage for the required security credentials which isrelated to storage complexity of the solution In Table V scalability of the similar(same keying problem and keying style) solutions are compared with each otherBasically each solution is assigned a scalability rank where higher rank meanshigher scalability There can be more than one solution sharing the same rankwhich means that corresponding solutions have roughly the same scalabilityResilience ”R” of each solution is given as either one of the following ways: (i)probability that a link is compromised when an adversary captures a node (ii)number of nodes whose security credentials are compromised when an adversarycaptures a node or (iii) number of sensor nodes required to be captured to compro-mise whole WSN Third one is represented as n-secure meaning that it is enough tocapture n+1 nodes to compromise whole WSN As these values increase networkbecomes less secure; therefore resilience decreasesKey connectivity ”K” considers probability that two (or more) sensor nodes storethe same key or keying material to be able to establish pair-wise group-wise ornetwork-wise keysEfficiency of the solutions is measured with their storage processing and commu-nication complexities Storage complexity ”M” is amount of memory units requiredto store security credentials We consider key key ID node ID node locations etcas one memory unit Processing complexity ”P” is number of unit functions exe-cuted Unit functions can be: (i) Search for one or more key in a key-chain (ii)functions such as PRF Hash MAC XOR and ENC (ii) VecMul(size) which multi-plies two vectors of given sizes and (iii) PolyEval which evaluates a polynomial ata given point Communication is the most power consuming operation performedby a sensor node Communication complexity ”C” is measured as number and sizeof packets sent and received by a sensor nodeBased on the results shown in Tables IV and V we conclude that there aresignificant tradeoffs and there is no one-size-fits-all solution for key distributionproblems in WSNsTR-05-07 Department of Computer Science Rensselaer Polytechnic Institute20 · S A C¸amtepe and B Yener(a)(b)The nodes are: A[Blom 1985] B[Blundo et al 1992] C[Eschenauer and Gligor 2002] D[Lai et al2002] E[Chan et al 2003] F[Pietro et al 2003] G[Liu and Ning 2003c] H[Du et al 2003] I[Liuand Ning 2003b] J[Zhu et al 2003] K[Du et al 2004] L[Dutertre et al 2004] M[Lee and Stinson2004b] N[Hwang et al 2004] P[Camtepe and Yener 2004] Q[Lee and Stinson 2004a] R[Huanget al 2004] S[Hwang and Kim 2004] a[Burmester and Desmedt 1994] b[Perrig et al 2000]c[Steiner et al 2000] d[Chen et al 2000] e[Carman et al 2002] f[Slijepcevic et al 2002] g[Perriget al 2002] h[Staddon et al 2002] i[Undercoffer et al 2002] j[Liu and Ning 2003a; 2003d] k[Denget al 2003a; 2003b] l[Law et al 2003] m[Bohge and Trappe 2003] n[Zhu et al 2003]Fig 6 Taxonomy of the papers on key distribution problems in (a) DWSN and (b) HWSNGraphs are DAGs (directed acyclic graphs) where nodes represent papers and edges representpredecessor/successor relations (improvements) among solutions provided by the papers Thereare three nodes which have only outgoing edges and which represent the pair-wise group-wiseand network-wise key distribution problems Style of an edge represents the problem on whichdestination node (paper) provides improvementsTR-05-07 Department of Computer Science Rensselaer Polytechnic InstituteKey distribution mechanisms for wireless sensor networks: a survey · 21Edges of figure 6(a) S K R M P CA → H ↓ ↓ ↑ ↑ - ↑A → M a ↑ ↓ ↓ ↑ - -B → G  I R ↓ ↓ - ↑ - ↑C → E b F J - - ↑ - ↑ ↑C → K - ↑ ↓ - - -C → N - - - - - ↓E → G ↑ ↑ - ↓ ↑ -G → M c ↑ - ↓ ↓ - -Edges of figure 6(b) S K R M P Cg → j ↑ - - ↓ ↓ ↑g → n - - ↓ ↑ ↑ ↑aDeterministic multiple space Blom’s scheme is consideredbMulti-path key reinforcement scheme is consideredcMultiple IOS scheme is consideredThe papers are: A[Blom 1985] B[Blundo et al 1992] C[Eschenauer and Gligor 2002] E[Chanet al 2003] F[Pietro et al 2003] G[Liu and Ning 2003c] H[Du et al 2003] I[Liu and Ning 2003b]J[Zhu et al 2003] K[Du et al 2004] M[Lee and Stinson 2004b] N[Hwang et al 2004] R[Huanget al 2004] g[Perrig et al 2002] j[Liu and Ning 2003a; 2003d] n[Zhu et al 2003]Table IV Evaluation of edges in Figure 6 Solutions corresponding to nodes (papers) of directededges are compared with each other by considering the six metrics defined in Section 42: (S)-scalability(K)-key connectivity (R)-resilience (M)-storage complexity (P)-processing complexity(C)-communication complexity A comparison result for a metric is given as ”↑” (increase) ”↓”(decrease) and ”-” (no change) Details of the solutions are given in Table VTR-05-07 Department of Computer Science Rensselaer Polytechnic Institute22·SAC¸amtepeandBYenerTable V: Evaluation of the solutions Solutions are grouped as in Sections 5 and 6 based on the keying problem and style Citation ofthe paper which provides corresponding solution is listed in ref column along with the letter with which the paper is represented in Figure6 Details of the solutions are provided for six metrics: (S)-scalability (K)-key connectivity (R)-resilience (M)-storage complexity (P)-processing complexity and (C)-communication complexity Numerical values in scalability column are the ranks of the solutions withineach section where higher ranks mean higher scalability Resilience column can take three different classes of values : (i) a number oran equation which represents probability that a link is compromised when an adversary captures a node (ii) a number or an equationwith keyword nodes which represents number of sensor nodes whose security credentials are compromised when an adversary captures anode and (iii) a number or an equation with keyword secure which represents number of sensor nodes required to compromise securityof whole WSN Processing complexity is provided in terms of unit functions such as Search Hash MAC PRF HMAC VecMul(size)PolyEval(count) etc Communication complexity includes number and size of messages sent and received where axb bxc means a numberof messages of size c units are sent and b number of messages of size c units are received Parameters used for each solution are describedin detail in Sections 5 and 6 Summary of parameters are: (d) degree of a node (p) probability that two nodes are connected due toErdos and Renyi’s work (c) number of cooperative nodes (r) regularity of a connected key distribution graph (`) number of nodes ina node class (θ) number of nodes in a generation (g) number of generations (j) number of paths (ω) number of spaces (τ) numberof spaces assigned to a node (m) number of keys in master key list of a node (u) number of commitment disclosure (v) number ofhigh level commitment disclosure and (w) number of low level commitment disclosure The papers are: A[Blom 1985] B[Blundo et al1992] C[Eschenauer and Gligor 2002] D[Lai et al 2002] E[Chan et al 2003] F[Pietro et al 2003] G[Liu and Ning 2003c] H[Du et al2003] I[Liu and Ning 2003b] J[Zhu et al 2003] K[Du et al 2004] L[Dutertre et al 2004] M[Lee and Stinson 2004b] N[Hwang et al2004] P[Camtepe and Yener 2004] Q[Lee and Stinson 2004a] R[Huang et al 2004] S[Hwang and Kim 2004] a[Burmester and Desmedt1994] b[Perrig et al 2000] c[Steiner et al 2000] d[Chen et al 2000] e[Carman et al 2002] f[Slijepcevic et al 2002] g[Perrig et al 2002]h[Staddon et al 2002] i[Undercoffer et al 2002] j[Liu and Ning 2003a; 2003d] k[Deng et al 2003a; 2003b] l[Law et al 2003] m[Bohgeand Trappe 2003] n[Zhu et al 2003]Solution Ref (S) (K) (R) (M) (P) (C)Pair-wise key pre-distribution solutions in DWSN (Section 511)All pair-wise - 1 1 0 2(N-1) Search 1x1dx1Random pair-wise E 2 Np/(N-1) 0 2Np Search 1x1dx1Closest pair-wise G 3 c/(N-1) 0 2c+1 Search or 1xPRF 1x1dx1IOS M 3 r/(N-1) 0 r+1 Search or 1xHash 1x1dx1Multiple IOS M 4 r`/(N-1) ` nodes r/`+1 Search or 1xHash 1x1dx1Master key based key pre-distribution solutions in DWSN (Section 512)BROSK D 1 1 1 1 1xPRF 1x1dx1Lightweight key management L 1 1 θ nodes 4+2g Search or 1xPRF 1x2dx2Random key-chain based key pre-distribution solutions in DWSN (Section 513)Continued on Next Page  TR-05-07DepartmentofComputerScienceRensselaerPolytechnicInstituteKeydistributionmechanismsforwirelesssensornetworks:asurvey·23Table V – ContinuedSolution Ref (S) (K) (R) (M) (P) (C)Basic probabilistic C 2((KP−k)!)2((KP−2k)!KP !)k/KP 2k Search 1xkdxkCluster key grouping N 2((KP−k)!)2((KP−2k)!KP !)k/KP 2k Search 1xCdxCPair-wise key establishment J 3((KP−k)!)2((KP−2k)!KP !)k/KP k Search+1xPRF 1x1dx1Q-composite random E 1 see E (kq )/(KPq ) 2k Search 1xkdxkMulti-path key reinforcement E 2((KP−k)!)2((KP−2k)!KP !)0 2k j XOR+Search 1xk+jx1dxk+jx1Pair-wise with threshold J 2((KP−k)!)2((KP−2k)!KP !)0 2k j XOR+Search 1xk+jx1dxk+jx1Co-operative pair-wise F 2((KP−k)!)2((KP−2k)!KP !)0 2k c XOR+Search 1xk+cx1dxk+cx1Using deployment knowledge K 2 see K k/KP 2k Search 1xkdxkCombinatorial design based key pre-distribution solutions in DWSN (Section 514)Combinatorial - Symmetric P 1 1 1/n 2(n+1) Search 1xndxnCombinatorial - GQ(n n2) P 2 1/n2 1/n3 2(n+1) Search 1xndxnCombinatorial - Hybrid P 3 see P 1/n3 2(n+1) Search 1xndxnKey matrix based dynamic key generation solutions in DWSN (Section 515)Blom’s scheme A 2 1 λ-secure 2(λ+1) VecMul(λ+1) 1x(λ+1)dx(λ+1)Multiple space H 1((ω−τ)!)2((ω−2τ)!ω!)λ-secure 2τ(λ+1) VecMul(λ+1) 1xτ+1x(λ+1)dxτ+dx(λ+1)MBS M 3 r/(N-1) λ-secure 2(λ+1) VecMul(λ+1) 1x(λ+1)dx(λ+1)DMBS M 4 r`/(N-1) ` nodes (r/`+1)(λ+1) VecMul(λ+1) 1x(λ+1)dx(λ+1)Polynomial based dynamic key generation solutions in DWSN (Section 516)Polynomial based B 3 1 λ-secure λ+1 PolyEval(1) 1x1dx1Polynomial pool I 2 1 λ-secure 2(λ+1) PolyEval(1) 1x2dx2Location-based pair-wise G 1 1 λ-secure 5(λ+1) PolyEval(1) 1x2dx2Grid-group deployment R 2 1 λ-secure 2(λ+1) PolyEval(1) 1x2dx2Group-wise key distribution solution in DWSN (Section 52)Polynomial - non-interactive B 1 1 λ-secure λ+1 PolyEval(1) 1x1(t-1)x1Polynomial - interactive B 1 1 λ-secure λ+1 1xXOR+PolyEval(t-1) tx1(t-1)x1Pair-wise key distribution solution in HWSN(Section 61)SNEP g 1 1 0 1 1xPRF 00Continued on Next Page  TR-05-07DepartmentofComputerScienceRensselaerPolytechnicInstitute24·SAC¸amtepeandBYenerTable V – ContinuedSolution Ref (S) (K) (R) (M) (P) (C)LEAP pair-wise n 1 1 1 2 1xMAC 2x22x1Group-wise key distribution solution in HWSN(Section 62)LEAP group-wise n 1 1 1 1 mxENC 0mx1Key matrix based network-wise key distribution solution in HWSN(Section 631)Multitiered f 1 1 1 m 1xPRF+1XHash 00TESLA based network-wise key distribution solution in HWSN(Section 632)micro-TESLA g 1 1 0 high 1xMAC+1XHash 0ux1TESLA Certificate m 1 1 0 high 2xMAC 03ux1µ-TESLA extensions j 2 1 0 low 1xMAC+1XHash 0vwx1TR-05-07DepartmentofComputerScienceRensselaerPolytechnicInstituteKey distribution mechanisms for wireless sensor networks: a survey · 25REFERENCESAkyildiz I Su W Sankarasubramaniam Y and Cayirci E 2002 Wireless sensor net-works: a survey Computer NetworksBlom R 1985 An optimal class of symmetric key generation systems In Eurocrypt 84Blundo C Santis A Herzberg A Kutten S Vaccaro U and Yung M 1992Perfectly-secure key distribution for dynamic conferences In Crypto 92Bohge M and Trappe W 2003 An authentication framework for hierarchical ad hoc sensornetworks In ACM workshop on Wireless SecurityBoneh D and Franklin M 2001 Identity-based encryption from the weil pairing In CRYPTO2001Burmester M and Desmedt Y 1994 A secure and efficient conference key distribution systemIn Eurocrypt 94Camtepe S and Yener B 2004 Combinatorial design of key distribution mechanisms forwireless sensor networks In 9th European Symposium on Research Computer SecurityCarman D Matt B and Cirincione G 2002 Energy-efficient and low-latency key manage-ment for sensor networks In 23rd Army Science ConferenceChan H Perrig A and Song D 2003 Random key predistribution schemes for sensornetworks In IEEE Symposium on Research in Security and PrivacyChen M Cui W Wen V and Woo A 2000 Security and deployment issues in a sensornetwork Ninja Project: A Scalable Internet Services Architecture BerkeleyDeng J Han R and Mishra S 2003a Enhancing base station security in wireless sensornetworks Tech Rep CU-CS-951-03 Department of Computer Science University of ColoradoAprilDeng J Han R and Mishra S 2003b A performance evaluation of intrusion-tolerant routingin wireless sensor networks In 2nd International Workshop on Information Processing inSensor Networks (IPSN ’03)Du W Deng J Han Y Chen S and Varshney P 2004 A key management scheme forwireless sensor networks using deployment knowledge In IEEE Infocom’04Du W Deng J Han Y and Varshney P 2003 A pairwise key pre-distribution schemefor wireless sensor networks In Proceedings of the 10th ACM conference on Computer andCommunications Security CCS’03Dutertre B Cheung S and Levy J 2004 Lightweight key management in wireless sensornetworks by leveraging initial trust Tech Rep SRI-SDL-04-02 System Design LaboratoryAprilEschenauer L and Gligor V D 2002 A key-management scheme for distributed sensornetworks In 9th ACM conference on Computer and Communications SecurityGaubatz G Kaps J P and Sunar B 2004 Public key cryptography in sensor networks InFirst European Workshop on Security in Ad-Hoc and Sensor Networks (ESAS 2004)Huang DMehta MMedhi D and Harn L 2004 Location-aware key management schemefor wireless sensor networks In 2nd ACM workshop on Security of Ad Hoc and Sensor Net-worksHuang Q Cukier J Kobayashi H Liu B and Zhang J 2003 Fast authenticated key es-tablishment protocols for self-organizing sensor networks In 2nd ACM international conferenceon Wireless Sensor Networks and ApplicationsHwang D Lai B and Verbauwhede I 2004 Energy-memory-security tradeoffs in distributedsensor networks In 3rd International Conference on Ad-Hoc Networks and Wireless (ADHOC-NOW 2004)Hwang J and Kim Y 2004 Revisiting random key pre-distribution for sensor networks InACM Workshop on Security of Ad Hoc and Sensor Networks (SASN 04)Jakobsson M Wetzel S and Yener B 2003 Stealth attacks on ad-hoc wireless networksIn Vehicular Technology ConferenceTR-05-07 Department of Computer Science Rensselaer Polytechnic Institute26 · S A C¸amtepe and B YenerKarlof C and Wagner D 2003 Secure routing in wireless sensor networks: Attacks andcountermeasures In First IEEE International Workshop on Sensor Network Protocols andApplicationsLai B Kim S and Verbauwhede I 2002 Scalable session key construction protocol forwireless sensor networks In IEEE Workshop on Large Scale RealTime and Embedded Systems(LARTES)Law Y Corin R Etalle S and Hartel P 2003 A formally verified decentralized keymanagement for wireless sensor networks In Personal Wireless CommunicationsLee J and Stinson D 2004a A combinatorial approach to key pre-distributed sensor networkshttp:// www cacr math uwaterloo ca/ ∼dstinson/ pubshtmlLee J and Stinson D 2004b Deterministic key pre-distribution schemes for distributed sensornetworks http:// www cacr math uwaterloo ca/ ∼dstinson/ pubshtmlLiu D and Ning P 2003a Efficient distribution of key chain commitments for broadcastauthentication in distributed sensor networks In 10th Annual Network and Distributed SystemSecurity SymposiumLiu D and Ning P 2003b Establishing pairwise keys in distributed sensor networks In 10thACM conference on Computer and communications security CCS’03Liu D and Ning P 2003c Location-based pairwise key establishment for static sensor networksIn 1st ACM Workshop on Security of Ad Hoc and Sensor NetworksLiu D and Ning P 2003d Multi-level u-tesla: A broadcast authentication system for distributedsensor networks Tech Rep TR-2003-08 Department of Computer Science North CarolinaState UniversityMalan D Welsh M and Smith M 2004 A public-key infrastructure for key distribution intinyos based on elliptic curve cryptography In First IEEE International Conference on Sensorand Ad Hoc Communications and Networks (SECON04)Merkle R 1978 Secure communication over insecure channels In Communications of theACMPerrig A Canetti R Tygar J and Song D X 2000 Efficient authentication and signingof multicast streams over lossy channels In IEEE Symposium on Security and PrivacyPerrig A Szewczyk RWen V Culler D and Tygar J 2002 Spins: Security protocolsfor sensor networks Wireless NetworksPietro R Mancini L and Mei A 2003 Random key assignment secure wireless sensornetworks In 1st ACM workshop on Security of Ad Hoc and Sensor NetworksShamir A 1984 Identity-based cryptosystems and signature schemes In CRYPTO 1984Slijepcevic S Potkonjak M Tsiatsis V Zimbeck S and Srivastava M 2002 On com-munication security in wireless ad-hoc sensor network In Eleventh IEEE International Work-shops on Enabling Technologies: Infrastructure for Collaborative Enterprises (WETICE’02)Staddon J Balfanz D and Durfee G 2002 Efficient tracing of failed nodes in sensornetworks In 1st ACM International Workshop on Wireless Sensor Networks and Applications(WSNA)Stajano F and Anderson R 1999 The resurrecting duckling: security issues for ad-hocwireless networks In AT&T software symposiumSteiner M Tsudik G and MWaidner 2000 Key agreement in dynamic peer groups IEEETransactions on Parallel and Distributed SystemsUndercoffer J Avancha S Joshi A and Pinkston J 2002 Security for sensor networksIn CADIP Research SymposiumWang G Cao G  and Porta T 2004 Movement-assisted sensor deployment In INFOCOM2004Zhou L and Haas Z 1999 Securing ad hoc networks IEEE Network MagazineZhu S Setia S and Jajodia S 2003 Leap: Efficient security mechanisms for large-scaledistributed sensor networks In 10th ACM Conference on Computer and CommunicationsSecurity (CCS ’03)TR-05-07 Department of Computer Science Rensselaer Polytechnic InstituteKey distribution mechanisms for wireless sensor networks: a survey · 27Zhu S Xu S Setia S and Jajodia S 2003 Establishing pairwise keys for secure commu-nication in ad hoc networks: a probabilistic approach In 11th IEEE International Conferenceon Network Protocols (ICNP’03)Zou Y and Chakrabarty K 2003 Sensor deployment and target localization based on virtualforces In INFOCOM 2003TR-05-07 Department of Computer Science Rensselaer Polytechnic Institute
Collaborative Authentication in UWSN-pdf,Collaborative Authentication In Unattended WSNsRoberto Di PietroUniversità di Roma Tredipietro@matuniroma3itClaudio SorienteUniversity of California Irvinecsorient@icsucieduAngelo SpognardiINRIA Rhône-Alpesspognard@inrialpesfrGene TsudikUniversity of California Irvinegts@icsucieduABSTRACTAn unattended wireless sensor network (UWSN) might col-lect valuable data representing an attractive target for theadversary Since a sink visits the network infrequently unat-tended sensors cannot immediately off-load data to somesafe external entity With sufficient time between sink visitsa powerful mobile adversary can easily compromise sensor-collected dataIn this paper we propose two schemes (CoMAC and ExCo)that leverage sensor co-operation to achieve data authenti-cation These schemes use standard (and inexpensive) sym-metric cryptographic primitives coupled with key evolutionand few messages exchange We provide security analysis forproposed schemes and assess their effectiveness via simula-tions We show that proposed schemes cope well with realWSN issues such as message loss and sensor failure Wealso compare the two schemes with respect to robustnessand overhead which allows network designers to carefullyselect the right scheme and tune appropriate system param-etersCategories and Subject DescriptorsC20 [Computer-Communication Networks]: General—Security and protection; C21 [Computer-CommunicationNetworks]: Network Architecture and Design—Wirelesscommunication; C24 [Computer Systems Organiza-tion]: computer communication networks—Distributed Sys-tems; K65 [Management of Computing and Informa-tion Systems]: Security and ProtectionGeneral TermsPerformance SecurityKeywordsWireless Sensor Networks Authentication Mobile Adver-saryPermission to make digital or hard copies of all or part of this work forpersonal or classroom use is granted without fee provided that copies arenot made or distributed for profit or commercial advantage and that copiesbear this notice and the full citation on the first page To copy otherwise torepublish to post on servers or to redistribute to lists requires prior specificpermission and/or a feeWiSec’09 March 16–18 2009 Zurich SwitzerlandCopyright 2009 ACM 978-1-60558-460-7/09/03 $5001 INTRODUCTIONUnattended Wireless Sensor Networks (UWSN-s) are anemerging class of WSN-s where the sink visits the networkto collect sensed data at infrequent intervals UWSN nodesstore sensed data locally until the next sink visit In con-trast much of prior research in WSN security assumes thatthe network is constantly attended by a trusted entity (col-lector or sink) to which data can be transferred at willThe inability to off-load sensed data in real time makesUWSN-s susceptible to a wide range of attacks Within thetime between sink visits an adversary (ADV from now on)can compromise sensors manipulate sensed data and leavethe network without leaving a trace The type of adversarythat roams the network gradually compromising nodes is of-ten called a mobile adversary Such an adversary has twosalient characteristics: (1) it can simultaneously compromiseup to k-out-of-n nodes (where k < n and n is the networksize); and (2) it can migrate between sets of compromisednodes In the last year several consecutive research results[6 16 5] defined the UWSNmobile adversary identified sev-eral sub-types varying in goals and behavior and suggestedsome mitigating techniques Such techniques are necessarysince prior solutions from WSN security literature are un-suitable for coping with a mobile adversary in UWSN-sIn this paper we focus on the type of the mobile adversarythat aims to introduce fraudulent data into the UWSN Suchan adversary might attempt to do so by replacing authenticdata obtained by sensors or by simply injecting fraudulentdata Within this framework we make several contribu-tions First we overview current solutions for the authen-tication problem in UWSN-s and show that they only offerweak protection against a mobile adversary Second we con-struct two techniques – based on sensor cooperation – thatachieve much higher security (compared to prior results)with small increase in overhead Both techniques rely onlyon symmetric cryptography We explore the effectiveness ofproposed techniques both analytically and via simulationsFurthermore we show how they cope with real network is-sues eg message loss and sensor failure Analytical andsimulation results indicate that our schemes are resilient aswell as efficient and allow network designers to easily findthe desired balance between overhead and robustnessThe rest of the paper is organized as follows: next sec-tion surveys related work Section 3 introduces the systemmodel in particular the network assumptions and the adver-sarial model Section 4 shows that traditional authenticationtechniques do not provide sufficient security in UWSN-sProposed cooperative schemes are introduced in Section 5237and security analysis is provided in Section 6 Simulationresults and discussion are presented in Section 7 Section 8provides concluding remarks2 RELATED WORKWSN security is a mature research area A number of im-portant topics were considered in the prior literature suchas: secure initialization key management secure/resilientrouting clone detection broadcast authentication and se-cure localization Data authentication has been the subjectof several research efforts however all of them relied on theconstant presence of the sink Several schemes eg [1714] have been proposed for efficient sink-to-sensors broad-cast authentication In contrast we focus on sensor-to-sinkdata authentication in the envisaged UWSN setting in thepresence of a mobile adversaryIn some prior work sensors are assumed capable of de-tecting false data via collaborative mechanisms for valueendorsement For example [22] describes an interleaved au-thentication scheme for filtering false data It is based onthe assumption that data with a list of MAC-s are routedtowards the sink and recursively verified along the routeSensors are grouped into clusters of size at least t+1 wheret is a collusion threshold: if t or fewer sensors are compro-mised the network detects false data before it traverses t+1hops towards the sinkA similar technique is Statistical En-route Filtering (SEF)[19] In it a data packet is authenticated by each clustersensor with an individual MAC Assuming a suitable keypre-distribution scheme one MAC is verified with a certainprobability at each hop along the route When a packetreaches the sink all enclosed MAC-s are verified An ex-tension to SEF can be found in [20] where the effectivenessof filtering is enhanced by using a family of pre-distributionand local collaborative cluster re-keying schemesOther schemes using en-route filtering include [18] and[21]: the former incorporates localization information foradditional data protection while the latter provides extrasecurity via multi-path routingAn authentication framework for hierarchical sensor net-works is presented in [4] It leverages network heterogeneityto relegate expensive crypto-operations to the most powerfulsensorsWhile many prior techniques provide bottom-up (sensors-to-sink) authentication we focus on Unattended WSN-swithout sink’s constant presence As mentioned earlier somevery recent results considered UWSN-s but focused on differ-ent problems and mobile adversary sub-types such as datasurvival [6] and key healing [16 5] for intrusion-tolerant se-crecyWe note that data authentication in UWSN-s was firstinvestigated in [15] which constructed forward-secure ag-gregate authentication techniques that optimize storage re-quirements However this is effective only against a rela-tively weak adversary referred to as reactive in [7] (More-over no communication among sensors is assumed in [15])Techniques proposed in this paper share some featureswith cooperative key-healing approaches in [16] and [5] Inboth [16] and [5] sensors regain security after compromiseusing randomness provided by non-compromised peers Se-crets derived from combining contributions by peers withprior state are used either as keys (with symmetric encryp-tion) or as randomizers (with public key encryption) How-ever the symmetric key case is very fragile since it assumesno lost messages and no node failures The public key caseis thus the only robust approach Unfortunately it doesnot apply to data authentication for the following reasonA secret value can be used as a randomizer in public keyencryption (under the sink’s public key) such that givena ciphertext learning the corresponding plaintext requiresguessing this randomizer which is computationally unfea-sible The same secret value cannot be used as a privatekey in computing digital signatures since signature verifica-tion requires the verifier (sink) to obtain the correspondingpublic key; but the public key (being dependent on the pri-vate key) is not always computable by the sink due to lostmessages and node failuresSolutions explored in this paper rely on purely symmetrictechniques and offer robustness in spite of imperfect com-munication and potential node failures Also our techniquesachieve higher security than [16 5] with the same bandwidthoverhead3 SYSTEM MODELThis section describes our assumptions about the networkand the adversary Notation is summarized in Table 1ADV the mobile adversaryn size of the UWSNv max # of rounds between successive sink visitsCr set of compromised sensors at round rk ADV’s compromise power – maximum size of Crs1sn sensorssi i ∈ [1n] node that collected target datar¯ target data collection rounddrj data collected by sj in round rKrj key used by sj in round rzrj MAC computed by sj at round r using Krjt numbers of co-authenticatorsTable 1: Notation31 Network assumptionsWe assume a homogeneous UWSN composed by a set ofsensors {s1 s2     sn} uniformly distributed over a certaingeographical area Notable details and assumptions are asfollows (similar to those in [5]):• Data collection: Time is divided in collection roundsand each sensor collects a single data item per roundRound synchronization can be obtained via any well-known technique such as [11]• Unattended operation: An itinerant sink period-ically visits the UWSN to collect data There is asystem-wide parameter – v – denoting the maximumnumber of data collection rounds between successivesink visits• Communication: The UWSN is always connectedand any two sensors can communicate either directlyor through peers according to the underlying routingprotocol However messages can be lost and sensorscan fail• Storage: Each sensor has storage to accommodateO(v) data items238• Cryptographic Capabilities: Each sensor can per-form cryptographic hashing and has a Pseudo-RandomNumber Generator (PRNG) initialized with a uniquesecret seed shared with the sink• Re-initialization: At each visit the sink securely re-initializes secret seed values for all sensors and resetsthe round counter32 Adversarial modelThe envisaged adversary has the following features:• Goal: ADV aims to substitute a value obtained bysi at round r¯ with an arbitrary value of its choiceWe assume that any sensor and any round are equallylikely to be chosen as ADV ’s targets ADV learns itsobjective namely si and r¯ at the end of round r¯ andfrom that moment it has v − r¯ rounds to accomplishits goal ADV is successful if at the end of roundv the sink visits the network to collect sensed dataand validates the value injected by the adversary as ameasurement of si at round r¯ We stress the fact thatthe network is unaware of si and r¯; thus each collecteddata item must be equally protected• Compromising capabilities: ADV can compromisea constant number k (k < n) of sensors at any roundbetween 1 and v If a sensor is compromised at round rADV acquires keys and status reads all storage/memoryand can eavesdrop on all incoming and outgoing com-munications of the compromised sensor We furtherdistinguish two types of ADV :Reactive: ADV starts compromising sensors at roundr¯ + 1 that is after identifying its targetProactive: ADV starts compromising sensors at round1 before receiving any information about the targetsensor and the target data collection round• Periodic Operation: Time is divided into equal andfixed compromise rounds At the end of each compro-mise round ADV picks a subset of k sensors to becompromised in the following round — this subset canhave non empty intersection with former one At thestart of each round the adversary releases in an atomicway the subset of sensors compromised in the previousround and compromises the new subset• Compromise Round & Collection Round: Forease of exposition and without loss of generality we as-sume that the compromise and collection rounds havethe same duration and are synchronized ie bothtypes of rounds start and end at the same time• Topology Knowledge: ADV knows the entire topol-ogy of the UWSN• Minimal Disruption: ADV does not interfere withsensor behavior mainly in order to remain undetectedIn particular it does not delete or delay messages anddoes not introduce spurious messages ADV ’s goal isto find the target data and replace it• Defense Awareness: ADV is fully aware of any schemeor algorithm that the UWSN uses to protect itselfNote that a proactive ADV starts compromising sensors be-fore learning its target; thus possibly si ∈ Cr¯ This caseis not interesting as ADV wins by dumb luck We focus ona more interesting and likely scenario where si /∈ Cr¯ andpossibly si ∈ Cr r < r¯ That is ADV does not controlsi while target data is being collected but it might havecompromised (and then released) that sensor at some ear-lier round4 BASIC TECHNIQUESSinceADV is focused on replacing (modifying or manufac-turing) data authentication is a natural defence That canbe achieved via either message authentication codes (MAC-s) or public key signatures Although it is normal to expectthe latter to offer better security we show that this is nottrue in UWSN-sWith MAC-s each sensor sj has a unique secret key Kj(shared with the sink) used for computing MAC-s At eachround r sj collects drj and computes zrj = MAC(Kj  drj)whereMAC(◦) can be the standard HMAC During its nextvisit the sink collects all pairs {drj  zrj }1≤r≤v and proceedsto verify their authenticityWith public key signatures each sensor sj can be initial-ized with a key-pair {SKj  PKj} SKj is used to sign col-lected data while PKj is used by anyone (eg the sink) forsignature verification At round r sj collects drj and com-putes σrj as the signature on drj under SKj  When the sinkcollects all pairs {drj  σrj}1≤r≤v it can verify each signaturewith sj ’s public keyUnfortunately neither approach is effective against ourmobile adversary not even against the reactive version In-deed once the reactive ADV learns {si r¯} it compromisessi during round r¯ + 1 and learns Ki (in case of MAC) orSKi (in case of public key signatures); knowledge of thiskey allows ADV to produce MAC-s or signaturesNote that off-loading data to random peers as investi-gated in [6] does not help much since after a few roundsADV can locate and replace the target dataA natural defense against a reactive ADV is the use offorward-secure cryptographic techniques Such techniquesrely on per-round key evolution that makes computationallyinfeasible for ADV to compute a prior key from any of itsdescendants Forward-secure MAC [3] and forward-securesignature schemes [2] can be found in the literature Witha forward-secure scheme even if the reactive ADV compro-mises si at round r¯+1 and learns si’s current key it cannotcompute the key used by si in round r¯ Once ADV compro-mises a sensor it does not matter whether forward-secureMAC-s or signatures are used; in either case ADV can onlyevolve the current key into the futureAlthough forward security is effective against a reactiveADV  it does not protect against its proactive counterpartRecall that: (1) if ADV is proactive we could have si ∈Cr r < r¯ and (2) with a forward-secure authenticationscheme ADV can compute keys that will be used by com-promised sensors in any round after compromise Thusif si ∈ Cr r < r¯ ADV can compute Kr¯i and replaceboth target data and its authentication tag Finally ifsi /∈ Cr r < r¯ the situation is essentially the same aswith the reactive ADV To protect against a proactive ADV  we need anotherproperty called backward security Informally an authenti-cation scheme is backward secure if knowledge of the secret239for the current round cannot lead to learning the next roundsecret An authentication scheme that is both forward andbackward secure is called key-insulated Unfortunately cur-rent key insulated schemes [9 10 8 12 13] are unsuitable forour setting The reason is that in a key-insulated schemeat least one of the inputs for the key evolution function mustcome from a separate entity typically a remote trusted thirdparty or a local tamper-resistant hardware device In the en-visaged UWSN setting neither per-sensor secure hardwarenor a constantly present third party is realisticIn summary we state that no current authentication schemecan achieve the desired level of security (both forward andbackward security) for UWSN-s to cope with a proactiveadversary5 COOPERATIVEMECHANISMSThe main shortcoming of aforementioned basic approachesis that the authentication tag of a given data item dependson the current key of a single sensor Once that sensor iscompromised its key becomes exposed and data can thusbe easily replaced Involving several sensors in the authenti-cation process of a single data item can lead to more secureschemes In the following we construct and evaluate twoschemes that enhance UWSN security using so-called co-authenticators We say that sj is a co-authenticator of slif sl requires sj ’s cooperation to authenticate its data Bysecurity we mean the probability that target data cannot bereplaced (until the next visit of the sink) Since as discussedabove public key signatures do not offer any particular ad-vantage we consider schemes that only rely on symmetriccryptography51 Co-MACThe main idea in this scheme is that each sensor asks aset of randomly chosen peers to authenticate its data and tokeep the resulting tagsAt round 1 each sj has an initial key K1j shared withthe sink At the end of each round a sensor evolves itscurrent key via a one-way collision-resistant function F (◦)to compute the next round’s key At any round sj runstwo separate processes MAIN and RECEIVE The formercomputes MAC of sensed data and commits it to storage Italso sends the data to t randomly chosen co-authenticatorsThe RECEIVE process receives data from peers computesMAC-s commits them to storage and computes the nextround keyProcess 1 CoMAC: MAINSense drjCompute zrj =MAC(Krj  drj )Store {djr zrj }Set Srj = SELECT DISTINCT(t n j)for p=1t doSend drj to sSrj [p]end forThe function SELECT DISTINCT(t n j) returns an ar-ray of t distinct elements randomly chosen from the set:{1     n} \ {j} Its output is based on the results of thePRNG that is initialized with a secret seed given by thesink and then queried at every round This way the sinkknows Srj for any sj and any rProcess 2 CoMAC: RECEIVESet Rrj = ∅p=1while round not over doReceive drqSet Rrj [p] = qCompute MAC(Krj  drq)Store MAC(Krj  drq)Set p = p+ 1end whileStore RrjCompute Kr+1j = F (Krj ||Rrj [1]||    ||Rrj [|Rrj |])During its next visit the sink acquires collected data alongwith corresponding MAC-s For each drj  it verifies zrj withKrj and then repeats the process for each co-authenticatorsq ∈ Srj  If all t + 1 MAC-s are verified successfully thesink considers drj to be authentic ie actually collected bysj at round r Note that computation of any Krj requiresknowledge of Kr−1j as well as knowledge of the sensors thatsj received a message from at round r (namely Rrj ) Thesink can compute anyKrj as it knows the initial key of sj andcan read the sets {Rr′j }1≤r′≤r−1 from sj ’ storage At anyround each sensor sends t messages and stores on averaget+ 1 MAC-sIn the present scheme each MAC authenticates a singledata item and is stored by the sensor that produced it As wediscuss below better security can be achieved by bundlingbatches of MAC-s computed over different data items frommultiple sensors52 Extensive Cooperation (ExCo)In this scheme each sensor sends the MAC computed overits own data to t randomly-chosen co-authenticators More-over it bundles all received MAC-s into a single authen-tication tag At round r sj runs the following processes:Process 3 ExCo: MAINSense drjCompute zrj =MAC(Krj  drj )Set Srj = SELECT DISTINCT(t n j)for p=1t doSend zrj to sSrj [p]end forProcess 4 ExCo: RECEIVESet Rrj = ∅Set Λrj = ∅p=1while round is not over doReceive zrqSet Rrj [p] = qSet Λrj [p] = zrqSet p = p+ 1end whileCompute Hrj =MAC(zrj ||Λrj [1]||    ||Λrj [|Rrj |])Compute Kr+1j = F (Krj ||Rrj [1]||    ||Rrj [|Rrj |])Store {drj Hrj  Rrj}Process MAIN computes the MAC of current data andsends it to t randomly chosen peers Process RECEIVE240Figure 1: In ExCo at round r Rrj contains the sen-sors which sj received a MAC from Srj contains thesensors sj sent its MAC to and Trj contains the sen-sors that sent the MAC to any sensor in Srj receives MAC-s from peers aggregates them in a single au-thentication tag commits it to storage and computes thenext round keyData verification in ExCo is similar to that in CoMACOnce the sink acquires drj  it verifies all authentication tagsinvolving that value In particular to verify drj  the sinkmust compute:• Hrj using Krj and {Krq  drq}sq∈Rrj• {Hrq }sq∈Srj using {Krq  drq} and {Krp  drp}sp∈Trj whereT rj = {Ssl∈SrjRrl }By T rj we denote the set of sensors that have at least one co-authenticator in common with sj at round r As an exampleFigure 1 shows a network where the colored sensors are theones involved in the authentication of a value sensed by sj atround r An arrow between sp and sq means that sq ∈ Srp  Inorder to verify drj  the sink must verify all the authenticationtags produced by sj ∪ Srj  That requires Krj as well as keyand sensed data at round r from each sensor in Srj ∪Rrj ∪Trj As before the sink can compute the key used by any sen-sor at any round knowing the initial key and using informa-tion found on that sensor At any round each sensor sendst messages and stores two authentication tags6 SECURITY ANALYSISIn this section we analyze ADV ’s ability to replace targetdata and its authentication tag(s) We assume that ADV isproactive and roams the network before learning r¯ hopingto discover as many keys as possible To maximize the totalnumber of collected keys (by round r¯) ADV compromisessensors in a round-robin fashion choosing Cr such that Cr∩{C1∪   ∪Cr−1} = ∅ With this strategy ADV can visit allsensors by round ⌈nk⌉ and from that point on it can replaceany data subsequently collected by any sensor 0 02 04 06 08 1 1  2  3  4  5  6  7  8  9  10Survival ProbabilityTarget data collection roundSettings: n=100 k=10t=1t=3t=5t=15Figure 2: Survival probability of the target datawith CoMAC61 CoMACTo “win” against CoMAC ADV must replace authentica-tion tags generated by si and Sr¯i  For this to happen:si ∪ Sr¯i ∈ {C1 ∪    ∪ Cr¯−1} (1)The probability of this event can be expressed as:PADV(n k r¯ t) =8<:k(r¯−1)n·Qti=1kr¯−in−iif kr¯ ≤ n1 otherwiseThe first term on the left accounts for the probability thatsi is compromised before round r¯ while the other terms rep-resent the probability that sensors in Sr¯i are compromisedup-to round r¯ Consequently the probability that the targetdata remains unforged is:PCoMAC(n k r¯ t) = 1− PADV(n k r¯ t) (2)Figure 2 plots this probability in a UWSN 100 sensorswhere ADV can compromise k = 10 sensors per round Itshows that even if target data collection occurs after ADVcompromises a substantial portion of the network ADV ’ssuccess probability is rather low even for small values of tUsing the set Rrj to update sj key at round r preventsADV from deleting any MAC computed by sj at that roundIn fact if ADV does not know the key of any sensor sj ∈ Sr¯i it might delete MAC(K r¯j  dr¯i ) from sj ’s storage as if si’s re-quest to MAC its data never reached sj  With the adoptedkey evolution if si is removed from Rr¯j  the sink will notbe able to correctly compute K r¯+1j  In particular sj wouldcompute K r¯+1j = F (Kr¯j ||Rr¯j ) while the sink would computeit as K r¯+1j = F (Kr¯j ||Rr¯j \ {si}) As a result verification ofany MAC computed by sj from round r¯+1 on will fail andthat would expose ADV ’s presence to the sink62 ExCoWith ExCo ADV must replace (that is must be able torecompute) all the authentication tags generated using dr¯i In particular ADV must replace H r¯i as well as Hr¯j for eachsj ∈ Sr¯i For each of the above authentication tags ADV mustknowK r¯i  Computation ofHr¯i requires also (Kr¯j  dr¯j) for each241sj ∈ Rr¯i  Furthermore for each sj ∈ Sr¯i  computation of Hr¯jrequires knowledge of both (K r¯j  dr¯j) and {(Kr¯q  dr¯q)}sq∈Sr¯j To summarize ADV must know all the following keys:K r¯i  {Kr¯j  dr¯j}sj∈Rr¯i  {Kr¯j  dr¯j}sj∈Sr¯i and {Kr¯j  dr¯j}sj∈T r¯i  Thatis ADV must have compromised si at any round r < r¯ andsensors in Sr¯i ∪Rr¯i ∪ Tr¯i at any round r ≤ r¯Note that sinceADV can eavesdrop on traffic routed throughcompromised sensors it does not require to know the pairs{K r¯j  dr¯j} if it has intercepted the corresponding zr¯j  Asshown in Figure 1 to replace target data ADV must knowK r¯i  as well as keys and sensed values at round r for everysensor in Sr¯i ∪ Rr¯i ∪ Tr¯i  To assess the effort ADV has tomake to succeed we estimate the probability of a sensor tobe in at least one of the sets Rr¯i  Sr¯i  Tr¯i  Let R (respectivelyS T ) denote the event that a sensor is in the set Rr¯i (Sr¯i  Tr¯i )and let R (respectively S T ) denote the event that a sensoris NOT in the set Rr¯i (Sr¯i  Tr¯i ) We can write:P [R] = P [S ] =tn− 1since a sensor always sends its value to t distinct sensorsrandomly chosen excluding itself and a sensor is selected –on average – by tn−1sensors as a co-authenticator We canalso write thatP [T |R ∧ S] =P [T ∧ R ∧ S]P [R∧ S]and thenP [T ∧ R ∧ S] = P [T |R ∧ S] · P [R∧ S] (3)It is worth noting that P [T |R∧S ] = P [T |R] since belong-ing to the set T r¯i is completely independent from belongingto set Sr¯i : ie sensor sj ∈ Sr¯i because has been chosen bysi but sj ∈ Tr¯i because itself chose as a co-authenticatoranother sensor in Sr¯i  To evaluate Equation 3 we can writeP [T |R] =„1−tn− 2«  „1−tn− 2− (t− 1)«==t−1Yj=0„1−tn− 2− j«≥„1−tn− 2«t(4)The last relation holds since sensor sj /∈ Tr¯i only if sj sentall its t MAC-s to sensors not belonging to Sr¯i (namely n− tsensors) and sensor sj did not send any MAC to si (sincesj /∈ Rr¯i ) Since sj cannot choose itself as a recipient for aMAC we have that sj /∈ Tr¯i because it has chosen t timesfrom the same set with n − t − 2 sensors always excludingsi sj and any sensor in Sr¯i Thus we can estimate ν(n t) the number of sensors in-volved in the computation of the authentication tags of genericdata drj  asν(n t) = n`1− P [T ∧ R ∧ S]´≥ n 1−„tn− 1«2„1−tn− 2«t!(5)Figure 3 reports the size of the set Rrj ∪ Srj ∪ Trj for t = 3varying the size of the network n from 100 to 1000: it reportsthe ratio between the number of times the set resulted of acertain size and the total number of trials The expectedsize was 14287 and 14906 for n = 100 and n = 1000 re-spectively while Equation 5 produces 1442 and 1494 re-spectively 0 002 004 006 008 01 012 014 0  5  10  15  20  25  30ProbabilitySet sizeSettings: t=3n=100n=1000Figure 3: Distribution of the size of R ∪ S ∪ T  0 10 20 30 40 50 60 70 80 90 100 0  5  10  15  20Expected size of set R ∪ S ∪ TNumber of co-authenticators (t)Settings: n=100set sizeFigure 4: Expected size of R ∪ S ∪ T Figure 4 reports the expected size of the set Rrj ∪Srj ∪Trj obtained via Equation 5 fixing n to 100 and varying thenumber of co-authenticators t It is clear that fixed t ExCoachieves better security than CoMAC because each data isauthenticated using secret material from a larger number ofsensors (ν(n t)+1 against t+1) In next section we presentsthe results of our simulations that confirm the above analysis(see Figure 5)As in CoMAC here as well key evolution is performedusing the IDs of communicating peers so that ADV can notdelete traces of the communication between sensors withoutrevealing its presence to the sink (cf Section 61)7 SIMULATION AND DISCUSSIONIn this section we present the results of our simulationsand discuss the robustness of presented schemes71 Simulation ResultsTo support the analysis of previous sections we report theresults of our simulations Experiments were run for a net-work with 100 sensors with k = 10: for each scenario ADVroams the network for r¯ rounds corrupting k different sen-sors at each round and collecting the keys that the sensorswill use to generate authentication tags The sensors on the242 0 02 04 06 08 1 1  2  3  4  5  6  7  8  9  10Survival probabilityTarget data collection roundSettings: n=100 k=10ExCo t=1CoMAC t=3ExCo t=3CoMAC t=15Figure 5: Comparison between CoMAC and ExCoother side sense a data item per round and authenticate itaccording to the selected scheme After r¯ rounds we ran-domly select target data among all data item collected dur-ing the current round and verify if ADV has all the requiredkeys used to produce the authentication tags Experimentswere repeated 1000 times for each configuration of t and r¯;the reported values are the resulting averagesIf target data was sensed at round 1 ADV has no way tosucceed since by assumption target data is never sensed bya sensor that is currently compromised Similarly if targetdata was sensed at round ≥ ⌈nk⌉ there is no way to avoidADV ’s success since enough rounds have passed to have theadversary compromising the whole networkFigure 5 and Figure 6 compare CoMAC and ExCo se-curity showing the survival probability of target data asintroduced in Section 6Figure 5 highlights the correctness of Equation 5 The xaxis is the number of compromise rounds before the targetdata collection one while the y axis is the expected survivalprobability Fixed n security performances of ExCo witht co-authenticators can be compared with CoMAC that in-volves ν(n t) co-authenticators: in figure ExCo with t = 1and t = 3 is comparable with CoMAC with t = 3 and t = 15respectivelyFigure 6 compares the schemes showing 3d plots of theexpected survival probability of target data: the x axis rep-resents the number of co-authenticators (t) while the y axisis the number of compromise rounds (r¯) before the targetdata collection one The survival probability of ExCo is al-ways greater than the one obtained by CoMAC for the sameconfiguration of t and r¯ For example given t = 3 survivalprobability of target data with ExCo is 08 even if ADVhas compromised 90% of the sensors Given the same ratioof compromised sensors CoMAC only reaches 03 survivalprobabilityEven if ADV has compromised 90% of the network beforetarget data is collected ExCo with t ≥ 4 provides a survivalprobability greater than 092 while CoMAC requires t = 20to reach such high probability72 RobustnessAnalysis and simulations of previous sections are valid foran ideal networks where messages between sensors are alwaysdelivered and sensors do not stop working for events such asmalfunctioning or battery depletion In this section we tryto analyze the proposed protocols in a real network wheremessage delivery can fail with probability β and sensor canfail with probability γMessage failure In an ideal network messages are au-thenticated t + 1 times with CoMAC and on the averageν(n t) + 1 times with ExCo With unreliable message de-livery the number of sensors that would authenticate drj would be dropped by a factor of β in both schemes In theworst case all messages sent by sj at round r are not deliv-ered and drj is only authenticated by sj  In this scenariofor ADV to win it only requires Krj to reach its goal withCoMAC while with ExCo it requires Krj as well as any keyKrq such that sq ∈ Rrj Sensor failure In case of sensor failure sensed data andMAC-s computed by the failed sensor are lost In particularassume that sl fails at round rWith CoMAC for each round r′ < r each dr′j such thatsl ∈ Sr′j looses one MAC Also the MAC-s computed on drlby any sj ∈ Srl can be discarded by the sink as data onwhich those MAC-s are computed will not be availableWith ExCo at each round r′ < r one authenticationtag of the value dr′q sensed by sq ∈ {Sr′j ∪ Rr′j ∪ Tr′j } willnot be verifiable Comparing ExCo and CoMAC the highersecurity achieved by ExCo leveraging on the secret materialof a larger set of peers comes at a cost of lower robustnessIn realistic settings if messages are not always deliveredand sensors can fail the sink might find MAC-s that lackof the corresponding data they where computed on or col-lected data with t′ ≤ t+ 1 MAC-sIn the first case MAC-s can be discarded Indeed if sen-sors become aware that any peer has failed (this mechanismis out of the scope of this paper however this informationcould be inferred from the routing protocol [1]) they candelete from their storage all MAC-s computed on data col-lected by the failed sensor In the second case data au-thentication is still viable but weakened Indeed we canconsider that the number of MAC-s provides a natural de-gree of confidence on the authenticity of the data: the morethe number of MAC-s the more the effort the adversaryneeds to make to forge an authenticated value8 CONCLUSIONIn this paper we focused on a mobile adversary attempt-ing to replace authentic data in UWSN-s We proposed twotechniques based on sensor cooperation that achieve muchhigher security than prior results with little overhead Bothtechniques rely only on symmetric cryptography We ex-plored the effectiveness of proposed techniques both analyt-ically and via simulations We also demonstrated how theycope with real network issues such as message loss and sen-sor failure9 ACKNOWLEDGMENTSRoberto Di Pietro is also with the UNESCO Chair in DataPrivacy Universitat Rovira i Virgili DEIM — TarragonaSpain Authors are the solely responsible for the views ex-pressed in this paper which do not necessarily reflect theposition of UNESCO nor commit that organizationThis work was partly supported by The Spanish Ministryof Science and Education through projects TSI2007-65406-243 1 2 3 4 5 6 7 8 9 10Co-authenticators (t)  1 2 3 4 5 6 7 8 9 10 Round of target data (r) 0 02 04 06 08 1Survival probability(a) CoMAC 1 2 3 4 5 6 7 8 9 10Co-authenticators (t)  1 2 3 4 5 6 7 8 9 10 Round of target data (r) 0 02 04 06 08 1Survival probability(b) ExCoFigure 6: Comparison between CoMAC and ExCoC03-01“E-AEGIS”and CONSOLIDERCSD2007- 00004“AR-ES” and by the Government of Catalonia under grant 2005SGR 00446; the IST project SENSEI (Integrating the Phys-ical with the Digital World of the Network of the FutureGrant Agreement Number: 215923) It was also supportedin part by an award from the US Army Research Office(ARO) contract W911NF0410280 as well as a grant fromthe US Fulbright Foundation10 REFERENCES[1] K Akkaya and M F Younis A survey on routingprotocols for wireless sensor networks Ad HocNetworks 3(3):325–349 2005[2] M Bellare and S Miner A forward-secure digitalsignature scheme In CRYPTO 1999[3] M Bellare and B Yee Forward Integrity for SecureAudit Logs UCSD CSE Dept Technical Report 231997[4] M Bohge and W Trappe An authenticationframework for hierarchical ad hoc sensor networks InACM Workshop on Wireless Security 2003[5] R Di Pietro D Ma C Soriente and G Tsudik Posh:Proactive co-operative self-healing in unattendedwireless sensor networks In IEEE SRDS 2008[6] R Di Pietro L Mancini C Soriente A Spognardiand G Tsudik Catch me (if you can): Data survivalin unattended sensor networks In IEEE PerCom2008[7] R Di Pietro L Mancini C Soriente A Spognardiand G Tsudik Playing hide-and-seek with a focusedmobile adversary Cryptology ePrint Archive Report2008/293 2008[8] Y Dodis M Franklin J Katz A Miyaji andM Yung A generic construction for intrusion-resilientpublic key encryption In CT-RSA 2004[9] Y Dodis J Katz S Xu and M Yung Key-insulatedpublic key cryptosystems In EUROCRYPT 2002[10] Y Dodis J Katz S Xu and M Yung Strongkey-insulated signature schemes In PKC 2003[11] S Ganeriwal S Capkun C Han and M SrivastavaSecure time synchronization service for sensornetworks In WiSe 2005[12] G Itkis Intrusion-resilient signatures: Genericconstructions In SCN 2002[13] G Itkis and L Reyzin SiBIR: Signer-baseintrusion-resilient signatures In CRYPTO 2002[14] D Liu P Ning S Zhu and S Jajodia Practicalbroadcast authentication in sensor networks In IEEEMobiQuitous 2005[15] D Ma and G Tsudik Extended abstract:Forward-secure sequential aggregate authentication InIEEE S&P 2007[16] D Ma and G Tsudik DISH: Distributed Self-Healing(in Unattended Sensor Networks) In SSS 2008[17] A Perrig R Szewczyk V Wen D E Culler andJ D Tygar Spins: security protocols for sensornetowrks In MOBICOM 2001[18] H Yang F Ye Y Yuan S Lu and W A ArbaughToward resilient security in wireless sensor networksIn ACM MobiHoc 2005[19] F Ye H Luo S Lu and L Zhang Statisticalen-route filtering of injected false data in sensornetworks In IEEE INFOCOM 2004[20] W Zhang and G Cao Group rekeying for filteringfalse data in sensor networks: a predistribution andlocal collaboration-based approach In IEEEINFOCOM 2005[21] Y Zhang J Yang and H T Vu The interleavedauthentication for filtering false reports in multipathrouting based sensor networks In IPDPS 2006[22] S Zhu S Setia S Jajodia and P Ning Interleavedhop-by-hop authentication against false data injectionattacks in sensor networks TOSN 3(3) 2007244
DISH-pdf,DISH: Distributed Self-Healing(in Unattended Sensor Networks)Di Ma and Gene TsudikUniversity of California Irvine{dma1gts}@icsucieduAbstract Unattended wireless sensor networks (UWSNs) operating in hostile environ-ments face the risk of compromise Unable to off-load collected data to a sink or someother trusted external entity sensors must protect themselves by attempting to mitigatepotential compromise and safeguarding their dataIn this paper we focus on techniques that allow unattended sensors to recover from intru-sions by soliciting help from peer sensors We define a realistic adversarial model and showhow certain simple defense methods can result in sensors re-gaining secrecy and authentic-ity of collected data despite adversary’s efforts to the contrary We present an extensiveanalysis and a set of simulation results that support our observations and demonstrate theeffectiveness of proposed techniques1 IntroductionSensors and sensor networks are deployed and utilized for various applications in both civilianand military settings One of the most attractive properties of sensors is their alleged ease ofdeployment Because of the low cost of individual sensors and commensurately meager resourcessecurity in sensor networks presents a number of formidable and unique challenges A large bodyof research has been accumulated in recent years dealing with various aspects of sensor networksecurity such as key management data authentication/privacy secure aggregation secure routingas well as attack detection and mitigationRecently unattended sensors and unattended sensor networks (UWSN) have become subjectof attention in the security research community [1 2] In the unattended setting a sensor isunable to communicate to a sink at will or in real time Instead it collects data and waits for anexplicit signal (or for some pre-determined time) to upload accumulated data to a sink In otherwords there is no real-time reporting of sensed data The inability to off-load it in real timeexposes the potentially sensitive data accumulated on unattended sensors to certain risks Thisis quite different from prior sensor security research where there is an assumption of an on-linesink collecting data in a more-or-less real-time fashionUnattended sensors deployed in a hostile environment represent an attractive attack targetWithout external connectivity sensors can be compromised with impunity and collected data canbe altered erased or substituted Sensor compromise is a realistic threat since sensors are oftenmass-produced commodity devices with no secure hardware or tamper-resistance componentsPrior security work typically assumed that some number of sensors can be compromised duringthe entire operation of the network and the main goal is to detect such compromise This is areasonable goal since given a constantly present sink attacks can be detected and isolated Thesink can then immediately take appropriate actions to prevent compromise of more sensorsIn our case in contrast the adversary can compromise a number of sensors within a particularinterval This interval can be much shorter than the time between successive visits of the sinkThus given enough intervals the adversary can subvert the entire network as it moves betweensets of compromised sensors gradually undermining security Generally speaking this type ofadversary is well-known in the cryptographic literature as the mobile adversary [3]11 The mobile adversary model is used to justify proactive cryptographic primitives such as signaturesand decryption [4 5]Consequently the main security challenge in the UWSN scenario is: How can a disconnectedsensor network protect itself from a mobile adversary? Here “protect” means: “maintain secrecyof collected information” ie can a sensor keep the adversary from learning sensed data eventhough the adversary might eventually break into that sensor and learn all of its secrets We viewthis as an important problem because there are many scenarios where sensors are used to collectcritical or high-value dataOnce a sensor is compromised and the adversary learns its secrets collected data – even ifencrypted – becomes exposed This holds regardless of where encrypted data is stored: on thesensor that produced it or elsewhere Some recent work [2] has analyzed and confirmed the futilityof hiding data by moving it around the networkWe now zoom in further onto the problem of data secrecy Considering that compromise ofa given sensor has a certain duration data collected by the said sensor can be partitioned intothree categories based on the time of compromise: (1) before compromise (2) during compromiseand (3) after compromise Obviously nothing can be done about secrecy of data that falls intocategory (2) since the adversary is fully in control The challenge thus becomes two-fold:• Forward Secrecy: the term forward means that category (1) data remains secret as timegoes forward• Backward Secrecy: the term backward means that category (3) data remains secret eventhough a compromise occurred before it was collectedWe are interested in the confidentiality of data collected when sensors are not under directcontrol of the adversary In the cryptographic literature notions of intrusion-resilience [6] and keyinsulation [7]2 refer to techniques of providing both forward and backward security to mitigatethe effect of exposure of decryption keys However these techniques are unsuitable for solvingthe problem at hand as discussed in Section 32Data integrity is an equally important issue which is normally considered in tandem with datasecrecy However in this paper we ignore data integrity This is because we distinguish betweenread-only and read-write adversaries The former is assumed to compromise sensors and leaveno evidence behind: it merely reads all memory and storage In contrast a read-write adversarycan delete or modify existing – and/or introduce its own fraudulent – data3 We consider aread-only adversary to be more realistic especially since it aims to remain stealthy A stealthyadversary has an incentive (and the ability) to visit the UWSN again and again while a non-stealthy one might be unable to do so once an attack is detected and corresponding measurementsare takenContributions: In this paper we propose DISH (Distributed Self-Healing) a scheme whereunattended sensors collectively attempt to recover from compromise and maintain secrecy ofcollected data DISH does not absolutely guarantee data secrecy; instead it offers probabilistictunable degree of secrecy which depends on variables such as: adversarial capability (numberof nodes it can compromise at a given time interval) amount of inter-node communication theUWSNs can support and number of data collection intervals between successive sink visits Webelieve that this work represents the first attempt to cope with the powerful mobile adversary inUWSNs Consequently it might open up a new line of researchOrganization The organization of the paper is as follows: Section 2 states our assumptionsabout the network and the mobile adversary We then propose a simple public key-based approachin Section 3 This approach though less viable is used as a security yeard-stick We then presentthe symmetric key-based DISH scheme in Sections 4 and 5 Section 6 shows our analytical andexperiment results Section 7 discusses drawbacks of DISH as well as possible ways to mitigatethem Section 9 concludes the paper Related work is deferred to Appendix 82 Both extend the notion of forward security [8 9]3 In the security literature read-only is often referred to as a passive adversary We do not use the term“passive” as it does not fit an adversary who is assumed capable of compromising sensors Whereasread-write is called an active adversary2 AssumptionsWe now state our network assumptions and present our model of the adversary Table 1 summa-rizes the notation used in the rest of the paper Note that the terms round and interval are usedinterchangeablyv number of rounds between successive sink visitsn number of sensor nodes in the networki j sensor indices 0 < i j ≤ nr r′ collection round (interval) indices 0 < r r′ ≤ Tsi sensor idri data collected by si at round rEri encrypted version of driH() one-way collision-resistant hash (eg SHA-2)Enc(XY ) randomized encryption of Y under key XDec(XY ) decryption of Y under key XOr set of compromised sensors at round rHr set of healthy sensors at round rSr set of sick sensors at round r|U | number of elements in set Uk maximum size of Or; assumed to be constantTable 1 Notation Summary21 Sensor Network AssumptionsWe envisage a homogeneous network consisting of peer sensors uniformly distributed over a cer-tain region The network operates as follows:• Sensors are programmed to collect data periodically 4 Each sensor obtains a single fixed-sizedata unit in each collection interval v denotes the maximum number of collection intervalsbetween successive sink visits• Sensors are unattended Each sensor waits for either a signal or for some pre-determined timeto upload accumulated data to the sink• The network is connected at all times Any two sensors can communicate either directly orindirectly via other sensors We make no assumption about the communication media: itcould in fact be wired or wireless• Sensors are capable of conducting certain cryptographic computations such as one-way hash-ing symmetric encryption and – optionally – public key encryption (but not decryption)However sensors are not able to run IDS on their own• Each sensor is equipped with either a Pseudo-Random Number Generator (PRNG) or aPhysical/True Random Number Generator (TRNG) We elaborate on this later in the paper• Regardless of its type encryption is always randomized [10] Informally speaking random-ized encryption means that given two encryptions under the same key it is unfeasible todetermine whether the corresponding plaintexts are the same• There is enough storage on a sensor to contain O(v) sensed (encrypted) data items betweensuccessive sink visits• Each time a sink visits the network the security “state” of all sensors is securely re-initializedThis includes all cryptographic keys as well as initial seeds for PRNGs All sensors maintainloosely synchronized clocks4 Event-driven sensing is also possible in the unattended setting; however we do not consider it for thetime being• There are no power constraints Although we try to minimize both computation and commu-nication costs we assume that security has a much higher priority than power conservationWe make no assumptions about the richness of sensed data: the set of possible sensor readingsmight be very large or very small It clearly depends on the specific sensor application In somecases sensed data can vary widely eg for complex chemical sensors Whereas a simple lightsensor might only collect 1-bit values (ie 0 or 1)22 Adversarial ModelWe now describe the anticipated adversary We refer to it as ADV from here on Our adversarymodel resembles that in [2] albeit with somewhat different operations and goals• Compromise power: ADV can compromise at most k < n sensors during any single collectioninterval We thus say that ADV is k-capable The threshold k may be absolute ie an integeror relative ie a fraction of n When ADV compromises a node and for as long as it remainsin control of that node it reads all of memory/storage contents and monitors all incomingand outgoing communication• Network knowledge: ADV knows the composition and topology of the network It is capableof compromising any node it chooses• Key-centric: ADV is only interested in learning the secrets (keys) of sensors it compromises(Since knowledge of keys allows it to decrypt data)• No interference: ADV does not interfere with any communications of any sensor and doesnot modify any data sensed by or stored on sensors it compromises In other words ADV isread-only as discussed above• Stealthy operation: ADV’s movements are unpredictable and untraceable Specifically it isinfeasible to detect when and if the adversary ever compromised (or intends to compromise)a particular sensor• Atomic movement: ADV moves monolithically ie at the end of each interval ADV selects atmost k nodes to compromise in the next interval and migrates to them in a single action• Strictly local eavesdropping: ADV is unable to monitor and record all communication It canonly monitor incoming and outgoing traffic on currently compromised nodesADV’s main goal is to learn data collected by sensors However this does not imply that ADVcan not guess that data Since there might be only a few possible values a sensor could obtainADV might know well advance the entire range of all such possible values as discussed at the endof Section 31 Instead ADV is interested in knowing exactly which value is being sensed In theextreme case this might correspond to a 1-bit flag3 Public Key-based SchemesAlthough for usual performance reasons we prefer a scheme based on symmetric cryptographyfor the sake of completeness we start with a simple public key-based approach and examine itsadvantages and limitations31 A Simple Public Key SchemeThe main features of the simple public key-based scheme are as follows:• The sink has a long-term public key PKsink known to all sensors• •As soon as a sensor collects data dri at round r si encrypts it to produce: Eri = Enc(PKsink Rri dri  r si · · · ) where Rri refers to a one-time random number included in each randomized en-cryption operation as specified in the OAEP+ quasi-standard [10]• When the sink finally visits the UWSN and gathers encrypted data from all sensors it caneasily decrypt it with its private key SKsink• Note that a sensor has no secret (private) key of its own – it merely uses the sink’s publickey to encrypt dataSince ADV does not know the sinks’s private key (SKsink) the only way it can determinecleartext data is by guessing and trying to encrypt it with the sink’s public key PKsink Inother words given a ciphertext Eri (which conceals data dri ) ADV cycles through all possibledata values d′ and compares Enc(PKsink d′) to Eri  If they match ADV learns that d′ is theencrypted value However as discussed in Section 21 we use randomized encryption and eachEri is computed as: Enc(PKsink Rri  dri  ) where Rri is a one-time random value produced bythe sensor for each encryption operation Assuming that bit-length of Rri is sufficient (eg 160or more) the guessing attack becomes computationally infeasibleThere is however a crucial security distinction based on the source of random number Rriused in randomized encryption If random numbers are obtained from a strong physical sourceof randomness then we can trivially achieve both forward and backward secrecy To argue thisclaim informally we observe that a true random number generator (TRNG) generates statisticallyindependent values That is given an arbitrarily long sequence of consecutive TRNG-generatednumbers removing any one number from the sequence makes any guess of the missing numberequally likely Let us suppose that ADV compromises a sensor si at round r′ and releases it atround r′′ > r′ Encrypted data from any round r < r′ remains secret since it has the form:Enc(PKsink Rri  dri  ) and all the random numbers that ADV learns while in control of si arestatistically independent from Rri  Thus we have forward secrecy Similarly any data encryptedafter round r′′ (after ADV releases si) also remains secret because all random numbers ADVlearns while in control of si are statistically independent from those generated later Thus wehave backward secrecyOn the other hand if random numbers are obtained from a pseudo-random number generator(PRNG) the resulting security is much lower This is because a typical PRNG produces “random”numbers by starting with a (secret) seed value and repeatedly applying a suitably strong one-wayfunction H() as: Rr+1i = H(Rri ) Therefore again assuming that si is compromised at round r′and released at r′′ data Eri = Enc(PKsink Rri  dri  ) for r < r′ remains secret since computingRri from Rr′i is computationally infeasible (even if r′ = r + 1) due to the one-way property offunction H() This implies that forward secrecy is preserved However for r > r′′ encrypteddata is easily decrypted by ADV since it is easy to compute Rri from Rr′′i by repeatedly applying(r − r′′ times) the function H() Therefore backward secrecy is lost32 Key-Insulated and Intrusion-Resilient SchemesWe now consider more complex – and seemingly relevant – cryptographic techniques that provideboth forward and backward secrecy They include key-insulated [7] and intrusion-resilient [11 12]encryption schemes In both models time is divided into fixed intervals The public key remainsfixed throughout the entire system lifetime whereas the private key is updated in each intervalWhen it is time to update the private key the user contacts the base a separate secure entitytypically in the form of a remote trusted server or a local tamper-resistant hardware for helpin updating its key This way without simultaneously compromising both the user and the baseADV is unable to learn future keys (thus backward security is achieved) The difference betweena key-insulated encryption scheme and a intrusion-resilient encryption scheme is that when theuser and base are compromised simultaneously all the security including forward security are lostin the key-insulated encryption scheme while forward security is still guaranteed in the intrusionresilient encryption schemeHowever all such schemes are completely useless in our scenario since nodes (sensors) do notpossess any decryption keys They only use the sink’s public key to encrypt data Therefore akey-insulated or an intrusion-resilient scheme can only help against sink’s private key compromise– a problem irrelevant in our context33 Public Key SummaryTo summarize our discussion thus far simple public key encryption can help in achieving bothbackward and forward secrecy (our “holy grail” in this paper) only if each sensor is equippedwith a physical source of randomness ie a TRNG Simple public key encryption with PRNG-equipped sensors achieves forward secrecy but fails with regard to backward secrecy More exotickey-insulated and intrusion-resilient schemes are geared for digital signatures and decryptionThey are unsuitable for the problem at hand4 A Simple Symmetric Key SchemeWe now construct a scheme based on symmetric cryptography and discuss its benefits and short-comingsWe assume that after each sink visit (at round 1) each si shares an initial and unique secretkey K1i with the sink (This is in line with our assumptions in Section 21) Then at round r ≥ 1as it collects data si produces Eri = Enc(Kri  dri  ) If the encryption key does not change asrounds go by all encrypted data can be trivially read by ADV It only needs to compromise thesensor once obtain its key and decrypt any encrypted data whether generated before or afterthe compromise period Instead we require that at the end of each round each sensor evolveits key using a one-way hash function H() thus achieving forward secrecy Specifically round r(for 1 < r ≤ T ) key is computed as: Kri = H(Kr−1i ) If ADV breaks in at round r it learns Kribut can not obtain Kr−1i (which was used to encrypt dr−1i ) due to the one-way property of H()Unfortunately backward secrecy is lacking This is because ADV who breaks in at round r learnsKri  Then by mimicking the key evolution process it can obtain any future key Kr′i (r′ > r) as:5Kr′i = Hr′−r(Kri ) Armed with Kr′i  it can decrypt any data (that it might find later) encryptedwith Kr′i  Hence there is no backward secrecy Worse still afternk rounds ADV reaches a steadystate whereby all data collected and encrypted by all sensors is easily readableBased on our discussion in Section 31 it might seem that if all sensors had TRNGs bothbackward and forward secrecy are achievable This intuition is wrong due to the following paradox:if si uses each random number Rri as a one-time symmetric encryption key to produce Eri =Enc(Rri  dri ) there is no way for the sink to later decrypt it This is because Rri  as a true randomnumber is unpredictable unique to si and irreproducible by anyone including the sink So thereis no other way for si to communicate Rri to the sinkSummary: Having reviewed simple public key and symmetric approaches we observe that –except for the public key scheme used in conjunction with all sensors equipped with TRNGs –neither achieves the desired level of security: forward and backward secrecy of encrypted data Webelieve that the combination of public key encryption and per-sensor TRNG is not realistic formany current and emerging sensor networks Public key encryption requires more computationand consumes higher storage and bandwidth than symmetric encryption Similarly node-specificTRNGs are not always realistic at least not on the scale in envisaged UWSNs Therefore belowwe focus on symmetric key techniques which do not assume any strong source of randomness onindividual sensors5 The notation Hp() means p repeated applications of H()5 DISH: Distributed Self-HealingWe now describe DISH: Distributed Self-Healing scheme providing probabilistic key-insulateddata secrecy DISH is based on symmetric cryptography ie sensors are only required to performhashing and symmetric encryption operations We first describe the general idea and then presentprotocol details51 General IdeaEach sensor si shares an initial unique secret key K1i with the sink as in Section 21 At thestart none of these keys are known to ADV As soon as the sink collects data and leaves thenetwork unattended ADV starts compromising sets of nodes at most k per roundWe observe that at round 1 when ADV first compromises k sensors in O1 there are stilln − k sensors that have not been compromised We call such sensors healthy and the currentlycompromised sensors – occupied While ADV moves to the next compromised set O2 in round 2nodes in O1 remain sick The term sick refers to the ADV’s ability to compute their secret keysfor round 2 (and later) even though it no longer occupies themOur main idea is very simple: we let healthy sensors cure sick sensors to become healthy Ahealthy sensor is the one that has either never been compromised yet or regained its securitythrough DISH Specifically sick sensors ask for contributions from healthy sensors and the lattercontribute secret values to sick sensors A healthy sensor generates each contribution share -a random number - using its PRNG This random number is secret to ADV since learning itrequires knowledge of the healthy sensor’s current PRNG state A sick sensor uses contributionshares from healthy sensors – along with its current key – as input to a one-way function togenerate its next round key As long as there is at least one contribution from a healthy sensorADV is unable to learn the new key (unless it compromises the same sensor again in the future)Consequently a previously sick sensor becomes healthy after a key update We call a sensor asponsor of another sensor if it furnishes the latter with a contribution in the latter’s key updateprocess A sick sensor asks a set of t sponsors for their contribution shares at the end of everyroundOur approach can be characterized by the following axioms:• Axiom 1: A healthy sensor remains healthy until ADV compromises it• Axiom 2: An occupied sensor can not become healthy (For it to have a chance of becominghealthy ADV has to release it)• Axiom 3: A sick sensor can become healthy in next round if and only if at least one healthysensor contributes input to the computation of its (sick sensor’s) key for round r + 1To better illustrate the process refer to Figure 1 which shows the sensor state transitiondiagram The description so far is clearly too simplistic First a sensor has no idea whetherit is sick or healthy since we assume that our ADV is stealthy: it moves unpredictably andleaves no trail Thus each sensor is potentially sick and potentially healthy For this reason werequire all sensors (whether occupied sick or healthy) randomly select a set of t sponsors at theend of every round and ask each sponsor for input Because the cure comes from peer sensorsthe network exhibits a self-healing property - something no individual node can provide– whichemerges through collaboration of all nodes52 DISH DetailsWithin each round each sensor runs two separate processes: main and sponsor The main processis shown in Algorithm 1 and the sponsor process in Algorithm 2 As in Section 4 at every sinkvisit each si is securely re-initialized with K1i – a unique secret generated by the sink (detailsOCCUPIEDHEALTHYSICKCompromiseRe leaseAt least one healthy sponsorAll sponsors are sick or compromisedFig 1 DISH sensor state transition diagramof this process are out of scope of the present work) All sensors are thus healthy at the initialstageThe main process (loop at line 5) shows how si selects a set of t sponsors and obtains a randomcontribution HELP [p] from each All collected contributions in addition to the current key arethen used to derive the next key Kr+1i  The one-way property of H() ensures that it is infeasiblefor ADV to compute this key as long as at least one input out of: {Kri  HELP [1] HELP [t]}is unknownAs shown in Algorithm 1 and 2 each sensor node uses its local PRNG for both sponsor nodesselection and contribution share generation (as a sponsor) As mentioned earlier a PRNG isoften realized as a one-way function (such as our H()) This allows ADV to compromise si atround r copy the PRNG state release si by round r + 1 and still be able to compute the setof sponsors that si will ask for help and the set of contribution values that si will generate as asponsor in round r + 1 Thus ADV knows the entire set of sponsors of each sick sensor and alsoall the contribution values the sick sensor will generate for each sponsoring request Because thesink knows all initial secrets and can compute all intermediate states of all sensors; thereforeit can also re-generate all sensor keys by mimicking the main and sponsoring processes in eachround That is the proposed key update process does not affect the sink’s knowledge of sensors’round keys and ability to eventually decrypt data encrypted with these keysCommunication and Computation Overhead In DISH each sensor needs to contact t sponsorsfor help and also serve as a sponsor for t other sensors in every key update This incurs a total of2t messages traversing the UWSN in the end of each round Each node needs to conduct 2t+ 1hash operations per round: t for sponsor selection t for contribution generation and 1 for keygeneration6 Analysis and SimulationsIn this section we present some adversarial strategies followed analysis and simulation resultsshowing how DISH fares against these strategies61 ADV Migration StrategiesThe goal of ADV is to minimize the set of healthy sensors - Hr (or maximize Sr) To achieve thisgoal its best strategy is to always choose k healthy sensors to compromise in the next roundWe distinguish between two varieties of ADV based on its Or selection strategy: Trivial Ad-versary (TADV for short) and Smart Adversary (SADV for short)TADV’s strategy is to select and compromise k sensors from Hr randomly TADV estimatescurrent sensor states by maintaining a network state map which records IDs of sensors compro-mised and also the compromise time Each round TADV either chooses to compromise sensorsthat have not yet been compromised - these are absolutely healthy sensors - or those have everbeen compromised a long time ago - there is higher probability that these sensors have regainedtheir security through DISHSADV’s strategy is to select k healthy sponsors of some sick sensors such that the latter remainsick in the next round SADV learns PRNG states of currently sick sensors; therefore it candetermine the entire set of sponsors for each sick sensor62 AnalysisWe analyze the performance of DISH against TADV in terms of the number of healthy nodes atany round Recall that a sick node becomes healthy if at least one of its healthy contributionsis not intercepted by TADV Let p(i) denote the probability that i out of t sponsors for a givensensor are healthy and pp(i) – the probability that at least one (out of i) replies is not routedthrough any occupied nodes The probability that a sick sensor with t sponsors becomes healthyafter the r-th round key update can be expressed as:pr(t) =t∑i=1p(i) ∗ pp(i) (1)where p(i) = (|Hr|i )∗(n−|Hr|−1t−i )(n−1t ) Note that pp(i) is influenced by the routing algorithm and UWSNtopology To make our analysis independent from these parameters we define p as the probabilityof any contribution from a sponsor to a recipient being intercepted (eavesdropped on) by TADVWe then have: pp(i) = 1− pi Therefore expected number of healthy sensors at round r + 1 canbe expressed as:|Hr+1| = |Hr|+ |Sr| ∗ pr(t)− k (2)¿From this we see that |Hr| depends on k p and t More specifically |Hr| is proportional to tand inversely proportional to k and p We now plot Equation 2 varying these three parametersIn this and all other plots in this paper we fix UWSN size at n = 400Figure 2 illustrates the influence of k and p on the number of healthy nodes with t fixed at6 When TADV can intercept 20% of all traffic (eg p = 02 as shown in Figure 2(a)) fork ≤ 127 the number of healthy nodes decreases in the first several rounds and then remainssteady afterwards That is there are enough healthy nodes for the UWSN to successfully defendagainst TADV However when the compromise power of TADV increases above the thresholdvalue of k = 127 healthy nodes eventually dwindle to none as TADV controls all nodes’ secretsfrom that round onwards If TADV can intercept 80% of traffic (as shown in Figure 2(b)) thethreshold k value decreases to 68 0 20 40 60 80 100 120 140 0 5 10 15 20 25 30 0 50 100 150 200 250 300 350 400Healthy NodeskRound 0 50 100 150 200 250 300 350 400(a) n = 400 t = 6 p = 02 0 20 40 60 80 100 120 140 0 5 10 15 20 25 30 0 50 100 150 200 250 300 350 400Healthy NodeskRound 0 50 100 150 200 250 300 350 400(b) n = 400 t = 6 p = 08Fig 2 TADV analysisFigure 3 shows the effect of t on the number of healthy nodes when TADV compromises k = 80nodes at each round We identify two critical t values and denote them as tr and to (to > tr)respectively tr determines whether the network can successfully defend against TADVI˙f t < trTADV eventually learns all secrets and wins It is easy to see that a higher t brings better securitywith more healthy nodes when the network reaches stable state However it also incurs highercommunication overhead We note that there is a value to such that: when t < to the numberof healthy nodes (after the network reaches stable state) increases quickly with the increasein t If t > to increasing t brings little extra security Since DISH is not designed to achieveguaranteed (deterministic) security to represents a balance between security and performance Italso determines the communication overhead As shown in Figure 3(a) if TADV intercepts 20%of all traffic tr = 1 and to = 4 Whereas if TADV intercepts 80% of all traffic (Figure 3(b))tr = 9 and to = 14 0 50 100 150 200 250 300 350 0  5  10  15  20  25  30Healthy NodesRoundt = 1t = 2t = 4t = 6t = 8t = 10t = 12(a) n = 400 k = 80 p = 02 0 50 100 150 200 250 300 350 0  5  10  15  20  25  30Healthy NodesRoundt = 2t = 4t = 6t = 8t = 10t = 12t = 14t = 16t = 18(b) n = 400 k = 80 p = 08Fig 3 Analysis of the effect of tIn contrast with TADV SADV strategically selects k healthy sponsor nodes from a subset ofthe sick sensor set Sr such that sensors in this subset are unable to re-gain security through thekey update process since their sponsors are now controlled by SADV To maximize its advantageSADV must also maximize the number of sick sensors It turns out that this problem is reducibleto the well-known Subset Cover Problem which is NP Since we consider a polynomial-timeSADV the size of the covered subset is determined by the specific Or selection algorithm usedbyu SADV However it is safe to say that there should be at least kt more sick sensors withSADV than with TADV under the same set of parameters We will validate this hypothesis bysimulation in the next section63 Simulation ResultsTo re-confirm the above analysis we developed a UWSN simulator and run numerous experi-ments For each experiment we defined network parameters (n t) and ADV parameters (k p)We run the simulator until either |Hr| reached a steady state (UWSN won) or |Hr| = 0 (ADVwon) Every node follows the main and helper algorithms described in Section 5With t = 6 and p = 02 Figure 4(a) shows TADV wins when k ≥ 130 but fails when k ≤ 120This matches our analytical prediction of the threshold value of k = 127 With t = 6 and p = 08Figure 4(b) shows TADV wins when k ≥ 80 but fails when k ≤ 60 This also matches ouranalytical prediction of the threshold value as k = 69 0 50 100 150 200 250 300 350 400 0  5  10  15  20  25  30Healthy NodesRoundk=40k=60k=80k=100k=120k=130(a) n = 400 t = 6 p = 02 0 50 100 150 200 250 300 350 400 0  5  10  15  20  25  30Healthy NodesRoundk=40k=60k=80k=100k=120(b) n = 400 t = 6 p = 08Fig 4 Simulation of TADVSimulation results with variable t are shown in Figure 5 They confirm that choice of t dramat-ically affects security and performance 200 220 240 260 280 300 320 0  5  10  15  20  25  30Healthy NodesRoundt=2t=4t=6t=8t=10t=12(a) n = 400 k = 80 p = 02 0 50 100 150 200 250 300 350 0  5  10  15  20  25  30Healthy NodesRoundt=2t=4t=6t=8t=10t=12t=14t=16t=18(b) n = 400 k = 80 p = 08Fig 5 Simulation with different values of tFigure 6 compares the performance of DISH under TADV and SADV We use a greedy Orselection algorithm to simulate SADVL˙et Hi be the healthy sponsor set of si The greedy algo-rithm is shown in Algorithm 3 Figure 6 shows when ADV is able to win the network SADVachieves the goal faster than TADV does Otherwise SADV learns more sensor secretes thanTADV learns 200 220 240 260 280 300 320 340 0  5  10  15  20  25  30Healthy NodesRoundTADV p = 02SADV p = 02TADV p = 08SADV p = 08(a) n = 400 k = 60 t = 6 0 50 100 150 200 250 300 0  5  10  15  20  25  30Healthy NodesRoundTADV p = 02SADV p = 02TADV p = 08SADV p = 08(b) n = 400 k = 100 t = 6Fig 6 Comparison between TADV and SADV7 DiscussionIn this section we discuss some limitations of the proposed technique and consider ways tomitigate them71 Attack Model LimitationsIn this paper we considered a relatively simple single-minded adversary who is only interested inlearning secret keys of compromised sensors by reading all storage and eavesdropping on all traffictraversing these sensors The proposed DISH scheme defends against such attacks as discussedin Section 6However it is not difficult to image other types of attacks that could be mounted by a moresophisticated ADV For example ADV can remain stealthy if it deletes existing measurementsand replaces them with (the same number of) fraudulent measurements Fraudulent data maychange overall sensing statistics and affect sink’s actions Therefore data integrity might be asimportant as data secrecy We acknowledge that DISH cannot be applied directly to address dataintegrity since more issues (such as storage and bandwidth overheads) incurred by authenticationneed to be studied furtherAlthough it is in ADV’s interest to be subtle subtlety is not always possible If ADV’s goalis denial-of-service by introducing fraudulent data erasing existing measurements or interfer-ing with legitimate communication ADV cannot possibly avoid detection In addition nothingprevents ADV from physically destroying or damaging sensors especially since the network isunattended most of the timeIn summary ADV can disrupt and attack the network in many other ways that are unaddressedby DISH However at least initially we focused on the basic read-only type of adversarial be-havior since its successful mitigation will allow us to address more advanced (and perhaps morerealistic) adversarial models in the future72 Communication and Sensor Model LimitationsWe considered DISH in an idealized network model where no message is lost and no sensor failsIn this model the sink can mimic the entire key evolution process for all sensors and re-generateall secret keys However message loss and/or sensor failures complicate this processUnreliable Communication & Reliable Sensors: If communication is unreliable but nosensor failures occur a sensor might receive < t contributions in a given round It then considersthe rest to be lost and records the ID-s of sensors whose it did not receive This incurs additionalstorage and communication overhead of O(pl ∗ t) per sensor per round where pl is message lossrateUnreliable Communication & Sensors: If both communication and sensors themselves arefaulty the sink cannot (later) mimic the correct key update process and is thus unable to decryptall sensor data It seems that no symmetric key-based approach (such as DISH) can fully addressthis problem ie public key techniques are needed There are two basic approaches to usingpublic key cryptography in this context In the first each node encrypts its data with the sink’spublic key and uses Kri as input input to the randomized public key encryption function In thesecond approach each node encrypts sensed data with Kri and then uses the sink’s public key toencrypt Kri  The security of the two approaches is the same However the latter is preferable ifthe size of sensed data exceeds the public key block size (eg 320 bits for Elliptic Curve ElGamalor 1024 bits for RSA)73 Drawbacks of Reactive SponsoringThe proposed DISH scheme is reactive in nature: a sensor selects its sponsors based on localpseudo-randomness and each sponsor generates a contribution to the next-round key Reactivesponsoring has two drawbacks: First it allows ADV to learn the sponsors of a sick sensor therebyallowing more powerful SADV attacks Second it incurs the overhead of two messages for eachcontribution An intuitive alternative is proactive sponsoring whereby in each round every sen-sor unilaterally selects t sensors to sponsor This simple change precludes ADV from learning thesponsor set of a sick sensor; thus SADV attacks become ineffective Also without explicit spon-sorship request messages bandwidth overhead is reduced by half We are currently conductinga detailed analysis and comparison of the two (proactive and reactive) approaches and hope toreport on our findings in the near future8 Related WorkData secrecy is a fundamental security issue in sensor networks and encryption is the standard wayto achieve it [13 14] Much research effort has been invested in clever techniques for establishingpairwise keys used to secure sensor-to-sensor and sink-to-sensor communication eg [15–18]Sensor compromise is viable since sensors are built using low-cost commodity hardware com-ponents Local keys are updated periodically to mitigate the effect of sensor compromise Mauwet al [19] proposed some techniques to provide forward-secure data authentication and confiden-tiality for node-to-sink communication Forward secure authentication has also been consideredrecently in the context of minimizing storage and bandwidth overhead due to data authentica-tion in the presence of a powerful adversary [1] The most related work to ours is Whisper [20]a protocol which provides both forward and backward security for communication between apair of sensors However the scheme’s security relies on a somewhat unrealistic assumption thatthe adversary is unable to compromise both sensors simultaneously Also every sensor must beequipped with a TRNGRecently unattended sensors and sensor networks have become subject of attention in thesecurity research community and various aspects of security have been explored [21 1 22 2]Parno et al proposed two distributed algorithms where sensors (without interference of sink)work collectively to detect node replication attack [21] Security and privacy in data-centric sensornetworks - typically running in unattended mode - have been recently studied in [22] Di Pietroet al [2] have considered data survivability in UWSNs in the presence of a mobile adversaryand proposed several simple network defense strategies UWSNs have also been considered inthe context of minimizing storage and bandwidth overhead due to data authentication [1] Theproposed forward-secure aggregate authentication techniques provide efficient forward securityAlthough this paper focuses on data secrecy our results naturally extend to data authenticationand to other peer group settings (eg P2P systems) where a set of nodes can be compromisedby a powerful mobile adversary9 ConclusionIn this paper we explored techniques for intrusion-resilient data secrecy in UWSNs We pro-posed DISH a symmetric key-based self-healing scheme that achieves both forward and (proba-bilistically) backward secrecy DISH successfully mitigates the effect of sensor compromise Oursimulation results clearly demonstrate the efficacy of DISH against a stealthy mobile adversaryReferences1 D Ma and G Tsudik “Forward-secure sequentical aggregate authentication” in IEEE Symposiumon Security and Privacy 2007 May 20072 R D Pietro L Mancini C Soriente A Spognardi and G Tsudik “Catch me (if you can): datasurvival in unattended sensor networks” in IEEE PERCOM’08 March 20083 R Ostrovsky and M Yung “How to withstand mobile virus attacks” in ACM PODC’91 OmntrealQuebec Canada August 19-21 19914 A Herzberg M Jakobsson S Jarecki H Krawczyk and M Yung “Proactive public key andsignature systems” in ACM CCS’97 19975 Y Frankel P Gemmel P MacKenzie and M Yung “Proactive rsa” in Crypto’97 Santa BarbaraCA USA August 17-21 1997 pp 440–4546 G Itkis and L Reyzin “Sibir: signer-base intrusion-resilient signatures” in Crypto’02 20037 Y Dodis J Katz S Xu and M Yung “Key-insulated public key cryptosystems” in Eurocrypt’02May 20028 R Anderson “Two remarks on public-key cryptology - invited lecture” in ACM CCS’97 April 19979 M Bellare and B Yee “Forward integrity for secure audit logs” in Technical Report ComputerScience and Engineering Department University of San Diego November 199710 V Shoup “OAEP reconsidered” Crypto 2001 vol 2139 200111 Y Dodis M Franklin J Katz A Miyaji and M Yung “Intrusion-resilient public-key encryption”in CT-RSA’03 April 200312 —— “A generic construction for intrusion-resilient public-key encryption” in CT-RSA’04 February200413 A Perrig J Stankovic and D Wagner “Security in wireless sensor networks” ACM Communvol 47 pp 53–57 200414 F Hu and N Sharma “Security considerations in ad hoc sensor networks” Ad Hoc Networks vol 3pp 69–89 200515 L Eschenauer and V D Gligor “A key-management scheme for distributed sensor networks” inACM CCS’02 200216 R D Pietro L V Mancini and A Mei “Random key assignment for secure wireless sensor net-works” in ACM Workshop on Security of Ad Hoc and Sensor Networks (SASN ’03) October 200317 W Du J Deng Y S Han S Chen and P Varshney “A key management scheme for wirelesssensor networks using deployment knowledge” in IEEE INFOCOM’04 March 200418 H Chan and A Perrig “Pike: peer intermediaries for key establishment in sensor networks” inIEEE INFOCOM’05 March 2005 pp 524–53519 S Mauw I van Vessem and B Bos “Forward secure communication in wireless sensor networks”in Third International Conference Security in Pervasive Computing (SPC’06) April 2006 pp 32–4220 V Naik A Arora S Bapat and M Gouda “Whisper: local secret maintenance in sensor networks”in Principles of Dependable Systems (PoDSy) 200321 B Parno A Perrig and V Gligor “Distributed detection of node replication attacks in sensornetworks” in IEEE Symposium on Security and Privacy 2005 May 200522 M Shao S Zhu W Zhang and G Cao “pdcs: Security and privacy support for data-centric sensornetworks” in IEEE INFOCOM’07 2007
Intrusion detection UWSN-POSH-pdf,Intrusion-Resilience in Mobile Unattended WSNsRoberto Di Pietro § ‡ Gabriele Oligeri ∗ † Claudio Soriente ¶ Gene Tsudik †∗ ISTI-CNR Pisa Research Area Pisa Italy† Computer Science Department University of California Irvine USA§ UNESCO Chair in Data Privacy Universitat Rovira i Virgili Av Paı¨sos Catalans 26 E-43007 Tarragona Spain¶ Universidad Politenica de Madrid Spain‡ Department of Mathematics Universita` di Roma Tre Rome ItalyAbstract— Wireless Sensor Networks (WSNs) are susceptible toa wide range of attacks due to their distributed nature limitedsensor resources and lack of tamper-resistance Once a sensoris corrupted the adversary learns all secrets and (even if thesensor is later released) it is very difficult for the sensor to regainsecurity ie to obtain intrusion-resilience Existing solutions relyon the presence of an on-line trusted third party such as a sinkor on the availability of secure hardware on sensors Neitherassumption is realistic in large-scale Unattended WSNs (UWSNs)characterized by long periods of disconnected operation andperiodic visits by the sink In such settings a mobile adversarycan gradually corrupt the entire network during the intervalsbetween sink visits As shown in some recent work intrusion-resilience in UWSNs can be attained (to a degree) via cooperativeself-healing techniquesIn this paper we focus on intrusion-resilience in Mobile Unat-tended Wireless Sensor Networks (µUWSNs) where sensorsmove according to some mobility model We argue that sensormobility motivates a specific type of adversary and defendingagainst it requires new security techniques Concretely wepropose a cooperative protocol that – by leveraging sensormobility – allows compromised sensors to recover secure stateafter compromise This is obtained with very low overhead andin a fully distributed fashion We provide a thorough analysisof the proposed protocol and support it by extensive simulationresultsI INTRODUCTIONMany current and envisaged applications for WirelessSensor Networks (WSNs) involve data collection in remoteinaccessible or hostile environments such as desertsmountains ocean floors and battlefields A multitude ofsensors might be deployed within a certain area and theiractivity is usually monitored and managed by a powerfultrusted entity commonly referred to as the sinkSecurity in WSNs presents several well-known challengesstemming from all kinds of resource constraints of individualsensors However resource limitations is not the mainchallenge in designing security techniques for WSNs It islack of ubiquitous (inexpensive) tamper-resistant hardwarethat makes sensor compromise a real threat Some recentresults (eg [1] [2]) showed that commodity sensors can beeasily corrupted Once a sensor is corrupted and all of itssecrets are exposed any cryptographic protocol ceases to beeffectiveBased on the time of corruption we can view the securitystate of a given sensor as a sequence of three epochs: (1) timebefore corruption; (2) time during corruption; and (3) timefollowing corruption Nothing can be done about security inepoch 2 as the adversary controls the sensor while enforcingsecurity in epochs 1 and 3 requires forward and backwardsecrecy respectively Informally a cryptographic protocolis forward secure if exposure of secret material at a giventime does not lead to compromise of secrets for any timepreceding compromise Whereas a cryptographic protocol isbackward secure if compromise of secret material at a giventime does not lead to compromise of any secrets to be usedin futureIt is well-known that forward secrecy can be easily obtainedby periodically evolving a secret (eg a key) using aone-way function If we assume that time is divided in roundsand let K0 be an initial secret the secret for round r ≥ 1(Kr) is computed as H(Kr−1) where H(·) is a one-wayfunction Hence if the adversary learns secret Kr it cannotcompute any secrets used in prior rounds However backwardsecurity is much more challenging since knowledge of Krallows the adversary to compute secrets for future rounds(any Kr′ for r′ > r) by mimicking the secret evolutionprocedure Note that this is possible even if the adversary isno longer in control of a given sensor in round r′ Backwardsecrecy would be trivial to obtain if each sensor had a truerandom number generator (TRNG) Because a TRNG yieldsinformation-theoretically independent values even if theadversary learns many (but not all) TRNG outputs it cannotcompute the missing values whether they correspond to thepast or to the future Unfortunately TRNGs are not foundon commodity sensors and not expected to be availablefor the near future An alternative to per-sensor TRNGsis the presence of a trusted third party; this is assumed inkey-insulated schemes [3] [4] In such schemes forwardand backward security is achieved by having end-devicesevolve their secrets in cooperation with a trusted third partycalled a base Unless both the end-device and the base arecompromised at the same time per-round keys are insulatedKey-insulated schemes are well-matched for WSNs witha constantly present sink where the latter acts as a baseHowever in Unattended WSNs (UWSNs) the sink visits thenetwork infrequently which rules out key-insulated schemesThis challenge forms the premise for our work in this paperContributions: We investigate collaborative intrusion-resilience in μUWSNs where sensors migrate within afixed deployment area Assuming a stationary adversary978-1-4244-5837-0/10/$2600 ©2010 IEEEThis full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the IEEE INFOCOM 2010 proceedingsThis paper was presented as part of the main Technical Program at IEEE INFOCOM 2010that controls a portion of the deployment area sensors takeadvantage of mobility and cooperation with peers to regainsecurity even after having been corrupted by inadvertentlywandering into the area under adversarial controlTo analyze the proposed protocol we use a sphericaldeployment area which makes it easy to ensure uniform nodedistribution However our approach is generic and applicableto most geometric shapes and surfacesUsing both analytical and simulation results we show thatthe proposed protocol provides strong security (ie intrusion-resilience via secret state recovery) without any trusted thirdparties or secure hardwareOrganization Next section surveys related work in the areaand Section III introduces the mobility and the adversarialmodels Section IV presents the new protocol to achieveintrusion-resilience The analysis of the protocol for each ofthe considered mobility models is provided in Section Vwhere extensive simulations support the analytical findingsDiscussion follows in Section VI Finally Section VII reportssome concluding remarksII RELATED WORKSome prior work has considered key exposure followingsensor compromise Dutta et al [5] proposed a constantstorage self-healing protocol for WSNs Sensor key updateuses a polynomial-based secret sharing scheme performedwith the help of the sink The sink periodically broadcastsinformation to allow non-revoked sensors to update theircurrent session key At any time sensors can be revoked andprevented from learning keys of any sessions after revocationSince this protocol relies on the constant presence of a sinkit is not applicable to UWSNsWHISPER [6] provides both backward and forward secrecyfor keys shared between any two sensors Session keys arecomputed from two secrets provided by each party ie thekey for session r between sj and sq is computed as Krjq =F(H(Kr−1j )H(Kr−1q )) where Kr−1j and Kr−1q are sj andsq secrets for session r − 1 and F (·) and H(·) are suitablehash functions The scheme is secure as long as the adversarydoes not compromise both sj and sq This assumption does nothold in UWSNs as their unattended nature allows the attackerto gradually compromise some (even all) sensors betweensuccessive sink visitsIn the last two years UWSNs have become subject of someattention The initial work [7] introduced the UWSN scenariodefined the mobile adversary and investigated simple tech-niques to counter attacks focused on erasing specific dataThis was later extended [8] to include the case where theadversary’s goal is to indiscriminately erase all sensor dataAnother recent result [9] introduced simple cryptographictechniques to prevent the adversary from recognizing data thatit aims to erase Sensor cooperation to achieve self-healing instationary UWSNs is explored in [10] and [11]Recently mobile WSNs have began to attract attention becauseof the advantages that mobility brings to sensing applications[12] If sensors move the network can guarantee optimal areacoverage even if precise sensor deployment is unfeasible (egbecause of hostile or inaccessible conditions of the deploymentarea) [13] Also mobility helps solve network connectivityproblems caused by sensor failures and allows sensors toadapt their sampling power to respond to precise events [14]Moreover mobile sensors can extend sensor lifetimes bringingenergy to sensors with depleted batteries [15] Finally mobilityis currently being investigated as a means to detect sensorcapture attacks [16] [17] and [18]III SYSTEM MODELWe now describe the network environment and the adver-sarial modelA Network EnvironmentWe consider a network deployed over a spherical surfaceThe main reason for choosing it is that it is easy to achieveuniform coverage over a spherical area with random mobilitymodels [19] Another reason is that random mobility modelsover non-spherical surfaces exhibit high variability in the av-erage number of neighbors [19] The latter is a key parameterfor analyzing the effectiveness of our approach and a sphereis likely the most suitable area for our purpose However westress that the shape of the deployment area’s surface is not thefocus of our work Our techniques can be applied to μUWSNdeployed on any fixed-area surfaceThe envisioned μUWSN includes N sensors uniformly dis-tributed over a spherical region of radius ρ with surface areaS Let N = {s1     sN} be the set of all sensors At initialdeployment sensor sj position is cp0j Time is divided in rounds and all sensors’ clocks are looselysynchronized eg via [20] Round length can be arbitrary;we assume that it reflects a single acquisition of data fromthe environment ie sensors obtain measurements once perround that is at round r sensor sj obtains data drj  Each sensorhas enough storage to accommodate O(v) data itemsSensors have a common one-way hash function H(·) used asa pseudo-random number generator (PRNG) Each sensor hasa unique random secret seed used to initialize the PRNG; thisseed is chosen by the sink and loaded onto each sensor uponeach sink visit We use K0j to denote the initial seed of sj We use notation X y←−$Z to denote a sensor using its PRNGto generate y distinct elements from Z and to assign them toX The sink is a trusted party that visits the μUWSN with certainfrequency which has an upper bound of v – the maximumnumber of rounds μUWSN remains unattended Upon eachvisit the sink obtains collected measurements from everysensor erases sensor memory provides a fresh initial secretseed for the PRNG and resets the round counter to 1We assume that each collected data item is encrypted sepa-rately using the sink’s public key PK known to each sensorAlthough in the past public key encryption was shunnedby the sensor security community because of its high costrecent developments make public key encryption feasible oncommodity sensors [21] [22] It might not be obvious why weThis full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the IEEE INFOCOM 2010 proceedingsThis paper was presented as part of the main Technical Program at IEEE INFOCOM 2010are using public key encryption when symmetric encryption ischeaper in all respects The reason for using public key is thatit allows the sink to seamlessly decrypt anything that sensorsencrypt (for it ) in any round (As discussed below the securityis based on the use of secret padding or randomizers [23] andnot on the mere use of public key encryption) In contrast ifwe were to use symmetric encryption it would be quite hard(indeed sometimes even impossible) for the sink to decryptdata This topic is discussed in detail in [9] [10] and [24]In practice details of data encryption depend on data sizeIf data (along with randomized padding) fits within a singlepublic key encryption block (eg 160 bits for ECC or 1024bits for RSA) then public key encryption suffices Howeverif data is too long hybrid encryption becomes necessaryThis entails encrypting data using a symmetric encryptionalgorithm (eg AES) with a one-time random key Krj (wherej corresponds to sj and r is the current round) Then Krj isitself encrypted using the sink’s public key PK1 If hybridencryption is used security is determined by the secrecy ofKrj  Whereas if pure public key encryption is used securityis based on the secrecy of randomized padding2 which forconvenience we also refer to as Krj  Regardless of how it isused Krj is obtained from sj’s PRNG To abstract away fromthe specifics we use EPK(Krj  sj  r drj) to denote ciphertextof drj produced by sj at round rSensors are free to move over the deployment area accordingto a network-wide mobility model At round r sj moves to anew point cprj on the sphere obtains data drj and encrypts itas described above We consider two mobility models:• Random Jump Model: each sensor sets its speed so itcan reach any point of the sphere in one round Startingwith round r = 1 and initial position cp0j  sj chooses arandom point wprj and moves there atomically• Random Waypoint Model: all sensors move with thesame constant speed and can cover a distance m in asingle round At round 1 sj at position cp0j choosesa random point wp1j and gradually moves there in⌈Do(cp0j wp1j )m⌉rounds where Do(cp0j  wp1j ) is the or-thodromic distance between cp0j and the waypoint wp1j Once sj reaches wp1 it picks a new waypoint and startsmoving towards it etcIt is worth noticing that increasing m the Random Waypointtends to the Random Jump but a detailed analysis on theinfluence of the step size m is not the goal of this paperHowever these two models provide uniform coverage of thesphere by randomly selecting the latitude θ and the longitudeφ of waypoints according to the “trig” method [25]Algorithms 1 and 2 show the pseudocode run by eachsensor sj  at any round r In Algorithm 2 the functionMove(cp wpm) computes the next position of a sensor1We emphasize that sensors do not have their own public/private keys anddo not perform any public key decryption or any other operation apart fromencryption with PK ie there is a single public key in the entire network2Note that we can not rely on the secrecy of the collected data; it mightbe predictable or be drawn from a small set of possible valuesat distance m from the previous position cp towards thewaypoint wpAlgorithm 1: RANDOM-JUMP()/* Generate a new random waypoint and move to it*/cpφ1←−$[−π π]rnd1←−$[−1 1]cpθ = 1π arccos(rnd)return(cp)Algorithm 2: RANDOM-WAYPOINT(cpwpm)let cp be the current position of the sensorlet wp be the current waypoint of the sensorlet m be the step length/* If waypoint wp is reached generate newwaypoint */if (cp == wp) thenwpφ1←−$[−π π]rnd1←−$[−1 1]wpθ = 1π arccos(rnd)/* Move towards wp with step of length m */cp = Move(cp wpm)return([cp wp])Each sj has a circular communication area Ss with radiusρs At round r sensor sj can communicate with sp ifDo(cprj  cprp) ≤ ρs ie sp ∈ B(sj  r) where B(sj  r) isthe set of neighbors of sj at round r Let Br = E[B(sj  r)]be the mean number of neighbors of sj at round r Sincesensors are always uniformly distributed on the sphere thisyields B = Br = N · SsS  r > 0B Adversarial ModelThe UWSN model considered in prior work assumes amobile adversary that migrates among different subsets ofcompromised sensors In our μUWSN setting sensors aremobile; thus there is no incentive for the adversary to moveie it might as well be stationary and wait for sensors tomove to its controlled area Albeit stationary the envisionedadversary differs from other adversarial models considered inmost prior WSN security literature The latter is static in termsof the number of sensors it corrupts ie it compromises k outof n sensor throughout the network lifetime Our adversaryhowever is stationary with respect to the portion of thedeployment area it controls; but the subset of compromisedsensors changes as nodes move into and out of the adversary-controlled areaADV resides on a random point ap of the sphere andhas a circular corruption area Sa of radius ρa The set ofcompromised sensors at round r is {sj |Do(ap cprj) ≤ ρa}In other words if sj winds up at distance smaller or equal toρa from ADV  we assume that it is corrupted ie ADVreads all sj’s storage/memory and listens to all incomingThis full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the IEEE INFOCOM 2010 proceedingsThis paper was presented as part of the main Technical Program at IEEE INFOCOM 2010TABLE INOTATION SUMMARYS spherical region/surfaceρ radius of Sv maximum number of roundsμUWSN stays unattendedr r′ round indicesN = {s1     sN} set of sensorsN size of Nsj  sq generic sensorssi target sensordrj data collected by sj at round rKri sj ’ secret state at round rKri key used by sj at round rcprj sj ’s current position at round rwprj sj ’s current waypoint at round rSs sensor communication areaρs sensor communication rangeDo(a b) orthodromic distance between points a and bB(sj  r) set of sj ’s neighbors at round rB mean numbers of neighborsADV adversaryap adversary positionρa adversary compromise rangeRr set of red sensors at round rYr set of yellow sensors at round rGr set of green sensors at round rand outgoing communications Even if a corrupted sensormoves away from the adversary-controlled area ADV canstill compute its future secrets3We distinguish between a focused and a non-focused ADV  Anon-focused ADV ’s goal is to learn as many sensor secrets aspossible In contrast a focused ADV is interested in a specific(target) sensor si and aims to learn its secrets Any sensor canbe the target and its identity is only known to ADV We stress that ADV does not interfere with sensors’ behaviorand can be described as a read-only adversary This is inorder to stay undetected for as long as possible Actually anymodification to sensor code can be later discovered by the sinkusing techniques in [26] [27] A stealthy adversary can benefitfrom repeated attacksFinally we assume that ADV is aware of the network defencestrategy while neither sensors nor the sink know ADV ’slocation In particular there is no way to tell if a given sensorhas ever been corruptedTable I summarizes the notation used throughout the paperIV THE PROTOCOLIn our protocol forward secrecy is (predictably) obtainedwith periodic secret evolution using a one-way function H(·)To obtain backward secrecy the main idea is for sensors toserve as a source of randomness for their peers A sensorthat is not currently corrupted (ie resides outside the areacontrolled by ADV ) but whose state is known to ADV can regain security and move to a new secure state if itobtains at least one contribution of secure randomness froma peer sensor whose secret state is not compromised Our3Since secrets are computed using one-way functions ADV can mimicthe secret evolution stepprotocol leverages mobility to bring computationally securerandomness to sensors whose state is compromised SinceADV ’s location is secret and we cannot distinguish betweencompromised and non-compromised sensors the protocol isproactively run by allAt round r each sj runs Algorithm 3: it moves accordingto the adopted mobility model and after reaching its newposition broadcasts a random value based on its current PRNGstate Then sj obtains data from the environment and encryptsit as described in Section III-A Next it receives random con-tributions from neighbors and uses those contributions alongwith its current secret state to compute the next round secretFunction keyGeneration(·) uses the sensor’s current secretstate to generate an encryption keyAlgorithm 3: intrusion-resilient Protocollet cp be the current position of the sensorlet mov be the mobility model/* Move according to a network-wide mobilitymodel */switch (mov) docase (RANDOM-JUMP)cp = RANDOM-JUMP(cp)case (RANDOM-WAYPOINT)[cp wp] = RANDOM-WAYPOINT(cp wpm)/* Pick a new secret */t1←−$$/* Broadcast the new secret to neighbors/peers*/broadcast(t)/* Sense data */Obtain drj/* Generate a new key from secret state */Krj = keyGeneration(Krj )/* Encrypt and store current data */Store EPK(Krj  drj  r sj)/* Initialize peer contributions vector */Rrj = [∅]c = 0/* Receive peer contributions */while (roundT imer) doReceive trp from spRrj [c] = trpc = c+ 1/* Generate new secret state */Kr+1j = H(Krj ||Rrj [0]||    ||Rrj [c− 1])Delete Krj KrjV ANALYSISTo support analytical findings with experimental resultswe developed a software simulator [28] for the sphericaldeployment area In all our simulations the μUWSN containsN = 500 sensors moving over a sphere of radius ρ = 105 TheThis full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the IEEE INFOCOM 2010 proceedingsThis paper was presented as part of the main Technical Program at IEEE INFOCOM 2010orthodromic distance covered with a step is m = 2 000 forthe Random Waypoint Model Sensor transmission range ρsis chosen such that SsS ranges in [10−6     10−2] In factas the number of neighbors is central to cooperative self-healing sensor transmission range dramatically influences theperformance of proposed protocol Neighborhood size can betuned either via sensor density or via sensor communicationrange: we chose to fix the former and vary the latterADV is randomly placed on the sphere and its corruptionrange ρa is chosen such that its compromise area Sa is 00501 and 02 of the spherical surface respectivelyAt any time during the protocol the set of sensors can bepartitioned into three distinct groups: red yellow or greendefined as follows• Red (Rr): a sensor is red if it is currently within ADV ’scorruption area Sa• Yellow (Yr): a sensor is yellow if it is not in Sa butADV still knows its state (ie keys and PRNG state)• Green (Gr): a sensor is green if its current secrets areunknown to ADV  This is because either it has neverbeen within Sa or has been “healed” via the proposedprotocolFigure 1 shows our scenario: (1) a green sensor remains greenuntil it moves at distance less or equal than ρa from ADV ; (2)a red sensor cannot become green without becoming yellowfirst; and (3) a yellow sensor can become green only if itreceives at least one contribution from a green sensor Figure2 depicts the state transition diagramFig 1 Reference ScenarioFig 2 State Transition DiagramKnowledge of sensor’s secrets allows ADV to performseveral attacks ranging from sensor impersonation tocompromising confidentiality of sensed data The goal of anon-focused ADV is to maximize the set of red and yellowsensors Whereas our intrusion-resilient protocol is designedto maximize the number of green sensorsA Non-Focused ADVTo assess the effectiveness of the proposed intrusion-resilience protocol against a non-focused ADV  we analyzethe number of red and yellow sensors at each roundLet R Y  and G be the mean number of red yellow and greensensors respectively Hereafter we assume the network to beat steady state that is Rr = R Yr = Y Gr = G for somer > 0 Since sensors are uniformly distributed on the surfacethe number of red sensors R is independent of the mobilitymodel and can be computed as:R = N · SaSThe number of yellow sensors at round r can be computed as:Yr = Yr−1 +Rr−1PRY − Yr−1PY R − Yr−1PY G(1)where PRY is the transition probability from red to yellowPY R is the transition probability from yellow to red state andPY G is the transition probability from yellow to greenSince the network is at steady state Eq(1) becomes:R · PRY − Y · PY R − Y · PY G = 0 ⇐⇒Y · (PY R + PY G) = R · PRY ⇐⇒Y = R · PRYPY R + PY G(2)1) Random Jump Model: Each sensor chooses a randompoint on the sphere and reaches it in one round The probabilityto become yellow being red can be computed as:PRY = 1− SaSThe probability to become red being yellow can be computedas:PY R =SaSThis full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the IEEE INFOCOM 2010 proceedingsThis paper was presented as part of the main Technical Program at IEEE INFOCOM 2010The probability to become green can be evaluated as:PY G = 1− P{B(sj  r) ∩ G = ∅}The probability that a yellow sensor sj has no green sensorswithin its communication range can be approximated as:P{B(sj  r) ∩ G = ∅} ≈(1− SnS − Sa)GThe ratio SnS−Sa can be rewritten as function of the meannumber of neighbors B yielding:PY G ≈ 1−(1− BN)N−R−Y(3)Finally Equation (2) can be rewritten as:Y(SaS+ 1−(1− BN)N−R−Y)−R · PRY ≈ 0(4)Figure 3 shows the simulation results and the theoretical205010020030040050060000001 0001 001 01 1 10Red + Yellow SensorsMean number of neighbours (B)020010005Fig 3 Random Jump Model: simulation results and theoretical analysisanalysis associated to the Random Jump Model Errorbarsshow quantiles 5 50 and 95 related to the sum of yellow andred (compromised) sensors observed during the simulationsSolid lines show the numerical solutions of Eq (4) Whenthe number of neighbors is high (B ≥ 1) the number ofcompromised sensors can be approximated as 2 · R that isat each round there are R red sensors and R yellow sensorsthat were red at previous round and just came out from theadversarial region Decreasing the mean number of neighborsby decreasing the communication range increases the numberof compromised sensors until no green sensors are left2) Random Waypoint Model: In this model PRY canbe computed if we approximate the corruption area of theadversary with a circle Sa of range ρa as shown in Fig 4The error introduced by this approximation can be considerednegligible as long as ρa  ρ In the following we denotewith O and Sa the adversary position and the adversary areaof radius ρa respectively Moreover O′ is the position of thesensor sj at round r (ie cprj ≡ O′) and D is the set ofpoints at distance m from O′ that is the set of points thesensor could move to in the following round (ie cpr+1j ∈ Dwith cpr+1j − cprj = m) PRY can be computed as:PRY = P{cpr+1j ∈ Dext ∧ cprj ∈ Am}+P{cpr+1j ∈ Dext ∧ cprj /∈ Am}but P{cpr+1j ∈ Dext ∧ cprj /∈ Am} = 0 that is the sensorcannot exit from ADV because m is not sufficiently largeThis yields:PRY = P{cpr+1j ∈ Dext ∧ cprj ∈ Am}= P{cpr+1j ∈ Dext∣∣∣ cprj ∈ Am} · P{cprj ∈ Am}(5)The probability P{cprj ∈ Am} that sj belongs to the circularring Am can be computed as:P{cprj ∈ Am} =πρ2a − π(ρa −m)2πρ2a≈ 2mρaThe first term of Eq (5) is:P{cpr+1j ∈ Dext∣∣∣ cprj ∈ Am} = E{Dext}2πm (6)where E{Dext} is the mean value of Dext evaluated for O′ ∈[ρa ρa −m]:E{Dext} = 1m∫ ρaρa−m2 · β′(x) ·m dx (7)where β′(x) can be obtained by observing that ρa cos[β(x)] =x+m ·cos[β′(x)] where x = OO′ If m ρa then β(x)  0and cos[β(x)]  1 yielding:ρa = x+m · cos[β′(x)]β′(x) = arccos(ρa − xm)(8)Combining Eq (7) with Eq (8) yields E{Dext} = 2mFinally Eq (6) can be re-written as:P{cpr+1j ∈ Dext∣∣∣ cprj ∈ Am} = 1πThis yields:PRY =2mπρa(9)We split the evaluation of PY R in two distinct cases: (i) whenthe number of neighbors is negligible (B  1); and (ii) whenthe number of neighbors is high (B ≥ 1) In the latter casewe assume PY R as negligible since all sensors are healed justafter they come out from the adversarial region (PY G  1)Therefore we do not take into account those sensors thatchoose their waypoint one step out from the adversarial regionand then come back into the adversary controlled area Inthe first case (B  1) we assume the number of greensensors negligible In fact PY R > 0 means that a sensor canreach its current waypoint and come back to the adversaryregion without having been healed ie the probability for aThis full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the IEEE INFOCOM 2010 proceedingsThis paper was presented as part of the main Technical Program at IEEE INFOCOM 2010Fig 4 Geometrical model for the evaluation of the probability PRY sensor to move within a green sensor communication rangeis negligible Considering Eq (2) assuming G  0 andconsequently PY G  0 yields:PY R = RPRYYSince N = G + Y +R the above equation can be rewrittenas:PY R = R · PRYN −R (10)The probability PY G to become green from being yellow canbe computed as in the Eq (3) Also in this case the latteris valid only if m ≥ 2 · ρs otherwise it can be consideredas an upper bound for the probability to be healed (PY G)Combining Eq (9) Eq(10) Eq(3) and Eq(2) yields:Y(R · PRYN −R + 1−(1− BN)N−R−Y)−R · PRY = 0(11)The three solid lines in Fig 5 show the numerical solutionsof Eq (11) as a function of B (mean numbers of neighbors)and SaS (the ratio between adversary controlled area and thewhole sphere) Errorbars show quantile 5 50 and 95 relatedto the sum of red and yellow sensors experienced during thesimulations When the number of neighbors is high (B ≥ 1)the healing protocol cuts down the number of compromisedsensors to the red sensors only that is 25 (5% of 500) 50(10% of 500) and 100 (20% of 500) Decreasing the number ofneighbors by reducing the communication range increases thenumber of compromised sensors In fact the healing protocolperforms worse due to the fact that less random contributionsprovided by green sensors are exchanged When the numberof neighbors is low (B ≤ 10−3) the healing protocol canbe considered switched off (no contributions are exchanged)therefore the adversary eventually controls all the sensors3) Mobility models comparison: Table II summarizes theprobabilities for sensors to change their state When thenumber of neighbors is high (B ≥ 1) then PY R < PY G  1205010020030040050060000001 0001 001 01 1 10Red + Yellow sensorsMean number of neighbours (B)020010005Fig 5 Random Waypoint Model: simulation results and theoretical analysisin both mobility models therefore almost all yellow sensorsare healed in one round However note that the number ofcompromised sensors is highly dependant on the number ofsensors that leave the adversarial region in one round In theRandom Jump Model just a small fraction of the sensors thatare red at round r do not leave the adversarial area (that isdo not become yellow) during next round (PRY ≥ 08) In theRandom Waypoint Model the step is smaller and thereforeonly few sensors exit the adversarial region (PRY ≤ 005)As a result when B ≥ 1 the number of compromisedsensors in the Random Jump Model is twice the number ofcompromised sensors in the Random Waypoint Model WhenTABLE IIPROBABILITIES AND MOBILITY MODELSMobility model PRY PY G PY RRandom Jump 1− SaS≤ 1−(1− BN)GSaSRandom Waypoint  2mπρa≤ 1−(1− BN)G ≤ R·PRYN−RB < 1 the Random Waypoint Model still guarantees betterperformances in terms of number of green sensors In factwhile the adversary controls almost all the network in theRandom Jump Model when B  01 using the RandomWaypoint Model the number of compromised sensors is justhalf the networkB Focused ADVAssume that ADV picks one of the sensors in the adversarycontrolled area namely si and decides to monitor its secretstate even when si moves away from Sa ADV will be able todo so as long as si remains yellow Hence we are interestedin the time required to sensor si once it has been corruptedto be healed by a green peer In the following we analyze thisevent referred to as time to healWe assume si eventually moves to the adversary controlledarea and from that round on we investigate the number ofThis full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the IEEE INFOCOM 2010 proceedingsThis paper was presented as part of the main Technical Program at IEEE INFOCOM 2010rounds si remains compromised ie red or yellow To providea theoretical analysis of the time to heal we will use absorbingMarkov chains [29] In particular the states of the chain areequivalent to the ones detailed in the above coloring schemeie green yellow and red We consider the green state ofthe model depicted in Fig 2 as the absorbing state of theMarkov chain that is PGG = 1 and PGX = 0 for X = G andX ∈ {YR} The 3×3 matrix M associated to the absorbingMarkov chain can be generated as:M =⎡⎣ PRR PRY 0PY R PY Y PY G0 0 1⎤⎦where PRY  PY R and PY G can be computed as presented inthe previous sections while PRR and PY Y can be computedconsidering the fact that the sum of all the transition probabil-ities related to each node in Fig 2 must be equal to 1 Hence:PRR = 1− PRY  PY Y = 1− PY R − PY GThe matrix M can be partitioned as:M =[Q A0 I]where Q gives the probabilities of transitions between transientstates; A gives the probability of transition from transient stateto absorbing state; and finally I and 0 are the identity andthe null matrices respectively The expected number of timesthat the process is in a compromised state can be computedas:D = (I −Q)−1 (12)Vector D = [d1 d2] provides average absorbing times whenthe chain starts from the red and the yellow state Since we areinterested in the time between corruption and healing (ie thechain always starts from the red state) d1 represents the timeto heal Figure 6 shows the time to heal experimented dur-110100100000001 0001 001 01 1 10Compromise Duration [rounds]Mean number of neighburs (B)R Jump SimulR Jump TheorR Waypoint SimulR Waypoint TheorFig 6 Time to heal as a function of the mean number of neighborsing the simulations and its theoretical evaluation consideringEq (12) For both mobility models the theoretical analysisfits simulation results It is worth noticing that the RandomJump Model experiments shorter time to heal in respect to theRandom Waypoint Model In particular considering a highnumber of neighbors (B ≥ 1) we observe that according tothe Random Jump Model a sensor needs at least 2 roundsto move back into the green state: the first one is needed toleave the adversarial region and to become yellow while thesecond one is required to be healed by a green neighbor Onthe contrary using the Random Waypoint Model the minimumtime to heal is almost 20 rounds In fact the ρam ratio is almost13 Therefore the sensor must spend at least 13 rounds insidethe adversarial region before coming out of it Moreover notethat the sensor also needs few rounds out of the adversaryregion before meeting a green peer Indeed the proximity ofthe adversarial area is populated by yellow sensors mainlyVI DISCUSSIONThe above analysis shows that the proposed protocol iseffective to guarantee intrusion-resilience in μUWSNsIn particular the two analyzed mobility models providescomplementary results The Random Waypoint Model per-forms better against a non-focused adversary ie there areless compromised sensors at any given round The RandomJump Model performs better against a focused adversary ascompromised sensors experience shorter time to healAn interesting feature of our protocol is that if the averagenumber of neighbors (tuned either via sensor density or sensortransmission range) is high enough (B ≥ 1) the networkexhibits a self-healing property that allows sensors to regainsecret state as soon as they move away from the adversary-controlled area In this case the surface controlled by ADVplays a very small role – if we exclude red sensors that areproportional to Sa This is because sensors cooperate; hence akey parameter in the performance of the proposed protocol isthe mean number of neighbors In our simulations we changedB tuning sensor transmission ranges In real deploymentsimilar results can be obtained using shorter transmissionranges (That would save sensor energy hence allowing theμUWSN to operate longer)Intrusion-resilience is provided with minimal computationaloverhead At each round a sensor broadcasts one message andreceives B messages on average It also runs two one-wayfunction operations and performs one public-key encryptionoperation In contrast with [10] and [11] the proposed protocolinvolves lower communication overhead since it does not relyon routing ie a sensor only communicate with its neighborsAs stated earlier our protocol leverages sensor mobility tospread ”healing randomness” around the network Since sensormobility is a built-in feature of μUWSNs intrusion-resiliencecomes at virtually no costThe protocol is also robust with respect to message lossor sensor failure As noted in [10] cooperative self-healingwith symmetric-key cryptography is not feasible if sensorsfail or message delivery is not guaranteed Indeed decryptionof sensors data would require the sink to synchronize withsensors decryption keys If sensors compute keys exchangingsecrets the sink must be aware of each exchange of secretthat has occurred during its absence which is not feasible inThis full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the IEEE INFOCOM 2010 proceedingsThis paper was presented as part of the main Technical Program at IEEE INFOCOM 2010case of message loss or sensor failures The use of public keyencryption (or hybrid encryption) allows the sink to decryptany ciphertext no matter which messages were not correctlyreceived or which sensors failed during the sink absenceVII CONCLUSIONSWe proposed a distributed self-healing protocol thatbased on sensor mobility and one-hop communication offersintrusion-resilience in μUWSNs The protocol has beentested under two mobility models assuming a sphericaldeployment surface Analytical results indicate that underthe realistic adversarial model the proposed protocol is bothhighly effective and efficient for a wide range of networkparameters For example when the number of neighbors isat least (roughly) one the protocol minimizes the number ofnodes not under the control of the adversary Our proposedapproach is evaluated via thorough analysis and extensivesimulationsACKNOWLEDGEMENTSR Di Pietro’s research was supported in part by:The Spanish Ministry of Science and Education throughprojects TSI2007-65406-C03-01 ’E-AEGIS’ and CON-SOLIDER CSD2007-00004 ’ARES’ and by the Governmentof Catalonia under grant 2005 SGR 00446G Oligeri’s research was supported in part by the EU 6thframework program contract no 38419 (Intermedia NoE) andby the University of California IrvineG Tsudik’s research was supported in part by the US ArmyResearch Office (ARO) under contract W911NF-04-1-0280This work was partially done while C Soriente was at Uni-versity of California IrvineREFERENCES[1] C Hartung J Balasalle and R Han “Node compromise in sensornetworks: The need for secure systems” University of Colorado atBoulder Technical Report TR-CU-CS-990-05 2005[2] A Francillon and C Castelluccia “Code injection attacks on harvard-architecture devices” in 15th ACM Conference on Computer and Com-munications Security (CCS’08) 2008 pp 15–26[3] Y Dodis J Katz S Xu and M Yung “Key-insulated public key cryp-tosystems” in International Conference on the Theory and Applicationsof Cryptographic Techniques (EUROCRYPT’02) 2002 pp 65–82[4] M Bellare and A Palacio “Protecting against key-exposure: stronglykey-insulated encryption with optimal threshold” Appl Algebra EngCommun Comput vol 16 no 6 pp 379–396 2006[5] R Dutta Y D Wu and S Mukhopadhyay “Constant storage self-healing key distribution with revocation in wireless sensor network” inIEEE International Conference on Communications (ICC’07) 2007 pp1323–1328[6] V Naik A Arora S Bapat and M G Gouda “Whisper: Local secretmaintenance in sensor networks” IEEE Distributed Systems Onlinevol 4 no 9 2003[7] R Di Pietro L V Mancini C Soriente A Spognardi and G Tsudik“Catch me (if you can): Data survival in unattended sensor networks”in 6th Annual IEEE International Conference on Pervasive Computingand Communications (PerCom’08) 2008 pp 185–194[8] R D Pietro L V Mancini C Soriente A Spognardi and G Tsudik“Data security in unattended wireless sensor networks” IEEE TransComputers vol 58 no 11 pp 1500–1511 2009[9] —— “Playing hide-and-seek with a focused mobile adversary inunattended wireless sensor networks” Ad Hoc Networks vol 7 no 8pp 1463–1475 2009[10] R Di Pietro D Ma C Soriente and G Tsudik “POSH: Proactive co-operative self-healing in unattended wireless sensor networks” in 27thIEEE Symposium on Reliable Distributed Systems (SRDS’08) 2008 pp185–194[11] D Ma and G Tsudik “Dish: Distributed self-healing” in 10th Interna-tional Symposium on Stabilization Safety and Security of DistributedSystems (SSS’08) 2008 pp 47–62[12] K Dantu M H Rahimi H Shah S Babel A Dhariwal and G SSukhatme “Robomote: enabling mobility in sensor networks” in 4thInternational Symposium on Information Processing in Sensor Networks(IPSN’05) 2005 pp 404–409[13] J Corte´s S Martı´nez T Karatas and F Bullo “Coverage control formobile sensing networks” in IEEE International Conference on Roboticsand Automation (ICRA’02) 2002 pp 1327–1332[14] G Wang G Cao T F L Porta and W Zhang “Sensor relocationin mobile sensor networks” in 24th Annual Joint Conference of theIEEE Computer and Communications Societies (INFOCOM’05) 2005pp 2302–2312[15] M H R andHardik Shah G S Sukhatme J S Heidemann andD Estrin “Studying the feasibility of energy harvesting in a mobilesensor network” in IEEE International Conference on Robotics andAutomation (ICRA’03) 2003 pp 19–24[16] M Conti R Di Pietro L V Mancini and A Mei “Emergent properties:detection of the node-capture attack in mobile wireless sensor networks”in 1st ACM Conference on Wireless Network Security (WISEC’08) 2008pp 214–219[17] M Conti R Di Pietro A Gabrielli L V Mancini and A Mei“The quest for mobility models to analyse security in mobile ad hocnetworks” in 7th International Conference on Wired/Wireless InternetCommunications (WWIC’09) 2009 pp 85–96[18] M Conti R Di Pietro A Mei and L V Mancini “Mobility andcooperation to thwart node capture attacks in manets” Journal onWireless Communications and Networking (EURASIP)[19] T Camp J Boleng and V Davies “A survey of mobility modelsfor ad hoc network research” Wireless Communications and MobileComputing (WCMC): Special issue on Mobile Ad Hoc Networking:Research Trends and Applications vol 2 pp 483–502 2002[20] F Sivrikaya and B Yener “Time synchronization in sensor networks: asurvey” IEEE Network vol 18 no 4 pp 45–50 2004[21] E P GD Murphy and W Marnane “Area-efficient processor forpublic-key cryptography in wireless sensor networks” in 2nd Interna-tional Conference on Sensor Technologies and Applications (SENSOR-COMM’08) 2008 pp 667–672[22] X L Ronghua Wang Wenliang Du and P Ning “Shortpk: A short-term public key scheme for broadcast authentication in sensor networks”ACM Transactions on Sensor Networks (TOSN) to appear[23] V Shoup “OAEP reconsidered” in 21st Annual International Cryptol-ogy Conference (CRYPTO’01) 2001 pp 239–259[24] D Ma C Soriente and G Tsudik “New adversary and new threats:security in unattended sensor networks” IEEE Network vol 23 no 2pp 43–48 2009[25] D Frenkel and B Smit Eds Understanding Molecular Simulation:From Algorithms to Applications Orlando FL USA: Academic PressInc 1996[26] T Park and K G Shin “Soft tamper-proofing via program integrityverification in wireless sensor networks” IEEE Trans Mob Computvol 4 no 3 pp 297–309 2005[27] A Seshadri A Perrig L van Doorn and P K Khosla “Swatt:Software-based attestation for embedded devices” in 2004 IEEE Sym-posium on Security and Privacy (SP’04) 2004 pp 272–282[28] G Oligeri “Mobile unattended sensor networks @ sphere”http://muwsnssourceforgenet/ July 2009[29] I Marius Finite Markov Processes and their applications Wiley EdNew York NY USA 2007This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the IEEE INFOCOM 2010 proceedingsThis paper was presented as part of the main Technical Program at IEEE INFOCOM 2010
WSN_A_Surevey-pdf,Wireless sensor networks: a surveyIF Akyildiz W Su* Y Sankarasubramaniam E CayirciBroadband and Wireless Networking Laboratory School of Electrical and Computer Engineering Georgia Institute of TechnologyAtlanta GA 30332 USAReceived 12 December 2001; accepted 20 December 2001AbstractThis paper describes the concept of sensor networks which has been made viable by the convergence of micro-electro-mechanical systems technology wireless communications and digital electronics First the sensing tasks and thepotential sensor networks applications are explored and a review of factors influencing the design of sensor networks isprovided Then the communication architecture for sensor networks is outlined and the algorithms and protocolsdeveloped for each layer in the literature are explored Open research issues for the realization of sensor networks arealso discussed  2002 Published by Elsevier Science BVKeywords: Wireless sensor networks; Ad hoc networks; Application layer; Transport layer; Networking layer; Routing; Data linklayer; Medium access control; Error control; Physical layer; Power aware protocols1 IntroductionRecent advances in micro-electro-mechanicalsystems (MEMS) technology wireless communi-cations and digital electronics have enabled thedevelopment of low-cost low-power multifunc-tional sensor nodes that are small in size andcommunicate untethered in short distances Thesetiny sensor nodes which consist of sensing dataprocessing and communicating components le-verage the idea of sensor networks based oncollaborative effort of a large number of nodesSensor networks represent a significant improve-ment over traditional sensors which are deployedin the following two ways [39]:• Sensors can be positioned far from the actualphenomenon ie something known by senseperception In this approach large sensorsthat use some complex techniques to distin-guish the targets from environmental noiseare required• Several sensors that perform only sensing can bedeployed The positions of the sensors and com-munications topology are carefully engineeredThey transmit time series of the sensed pheno-menon to the central nodes where computationsare performed and data are fusedA sensor network is composed of a large num-ber of sensor nodes which are densely deployedeither inside the phenomenon or very close to itComputer Networks 38 (2002) 393–422wwwelseviercom/locate/comnet*Corresponding author Tel: +1-404-894-5141; fax: +1-404-894-7883E-mail addresses: ian@ecegatechedu (IF Akyildiz) weil-ian@ecegatechedu (W Su) yogi@ecegatechedu (Y Sanka-rasubramaniam) erdal@ecegatechedu (E Cayirci)1389-1286/02/$ - see front matter  2002 Published by Elsevier Science BVPII: S1389-1286 (01 )00302-4The position of sensor nodes need not be engi-neered or pre-determined This allows randomdeployment in inaccessible terrains or disasterrelief operations On the other hand this alsomeans that sensor network protocols and algo-rithms must possess self-organizing capabilitiesAnother unique feature of sensor networks is thecooperative effort of sensor nodes Sensor nodesare fitted with an on-board processor Instead ofsending the raw data to the nodes responsible forthe fusion sensor nodes use their processing abil-ities to locally carry out simple computations andtransmit only the required and partially processeddataThe above described features ensure a widerange of applications for sensor networks Some ofthe application areas are health military and se-curity For example the physiological data abouta patient can be monitored remotely by a doctorWhile this is more convenient for the patientit also allows the doctor to better understand thepatient’s current condition Sensor networks canalso be used to detect foreign chemical agents inthe air and the water They can help to identify thetype concentration and location of pollutants Inessence sensor networks will provide the end userwith intelligence and a better understanding of theenvironment We envision that in future wirelesssensor networks will be an integral part of ourlives more so than the present-day personalcomputersRealization of these and other sensor networkapplications require wireless ad hoc networkingtechniques Although many protocols and algo-rithms have been proposed for traditional wirelessad hoc networks they are not well suited for theunique features and application requirements ofsensor networks To illustrate this point the dif-ferences between sensor networks and ad hocnetworks [65] are outlined below:• The number of sensor nodes in a sensor net-work can be several orders of magnitude higherthan the nodes in an ad hoc network• Sensor nodes are densely deployed• Sensor nodes are prone to failures• The topology of a sensor network changes veryfrequently• Sensor nodes mainly use broadcast communica-tion paradigm whereas most ad hoc networksare based on point-to-point communications• Sensor nodes are limited in power computa-tional capacities and memory• Sensor nodes may not have global identification(ID) because of the large amount of overheadand large number of sensorsSince large number of sensor nodes are denselydeployed neighbor nodes may be very close to eachother Hence multihop communication in sensornetworks is expected to consume less power thanthe traditional single hop communication Fur-thermore the transmission power levels can bekept low which is highly desired in covert opera-tions Multihop communication can also effec-tively overcome some of the signal propagationeffects experienced in long-distance wireless com-municationOne of the most important constraints on sensornodes is the low power consumption requirementSensor nodes carry limited generally irreplaceablepower sources Therefore while traditional net-works aim to achieve high quality of service (QoS)provisions sensor network protocols must focusprimarily on power conservation They must haveinbuilt trade-off mechanisms that give the end userthe option of prolonging network lifetime at thecost of lower throughput or higher transmissiondelayMany researchers are currently engaged in de-veloping schemes that fulfill these requirements Inthis paper we present a survey of protocols andalgorithms proposed thus far for sensor networksOur aim is to provide a better understanding of thecurrent research issues in this field We also at-tempt an investigation into pertaining designconstraints and outline the use of certain tools tomeet the design objectivesThe remainder of the paper is organized asfollows: In Section 2 we present some potentialsensor network applications which show the use-fulness of sensor networks In Section 3 we discussthe factors that influence the sensor networkdesign We provide a detailed investigation ofcurrent proposals in this area in Section 4 Weconclude our paper in Section 5394 IF Akyildiz et al / Computer Networks 38 (2002) 393–4222 Sensor networks applicationsSensor networks may consist of many differenttypes of sensors such as seismic low sampling ratemagnetic thermal visual infrared acoustic andradar which are able to monitor a wide variety ofambient conditions that include the following [23]:• temperature• humidity• vehicular movement• lightning condition• pressure• soil makeup• noise levels• the presence or absence of certain kinds of ob-jects• mechanical stress levels on attached objects and• the current characteristics such as speed direc-tion and size of an objectSensor nodes can be used for continuous sens-ing event detection event ID location sensingand local control of actuators The concept ofmicro-sensing and wireless connection of thesenodes promise many new application areas Wecategorize the applications into military environ-ment health home and other commercial areas Itis possible to expand this classification with morecategories such as space exploration chemicalprocessing and disaster relief21 Military applicationsWireless sensor networks can be an integral partof military command control communicationscomputing intelligence surveillance reconnaissanceand targeting (C4ISRT) systems The rapid de-ployment self-organization and fault tolerancecharacteristics of sensor networks make them avery promising sensing technique for militaryC4ISRT Since sensor networks are based onthe dense deployment of disposable and low-costsensor nodes destruction of some nodes by hostileactions does not affect a military operation asmuch as the destruction of a traditional sensorwhich makes sensor networks concept a betterapproach for battlefields Some of the militaryapplications of sensor networks are monitoringfriendly forces equipment and ammunition; bat-tlefield surveillance; reconnaissance of opposingforces and terrain; targeting; battle damage as-sessment; and nuclear biological and chemical(NBC) attack detection and reconnaissanceMonitoring friendly forces equipment and am-munition: Leaders and commanders can constantlymonitor the status of friendly troops the condi-tion and the availability of the equipment andthe ammunition in a battlefield by the use of sen-sor networks Every troop vehicle equipmentand critical ammunition can be attached withsmall sensors that report the status These reportsare gathered in sink nodes and sent to the troopleaders The data can also be forwarded to theupper levels of the command hierarchy while beingaggregated with the data from other units at eachlevelBattlefield surveillance: Critical terrains ap-proach routes paths and straits can be rapidlycovered with sensor networks and closely watchedfor the activities of the opposing forces As theoperations evolve and new operational plans areprepared new sensor networks can be deployedanytime for battlefield surveillanceReconnaissance of opposing forces and terrain:Sensor networks can be deployed in critical ter-rains and some valuable detailed and timely in-telligence about the opposing forces and terraincan be gathered within minutes before the oppos-ing forces can intercept themTargeting: Sensor networks can be incorporatedinto guidance systems of the intelligent ammuni-tionBattle damage assessment: Just before or afterattacks sensor networks can be deployed in thetarget area to gather the battle damage assessmentdataNuclear biological and chemical attack detec-tion and reconnaissance: In chemical and biologicalwarfare being close to ground zero is importantfor timely and accurate detection of the agentsSensor networks deployed in the friendly regionand used as a chemical or biological warning sys-tem can provide the friendly forces with criticalreaction time which drops casualties drasticallyWe can also use sensor networks for detailedIF Akyildiz et al / Computer Networks 38 (2002) 393–422 395reconnaissance after an NBC attack is detectedFor instance we can make a nuclear reconnais-sance without exposing a recce team to nuclearradiation22 Environmental applicationsSome environmental applications of sensornetworks include tracking the movements of birdssmall animals and insects; monitoring environ-mental conditions that affect crops and livestock;irrigation; macroinstruments for large-scale Earthmonitoring and planetary exploration; chemical/biological detection; precision agriculture; biolog-ical Earth and environmental monitoring in ma-rine soil and atmospheric contexts; forest firedetection; meteorological or geophysical research;flood detection; bio-complexity mapping of theenvironment; and pollution study [26–8101114313539404261818889]Forest fire detection: Since sensor nodes may bestrategically randomly and densely deployed in aforest sensor nodes can relay the exact origin ofthe fire to the end users before the fire is spreaduncontrollable Millions of sensor nodes can bedeployed and integrated using radio frequencies/optical systems Also they may be equipped witheffective power scavenging methods [12] such assolar cells because the sensors may be left unat-tended for months and even years The sensornodes will collaborate with each other to performdistributed sensing and overcome obstacles suchas trees and rocks that block wired sensors’ line ofsightBiocomplexity mapping of the environment [11]:A biocomplexity mapping of the environment re-quires sophisticated approaches to integrate in-formation across temporal and spatial scales[2687] The advances of technology in the remotesensing and automated data collection have en-abled higher spatial spectral and temporal reso-lution at a geometrically declining cost per unitarea [15] Along with these advances the sensornodes also have the ability to connect with theInternet which allows remote users to controlmonitor and observe the biocomplexity of theenvironmentAlthough satellite and airborne sensors areuseful in observing large biodiversity eg spatialcomplexity of dominant plant species they are notfine grain enough to observe small size biodiver-sity which makes up most of the biodiversity inan ecosystem [43] As a result there is a need forground level deployment of wireless sensor nodesto observe the biocomplexity [2930] One exampleof biocomplexity mapping of the environment isdone at the James Reserve in Southern California[11] Three monitoring grids with each having 25–100 sensor nodes will be implemented for fixed viewmultimedia and environmental sensor data loggersFlood detection [7]: An example of a flood de-tection is the ALERT system [90] deployed in theUS Several types of sensors deployed in theALERT system are rainfall water level andweather sensors These sensors supply informationto the centralized database system in a pre-definedway Research projects such as the COUGARDevice Database Project at Cornell University [7]and the DataSpace project at Rutgers [38] areinvestigating distributed approaches in interactingwith sensor nodes in the sensor field to providesnapshot and long-running queriesPrecision Agriculture: Some of the benefits is theability to monitor the pesticides level in the drink-ing water the level of soil erosion and the level ofair pollution in realtime23 Health applicationsSome of the health applications for sensor net-works are providing interfaces for the disabled;integrated patient monitoring; diagnostics; drugadministration in hospitals; monitoring the move-ments and internal processes of insects or othersmall animals; telemonitoring of human physio-logical data; and tracking and monitoring doctorsand patients inside a hospital [842607188]Telemonitoring of human physiological data: Thephysiological data collected by the sensor net-works can be stored for a long period of time [41]and can be used for medical exploration [62] Theinstalled sensor networks can also monitor anddetect elderly people’s behavior eg a fall [916]These small sensor nodes allow the subject a396 IF Akyildiz et al / Computer Networks 38 (2002) 393–422greater freedom of movement and allow doctors toidentify pre-defined symptoms earlier [56] Alsothey facilitate a higher quality of life for the sub-jects compared to the treatment centers [5] A‘‘Health Smart Home’’ is designed in the Facultyof Medicine in Grenoble––France to validate thefeasibility of such system [60]Tracking and monitoring doctors and patientsinside a hospital: Each patient has small and lightweight sensor nodes attached to them Each sensornode has its specific task For example one sensornode may be detecting the heart rate while anotheris detecting the blood pressure Doctors may alsocarry a sensor node which allows other doctors tolocate them within the hospitalDrug administration in hospitals: If sensor nodescan be attached to medications the chance ofgetting and prescribing the wrong medication topatients can be minimized Because patients willhave sensor nodes that identify their allergies andrequired medications Computerized systems asdescribed in [78] have shown that they can helpminimize adverse drug events24 Home applicationsHome automation: As technology advancessmart sensor nodes and actuators can be buried inappliances such as vacuum cleaners micro-waveovens refrigerators and VCRs [67] These sensornodes inside the domestic devices can interact witheach other and with the external network via theInternet or Satellite They allow end users tomanage home devices locally and remotely moreeasilySmart environment: The design of smart envi-ronment can have two different perspectives iehuman-centered and technology-centered [1] Forhuman-centered a smart environment has to adaptto the needs of the end users in terms of input/output capabilities For technology-centered newhardware technologies networking solutions andmiddleware services have to be developed A sce-nario of how sensor nodes can be used to create asmart environment is described in [36] The sensornodes can be embedded into furniture and appli-ances and they can communicate with each otherand the room server The room server can alsocommunicate with other room servers to learnabout the services they offered eg printingscanning and faxing These room servers andsensor nodes can be integrated with existing em-bedded devices to become self-organizing self-regulated and adaptive systems based on controltheory models as described in [36] Anotherexample of smart environment is the ‘‘Residen-tial Laboratory’’ at Georgia Institute of Techno-logy [21] The computing and sensing in thisenvironment has to be reliable persistent andtransparent25 Other commercial applicationsSome of the commercial applications are mon-itoring material fatigue; building virtual key-boards; managing inventory; monitoring productquality; constructing smart office spaces; environ-mental control in office buildings; robot controland guidance in automatic manufacturing envi-ronments; interactive toys; interactive museums;factory process control and automation; moni-toring disaster area; smart structures with sensornodes embedded inside; machine diagnosis; trans-portation; factory instrumentation; local controlof actuators; detecting and monitoring car thefts;vehicle tracking and detection; and instrumenta-tion of semiconductor processing chambers ro-tating machinery wind tunnels and anechoicchambers [28142324426369–717788]Environmental control in office buildings: The airconditioning and heat of most buildings are cen-trally controlled Therefore the temperature insidea room can vary by few degrees; one side might bewarmer than the other because there is only onecontrol in the room and the air flow from thecentral system is not evenly distributed A dis-tributed wireless sensor network system can beinstalled to control the air flow and temperature indifferent parts of the room It is estimated thatsuch distributed technology can reduce energyconsumption by two quadrillion British ThermalUnits (BTUs) in the US which amounts to savingof $55 billion per year and reducing 35 millionmetric tons of carbon emissions [71]IF Akyildiz et al / Computer Networks 38 (2002) 393–422 397Interactive museums: In the future children willbe able to interact with objects in museums tolearn more about them These objects will be ableto respond to their touch and speech Also chil-dren can participate in real time cause-and-effectexperiments which can teach them about scienceand environment In addition the wireless sensornetworks can provide paging and localization in-side the museum An example of such museumsis the San Franciso Exploratorium that features acombination of data measurements and cause-and-effect experiments [71]Detecting and monitoring car thefts: Sensornodes are being deployed to detect and identifythreats within a geographic region and report thesethreats to remote end users by the Internet foranalysis [69]Managing inventory control: Each item in awarehouse may have a sensor node attached Theend users can find out the exact location of theitem and tally the number of items in the samecategory If the end users want to insert new in-ventories all the users need to do is to attach theappropriate sensor nodes to the inventories Theend users can track and locate where the inven-tories are at all timesVehicle tracking and detection: There are twoapproaches as described in [77] to track and detectthe vehicle: first the line of bearing of the vehicle isdetermined locally within the clusters and then it isforwarded to the base station and second the rawdata collected by the sensor nodes are forwardedto the base station to determine the location of thevehicle3 Factors influencing sensor network designA sensor network design is influenced by manyfactors which include fault tolerance; scalability;production costs; operating environment; sensornetwork topology; hardware constraints; transmis-sion media; and power consumption These factorsare addressed by many researchers as surveyed inthis paper However none of these studies has afull integrated view of all factors that are drivingthe design of sensor networks and sensor nodesThese factors are important because they serve as aguideline to design a protocol or an algorithm forsensor networks In addition these influencingfactors can be used to compare different schemes31 Fault toleranceSome sensor nodes may fail or be blocked dueto lack of power have physical damage or envi-ronmental interference The failure of sensor nodesshould not affect the overall task of the sensornetwork This is the reliability or fault toleranceissue Fault tolerance is the ability to sustain sen-sor network functionalities without any interrup-tion due to sensor node failures [375575] Thereliability RkðtÞ or fault tolerance of a sensor nodeis modelled in [37] using the Poisson distributionto capture the probability of not having a failurewithin the time interval (0; t):RkðtÞ ¼ expðkktÞ ð1Þwhere kk and t are the failure rate of sensor node kand the time period respectivelyNote that protocols and algorithms may bedesigned to address the level of fault tolerancerequired by the sensor networks If the environ-ment where the sensor nodes are deployed haslittle interference then the protocols can be morerelaxed For example if sensor nodes are beingdeployed in a house to keep track of humidity andtemperature levels the fault tolerance requirementmay be low since this kind of sensor networks isnot easily damaged or interfered by environmentalnoise On the other hand if sensor nodes are beingdeployed in a battlefield for surveillance and de-tection then the fault tolerance has to be highbecause the sensed data are critical and sensornodes can be destroyed by hostile actions As aresult the fault tolerance level depends on the ap-plication of the sensor networks and the schemesmust be developed with this in mind32 ScalabilityThe number of sensor nodes deployed instudying a phenomenon may be in the order ofhundreds or thousands Depending on the appli-cation the number may reach an extreme value ofmillions The new schemes must be able to work398 IF Akyildiz et al / Computer Networks 38 (2002) 393–422with this number of nodes They must also utilizethe high density nature of the sensor networksThe density can range from few sensor nodes tofew hundred sensor nodes in a region which canbe less than 10 m in diameter [14] The density canbe calculated according to [8] aslðRÞ ¼ ðNpR2Þ=A ð2Þwhere N is the number of scattered sensor nodes inregion A; and R the radio transmission rangeBasically lðRÞ gives the number of nodes withinthe transmission radius of each node in region AIn addition the number of nodes in a regioncan be used to indicate the node density The nodedensity depends on the application in which thesensor nodes are deployed For machine diagnosisapplication the node density is around 300 sensornodes in a 5 5 m2 region and the density for thevehicle tracking application is around 10 sensornodes per region [77] In general the density canbe as high as 20 sensor nodes/m3 [77] A home maycontain around two dozens of home appliancescontaining sensor nodes [67] but this number willgrow if sensor nodes are embedded into furnitureand other miscellaneous items For habitat moni-toring application the number of sensor nodesranges from 25 to 100 per region [11] The densitywill be extremely high when a person normallycontaining hundreds of sensor nodes which areembedded in eye glasses clothing shoes watchjewelry and human body is sitting inside a sta-dium watching a basketball football or baseballgame33 Production costsSince the sensor networks consist of a largenumber of sensor nodes the cost of a single nodeis very important to justify the overall cost ofthe networks If the cost of the network is moreexpensive than deploying traditional sensors thenthe sensor network is not cost-justified As a re-sult the cost of each sensor node has to be keptlow The state-of-the-art technology allows a Blue-tooth radio system to be less than 10$ [71] Alsothe price of a PicoNode is targeted to be less than1$ [70] The cost of a sensor node should be muchless than 1$ in order for the sensor network to befeasible [70] The cost of a Bluetooth radio whichis known to be a low-cost device is even 10 timesmore expensive than the targeted price for a sensornode Note that a sensor node also has some ad-ditional units such as sensing and processing unitsas described in Section 34 In addition it may beequipped with a location finding system mobilizeror power generator depending on the applicationsof the sensor networks As a result the cost of asensor node is a very challenging issue given theamount of functionalities with a price of much lessthan a dollar34 Hardware constraintsA sensor node is made up of four basic com-ponents as shown in Fig 1: a sensing unit a pro-cessing unit a transceiver unit and a power unitThey may also have application dependent addi-tional components such as a location finding sys-tem a power generator and a mobilizer Sensingunits are usually composed of two subunits: sen-sors and analog to digital converters (ADCs) Theanalog signals produced by the sensors based onthe observed phenomenon are converted to digitalsignals by the ADC and then fed into the pro-cessing unit The processing unit which is gener-ally associated with a small storage unit managesthe procedures that make the sensor node collab-orate with the other nodes to carry out the as-signed sensing tasks A transceiver unit connectsthe node to the network One of the most impor-tant components of a sensor node is the powerunit Power units may be supported by a powerscavenging unit such as solar cells There are alsoother subunits which are application dependentFig 1 The components of a sensor nodeIF Akyildiz et al / Computer Networks 38 (2002) 393–422 399Most of the sensor network routing techniquesand sensing tasks require the knowledge of loca-tion with high accuracy Thus it is common that asensor node has a location finding system A mo-bilizer may sometimes be needed to move sensornodes when it is required to carry out the assignedtasksAll of these subunits may need to fit into amatchbox-sized module [39] The required sizemay be smaller than even a cubic centimeter [69]which is light enough to remain suspended in theair Apart from the size there are also some otherstringent constraints for sensor nodes These nodesmust [42]• consume extremely low power• operate in high volumetric densities• have low production cost and be dispensable• be autonomous and operate unattended• be adaptive to the environmentSince the sensor nodes are often inaccessiblethe lifetime of a sensor network depends on thelifetime of the power resources of the nodes Poweris also a scarce resource due to the size limitationsFor instance the total stored energy in a smartdust mote is on the order of 1 J [69] For wirelessintegrated network sensors (WINS) [86] the totalaverage system supply currents must be less than30 lA to provide long operating life WINS nodesare powered from typical lithium (Li) coin cells(25 cm in diameter and 1 cm in thickness) [86]It is possible to extend the lifetime of the sensornetworks by energy scavenging [71] which meansextracting energy from the environment Solarcells is an example for the techniques used forenergy scavengingThe transceiver unit of sensor nodes may be apassive or active optical device as in smart dustmotes [69] or a radio frequency (RF) device RFcommunications require modulation band passfiltering demodulation and multiplexing circuitrywhich make them more complex and expensiveAlso the path loss of the transmitted signal be-tween two sensor nodes may be as high as thefourth order exponent of the distance betweenthem because the antennas of the sensor nodes areclose to the ground [69] Nevertheless RF com-munication is preferred in most of the ongoingsensor network research projects because the pack-ets conveyed in sensor networks are small datarates are low (ie generally less than 1 Hz) [71]and the frequency re-use is high due to shortcommunication distances These characteristicsalso make it possible to use low duty cycle radioelectronics for sensor networks However design-ing energy efficient and low duty cycle radio cir-cuits is still technically challenging and currentcommercial radio technologies such as those usedin Bluetooth is not efficient enough for sensor net-works because turning them on and off consumesmuch energy [77]Though the higher computational powers arebeing made available in smaller and smaller pro-cessors processing and memory units of sensornodes are still scarce resources For instance theprocessing unit of a smart dust mote prototype is a4 MHz Atmel AVR 8535 micro-controller with 8KB instruction flash memory 512 bytes RAM and512 bytes EEPROM [66] TinyOS operating sys-tem is used on this processor which has 3500 bytesOS code space and 4500 bytes available codespace The processing unit of another sensor nodeprototype namely lAMPS wireless sensor nodehas a 59–206 MHz SA-1110 micro-processor [77]A multithreaded l-OS operating system is run onlAMPS wireless sensor nodesMost of the sensing tasks require the knowledgeof position Since sensor nodes are generally de-ployed randomly and run unattended they need tocorporate with a location finding system Locationfinding systems are also required by many of theproposed sensor network routing protocols as ex-plained in Section 4 It is often assumed that eachsensor node will have a global positioning system(GPS) unit that has at least 5 m accuracy [48] In[74] it is argued that equipping all sensor nodeswith a GPS is not viable for sensor networks Analternative approach where a limited number ofnodes use GPS and help the other nodes to findout their locations terrestrially as proposed in [74]35 Sensor network topologySheer numbers of inaccessible and unattendedsensor nodes which are prone to frequent failures400 IF Akyildiz et al / Computer Networks 38 (2002) 393–422make topology maintenance a challenging taskHundreds to several thousands of nodes are de-ployed throughout the sensor field They are de-ployed within tens of feet of each other [39] Thenode densities may be as high as 20 nodes/m3 [77]Deploying high number of nodes densely requirescareful handling of topology maintenance Weexamine issues related to topology maintenanceand change in three phases:351 Pre-deployment and deployment phaseSensor nodes can be either thrown in mass orplaced one by one in the sensor field They can bedeployed by• dropping from a plane• delivering in an artillery shell rocket or missile• throwing by a catapult (from a ship board etc)• placing in factory and• placing one by one either by a human or a ro-botAlthough the sheer number of sensors and theirunattended deployment usually preclude placingthem according to a carefully engineered deploy-ment plan the schemes for initial deploymentmust• reduce the installation cost• eliminate the need for any pre-organization andpre-planning• increase the flexibility of arrangement and• promote self-organization and fault tolerance352 Post-deployment phaseAfter deployment topology changes are due tochange in sensor nodes’ [3950]• position• reachability (due to jamming noise moving ob-stacles etc)• available energy• malfunctioning and• task detailsSensor nodes may be statically deployedHowever device failure is a regular or commonevent due to energy depletion or destruction It isalso possible to have sensor networks with highlymobile nodes Besides sensor nodes and the net-work experience varying task dynamics and theymay be a target for deliberate jamming Thereforesensor network topologies are prone to frequentchanges after deployment353 Re-deployment of additional nodes phaseAdditional sensor nodes can be re-deployed atany time to replace the malfunctioning nodes ordue to changes in task dynamics Addition of newnodes poses a need to re-organize the networkCoping with frequent topology changes in an adhoc network that has myriads of nodes and verystringent power consumption constraints requiresspecial routing protocols This issue is examined indetail in Section 436 EnvironmentSensor nodes are densely deployed either veryclose or directly inside the phenomenon to be ob-served Therefore they usually work unattended inremote geographic areas They may be working• in busy intersections• in the interior of a large machinery• at the bottom of an ocean• inside a twister• on the surface of an ocean during a tornado• in a biologically or chemically contaminatedfield• in a battlefield beyond the enemy lines• in a home or a large building• in a large warehouse• attached to animals• attached to fast moving vehicles and• in a drain or river moving with currentThis list gives us an idea about under whichconditions sensor nodes are expected to workThey work under high pressure in the bottom ofan ocean in harsh environments such as a debrisor a battlefield under extreme heat and cold suchas in the nozzle of an aircraft engine or in arcticregions and in an extremely noisy environmentsuch as under intentional jammingIF Akyildiz et al / Computer Networks 38 (2002) 393–422 40137 Transmission mediaIn a multihop sensor network communicatingnodes are linked by a wireless medium These linkscan be formed by radio infrared or optical mediaTo enable global operation of these networks thechosen transmission medium must be availableworldwideOne option for radio links is the use of indus-trial scientific and medical (ISM) bands whichoffer license-free communication in most coun-tries The International Table of Frequency Allo-cations contained in Article S5 of the RadioRegulations (Volume 1) species some frequencybands that may be made available for ISM appli-cations They are listed in Table 1Some of these frequency bands are already be-ing used for communication in cordless phone sys-tems and wireless local area networks (WLANs)For sensor networks a small-sized low-cost ul-tralow power transceiver is required According to[68] certain hardware constraints and the trade-offbetween antenna efficiency and power consump-tion limit the choice of a carrier frequency for suchtransceivers to the ultrahigh frequency range Theyalso propose the use of the 433 MHz ISM band inEurope and the 915 MHz ISM band in NorthAmerica The transceiver design issues in these twobands are addressed in [2551] The main advan-tages of using the ISM bands are the free radiohuge spectrum allocation and global availabilityThey are not bound to a particular standardthereby giving more freedom for the implementa-tion of power saving strategies in sensor networksOn the other hand there are various rules andconstraints like power limitations and harmfulinterference from existing applications These fre-quency bands are also referred to as unregulatedfrequenciesMuch of the current hardware for sensor nodesis based upon RF circuit design The lAMPSwireless sensor node described in [77] uses a Blue-tooth-compatible 24 GHz transceiver with an in-tegrated frequency synthesizer The low-powersensor device described in [93] uses a single chan-nel RF transceiver operating at 916 MHz TheWINS architecture [69] also uses radio links forcommunicationAnother possible mode of internode communi-cation in sensor networks is by infrared Infraredcommunication is license-free and robust to in-terference from electrical devices Infrared basedtransceivers are cheaper and easier to build Manyof today’s laptops PDAs and mobile phones offeran infrared data association interface The maindrawback though is the requirement of a line ofsight between sender and receiver This makes in-frared a reluctant choice for transmission mediumin the sensor network scenarioAn interesting development is that of the smartdust mote [42] which is an autonomous sensingcomputing and communication system that uses op-tical medium for transmission Two transmissionschemes passive transmission using a corner-cuberetroreflector (CCR) and active communicationusing a laser diode and steerable mirrors are ex-amined in [88] In the former the mote does notrequire an onboard light source A configurationof three mirrors (CCR) is used to communicate adigital high or low The latter uses an onboardlaser diode and an active-steered laser communi-cation system to send a tightly collimated lightbeam toward the intended receiverThe unusual application requirements of sen-sor networks make the choice of transmissionmedia more challenging For instance marine ap-plications may require the use of the aqueoustransmission medium Here one would like to uselong-wavelength radiation that can penetrate thewater surface Inhospitable terrain or battlefieldapplications might encounter error prone channelsTable 1Frequency bands available for ISM applicationsFrequency band Center frequency6765–6795 kHz 6780 kHz13553–13567 kHz 13560 kHz26957–27283 kHz 27120 kHz4066–4070 MHz 4068 MHz43305–43479 MHz 43392 MHz902–928 MHz 915 MHz2400–2500 MHz 2450 MHz5725–5875 MHz 5800 MHz24–2425 GHz 24125 GHz61–615 GHz 6125 GHz122–123 GHz 1225 GHz244–246 GHz 245 GHz402 IF Akyildiz et al / Computer Networks 38 (2002) 393–422and greater interference Moreover a sensor an-tenna might not have the height and radiationpower of those in other wireless devices Hence thechoice of transmission medium must be supportedby robust coding and modulation schemes that ef-ficiently model these vastly different channel char-acteristics38 Power consumptionThe wireless sensor node being a micro-elec-tronic device can only be equipped with a limitedpower source (<05 Ah 12 V) In some applica-tion scenarios replenishment of power resourcesmight be impossible Sensor node lifetime there-fore shows a strong dependence on battery life-time In a multihop ad hoc sensor network eachnode plays the dual role of data originator anddata router The disfunctioning of few nodes cancause significant topological changes and mightrequire re-routing of packets and re-organizationof the network Hence power conservation andpower management take on additional impor-tance It is for these reasons that researchers arecurrently focusing on the design of power-awareprotocols and algorithms for sensor networksIn other mobile and ad hoc networks powerconsumption has been an important design factorbut not the primary consideration simply becausepower resources can be replaced by the user Theemphasis is more on QoS provisioning than thepower efficiency In sensor networks though powerefficiency is an important performance metric di-rectly influencing the network lifetime Applicationspecific protocols can be designed by appropriatelytrading off other performance metrics such as delayand throughput with power efficiencyThe main task of a sensor node in a sensor fieldis to detect events perform quick local data pro-cessing and then transmit the data Power con-sumption can hence be divided into three domains:sensing communication and data processingThe sensing unit and its components were in-troduced in Section 34 Sensing power varies withthe nature of applications Sporadic sensing mightconsume lesser power than constant event moni-toring The complexity of event detection alsoplays a crucial role in determining energy expen-diture Higher ambient noise levels might causesignificant corruption and increase detectioncomplexity Power consumption in data commu-nication and processing are discussed in detail inthe following subsections381 CommunicationOf the three domains a sensor node expendsmaximum energy in data communication Thisinvolves both data transmission and reception Itcan be shown that for short-range communicationwith low radiation power (0 dbm) transmissionand reception energy costs are nearly the sameMixers frequency synthesizers voltage controloscillators phase locked loops (PLL) and poweramplifiers all consume valuable power in thetransceiver circuitry It is important that in thiscomputation we not only consider the active powerbut also the start-up power consumption in thetransceiver circuitry The start-up time being ofthe order of hundreds of micro-seconds makes thestart-up power non-negligible This high value forthe start-up time can be attributed to the lock timeof the PLL As the transmission packet size is re-duced the start-up power consumption starts todominate the active power consumption As a re-sult it is inefficient in turning the transceiver ONand OFF because a large amount of power is spentin turning the transceiver back ON each timeIn [77] the authors present a formulation forthe radio power consumption (Pc) asPc ¼ NT½PTðTon þ TstÞ þ PoutðTonÞ	þ NR½PRðRon þ RstÞ	 ð3Þwhere PT=R is the power consumed by the trans-mitter/receiver; Pout the output power of the trans-mitter; T =Ron the transmitter/receiver on time;T=Rst the transmitter/receiver start-up time andNT=R the number of times transmitter/receiver isswitched on per unit time which depends on thetask and medium access control (MAC) schemeused Ton can further be rewritten as L=R where Lis the packet size and R the data rate Today’sstate-of-the-art low power radio transceiver hastypical PT and PR values around 20 dbm and Poutclose to 0 dbm [59] Note that PicoRadio aims ata Pc value of 20 dbmIF Akyildiz et al / Computer Networks 38 (2002) 393–422 403The design of a small-sized low-cost ultralowpower transceiver is discussed in [68] A direct-conversion architecture is proposed for the trans-ceiver circuitry Based on their results the authorspresent a power budget and estimate the powerconsumption to be at least an order of magnitudeless than the values given above for PT and PRvalues382 Data processingEnergy expenditure in data processing is muchless compared to data communication The ex-ample described in [69] effectively illustrates thisdisparity Assuming Rayleigh fading and fourthpower distance loss the energy cost of transmit-ting 1 KB a distance of 100 m is approximately thesame as that for executing 3 million instructions bya 100 million instructions per second (MIPS)/Wprocessor Hence local data processing is crucialin minimizing power consumption in a multihopsensor networkA sensor node must therefore have built-incomputational abilities and be capable of inter-acting with its surroundings Further limitations ofcost and size lead us to the choice of complemen-tary metal oxide semiconductor (CMOS) technol-ogy for the micro-processor Unfortunately thishas inbuilt limitations on energy efficiency ACMOS transistor pair draws power everytime it isswitched This switching power is proportional tothe switching frequency device capacitance (whichfurther depends on the area) and square of thevoltage swing Reducing the supply voltage ishence an effective means of lowering power con-sumption in the active state Dynamic voltagescaling explored in [5264] aims to adapt proces-sor power supply and operating frequency tomatch workloads When a micro-processor han-dles time-varying computational load simply re-ducing the operating frequency during periods ofreduced activity results in a linear decrease inpower consumption but reducing the operatingvoltage gives us quadratic gains On the otherhand this compromises on peak performance ofthe processor Significant energy gains can be ob-tained by recognizing that peak performance is notalways desired and therefore the processor’s op-erating voltage and frequency can be dynamicallyadapted to instantaneous processing requirementsIn [80] the authors propose a workload predic-tion scheme based on adaptive filtering of thepast workload profile and analyze several filter-ing schemes Other low power CPU organizationstrategies are discussed in [284991]The power consumption in data processing (Pp)can be formulated as follows:Pp ¼ CV 2ddf þ VddI0eVdd=n0VT ð4Þwhere C is the total switching capacitance; Vdd thevoltage swing and f the switching frequency Thesecond term indicates the power loss due to leak-age currents [80] The lowering of threshold volt-age to satisfy performance requirements results inhigh subthreshold leakage currents Coupled withthe low duty cycle operation of the micro-proces-sor in a sensor node the associated power lossbecomes significant [77]It is to be noted that there may be some addi-tional circuitry for data encoding and decodingApplication specific integrated circuits may also beused in some cases In all these scenarios the de-sign of sensor network algorithms and protocolsare influenced by the corresponding power ex-penditures in addition to those that have beendiscussed4 Sensor networks communication architectureThe sensor nodes are usually scattered in asensor field as shown in Fig 2 Each of these scat-tered sensor nodes has the capabilities to collectdata and route data back to the sink and the endusers Data are routed back to the end user by amultihop infrastructureless architecture throughthe sink as shown in Fig 2 The sink may commu-nicate with the task manager node via Internet orSatelliteThe protocol stack used by the sink and allsensor nodes is given in Fig 3 This protocol stackcombines power and routing awareness integratesdata with networking protocols communicatespower efficiently through the wireless medium andpromotes cooperative efforts of sensor nodes Theprotocol stack consists of the application layertransport layer network layer data link layer404 IF Akyildiz et al / Computer Networks 38 (2002) 393–422physical layer power management plane mobilitymanagement plane and task management planeDepending on the sensing tasks different types ofapplication software can be built and used on theapplication layer The transport layer helps tomaintain the flow of data if the sensor networksapplication requires it The network layer takescare of routing the data supplied by the transportlayer Since the environment is noisy and sensornodes can be mobile the MAC protocol must bepower aware and able to minimize collision withneighbors’ broadcast The physical layer addressesthe needs of a simple but robust modulationtransmission and receiving techniques In additionthe power mobility and task management planesmonitor the power movement and task distribu-tion among the sensor nodes These planes helpthe sensor nodes coordinate the sensing task andlower the overall power consumptionThe power management plane manages how asensor node uses its power For example the sen-sor node may turn off its receiver after receiving amessage from one of its neighbors This is to avoidgetting duplicated messages Also when the powerlevel of the sensor node is low the sensor nodebroadcasts to its neighbors that it is low in powerand cannot participate in routing messages Theremaining power is reserved for sensing The mo-bility management plane detects and registers themovement of sensor nodes so a route back to theuser is always maintained and the sensor nodescan keep track of who are their neighbor sensornodes By knowing who are the neighbor sensornodes the sensor nodes can balance their powerand task usage The task management plane bal-ances and schedules the sensing tasks given to aspecific region Not all sensor nodes in that regionare required to perform the sensing task at thesame time As a result some sensor nodes performthe task more than the others depending on theirpower level These management planes are neededso that sensor nodes can work together in a powerefficient way route data in a mobile sensor net-work and share resources between sensor nodesWithout them each sensor node will just workindividually From the whole sensor networkstandpoint it is more efficient if sensor nodes cancollaborate with each other so the lifetime of thesensor networks can be prolonged Before we dis-cuss the need for the protocol layers and man-agement planes in sensor networks we map threeexisting work [426977] to the protocol stack asshown in Fig 3The so-called WINS is developed in [69] wherea distributed network and Internet access is pro-vided to the sensor nodes controls and proces-sors Since the sensor nodes are in large numberthe WINS networks take advantage of this shortdistance between sensor nodes to provide multihop communication and minimize power con-sumption The way in which data is routed back tothe user in the WINS networks follows the archi-tecture specified in Fig 2 The sensor node ie aWINS node detects the environmental data andthe data is routed hop by hop through the WINSnodes until it reaches the sink ie a WINS gate-way So the WINS nodes are sensor nodes A B CFig 3 The sensor networks protocol stackFig 2 Sensor nodes scattered in a sensor fieldIF Akyildiz et al / Computer Networks 38 (2002) 393–422 405D and E according to the architecture in Fig 2The WINS gateway communicates with the userthrough conventional network services such as theInternet The protocol stack of a WINS networkconsists of the application layer network layerMAC layer and physical layer Also it is explicitlypointed out in [69] that a low-power protocol suitethat addresses the constraints of the sensor net-works should be developedThe smart dust motes [42] ie sensor nodesmay be attached to objects or even float in the airbecause of their small size and light weight Theyuse MEMS technology for optical communicationand sensing These motes may contain solar cellsto collect energy during the day and they require aline of sight to communicate optically with thebase station transceiver or other motes Compar-ing the smart dust communication architecturewith the one in Fig 2 the smart dust mote iethe sensor node typically communicates directlywith the base station transceiver ie sink A peer-to-peer communication is also possible but thereare possible collision problems in medium accessdue to ‘‘hidden nodes’’ The protocol layers inwhich the smart dust motes incorporate are ap-plication layer MAC layer and the physical layerAnother approach to design protocols and al-gorithms for sensor networks is driven by the re-quirements of the physical layer [77] The protocolsand algorithms should be developed according tothe choice of physical layer components such asthe type of micro-processors and the type of re-ceivers This bottom–up approach of the lAMPSwireless sensor node also addresses the importanceof the application layer network layer MAC layerand physical layer as illustrated in Fig 3 to betightly integrated with the sensor node’s hardwareThe lAMPS wireless sensor node also communi-cates with the user according to the architecturespecified in Fig 2 Different schemes such as timedivision multiple access (TDMA) versus frequencydivision multiple access (FDMA) and binary mod-ulation versus M-ary modulation are compared in[77] This bottom–up approach points out thatsensor network algorithms have to be aware of thehardware and able to use special features ofthe micro-processors and transceivers to minimizethe sensor node’s power consumption This maypush toward a custom solution for different typesof sensor node design Different types of sensornodes deployed also lead to different types of sen-sor networks This may also lead to different typesof collaborative algorithms41 Application layerTo the best of our knowledge although manyapplication areas for sensor networks are definedand proposed potential application layer proto-cols for sensor networks remains a largely unex-plored region In this survey we examine threepossible application layer protocols ie sensormanagement protocol (SMP) task assignment anddata advertisement protocol (TADAP) and sensorquery and data dissemination protocol (SQDDP)needed for sensor networks based on the proposedschemes related to the other layers and sensornetwork application areas All of these applicationlayer protocols are open research issues411 Sensor management protocolDesigning an application layer managementprotocol has several advantages Sensor networkshave many different application areas and ac-cessing them through networks such as Internet isaimed in some current projects [69] An applica-tion layer management protocol makes the hard-ware and softwares of the lower layers transparentto the sensor network management applicationsSystem administrators interact with sensornetworks by using SMP Unlike many other net-works sensor networks consist of nodes that donot have global IDs and they are usually infra-structureless Therefore SMP needs to access thenodes by using attribute-based naming and loca-tion-based addressing which are explained in de-tail in Section 43SMP is a management protocol that providesthe software operations needed to perform thefollowing administrative tasks:• introducing the rules related to data aggrega-tion attribute-based naming and clustering tothe sensor nodes• exchanging data related to the location findingalgorithms406 IF Akyildiz et al / Computer Networks 38 (2002) 393–422• time synchronization of the sensor nodes• moving sensor nodes• turning sensor nodes on and off• querying the sensor network configuration andthe status of nodes and re-configuring the sen-sor network and• authentication key distribution and security indata communicationsThe descriptions of some of these tasks are gi-ven in [2023667475]412 Task assignment and data advertisementprotocolAnother important operation in the sensor net-works is interest dissemination Users send theirinterest to a sensor node a subset of the nodes orwhole network This interest may be about a cer-tain attribute of the phenomenon or a triggeringevent Another approach is the advertisement ofavailable data in which the sensor nodes advertisethe available data to the users and the users querythe data which they are interested in An applica-tion layer protocol that provides the user softwarewith efficient interfaces for interest disseminationis useful for lower layer operations such as routingas explained in Section 43413 Sensor query and data dissemination protocolSQDDP provides user applications with inter-faces to issue queries respond to queries and col-lect incoming replies Note that these queries aregenerally not issued to particular nodes Insteadattribute-based or location-based naming is pre-ferred For instance ‘‘the locations of the nodesthat sense temperature higher than 70 F’’ is anattribute-based query Similarly ‘‘temperaturesread by the nodes in region A’’ is an example forlocation-based namingSensor query and tasking language (SQTL) [75]is proposed as an application that provides evena larger set of services SQTL supports three typesof events which are defined by keywords receiveevery and expire Receive keyword defines eventsgenerated by a sensor node when the sensor nodereceives a message; every keyword defines eventsoccurred periodically due to a timer time-out; andexpire keyword defines the events occurred when atimer is expired If a sensor node receives a mes-sage that is intended for it and contains a scriptthe sensor node then executes the script AlthoughSQTL is proposed different types of SQDDP canbe developed for various applications The use ofSQDDPs may be unique to each application414 Open research issuesAlthough SQTL is proposed there are stillother application layer protocols need to be de-veloped to provide a greater level of services Asmentioned before the SMP allows software toperform administrative tasks such as moving sen-sor nodes and time synchronization of the nodesResearch developments should also focus on theTADAP and SQDDP as described in Sections412 and 41342 Transport layerThe need for transport layer is pointed out inthe literature [6971] This layer is especially nee-ded when the system is planned to be accessedthrough Internet or other external networks How-ever to the best of our knowledge there has notbeen any attempt thus far to propose a scheme orto discuss the issues related to the transport layerof a sensor network in literature TCP with itscurrent transmission window mechanisms doesmatch to the extreme characteristics of the sensornetwork environment An approach such as TCPsplitting [4] may be needed to make sensor net-works interact with other networks such as Inter-net In this approach TCP connections are endedat sink nodes and a special transport layer pro-tocol can handle the communications betweenthe sink node and sensor nodes As a result thecommunication between the user and the sinknode is by UDP or TCP via the Internet or Sat-ellite; on the other hand the communication be-tween the sink and sensor nodes may be purely byUDP type protocols because each sensor node haslimited memoryUnlike protocols such as TCP the end-to-endcommunication schemes in sensor networks arenot based on global addressing These schemesmust consider that attribute-based naming is usedto indicate the destinations of the data packetsIF Akyildiz et al / Computer Networks 38 (2002) 393–422 407The attributed-based naming is described in Sec-tion 43 The factors such as power consumptionand scalability and the characteristics like data-centric routing makes sensor networks need dif-ferent handling in transport layer Thus theserequirements stress the need for new types oftransport layer protocols421 Open research issuesThe development of transport layer protocols isa challenging effort because the sensor nodes areinfluenced by the factors explained in Section 3especially the hardware constraints such as thelimited power and memory As a result eachsensor node cannot store large amount of data likea server in the Internet and acknowledgements aretoo costly for sensor networks Therefore newschemes that split the end-to-end communicationprobably at the sinks may be needed where UDPtype protocols are used in the sensor network andtraditional TCP/UDP protocols in the Internet orSatellite network43 Network layerSensor nodes are scattered densely in a fieldeither close to or inside the phenomenon as shownin Fig 2 As discussed in Section 1 special mul-tihop wireless routing protocols between the sen-sor nodes and the sink node are needed The adhoc routing techniques already proposed in theliterature [65] do not usually fit the requirements ofthe sensor networks due to the reasons explainedin Section 1 The networking layer of sensor net-works is usually designed according to the fol-lowing principles:• Power efficiency is always an important consid-eration• Sensor networks are mostly data centric• Data aggregation is useful only when it does nothinder the collaborative effort of the sensornodes• An ideal sensor network has attribute-based ad-dressing and location awarenessOne of the following approaches can be used toselect an energy efficient route We use Fig 4 todescribe each of these approaches where node T isthe source node that senses the phenomena It hasthe following four possible routes to communicatewith the sink:• Route 1: Sink-A-B-T total PA¼ 4 total a ¼ 3• Route 2: Sink-A-B-C-T total PA¼ 6 totala ¼ 6• Route 3: Sink-D-T total PA¼ 3 total a ¼ 4• Route 4: Sink-E-F-T total PA¼ 5 total a ¼ 6where PA is the available power and ai the energyrequired to transmit a data packet through therelated link• Maximum available power (PA) route: Theroute that has maximum total available poweris preferred The total PA is calculated by sum-ming the PAs of each node along the routeBased on this approach Route 2 is selected inFig 4 However Route 2 includes the nodesin Route 1 and an extra node Therefore al-though it has a higher total PA it is not a powerefficient one As a result it is important not toconsider the routes derived by extending theroutes that can connect the sensor to the sinkas an alternative route Eliminating Route 2we select Route 4 as our power efficient routewhen we use maximum PA scheme• Minimum energy (ME) route: The route thatconsumes ME to transmit the data packets be-tween the sink and the sensor node is the MEroute As shown in Fig 4 Route 1 is the MErouteFig 4 The power efficiency of the routes408 IF Akyildiz et al / Computer Networks 38 (2002) 393–422• Minimum hop (MH) route: The route thatmakes the MH to reach the sink is preferredRoute 3 in Fig 4 is the most efficient routebased on this scheme Note that the ME schemeselects the same route as the MH when the sameamount of energy ie all a are the same is usedon every link Therefore when nodes broadcastwith same power level without any power con-trol MH is then equivalent to ME• Maximum minimum PA node route: The routealong which the minimum PA is larger thanthe minimum PAs of the other routes is pre-ferred In Fig 4 Route 3 is the most efficientand Route 1 is the second efficient paths Thisscheme precludes the risk of using up a sensornode with low PA much earlier than the othersbecause they are on a route with nodes whichhas very high PAsAnother important issue is that routing may bebased on data centric In data-centric routing theinterest dissemination is performed to assign thesensing tasks to the sensor nodes There are twoapproaches used for interest dissemination: sinksbroadcast the interest [39] and sensor nodesbroadcast an advertisement for the available data[35] and wait for a request from the interested sinksThe data-centric routing requires attribute-based naming [20225475] For attribute-basednaming the users are more interested in queryingan attribute of the phenomenon rather than que-rying an individual node For instance‘‘the areaswhere the temperature is over 70 F’’ is a morecommon query than ‘‘the temperature read by acertain node’’ The attribute-based naming is usedto carry out queries by using the attributes of thephenomenon The attribute-based naming alsomakes broadcasting attribute-based multicastinggeo-casting and any-casting important for sensornetworksThe data aggregation is a technique used tosolve the implosion and overlap problems in data-centric routing [35] In this technique a sensornetwork is usually perceived as a reverse multicasttree as shown in Fig 5 where the sink asks thesensor nodes to report the ambient condition ofthe phenomena Data coming from multiple sensornodes are aggregated as if they are about the sameattribute of the phenomenon when they reach thesame routing node on the way back to the sinkFor example sensor node E aggregates the datafrom sensor nodes A and B while sensor node Faggregates the data from sensor nodes C and Das shown in Fig 5 Data aggregation can be per-ceived as a set of automated methods of combiningthe data that comes from many sensor nodes into aset of meaningful information [34] With this re-spect data aggregation is known as data fusion[35] Also care must be taken when aggregatingdata because the specifics of the data eg thelocations of reporting sensor nodes should not beleft out Such specifics may be needed by certainapplicationsOne other important function of the networklayer is to provide internetworking with externalnetworks such as other sensor networks commandand control systems and the Internet In one sce-nario the sink nodes can be used as a gateway toother networks While another scenario is creatinga backbone by connecting sink nodes together andmaking this backbone access other networks via agatewayTo provide insight into current research on thenetworking layer we discuss different schemesproposed for the sensor networks for the rest ofthis sectionSmall minimum energy communication network(SMECN): A protocol is developed in [73] whichcomputes an energy efficient subnetwork namelythe MECN when a communication network isgiven A new algorithm called SMECN is pro-posed by [48] to also provide such a subnetworkFig 5 Example of data aggregationIF Akyildiz et al / Computer Networks 38 (2002) 393–422 409The subnetwork ie subgraph constructed bySMECN is smaller than the one that is constructedby MECN if the broadcast region is circulararound a broadcaster for a given power settingThe subgraph G of the graph G0 which representsthe sensor network minimizes the energy usagesatisfying the following conditions: the number ofedges in G is less than in G0 while containing allnodes in G0; if two nodes u and v are connected ingraph G0 they are also connected in subgraph G;the energy required to transmit data from node uto all its neighbors in subgraph G is less than theenergy required to transmit to all its neighborsin graph G0 The SMECN also follows the MEproperty which MECN uses to construct thesubnetwork The ME property is such that thereexists a ME path in subgraph G between node uand v for every pair ðu; vÞ of nodes that are con-nected in G0The power required to transmit data betweennode u and v is modelled as pðu; vÞ ¼ tdðu; vÞnwhere t is a constant; dðu; vÞ the distance betweennode u and v; and nP 2 the path-loss exponentexperienced by radio transmission Also thepower needed to receive data is c Since pðu; vÞincreases by nth power of the distance betweennode u and v it may take less power to relay datathan directly transmit data between node u and vThe path between node u (ie u0) and v (ie uk) isrepresented by r where r ¼ ðu0; u1;    ; ukÞ in thesubgraph G ¼ ðV ;EÞ is an ordered list of nodessuch that the pair ðui; uiþ1Þ 2 E Also the length ofr is k The total power consumption between nodeu0 and uk isCðrÞ ¼Xk1i¼0ðpðui; uiþ1Þ þ cÞ ð5Þwhere pðui; uiþ1Þ is the power required to transmitdata between node ui and uiþ1; and c the powerrequired to receive data A path r is a ME pathfrom u0 to uk if CðrÞ6Cðr0Þ for all paths r0 betweennode u0 and uk in G0 As a result a subgraph G hasthe ME property if for all ðu; vÞ 2 V  there exists apath r in G which is a ME path in G0 betweennode u and vFlooding: Flooding is an old technique that canalso be used for routing in sensor networks Inflooding each node receiving a data or manage-ment packet repeats it by broadcasting unless amaximum number of hops for the packet isreached or the destination of the packet is thenode itself Flooding is a reactive technique and itdoes not require costly topology maintenance andcomplex route discovery algorithms However ithas several deficiencies such as [35]:• Implosion: Implosion is a situation where dupli-cated messages are sent to the same node Forexample if sensor node A has N neighbor sen-sor nodes that are also the neighbors of sensornode B the sensor node B receives N copies ofthe message sent by sensor node A• Overlap: If two nodes share the same observingregion both of them may sense the same stimuliat the same time As a result neighbor nodes re-ceive duplicated messages• Resource blindness: The flooding protocol doesnot take into account of the available energy re-sources An energy resource aware protocolmust take into account the amount of energyavailable to them at all timeGossiping: A derivation of flooding is gossiping[32] in which nodes do not broadcast but send theincoming packets to a randomly selected neighborA sensor node randomly selects one of its neigh-bors to send the data Once the neighbor nodereceives the data it selects randomly another sen-sor node Although this approach avoid the im-plosion problem by just having one copy of amessage at any node it takes long time to propa-gate the message to all sensor nodesSensor protocols for information via negotiation(SPIN): A family of adaptive protocols calledSPIN [35] is designed to address the deficienciesof classic flooding by negotiation and resourceadaptation The SPIN family of protocols are de-signed based on two basic ideas: sensor nodesoperate more efficiently and conserve energy bysending data that describe the sensor data insteadof sending the whole data eg image and sensornodes must monitor the changes in their energyresourcesSPIN has three types of messages ie ADVREQ and DATA Before sending a DATA410 IF Akyildiz et al / Computer Networks 38 (2002) 393–422message the sensor broadcasts an ADV messagecontaining a descriptor ie meta-data of theDATA as shown in Step 1 of Fig 6 If a neighboris interested in the data it sends a REQ messagefor the DATA and DATA is sent to this neighborsensor node as shown in Steps 2 and 3 of Fig 6respectively The neighbor sensor node then re-peats this process as illustrated in Steps 4 5 and 6of Fig 6 As a result the sensor nodes in the entiresensor network which are interested in the datawill get a copyNote that SPIN is based on data-centric routing[35] where the sensor nodes broadcast an adver-tisement for the available data and wait for a re-quest from interested sinksSequential assignment routing (SAR): In [83] aset of algorithms which perform organizationmanagement and mobility management operationsin sensor networks are proposed Self-organizingMAC for sensor networks (SMACS) is a distrib-uted protocol that enables a collection of sensornodes to discover their neighbors and establishtransmission/reception schedules without the needfor a central management system The eavesdropand register (EAR) algorithm is designed to sup-port seamless interconnection of the mobile nodesThe EAR algorithm is based on the invitationmessages and on the registration of stationarynodes by the mobile nodes The SAR algorithmcreates multiple trees where the root of each treeis an one hop neighbor from the sink Each treegrows outward from the sink while avoiding nodeswith very low QoS (ie low throughput/high de-lay) and energy reserves At the end of this pro-cedure most nodes belong to multiple trees Thisallows a sensor node to choose a tree to relay itsinformation back to the sink There are two pa-rameters associated with each path ie a treeback to the sink:• Energy resources: The energy resources is esti-mated by the number of packets which the sen-sor node can send if the sensor node hasexclusive use of the path• Additive QoS metric: A high additive QoS met-ric means low QoSThe SAR algorithm selects the path based onthe energy resources and additive QoS metric ofeach path and the packet’s priority level As aresult each sensor node selects its path to route thedata back to the sinkAlso two more algorithms called single winnerelection and multiwinner election handle the nec-essary signaling and data transfer tasks in localcooperative information processingLow-energy adaptive clustering hierarchy(LEACH): LEACH is a clustering-based protocolthat minimizes energy dissipation in sensor net-works [34] The purpose of LEACH is to randomlyselect sensor nodes as cluster-heads so the high-energy dissipation in communicating with the basestation is spread to all sensor nodes in the sensornetwork The operation of LEACH is separatedinto two phases the set-up phase and the steadyphase The duration of the steady phase is longerthan the duration of the set-up phase in order tominimize the overheadDuring the set-up phase a sensor node choosesa random number between 0 and 1 If this randomnumber is less than the threshold T ðnÞ the sensornode is a cluster-head T ðnÞ is calculated asT ðnÞ ¼P1 P ½rmodð1=P Þ	 if n 2 G;0 otherwise;8<:where P is the desired percentage to become acluster-head; r the current round; and G the set ofnodes that have not being selected as a cluster-head in the last 1=P rounds After the cluster-heads are selected the cluster-heads advertise to allFig 6 The SPIN protocol [35]IF Akyildiz et al / Computer Networks 38 (2002) 393–422 411sensor nodes in the network that they are the newcluster-heads Once the sensor nodes receive theadvertisement they determine the cluster that theywant to belong based on the signal strength of theadvertisement from the cluster-heads to the sensornodes The sensor nodes inform the appropriatecluster-heads that they will be a member of thecluster Afterwards the cluster-heads assign thetime on which the sensor nodes can send data tothe cluster-heads based on a TDMA approachDuring the steady phase the sensor nodes canbegin sensing and transmitting data to the cluster-heads The cluster-heads also aggregate data fromthe nodes in their cluster before sending these datato the base station After a certain period of timespent on the steady phase the network goes intothe set-up phase again and entering into anotherround of selecting the cluster-headsDirected diffusion: The directed diffusion datadissemination paradigm is proposed in [39] wherethe sink sends out interest which is a task de-scription to all sensors as shown in Fig 7(a) Thetask descriptors are named by assigning attribute-value pairs that describe the task Each sensornode then stores the interest entry in its cache Theinterest entry contains a timestamp field and sev-eral gradient fields As the interest is propagatedthroughout the sensor network the gradients fromthe source back to the sink are set up as shown inFig 7(b) When the source has data for the inter-est the source sends the data along the interest’sgradient path as shown in Fig 7(c) The interestand data propagation and aggregation are deter-mined locally Also the sink must refresh and re-inforce the interest when it starts to receive datafrom the source Note that the directed diffusion isbased on data-centric routing where the sinkbroadcasts the interest431 Open research issuesAn overview of the protocols proposed forsensor networks is given in Table 2 These proto-cols need to be improved or new protocols need tobe developed to address higher topology changesand higher scalability Also new internetworkingschemes should be developed to allow easy com-munication between the sensor networks and ex-ternal networks eg Internet44 Data link layerThe data link layer is responsible for the mul-tiplexing of data streams data frame detectionmedium access and error control It ensures reli-able point-to-point and point-to-multipoint con-nections in a communication network In thefollowing two subsections we discuss some of themedium access and error control strategies forsensor networks441 Medium access controlThe MAC protocol in a wireless multihop self-organizing sensor network must achieve two goalsThe first is the creation of the network infra-structure Since thousands of sensor nodes aredensely scattered in a sensor field theMAC schememust establish communication links for data trans-fer This forms the basic infrastructure needed forwireless communication hop by hop and givesthe sensor network self-organizing ability Thesecond objective is to fairly and efficiently sharecommunication resources between sensor nodesTraditional MAC schemes can all be categorizedbased on their resource sharing mechanisms Table3 provides an insight into the advantages anddisadvantages and application domains of theseclassesReasons why existing MAC protocols cannot beused: It has been emphasized in earlier sectionsFig 7 An example of directed diffusion [39]: (a) propagateinterest (b) set up gradient and (c) send data412 IF Akyildiz et al / Computer Networks 38 (2002) 393–422that novel protocols and algorithms are needed toeffectively tackle the unique resource constraintsand application requirements of sensor networksTo illustrate the impact of these constraints letus take a closer look at MAC schemes in otherwireless networks and analyze why they cannot beadopted into the sensor network scenarioIn a cellular system the base stations form awired backbone A mobile node is only a single hopaway from the nearest base station This type ofnetwork is also referred to as infrastructure basedin literature The primary goal of the MAC pro-tocol in such systems is the provision of high QoSand bandwidth efficiency Power conservation as-sumes only secondary importance as base stationshave unlimited power supply and the mobile usercan replenish exhausted batteries in the handsetHence medium access is invariably inclined towarda dedicated resource assignment strategy Such anaccess scheme is impractical for sensor networks asthere is no central controlling agent like the basestation This makes network-wide synchronizationa difficult proposition Moreover power efficiencydirectly influences network lifetime in a sensornetwork and hence is of prime importanceBluetooth and the mobile ad hoc network(MANET) are probably the closest peers to thesensor networks Bluetooth is an infrastructure-less short-range wireless system intended to re-place the cable between electronic user terminalswith RF links The Bluetooth topology is a starnetwork where a master node can have up toseven slave nodes wirelessly connected to it toform a piconet Each piconet uses a centrally as-signed TDMA schedule and frequency hoppingpattern Transmission power is typically around20 dBm and the transmission range is of the or-der of tens of meters The MAC protocol in aMANET has the task of forming the networkinfrastructure and maintaining it in the face ofmobility Hence the primary goal is the provisionof high QoS under mobile conditions Al-though the nodes are portable battery-powereddevices they can be replaced by the user andhence power consumption is only of secondaryimportanceTable 2An overview of network layer schemesNetwork layer scheme DescriptionSMECN [48] Creates a subgraph of the sensor network that contains the ME pathFlooding Broadcasts data to all neighbor nodes regardless if they receive it before or notGossiping [32] Sends data to one randomly selected neighborSPIN [35] Sends data to sensor nodes only if they are interested; has three types of messages ie ADV REQand DATASAR [83] Creates multiple trees where the root of each tree is one hop neighbor from the sink; select a tree fordata to be routed back to the sink according to the energy resources and additive QoS metricLEACH [34] Forms clusters to minimize energy dissipationDirected diffusion [39] Sets up gradients for data to flow from source to sink during interest disseminationTable 3Categorization of MAC protocolsCategory Resource sharing mode Application domain DisadvantagesDedicated assignmentor fixed allocationPre-determined fixed allocation Appropriate for continuoustraffic and provides boundeddelayInefficient for bursty trafficDemand based According to demand or userrequestUseful for variable rate andmultimedia trafficAdditional overhead and delaydue to reservation processRandom access orcontention basedChannel contention when trans-mission packets are availableSuitable for bursty traffic Inefficient for delay-sensitivetrafficIF Akyildiz et al / Computer Networks 38 (2002) 393–422 413In contrast to these two systems the sensornetwork may have a much larger number of nodesThe transmission power (0 dBm) and radio rangeof a sensor node is much less than those of theBluetooth or the MANET Topology changesare more frequent in a sensor network and can beattributed both to node mobility and failure Themobility rate can also be expected to be muchlower than in the MANET In essence the primaryimportance of power conservation to prolongnetwork lifetime in a sensor network means thatnone of the existing Bluetooth or MANET MACprotocols can be directly usedMAC for sensor networks: It is evident from ourprevious discussions that the MAC protocol forsensor networks must have built-in power conser-vation mobility management and failure recoverystrategies Though many schemes for medium ac-cess have been proposed for MANETs [859495]the design of an efficient MAC scheme for the newregime of sensor networks is still an open researchissue Thus far both fixed allocation and randomaccess versions of medium access have been pro-posed [8393] Demand-based MAC schemes maybe unsuitable for sensor networks due their largemessaging overhead and link set-up delay Powerconservation is achieved by the use of power savingoperation modes and by preferring time-outs toacknowledgements wherever possibleIt has been reasoned in [69] that since radiosmust be turned off during idling for preciouspower savings the MAC scheme should include avariant of TDMA Such a medium access mecha-nism is presented in [83] Further contention-based channel access is deemed unsuitable dueto their requirement to monitor the channel atall times It must be noted however that randommedium access can also support power conserva-tion as in the IEEE 80211 standard for WLANsby turning off radios depending on the status ofthe net allocation vector Constant listening timesand adaptive rate control schemes can also helpachieve energy efficiency in random access schemesfor sensor networks [93] Some of the proposedMAC protocols are discussed nextSMACS and the EAR algorithm: The SMACSprotocol [83] achieves network start-up and link-layer organization and the EAR algorithm en-ables seamless connection of mobile nodes in asensor network SMACS is a distributed infra-structure-building protocol which enables nodes todiscover their neighbors and establish transmis-sion/reception schedules for communication with-out the need for any local or global master nodesIn this protocol the neighbor discovery andchannel assignment phases are combined so thatby the time nodes hear all their neighbors theywould have formed a connected network A com-munication link consists of a pair of time slotsoperating at a randomly chosen but fixed fre-quency (or frequency hopping sequence) This isa feasible option in sensor networks since asmentioned earlier in Section 37 the availablebandwidth can be expected to be much higher thanthe maximum data rate for sensor nodes Sucha scheme avoids the necessity for network-widesynchronization although communicating neigh-bors in a subnet need to be time synchronizedPower conservation is achieved by using a randomwake-up schedule during the connection phase andby turning the radio off during idle time slotsThe EAR protocol [83] attempts to offer con-tinuous service to the mobile nodes under bothmobile and stationary conditions Here the mobilenodes assume full control of the connection pro-cess and also decide when to drop connectionsthereby minimizing messaging overhead The EARis transparent to the SMACS so that the SMACSis functional until the introduction of mobile nodesinto the network In this model the network isassumed to be mainly static ie any mobile nodehas a number of stationary nodes in its vicinity Adrawback of such a time-slot assignment scheme isthe possibility that members already belonging todifferent subnets might never get connectedCSMA based medium access: A CSMA basedMAC scheme for sensor networks is presented in[93] Traditional CSMA based schemes are deemedinappropriate as they all make the fundamentalassumption of stochastically distributed traffic andtend to support independent point-to-point flowsOn the contrary the MAC protocol for sensornetworks must be able to support variable buthighly correlated and dominantly periodic trafficAny CSMA based medium access scheme has twoimportant components the listening mechanism414 IF Akyildiz et al / Computer Networks 38 (2002) 393–422and the backoff scheme As reported and based onsimulations in [93] the constant listen periodsare energy efficient and the introduction of ran-dom delay provides robustness against repeatedcollisions Fixedwindow and binary exponential de-crease backoff schemes are recommended to main-tain proportional fairness in the network A phasechange at the application level is also advocated toget over any capturing effects It is proposed in thiswork that the energy consumed per unit of suc-cessful communication can serve as a good indi-cator of energy efficiencyAn adaptive transmission rate control (ARC)scheme that achieves medium access fairness bybalancing the rates of originating and route-thrutraffic is also discussed here This ensures thatnodes closer to the access point are not favoredover those deep down into the network The ARCcontrols the data origination rate of a node inorder to allow the route-thru traffic to propagateA progressive signalling mechanism is used to in-form the nodes to lower their data originating rateThe ARC uses a linear increase and multiplicativedecrease approach [57] While the linear increaseleads to more aggressive channel competition themultiplicative decrease controls transmission fail-ure penalty Since dropping route-thru traffic iscostlier the associated penalty is lesser than thatfor originating data transmission failure This en-sures that route-thru traffic is preferred over theoriginating trafficThe computational nature of this scheme makesit more energy efficient than handshaking andmessaging schemes using the radio The ARC alsoattempts to reduce the problem of hidden nodesin a multihop network by constantly tuning thetransmission rate and performing phase changesso that periodic streams are less likely to repeat-edly collideHybrid TDMA/FDMA based: This centrallycontrolled MAC scheme is introduced in [77] Inthis work the effect of non-ideal physical layerelectronics on the design of MAC protocols forsensor networks is investigated The system is as-sumed to be made up of energy constrained sensornodes that communicate to a single nearby high-powered base station (<10 m) Specifically themachine monitoring application of sensor net-works with strict data latency requirements isconsidered and a hybrid TDMA–FDMA mediumaccess scheme is proposed While a pure TDMAscheme dedicates the full bandwidth to a singlesensor node a pure FDMA scheme allocates min-imum signal bandwidth per node Despite the factthat a pure TDMA scheme minimizes the transmiton-time it is not always preferred due to the as-sociated time synchronization costs An analyticalformula is derived in [77] to find the optimumnumber of channels which gives the lowest systempower consumption This determines the hybridTDMA–FDMA scheme to be used The optimumnumber of channels is found to depend on theratio of the power consumption of the transmitterto that of the receiver If the transmitter consumesmore power a TDMA scheme is favored whilethe scheme leans toward FDMA when the receiverconsumes greater powerTo get a deeper insight into the salient featuresand effectiveness of MAC protocols for sensornetworks we present a qualitative overview inTable 4 It also serves as an indicator for compar-ative evaluation of some of the MAC schemesTable 4Qualitative overview of MAC protocols for sensor networksMAC protocol Channel access mode Sensor network specifics Power conservationSMACS and EAR [83] Fixed allocation of duplextime slots at fixed frequencyExploitation of large availablebandwidth compared to sensor datarateRandom wake up during set-upand turning radio off while idleHybrid TDMA/FDMA[77]Centralized frequency andtime divisionOptimum number of channels cal-culated for minimum system energyHardware based approach forsystem energy minimizationCSMA based [93] Contention-based randomaccessApplication phase shift and pre-transmit delayConstant listening time forenergy efficiencyIF Akyildiz et al / Computer Networks 38 (2002) 393–422 415proposed thus far in literature The column titledsensor network specifics aims to illustrate the noveland important features in each of these schemesthat enable their application in the sensor networkdomain They present the deviations and differ-ences from traditional MAC schemes which bythemselves would not be applicable We also out-line how each of these schemes achieves power ef-ficiency442 Power saving modes of operationRegardless of which type of medium accessscheme is used for sensor networks it certainlymust support the operation of power saving modesfor the sensor node The most obvious means ofpower conservation is to turn the transceiver offwhen it is not required Though this power savingmethod seemingly provides significant energygains an important point that must not be over-looked is that sensor nodes communicate usingshort data packets As explained in Section 381the shorter the packets the more the dominanceof start-up energy In fact if we blindly turn theradio off during each idling slot over a period oftime we might end up expending more energythan if the radio had been left on As a resultoperation in a power saving mode is energy effi-cient only if the time spent in that mode is greaterthan a certain threshold There can be a number ofsuch useful modes of operation for the wirelesssensor node depending on the number of statesof the micro-processor memory A/D convertorand the transceiver Each of these modes can becharacterized by its power consumption and thelatency overhead which is the transition powerto and from that mode A dynamic power man-agement scheme for wireless sensor networksis discussed in [80] where five power saving modesare proposed and intermode transition policiesare investigated The threshold time is foundto depend on the transition times and the indi-vidual power consumption of the modes in ques-tion443 Error controlAnother important function of the data linklayer is the error control of transmission data Twoimportant modes of error control in communica-tion networks are the forward error correction(FEC) and automatic repeat request (ARQ) Tothe best of our knowledge the application of ARQschemes is thus far unexplored in the regime ofsensor networks though many adaptive and low-power versions are existent in literature for othermobile networks [4497] The usefulness of ARQin sensor network applications is limited by theadditional re-transmission cost and overhead Onthe other hand decoding complexity is greaterin FEC as error correction capabilities need to bebuilt-in Considering this simple error controlcodes with low-complexity encoding and decodingmight present the best solutions for sensor net-works In the design of such a scheme it is im-portant to have good knowledge of the channelcharacteristics and implementation techniquesIn the following subsection we briefly review themotivation and basic design considerations forFEC which in turn will help us understand therequirements for sensor networksFEC: Link reliability is an important parameterin the design of any wireless network and more soin sensor networks due to the unpredictable andharsh nature of channels encountered in variousapplication scenarios Some of the applicationslike mobile tracking and machine monitoring re-quire high data precision Channel bit error rate(BER) is a good indicator of link reliability TheBER can be shown to be directly proportional tothe symbol rate Rs and inversely proportional toboth the received SNR ðEs=N0Þ and the transmitterpower level Pout Let us assume that a codingscheme with rate R is used If the data symboltransmission rate remains the same as that beforecoding the total symbol transmission rate mustincrease to Rs=R Also if the transmission power isunchanged the received energy per symbol de-creases to REs The BER measured at the decoderinput the raw BER is hence greater than the BERwithout coding This loss is overcome in the de-coder by exploiting the redundancy and structureof the code to correct some of the transmissionerrors In fact a good choice of the error cor-recting code can result in several orders of mag-nitude reduction in BER and an overall gain Thecoding gain is generally expressed in terms ofthe additional transmit power needed to obtain the416 IF Akyildiz et al / Computer Networks 38 (2002) 393–422same BER without coding A simple (1511) Ham-ming code is found to reduce BER by almost 103and ensures a coding gain of 15 dB for binaryphase shift keying modulated data and additivewhite Gaussian noise model [92]Reliable data communication can hence beprovided either by increasing the output transmitpower ðPoutÞ or the use of suitable FEC Since asensor node has limited power resources the for-mer option is not feasible We hence turn to FECAs we have seen FEC can achieve significantreduction in the BER for any given value of PoutHowever we must take into account the additionalprocessing power that goes into encoding and de-coding This processing power is drawn from thelimited resources possessed by the node Thismight be critical for sensor networks though it canbe negligibly small in other wireless networks Ifthe associated processing power is greater than thecoding gain then the whole process in energyinefficiency and the system is better off withoutcoding On the other hand FEC is a valuable assetin sensor networks if the sum of the encoding anddecoding processing powers is less than the trans-mission power savings It is to be noted that allthese computations and comparisons must becarried out for a given in most cases applicationspecific BERThough adaptive FEC has received some at-tention in other wireless networks it remains lar-gely unexplored in sensor networks The impact ofadapting packet size and error control on energyefficiency in wireless systems is investigated in[4758] In [76] the authors examine this issue forsensor networks They assume a frequency non-selective slow Rayleigh fading channel and useconvolutional codes for FEC Based on their anal-ysis they conclude that the average energy con-sumption per useful bit shows an exponentialincrease with the constraint length of the code andis independent of the code rate Moreover theyfind that FEC is generally inefficient if the decodingis performed using a micro-processor and recom-mend an on-board dedicated Viterbi decoder Tothe best of our knowledge other coding schemesremain unexplored Simple encoding techniquesthat enable easy decoding might present an energyefficient solution for sensor networks444 Open research issuesThough some medium access schemes havebeen proposed for sensor networks the area is stilllargely open to research So is the mainly unex-plored domain of error control in sensor networksKey open research issues include:• MAC for mobile sensor networks: The proposedSMACS and EAR [83] perform well only in amainly static sensor networks It is assumed inthe connection schemes that a mobile nodehas many static nodes as neighbors These algo-rithms must be improved to deal with more ex-tensive mobility in the sensor nodes and targetsMobility issues carrier sensing and backoffmechanisms for the CSMA based scheme alsoremain largely unexplored• Determination of lower bounds on the energy re-quired for sensor network self-organization• Error control coding schemes: Error control isextremely important in some sensor networkapplications like mobile tracking and machinemonitoring Convolutional coding effects havebeen considered in [77] The feasibility of othererror control schemes in sensor networks needsto be explored• Power saving modes of operation: To prolongnetwork lifetime a sensor node must enter intoperiods of reduced activity when running low onbattery power The enumeration and transitionmanagement for these nodes is open to researchSome ideas are outlined in [80]45 Physical layerThe physical layer is responsible for frequencyselection carrier frequency generation signal de-tection modulation and data encryption Fre-quency selection aspects have been dealt with inSection 37 Frequency generation and signal de-tection have more to do with the underlyinghardware and transceiver design and hence arebeyond the scope of our paper In the following wefocus on signal propagation effects power effi-ciency and modulation schemes for sensor net-worksIt is well known that long-distance wirelesscommunication can be expensive both in termsIF Akyildiz et al / Computer Networks 38 (2002) 393–422 417of energy and implementation complexity Whiledesigning the physical layer for sensor networksenergy minimization assumes significant impor-tance over and above the decay scattering shad-owing reflection diffraction multipath and fadingeffects In general the minimum output power re-quired to transmit a signal over a distance d isproportional to dn where 26 n < 4 The exponentn is closer to four for low-lying antennae and near-ground channels [7282] as is typical in sensornetwork communication This can be attributed tothe partial signal cancellation by a ground-reflectedray While trying to resolve these problems itis important that the designer is aware of inbuiltdiversities and exploits this to the fullest Forinstance multihop communication in a sensornetwork can effectively overcome shadowing andpath-loss effects if the node density is high enoughSimilarly while propagation losses and channelcapacity limit data reliability this very fact canbe used for spatial frequency re-use Energy effi-cient physical layer solutions are currently beingpursued by researchers Although some of thesetopics have been addressed in literature it still re-mains a vastly unexplored domain of the wirelesssensor networks A discussion of some existingideas followsThe choice of a good modulation scheme iscritical for reliable communication in a sensornetwork Binary and M-ary modulation schemesare compared in [77] While an M-ary scheme canreduce the transmit on-time by sending multiplebits per symbol it results in complex circuitry andincreased radio power consumption These trade-off parameters are formulated in [76] and it isconcluded that under start-up power dominantconditions the binary modulation scheme is moreenergy efficient Hence M-ary modulation gainsare significant only for low start-up power systemsA low-power direct-sequence spread-spectrummodem architecture for sensor networks is pre-sented in [13] This low-power architecture can bemapped to an ASIC technology to further improveefficiencyUltrawideband (UWB) or impulse radio (IR)has been used for baseband pulse radar andranging systems and has recently drawn consider-able interest for communication applications [18]especially in indoor wireless networks [53] UWBemploys baseband transmission and thus it re-quires no intermediate or radio carrier frequenciesGenerally pulse position modulation is used Themain advantage of UWB is its resilience to multi-path [174546] Low transmission power andsimple transceiver circuitry make UWB an at-tractive candidate for sensor networks451 Open research issuesThe physical layer is a largely unexplored areain sensor networks Open research issues rangefrom power efficient transceiver design to modu-lation schemes A few of these are given below• Modulation schemes: Simple and low-powermodulation schemes need to be developedfor sensor networks The modulation schemecan be either baseband as in UWB or pass-band• Strategies to overcome signal propagation effects:Signal propagation effects in sensor networkshave been dealt with in Section 45• Hardware design: Tiny low-power low-costtransceiver sensing and processing units needto be designed Power efficient hardware man-agement strategies are also essential5 ConclusionThe flexibility fault tolerance high sensing fi-delity low-cost and rapid deployment character-istics of sensor networks create many new andexciting application areas for remote sensing Inthe future this wide range of application areas willmake sensor networks an integral part of our livesHowever realization of sensor networks needsto satisfy the constraints introduced by factorssuch as fault tolerance scalability cost hardwaretopology change environment and power con-sumption Since these constraints are highlystringent and specific for sensor networks newwireless ad hoc networking techniques are re-quired Many researchers are currently engaged indeveloping the technologies needed for differentlayers of the sensor networks protocol stack asshown in Fig 3 A list of current sensor networks418 IF Akyildiz et al / Computer Networks 38 (2002) 393–422research projects is given in Table 5 Along withthe current research projects we encourage moreinsight into the problems and more development insolutions to the open research issues as describedin this paperReferences[1] GD Abowd JPG Sterbenz Final report on the inter-agency workshop on research issues for smart environ-ments IEEE Personal Communications (October 2000)36–40[2] J Agre L Clare An integrated architecture for cooper-ative sensing networks IEEE Computer Magazine (May2000) 106–108[3] IF Akyildiz W Su A power aware enhanced routing(PAER) protocol for sensor networks Georgia TechTechnical Report January 2002 submitted for publica-tion[4] A Bakre BR Badrinath I-TCP: indirect TCP for mobilehosts Proceedings of the 15th International Conference onDistributed Computing Systems Vancouver BC May1995 pp 136–143[5] P Bauer M Sichitiu R Istepanian K Premaratne Themobile patient: wireless distributed sensor networks forpatient monitoring and care Proceedings 2000 IEEEEMBS International Conference on Information Technol-ogy Applications in Biomedicine 2000 pp 17–21[6] M Bhardwaj T Garnett AP Chandrakasan Upperbounds on the lifetime of sensor networks IEEE Interna-tional Conference on Communications ICC’01 HelsinkiFinland June 2001[7] P Bonnet J Gehrke P Seshadri Querying the physicalworld IEEE Personal Communications (October 2000)10–15[8] N Bulusu D Estrin L Girod J Heidemann Scalablecoordination for wireless sensor networks: self-configuringlocalization systems International Symposium on Com-munication Theory and Applications (ISCTA 2001) Am-bleside UK July 2001[9] BG Celler et al An instrumentation system for theremote monitoring of changes in functional health status ofthe elderly International Conference IEEE-EMBS NewYork 1994 pp 908–909Table 5Current research projectsProject name Research area HTTP locationSensoNet [3] Transport network data link and physical layersPower control mobility and task management planeshttp://wwwecegatechedu/research/labs/bwn/WINS [2269] Distributed network and Internet access to sensorscontrols and processorshttp://wwwjanetuclaedu/WINS/SPIN [35] Data dissemination protocols http://nmslcsmiledu/projects/leachSPINS [66] Security protocol http://pariscsberkeleyedu/perrig/projectshtmlSINA [7584] Information networking architecture http://wwweecisudeledu/cshen/lAMPS [77] Framework for implementing adaptive energy-awaredistributed microsensorshttp://www-mtlmiledu/research/icsystems/uamps/LEACH [34] Cluster formation protocol http://nmslcsmitedu/projects/leachSmart dust [42] Laser communication from a cubic millimeterMote deliverySubmicroWatt electronicsPower sourcesMacroMotes (COTS Dust)http://roboticseecsberkeleyedu/pister/SmartDust/SCADDS[81120222327333996]Scalable coordination architectures for deeply distributedand dynamic systemshttp://wwwisiedu/scadds/PicoRadio [7071] Develop a ‘‘system-on-chip’’ implementation of a PicoNode http://bwrceecsberkeleyedu/Re-search/Pico_Radio/PicoNodehtmPACMAN [79] Mathematical framework that incorporates key features ofcomputing nodes and networking elementshttp://pacmanusceduDynamic sensor networks[19]Routing and power aware sensor management Networkservices APIhttp://wwweastisiedu/DIVl0/dsn/Aware home [36] Requisite technologies to create a home environment thatcan both perceive and assist its occupantshttp://wwwccgatechedu/fce/ahriCOUGAR device databaseproject [7]Distributed query processing http://wwwcscornelledu/database/cougar/indexhtmDataSpace [38] Distributed query processing http://wwwcsrutgersedu/datamanIF Akyildiz et al / Computer Networks 38 (2002) 393–422 419[10] A Cerpa D Estrin ASCENT: adaptive self-configuringsensor networks topologies UCLA Computer ScienceDepartment Technical Report UCLA/CSDTR-01-0009May 2001[11] A Cerpa J Elson M Hamilton J Zhao Habitatmonitoring: application driver for wireless communica-tions technology ACM SIGCOMM’2000 Costa RicaApril 2001[12] A Chandrakasan R Amirtharajah S Cho J GoodmanG Konduri J Kulik W Rabiner A Wang Designconsiderations for distributed micro-sensor systems Pro-ceedings of the IEEE 1999 Custom Integrated CircuitsConference San Diego CA May 1999 pp 279–286[13] C Chien I Elgorriaga C McConaghy Low-power direct-sequence spread-spectrum modem architecture for distrib-uted wireless sensor networks ISLPED’01 HuntingtonBeach California August 2001[14] S Cho A Chandrakasan Energy-efficient protocols forlow duty cycle wireless microsensor Proceedings of the33rd Annual Hawaii International Conference on SystemSciences Maui HI Vol 2 (2000) p 10[15] R Colwell Testimony of Dr Rita Colwell DirectorNational Science Foundation Before the Basic ResearchSubcommitte House Science Committe Hearing on Re-mote Sensing as a Research and Management ToolSeptember 1998[16] G Coyle et al Home telecare for the elderly Journal ofTelemedicine and Telecare 1 (1995) 183–184[17] RJ Cramer MZ Win RA Scholtz Impulse radiomultipath characteristics and diversity reception IEEEInternational Conference on Communications ICC’98 Vol3 (1998) pp 1650–1654[18] JM Cramer RA Scholtz MZ Win On the analysis ofUWB communication channels IEEE MILCOM’99 1999pp 1191–1195[19] DSN Team Multilateration Poster SensIT WorkshopSt Petersburg FL April 2001[20] J Elson D Estrin Random ephemeral transactionidentifiers in dynamic sensor networks Proceedings 21stInternational Conference on Distributed Computing Sys-tems Mesa AZ April 2001 pp 459–468[21] IA Essa Ubiquitous sensing for smart and awareenvironments IEEE Personal Communications (October2000) 47–49[22] D Estrin L Girod G Pottie M Srivastava Instrumen-ting the world with wireless sensor networks InternationalConference on Acoustics Speech and Signal Processing(ICASSP 2001) Salt Lake City Utah May 2001[23] D Estrin R Govindan J Heidemann S Kumar Nextcentury challenges: scalable coordination in sensor net-works ACM MobiCom’99 Washingtion USA 1999pp 263–270[24] D Estrin R Govindan J Heidemann Embedding theInternet Communication ACM 43 (2000) 38–41[25] P Favre et al A 2V 600 lA 1 GHz BiCMOS superregenerative receiver for ISM applications IEEE Journalof Solid State Circuits 33 (1998) 2186–2196[26] M Gell-Mann What is complexity? Complexity 1 (1)1995[27] L Girod D Estrin Robust range estimation usingacoustic and multimodal sensing Proceedings of theIEEE/RSJ International Conference on Intelligent Robotsand Systems (IROS 2001) Maui Hawaii October 2001[28] K Govil E Chan H Wasserman Comparing algorithmsfor dynamic speed-setting of a low-power CPU Procee-dings of ACM MobiCom’95 Berkeley CA November1995 pp 13–25[29] MP Hamilton M Flaxman Scientific data visualizationand biological diversity: new tools for spatializing multi-media observations of species and ecosystems Landscapeand Urban Planning 21 (1992) 285–297[30] MP Hamilton Hummercams robots and the virtualreserve Directors Notebook February 6 2000 availablefrom http://wwwjamesreserveedu/newshtml[31] B Halweil Study finds modern farming is costly WorldWatch 14 (1) (2001) 9–10[32] S Hedetniemi A Liestman A survey of gossiping andbroadcasting in communication networks Networks 18 (4)(1988) 319–349[33] J Heidemann F Silva C Intanagonwiwat Buildingefficient wireless sensor networks with low-level namingProceedings of the Symposium on Operating SystemsPrinciples Banff Canada 2001[34] WR Heinzelman A Chandrakasan H BalakrishnanEnergy-efficient communication protocol for wireless mic-rosensor networks IEEE Proceedings of the HawaiiInternational Conference on System Sciences January2000 pp 1–10[35] WR Heinzelman J Kulik H Balakrishnan Adaptiveprotocols for information dissemination in wireless sensornetworks Proceedings of the ACM MobiCom’99 SeattleWashington 1999 pp 174–185[36] C Herring S Kaplan Component-based software systemsfor smart environments IEEE Personal CommunicationsOctober 2000 pp 60–61[37] G Hoblos M Staroswiecki A Aitouche Optimal designof fault tolerant sensor networks IEEE InternationalConference on Control Applications Anchorage AKSeptember 2000 pp 467–472[38] T Imielinski S Goel DataSpace: querying and monitor-ing deeply networked collections in physical space ACMInternational Workshop on Data Engineering for Wirelessand Mobile Access MobiDE 1999 Seattle Washington1999 pp 44–51[39] C Intanagonwiwat R Govindan D Estrin Directeddiffusion: a scalable and robust communication paradigmfor sensor networks Proceedings of the ACM Mobi-Com’00 Boston MA 2000 pp 56–67[40] C Jaikaeo C Srisathapornphat C Shen Diagnosis ofsensor networks IEEE International Conference on Com-munications ICC’01 Helsinki Finland June 2001[41] P Johnson et al Remote continuous physiological mon-itoring in the home Journal of Telemed Telecare 2 (2)(1996) 107–113420 IF Akyildiz et al / Computer Networks 38 (2002) 393–422[42] JM Kahn RH Katz KSJ Pister Next centurychallenges: mobile networking for smart dust Proceedingsof the ACM MobiCom’99 Washington USA 1999pp 271–278[43] TH Keitt DL Urban BT Milne Detecting criticalscales in fragmented landscapes Conservation Ecology 1(1) (1997) 4 Available from <http://wwwconsecoloorg/vol1/iss1/art4>[44] R Kravets K Schwan K Calvert Power-aware commu-nication for mobile computers Proceedings of Mo-MUC’99 San Diego CA November 1999 pp 64–73[45] H Lee B Han Y Shin S Im Multipath characteristicsof impulse radio channels IEEE Vehicular TechnologyConference Proceedings Tokyo Vol 3 2000 pp 2487–2491[46] CJ Le Martret GB Giannakis All-digital impulse radiofor MUI/ISI-resilient multiuser communications over fre-quency-selective multipath channels Proceedings of IEEEMilitary Communications Conference (MILCOM’00)Vol 2 2000 pp 655–659[47] P Letteri MB Srivastava Adaptive frame length controlfor improving wireless link throughput range and energyefficiency Proceedings of IEEE INFOCOM’98 San Fran-cisco USA March 1998 pp 564–571[48] L Li JY Halpern Minimum-energy mobile wirelessnetworks revisited IEEE International Conference onCommunications ICC’01 Helsinki Finland June 2001[49] J Lorch A Smith Reducing processor power consump-tion by improving processor time management in a single-user operating system Proceedings of ACM MobiCom’961996[50] S Meguerdichian F Koushanfar G Qu M PotkonjakExposure in wireless ad-hoc sensor networks Proceed-ings of ACM MobiCom’01 Rome Italy 2001 pp 139–150[51] T Melly A Porret CC Enz EA Vittoz A 12 V 430MHz 4dBm power amplifier and a 250 lW Frontendusing a standard digital CMOS process IEEE Interna-tional Symposium on Low Power Electronics and DesignConference San Diego August 1999 pp 233–237[52] R Min T Furrer A Chandrakasan Dynamic voltagescaling techniques for distributed microsensor networksProceedings of ACM MobiCom’95 August 1995[53] FR Mireles RA Scholtz Performance of equicorrelatedultra-wideband pulse-position-modulated signals in theindoor wireless impulse radio channel IEEE Conferenceon Communications Computers and Signal ProcessingVol 2 1997 pp 640–644[54] J Mirkovic GP Venkataramani S Lu L Zhang A self-organizing approach to data forwarding in largescalesensor networks IEEE International Conference on Com-munications ICC’01 Helsinki Finland June 2001[55] D Nadig SS Iyengar A new architecture for distributedsensor integration Proceedings of IEEE Southeastcon’93Charlotte NC April 1993[56] YH Nam et al Development of remote diagnosis systemintegrating digital telemetry for medicine InternationalConference IEEE-EMBS Hong Kong 1998 pp 1170–1173[57] T Nandagopal T Kim X Gao V Bhargavan AchievingMAC layer fairness in wireless packet networks Proceed-ings of the ACM MobiCom’00 Boston MA 2000[58] B Narendran J Sienicki S Yajnik P Agrawal Evalu-ation of an adaptive power and error control algorithmfor wireless systems IEEE International Conferenceon Communications ICC’97 Montreal Canada June1997[59] National Semiconductor Corporation LMX3162 SingleChip Radio Transceiver Evaluation Notes and DatasheetMarch 2000[60] N Noury T Herve V Rialle G Virone E Mercier GMorey A Moro T Porcheron Monitoring behavior inhome using a smart fall sensor IEEE-EMBS Special TopicConference on Microtechnologies in Medicine and Bio-logy October 2000 pp 607–610[61] With Glacier Park in Its Path Fire Spreads to 40000Acres New York Times Vol 150 Issue 51864 p 24 0p 1map 4c 9/2/2001[62] M Ogawa et al Fully automated biosignal acquisition indaily routine through 1 month International Conferenceon IEEE-EMBS Hong Kong 1998 pp 1947–1950[63] N Priyantha A Chakraborty H Balakrishnan Thecricket location-support system Proceedings of ACMMobiCom’00 August 2000 pp 32–43[64] T Pering T Burd R Brodersen The simulation andevaluation of dynamic voltage scaling algorithms Pro-ceedings of International Symposium on Low PowerElectronics and Design ISLPED’98 August 1998 pp76–81[65] C Perkins Ad Hoc Networks Addison-Wesley ReadingMA 2000[66] A Perrig R Szewczyk V Wen D Culler JD TygarSPINS: security protocols for sensor networks Procee-dings of ACM MobiCom’01 Rome Italy 2001 pp 189–199[67] EM Petriu ND Georganas DC Petriu D MakrakisVZ Groza Sensor-based information appliances IEEEInstrumentation and Measurement Magazine (December2000) 31–35[68] A Porret T Melly CC Enz EA Vittoz A low-powerlow-voltage transceiver architecture suitable for wirelessdistributed sensors network IEEE International Sympo-sium on Circuits and Systems’00 Geneva Vol 1 2000 pp56–59[69] GJ Pottie WJ Kaiser Wireless integrated networksensors Communications of the ACM 43 (5) (2000) 551–558[70] J Rabaey J Ammer JL da Silva Jr D Patel Pico-Radio: ad-hoc wireless networking of ubiquitous low-energy sensor/monitor nodes Proceedings of the IEEEComputer SocietyAnnualWorkshoponVLSI (WVLSI’00)Orlanda Florida April 2000 pp 9–12[71] JM Rabaey MJ Ammer JL da Silva Jr D Patel SRoundy PicoRadio supports ad hoc ultra-low powerIF Akyildiz et al / Computer Networks 38 (2002) 393–422 421wireless networking IEEE Computer Magazine (2000)42–48[72] T Rappaport Wireless Communications: Principles andPractice Prentice-Hall Englewood Cliffs NJ 1996[73] V Rodoplu TH Meng Minimum energy mobile wirelessnetworks IEEE Journal of Selected Areas in Communi-cations 17 (8) (1999) 1333–1344[74] A Savvides C Han M Srivastava Dynamic fine-grainedlocalization in ad-hoc networks of sensors Proceedings ofACM MobiCom’01 Rome Italy July 2001 pp 166–179[75] C Shen C Srisathapornphat C Jaikaeo Sensor infor-mation networking architecture and applications IEEEPersonal Communications August 2001 pp 52–59[76] E Shih BH Calhoun S Cho A Chandrakasan Energy-efficient link layer for wireless microsensor networksProceedings IEEE Computer Society Workshop on VLSI2001 Orlando FL April 2001 pp 16–21[77] E Shih S Cho N Ickes R Min A Sinha A Wang AChandrakasan Physical layer driven protocol and algo-rithm design for energy-efficient wireless sensor networksProceedings of ACM MobiCom’01 Rome Italy July2001 pp 272–286[78] B Sibbald Use computerized systems to cut adverse drugevents: report CMAJ: Canadian Medical AssociationJournal 164 (13) (2001) 1878 1/2p 1c[79] S Singh M Woo CS Raghavendra Power-awarerouting in mobile ad hoc networks Proceedings of ACMMobiCom’98 Dallas Texas 1998 pp 181–190[80] A Sinha A Chandrakasan Dynamic power managementin wireless sensor networks IEEE Design and Test ofComputers March/April 2001[81] S Slijepcevic M Potkonjak Power efficient organizationof wireless sensor networks IEEE International Confer-ence on Communications ICC’01 Helsinki Finland June2001[82] K Sohrabi B Manriquez G Pottie Near-ground wide-band channel measurements IEEE Proceedings of Vehic-ular Technology Conference New York 1999[83] K Sohrabi J Gao V Ailawadhi GJ Pottie Protocolsfor self-organization of a wireless sensor network IEEEPersonal Communications October 2000 pp 16–27[84] C Srisathapornphat C Jaikaeo C Shen Sensor in-formation networking architecture International Work-shop on Parallel Processing September 2000 pp 23–30[85] Y Tseng S Wu C Lin J Sheu A multi-channel MACprotocol with power control for multi-hop mobile ad hocnetworks IEEE International Conference on DistributedComputing Systems Mesa AZ April 2001 pp 419–424[86] S Vardhan M Wilczynski G Pottie WJ KaiserWireless integrated network sensors (WINS): distributedin situ sensing for mission and flight systems IEEEAerospace Conference Vol 7 2000 pp 459–463[87] B Walker W Steffen An overview of the implications ofglobal change of natural and managed terrestrial ecosys-tems Conservation Ecology 1 (2) (1997) Available from<http://wwwconsecolorg/vol1/iss2/art2>[88] B Warneke B Liebowitz KSJ Pister Smart dust:communicating with a cubic-millimeter computer IEEEComputer (January 2001) 2–9[89] http://wwwfaoorg/sd/EIdirect/EIre0074htm[90] http://wwwalertsystemsorg[91] M Weiser et al Scheduling for reduced CPU energyProceedings of 1st USENIX Symposium on OperatingSystem Design and Implementation November 1994pp 13–23[92] S Wicker Error Control Coding for Digital Communica-tion and Storage Prentice-Hall EnglewoodCliffs NJ 1995[93] A Woo D Culler A transmission control scheme formedia access in sensor networks Proceedings of ACMMobiCom’01 Rome Italy July 2001 pp 221–235[94] S Wu C Lin Y Tseng J Sheu A new multi channelMAC protocol with on-demand channel assignment formultihop mobile ad hoc networks International Sympo-sium on Parallel Architectures Algorithms and NetworksI-SPAN 2000 Dallas 2000 pp 232–237[95] S Wu Y Tseng J Sheu Intelligent medium access formobile ad hoc networks with busy tones and powercontrol IEEE Journal on Selected Areas in Communica-tions (September 2000) 1647–1657[96] Y Xu J Heidemann D Estrin Geography-informedenergy conservation for ad hoc routing Proceedings ofACM MobiCom’2001 Rome Italy July 2001[97] M Zorzi R Rao Error control and energy consumptionin communications for nomadic computing IEEE Trans-actions on Computers 46 (3) (1997) 279–289422 IF Akyildiz et al / Computer Networks 38 (2002) 393–422
